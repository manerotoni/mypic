diff --git a/.gitignore b/.gitignore
index 96f7ca3..c3f85f8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,117 @@
+<<<<<<< HEAD
+# Build Folders (you can keep bin if you'd like, to store dlls and pdbs)
+[Bb]in/
+[Oo]bj/
+
+# mstest test results
+TestResults
+
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+
+# User-specific files
+*.suo
+*.user
+*.sln.docstates
+
+# Build results
+[Dd]ebug/
+[Rr]elease/
+x64/
+*_i.c
+*_p.c
+*.ilk
+*.meta
+*.obj
+*.pch
+*.pdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.log
+*.vspscc
+*.vssscc
+.builds
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opensdf
+*.sdf
+
+# Visual Studio profiler
+*.psess
+*.vsp
+*.vspx
+
+# Guidance Automation Toolkit
+*.gpState
+
+# ReSharper is a .NET coding add-in
+_ReSharper*
+
+# NCrunch
+*.ncrunch*
+.*crunch*.local.xml
+
+# Installshield output folder
+[Ee]xpress
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish
+
+# Publish Web Output
+*.Publish.xml
+
+# NuGet Packages Directory
+packages
+
+# Windows Azure Build Output
+csx
+*.build.csdef
+
+# Windows Store app package directory
+AppPackages/
+
+# Others
+[Bb]in
+[Oo]bj
+sql
+TestResults
+[Tt]est[Rr]esult*
+*.Cache
+ClientBin
+[Ss]tyle[Cc]op.*
+~$*
+*.dbmdl
+Generated_Code #added for RIA/Silverlight projects
+
+# Backup & report files from converting an old project file to a newer
+# Visual Studio version. Backup files are not needed, because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+=======
 /target/
 .classpath
 .project
 .settings/*
 .DS_Store
 .pydevproject
+>>>>>>> v2.1
diff --git a/AutofocusScreen/AFSloader_AutofocusScreen_ZEN.lvb b/AutofocusScreen/AFSloader_AutofocusScreen_ZEN.lvb
deleted file mode 100644
index 46b9cca..0000000
Binary files a/AutofocusScreen/AFSloader_AutofocusScreen_ZEN.lvb and /dev/null differ
diff --git a/AutofocusScreen/AutofocusScreen_ZEN.lvb b/AutofocusScreen/AutofocusScreen_ZEN.lvb
index cdc1b9f..3a1fa8b 100644
Binary files a/AutofocusScreen/AutofocusScreen_ZEN.lvb and b/AutofocusScreen/AutofocusScreen_ZEN.lvb differ
diff --git a/AutofocusScreen/AutofocusScreen_ZEN_backup.lvb b/AutofocusScreen/AutofocusScreen_ZEN_backup.lvb
index 3b696cc..da2110d 100644
Binary files a/AutofocusScreen/AutofocusScreen_ZEN_backup.lvb and b/AutofocusScreen/AutofocusScreen_ZEN_backup.lvb differ
diff --git a/AutofocusScreen/AutofocusScreen_ZEN_largeChanges.lvb b/AutofocusScreen/AutofocusScreen_ZEN_largeChanges.lvb
deleted file mode 100644
index c6915cf..0000000
Binary files a/AutofocusScreen/AutofocusScreen_ZEN_largeChanges.lvb and /dev/null differ
diff --git a/AutofocusScreen/AutofocusScreen_ZEN_largeChanges2.lvb b/AutofocusScreen/AutofocusScreen_ZEN_largeChanges2.lvb
deleted file mode 100644
index 757237f..0000000
Binary files a/AutofocusScreen/AutofocusScreen_ZEN_largeChanges2.lvb and /dev/null differ
diff --git a/AutofocusScreen/CreateRoi.lvb b/AutofocusScreen/CreateRoi.lvb
new file mode 100644
index 0000000..1881914
Binary files /dev/null and b/AutofocusScreen/CreateRoi.lvb differ
diff --git a/AutofocusScreen/FCSSet.lvb b/AutofocusScreen/FCSSet.lvb
new file mode 100644
index 0000000..89d1d35
Binary files /dev/null and b/AutofocusScreen/FCSSet.lvb differ
diff --git a/AutofocusScreen/FCSSet2.lvb b/AutofocusScreen/FCSSet2.lvb
new file mode 100644
index 0000000..9047a33
Binary files /dev/null and b/AutofocusScreen/FCSSet2.lvb differ
diff --git a/AutofocusScreen/FCScalibration.lvb b/AutofocusScreen/FCScalibration.lvb
new file mode 100644
index 0000000..cd98acf
Binary files /dev/null and b/AutofocusScreen/FCScalibration.lvb differ
diff --git a/AutofocusScreen/TODO b/AutofocusScreen/TODO
new file mode 100644
index 0000000..d71a041
--- /dev/null
+++ b/AutofocusScreen/TODO
@@ -0,0 +1,16 @@
+ To do for version 3 (eventually in the Workflow-Manager):
+
+Feature: save setting of macro/ and original setting so to retrieve them after a crash
+		 mirror axis feature
+		
+Maybe create a Autofocus macro independent of micropilot. Divide macros in different small macros that are called when needed.
+
+A general window for setting specific tracks (for autofocus, micropilot etc).
+
+FCS control
+
+Tracing of crosses on cells to find volume and reset the z stacks
+
+Non-linear timesampling 
+
+Online changing of acquisition parameteres
diff --git a/AutofocusScreen/TestController.lvb b/AutofocusScreen/TestController.lvb
new file mode 100644
index 0000000..0e68ede
Binary files /dev/null and b/AutofocusScreen/TestController.lvb differ
diff --git a/AutofocusScreen/concat.lvb b/AutofocusScreen/concat.lvb
index ddc34f0..401759b 100755
Binary files a/AutofocusScreen/concat.lvb and b/AutofocusScreen/concat.lvb differ
diff --git a/AutofocusScreen/doc/AcquisitionPage.PNG b/AutofocusScreen/doc/AcquisitionPage.PNG
new file mode 100644
index 0000000..8bff428
Binary files /dev/null and b/AutofocusScreen/doc/AcquisitionPage.PNG differ
diff --git a/AutofocusScreen/doc/AutofocusAdditionalAcquisition.PNG b/AutofocusScreen/doc/AutofocusAdditionalAcquisition.PNG
deleted file mode 100644
index 085c6d6..0000000
Binary files a/AutofocusScreen/doc/AutofocusAdditionalAcquisition.PNG and /dev/null differ
diff --git a/AutofocusScreen/doc/AutofocusMicropilot.PNG b/AutofocusScreen/doc/AutofocusMicropilot.PNG
deleted file mode 100644
index 1a2560c..0000000
Binary files a/AutofocusScreen/doc/AutofocusMicropilot.PNG and /dev/null differ
diff --git a/AutofocusScreen/doc/AutofocusPage.PNG b/AutofocusScreen/doc/AutofocusPage.PNG
index 00ab95b..3bee73c 100644
Binary files a/AutofocusScreen/doc/AutofocusPage.PNG and b/AutofocusScreen/doc/AutofocusPage.PNG differ
diff --git a/AutofocusScreen/doc/AutofocusPagePostAcquisitionTrack.PNG b/AutofocusScreen/doc/AutofocusPagePostAcquisitionTrack.PNG
deleted file mode 100644
index c5a5f7a..0000000
Binary files a/AutofocusScreen/doc/AutofocusPagePostAcquisitionTrack.PNG and /dev/null differ
diff --git a/AutofocusScreen/doc/AutofocusPage_GridScan.PNG b/AutofocusScreen/doc/AutofocusPage_GridScan.PNG
deleted file mode 100644
index 76f3843..0000000
Binary files a/AutofocusScreen/doc/AutofocusPage_GridScan.PNG and /dev/null differ
diff --git a/AutofocusScreen/doc/AutofocusPage_ScanFrame.PNG b/AutofocusScreen/doc/AutofocusPage_ScanFrame.PNG
deleted file mode 100644
index 44ad8d9..0000000
Binary files a/AutofocusScreen/doc/AutofocusPage_ScanFrame.PNG and /dev/null differ
diff --git a/AutofocusScreen/doc/AutofocusPage_v3.PNG b/AutofocusScreen/doc/AutofocusPage_v3.PNG
deleted file mode 100644
index f4da2cd..0000000
Binary files a/AutofocusScreen/doc/AutofocusPage_v3.PNG and /dev/null differ
diff --git a/AutofocusScreen/doc/Trigger1Page.PNG b/AutofocusScreen/doc/Trigger1Page.PNG
new file mode 100644
index 0000000..3a8d2e9
Binary files /dev/null and b/AutofocusScreen/doc/Trigger1Page.PNG differ
diff --git a/AutofocusScreen/src/AutofocusScreen/AFcsJob.cls b/AutofocusScreen/src/AutofocusScreen/AFcsJob.cls
new file mode 100644
index 0000000..082dac1
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/AFcsJob.cls
@@ -0,0 +1,377 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "AFcsJob"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+''''
+' Class for storing FCS job parameters
+''''
+
+Option Explicit
+Public Name As String
+Public LightPathConfig As String
+Private LaserActive() As Boolean
+Private LaserName() As String
+Private BleachActive() As Boolean
+Private LaserTransmission() As Double
+Private BleachTransmission() As Double
+Private MeasurementTime As Double
+Private Repetitions As Integer
+Private BleachTime As Double
+Private PositionsEnabled As Boolean
+Private TimeSeriesEnabled As Boolean
+
+'Private Filters() As Long
+'Private Channels() As Long
+'
+'Private BeamSplitterVis As Long
+'Private BeamSplitterInVis As Long
+'Private IRBlockFilter As Long
+'Private BeamSplitter2 As Long
+'Private EmissionFilterAPD1 As Long
+'Private EmissionFilterAPD2 As Long
+'Private SelectCh1 As Boolean
+'Private SelectCh2 As Boolean
+'Private SelectCh1Ch2 As Boolean
+'Private SelectCh2Ch1 As Boolean
+
+'''
+' setJob(ZEN As Object, ZENv As Integer)
+'   loads FCSJob from ZEN into Macro. Calls respective function
+'''
+Public Function setJob(ZEN As Object, ZENv As Integer) As Boolean
+    If ZENv > 2010 Then
+       setJobAi ZEN
+    Else
+       setJobNoAi "current"
+    End If
+End Function
+
+''''
+'   reads FCS settings from ZEN into Macro. This command is used for ZENv < 2011
+'   In the absence of ZEN_Micro_AIM_ApplicationInterface
+'   Only stores which laser is active, its transmission and the measurement time and repetitions
+'''
+Public Function setJobNoAi(ConfigName As String) As Boolean
+    Dim FcsControl As AimFcsController
+    Set FcsControl = Fcs
+    Dim i As Integer
+    Dim NrLasers As Long
+    
+    LightPathConfig = ConfigName
+    NrLasers = FcsControl.HardwareInformation.GetNumberAttenuators
+   
+    ReDim BleachActive(0 To NrLasers - 1)
+    ReDim BleachTransmission(0 To NrLasers - 1)
+    ReDim LaserActive(0 To NrLasers - 1)
+    ReDim LaserTransmission(0 To NrLasers - 1)
+    ReDim LaserName(0 To NrLasers - 1)
+    For i = 0 To NrLasers - 1
+          LaserName(i) = CStr(1000000000 * FcsControl.HardwareInformation.GetAttenuatorWavelength(i))
+          LaserActive(i) = FcsControl.BeamPathParameters.AttenuatorOn(i)
+          BleachActive(i) = FcsControl.BeamPathParameters.BleachAttenuatorOn(i)
+          BleachTransmission(i) = FcsControl.BeamPathParameters.BleachAttenuatorPower(i)
+          LaserTransmission(i) = FcsControl.BeamPathParameters.AttenuatorPower(i)
+    Next i
+    MeasurementTime = FcsControl.AcquisitionParameters.MeasurementTime
+    Repetitions = FcsControl.AcquisitionParameters.MeasurementRepeat
+    BleachTime = FcsControl.AcquisitionParameters.BleachTime
+
+End Function
+
+
+''''
+'   loads FCSJob from ZEN into Macro. Uses the GUI (only works for ZENv > 2010)
+'   recquires ZEN_Micro_AIM_ApplicationInterface
+'   force to save the lightpath config. This config can then be reloaded when needed
+'   Save also settings for lasers. It is compatible with putJobNoGui
+'''
+Public Function setJobAi(ZEN As Object) As Boolean
+    On Error GoTo ErrorHandle
+    Dim FcsControl As AimFcsController
+    Set FcsControl = Fcs
+    Dim i As Integer
+    Dim NrLasers As Integer
+    If Not ZEN Is Nothing Then
+        NrLasers = ZEN.gui.Fcs.LightPath.Lasers.ItemCount
+        ZEN.CommandExecute "Fcs.BeamPath.Save"
+        'get the current saved item. Loading this item is in priciple enough for the experiment
+        LightPathConfig = ZEN.gui.Fcs.LightPathConfig.CurrentItem
+        
+        ReDim LaserActive(0 To NrLasers - 1)
+        ReDim LaserTransmission(0 To NrLasers - 1)
+        ReDim LaserName(0 To NrLasers - 1)
+        
+        For i = 0 To NrLasers - 1
+            ZEN.gui.Fcs.LightPath.Lasers.ByIndex = i
+            LaserActive(i) = ZEN.gui.Fcs.LightPath.Lasers.On.Value
+            LaserTransmission(i) = ZEN.gui.Fcs.LightPath.Lasers.Transmission.Value / 100
+            LaserName(i) = ZEN.gui.Fcs.LightPath.Lasers.ByName
+        Next i
+        
+        ReDim BleachActive(0 To NrLasers - 1)
+        ReDim BleachTransmission(0 To NrLasers - 1)
+        
+        For i = 0 To NrLasers - 1
+            ZEN.gui.Fcs.LightPath.BleachLasers.ByIndex = i
+            BleachActive(i) = ZEN.gui.Fcs.LightPath.BleachLasers.On.Value
+            BleachTransmission(i) = ZEN.gui.Fcs.LightPath.BleachLasers.Transmission.Value / 100
+        Next i
+        MeasurementTime = FcsControl.AcquisitionParameters.MeasurementTime
+        Repetitions = FcsControl.AcquisitionParameters.MeasurementRepeat
+        BleachTime = FcsControl.AcquisitionParameters.BleachTime
+        PositionsEnabled = ZEN.gui.Fcs.EnablePositions.Value
+        TimeSeriesEnabled = ZEN.gui.Fcs.EnableTimeSeries.Value
+        setJobAi = True
+
+    Else
+        Exit Function
+    End If
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in AFcsJob.setJobAi " + Err.Description
+    ErrorLog.UpdateLog "Error in AFcsJob.setJobGui " + Err.Description
+End Function
+
+
+'''
+' putJob(ZEN As Object, ZENv As Integer)
+'   put stored settings from Macro back into ZEN. Calls respective function depending on ZEN version
+'''
+Public Function putJob(ZEN As Object, ZENv As Integer) As Boolean
+    If ZENv > 2010 Then
+        putJob = putJobAi(ZEN)
+    Else
+        putJob = putJobNoAi
+    End If
+End Function
+
+
+'''
+'     Transfers settings from Macro into ZEN using the GUI (ZENv > 2011)
+'     recquires ZEN_Micro_AIM_ApplicationInterface
+'     Complete setting with name LightPathConfig for light path can be uploaded
+'     also the Measurement time etc are stored
+'''
+Public Function putJobAi(ZEN As Object) As Boolean
+
+    On Error GoTo ErrorHandle
+    If Not ZEN Is Nothing Then
+        'get the current saved item. Loading this item is in priciple enough for the experiment
+        If ZEN.gui.Fcs.LightPathConfig.isValidItem(LightPathConfig) Then
+            ZEN.gui.Fcs.LightPathConfig.Load LightPathConfig
+        Else
+            If LightPathConfig <> "" Then
+                MsgBox "AFcsJob.putJobGui. For Fcs Job " & Name & ". No LightPathconfig with the name " & LightPathConfig
+            Else
+                MsgBox "AFcsJob.putJobGui. Fcs Job " & Name & " has not been initiated use ZEN->Macro button"
+            End If
+            Exit Function
+        End If
+        ZEN.gui.Fcs.EnablePositions.Value = PositionsEnabled
+        ZEN.gui.Fcs.EnableTimeSeries.Value = TimeSeriesEnabled
+        ZEN.SetDouble "Fcs.Acquisition.MeasureTime", MeasurementTime
+        ZEN.SetDouble "Fcs.Acquisition.Repetitions", Repetitions
+        ZEN.SetDouble "Fcs.Acquisition.BleachTime", BleachTime
+        putJobAi = True
+    
+    
+        Exit Function
+    End If
+    
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in AFcsJob.setJobGui " + Err.Description
+    ErrorLog.UpdateLog "Error in AFcsJob.setJobGui " + Err.Description
+End Function
+
+     
+     
+'''
+' putJobNoGui()
+'   Transfer settings from Macro into ZEN without using the GUI
+'   In the absence of ZEN_Micro_AIM_ApplicationInterface (ZENv <2011) we only save which lasers are on, laser power, and time lapse.
+'   All other settings are not saved and use the
+'   current status
+'''
+Public Function putJobNoAi() As Boolean
+    Dim FcsControl As AimFcsController
+    Set FcsControl = Fcs
+    Dim i As Integer
+    Dim NrLasers As Long
+    NrLasers = FcsControl.HardwareInformation.GetNumberAttenuators
+    For i = 0 To NrLasers - 1
+          FcsControl.BeamPathParameters.AttenuatorOn(i) = LaserActive(i)
+          FcsControl.BeamPathParameters.BleachAttenuatorOn(i) = BleachActive(i)
+          FcsControl.BeamPathParameters.BleachAttenuatorPower(i) = BleachTransmission(i)
+          FcsControl.BeamPathParameters.AttenuatorPower(i) = LaserTransmission(i)
+    Next i
+    FcsControl.AcquisitionParameters.MeasurementTime = MeasurementTime
+    FcsControl.AcquisitionParameters.MeasurementRepeat = Repetitions
+    FcsControl.AcquisitionParameters.BleachTime = BleachTime
+End Function
+
+''''
+' Create a string with the description of a Job
+''''
+Public Function jobDescriptor() As String
+    Dim i As Integer
+    Dim Description As String
+    Description = "FcsJob: " & Name & vbCrLf
+    If LightPathConfig <> "" Then
+        Description = Description & "Configuration: " & LightPathConfig & vbCrLf
+        Description = Description & "FcsLasers: " & vbCrLf
+        For i = 0 To UBound(LaserName)
+            If LaserActive(i) Then
+                Description = Description & "  " & LaserName(i) & " at " & CStr(Round(LaserTransmission(i) * 100, 3)) & "%" & vbCrLf
+            End If
+        Next i
+        Description = Description & "BleachLasers: " & vbCrLf
+        For i = 0 To UBound(LaserName)
+            If BleachActive(i) Then
+                Description = Description & "  " & LaserName(i) & " at  " & CStr(Round(BleachTransmission(i) * 100, 3)) & "%" & vbCrLf
+            End If
+        Next i
+        Description = Description & "MeasurementTime = " & MeasurementTime & " s" & vbCrLf
+        Description = Description & "Repetitions = " & Repetitions & vbCrLf
+        Description = Description & "Bleach Time = " & BleachTime & " s" & vbCrLf
+ 
+    Else
+        Description = Description & "Job has not been set"
+    End If
+    jobDescriptor = Description
+End Function
+
+'''
+' split a String into two different Strigs depending on their maximal length
+''''
+Public Function splittedJobDescriptor(MaxLines As Integer, jobDescription As String) As String()
+    Dim i As Integer
+    Dim Label1() As String
+    Dim Label2() As String
+    Dim Output() As String
+    ReDim Output(1)
+    Label1 = Split(jobDescription, vbCrLf)
+    If UBound(Label1) > MaxLines - 1 Then
+        ReDim Label2(0 To UBound(Label1) - MaxLines)
+        For i = 0 To UBound(Label1) - MaxLines
+            Label2(i) = Label1(MaxLines + i)
+        Next i
+        ReDim Preserve Label1(0 To MaxLines - 1)
+    Else
+        ReDim Label2(0)
+    End If
+    Output(0) = Join(Label1, vbCrLf)
+    Output(1) = Join(Label2, vbCrLf)
+    splittedJobDescriptor = Output
+End Function
+
+''
+' create a String to save of the "complete" job desriptin
+''
+Public Function jobDescriptorSettings() As String
+    Dim Descriptor As String
+    Descriptor = "JobFcsName " & Me.Name & vbCrLf
+    Descriptor = Descriptor & "LightPathConfig " & LightPathConfig & vbCrLf
+    Descriptor = Descriptor & "PositionsEnabled " & PositionsEnabled & vbCrLf
+    Descriptor = Descriptor & "TimeSeriesEnabled " & TimeSeriesEnabled & vbCrLf
+    Descriptor = Descriptor & "MeasurementTime " & MeasurementTime & vbCrLf
+    Descriptor = Descriptor & "Repetitions " & MeasurementTime & vbCrLf
+    Descriptor = Descriptor & "BleachTime " & BleachTime & vbCrLf
+    Descriptor = Descriptor & "EndJobFcsDef " & vbCrLf
+    jobDescriptorSettings = Descriptor
+End Function
+
+Public Sub testDescriptor()
+    consistencyDescriptor (jobDescriptorSettings)
+End Sub
+
+Private Function consistencyDescriptor(Descriptor As String)
+    Dim i As Integer
+    Dim DerivedDescr() As String
+    Dim KeyItem() As String
+    DerivedDescr = Split(Descriptor, vbCrLf)
+    For i = 0 To UBound(DerivedDescr)
+        'Debug.Print DerivedDescr(i)
+        Sleep (100)
+        KeyItem = Split(DerivedDescr(i), " ")
+        If UBound(KeyItem) = 1 Then
+            If Not changeJobFromDescriptor(KeyItem(0), KeyItem(1)) Then
+                Exit Function
+            End If
+        End If
+    Next i
+    consistencyDescriptor = True
+End Function
+
+
+''''
+' change a job from a descriptor
+'''
+Public Function changeJobFromDescriptor(Descriptor As String, Value As Variant)
+    
+    Select Case Descriptor
+        Case "JobFcsName":
+            Name = CStr(Value)
+        Case "LightPathConfig":
+            LightPathConfig = CStr(Value)
+        Case "PositionsEnabled":
+            PositionsEnabled = CBool(Value)
+        Case "TimeSeriesEnabled":
+            TimeSeriesEnabled = CBool(Value)
+        Case "MeasurementTime":
+            MeasurementTime = CDbl(Value)
+        Case "Repetitions":
+            Repetitions = CInt(Value)
+        Case "BleachTime":
+            BleachTime = CDbl(Value)
+        Case "EndJobFcsDef":
+            
+        Case Else:
+            MsgBox " No Item " & Descriptor
+            Exit Function
+    End Select
+    changeJobFromDescriptor = True
+End Function
+
+
+
+' some commands one can use
+'    Dim Power As Double
+'    starts with 1 this is the acquisition power
+'    Power = FcsControl.BeamPathParameters.AttenuatorPower(2)
+'    Power = FcsControl.BeamPathParameters.BleachAttenuatorPower(1)
+'    FcsControl.BeamPathParameters.AttenuatorOn(1) = False
+'    Dim FcsControl As AimFcsController
+'    Set FcsControl = Fcs
+'    ZEN.GUI.Fcs.LightPath.BleachLasers.ByIndex = 1
+'    ZEN.GUI.Fcs.LightPath.BleachLasers.Transmission.Value = 0.1
+        'load Filters we only save the laser power
+        '        BeamSplitterVis = ZEN.gui.Fcs.LightPath.BeamSplitterVis.ByIndex
+        '        BeamSplitterInVis = ZEN.gui.Fcs.LightPath.BeamSplitterInVis.ByIndex
+        '        IRBlockFilter = ZEN.gui.Fcs.LightPath.IRBlockFilter.ByIndex
+        '        BeamSplitter2 = ZEN.gui.Fcs.LightPath.BeamSplitter2.ByIndex
+        '        EmissionFilterAPD1 = ZEN.gui.Fcs.LightPath.EmissionFilterAPD1.ByIndex
+        '        EmissionFilterAPD2 = ZEN.gui.Fcs.LightPath.EmissionFilterAPD2.ByIndex
+        '        SelectCh1 = ZEN.gui.Fcs.LightPath.SelectCh1.Value
+        '        SelectCh2 = ZEN.gui.Fcs.LightPath.SelectCh2.Value
+        '        SelectCh1Ch2 = ZEN.gui.Fcs.LightPath.SelectCh1Ch2.Value
+        '        SelectCh2Ch1 = ZEN.gui.Fcs.LightPath.SelectCh2Ch1.Value
+            
+    'there are too many things one shall record we only set the laser power
+    'NrFilters = FcsControl.HardwareInformation.GetNumberFilterSets
+    'For i = 0 To NrFilters - 1
+    '    Filters(i) = FcsControl.BeamPathParameters.FilterSetPosition(i)
+    'Next i
+    ' NrChannels = FcsControl.AcquisitionParameters.Channels
+'    For i = 0 To NrChannels - 1
+'        Channels(i) = FcsControl.AcquisitionParameters.ChannelEnabled(i)
+'    Next i
+    'SelectCh1 = FcsControl.AcquisitionParameters.ChannelDetectorA
+    'dumper = FcsControl.BeamPathParameters.Dump
+'    Debug.Print FcsControl.AcquisitionParameters.ChannelDetectorA
+'    Debug.Print "Position Filter " & FcsControl.BeamPathParameters.FilterSetPosition(0)
diff --git a/AutofocusScreen/src/AutofocusScreen/AGrid.cls b/AutofocusScreen/src/AutofocusScreen/AGrid.cls
new file mode 100644
index 0000000..c924473
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/AGrid.cls
@@ -0,0 +1,901 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "AGrid"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''
+' Class for creating and administrating a grid
+' The positions and subpositions are numbered starting from 1
+' A grid defines positions travelled with the stage for imaging
+'''
+Option Explicit
+
+'''' Name if grid
+Public NameGrid As String
+'''' Max zeros padded in front of Wxxxx
+Const maxZeros = 4
+
+'''' A gridpoint is the unit of a grid. It will have a name specified by its position in the array
+Private Type GridPoint
+    Name As String    'this is used as prefix for the name
+    X As Double
+    Y As Double
+    Z As Double
+    Valid As Boolean
+End Type
+
+'''' An array of gridpoints
+Private GridArray() As GridPoint
+'''' Define size of Array
+Public numRow As Long
+Public numCol As Long
+Public numRowSub As Long
+Public numColSub As Long
+
+''''Current Row, Col, RowSub, ColSub when 0 it is empty array. Proper array starts from 1!
+Public iRow As Long
+Public iCol As Long
+Public iRowSub As Long
+Public iColSub As Long
+
+'''
+'   Initialize the dimensions of the array
+'''
+Public Sub initialize(Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If Row = 0 Or Col = 0 Or RowSub = 0 Or ColSub = 0 Then
+        initializeToZero
+    Else
+        On Error GoTo ErrorHandle:
+        Me.numRow = Row
+        Me.numCol = Col
+        Me.numRowSub = RowSub
+        Me.numColSub = ColSub
+        Me.iRow = 1
+        Me.iCol = 1
+        Me.iRowSub = 1
+        Me.iColSub = 1
+        ReDim GridArray(1 To Me.numRow, 1 To Me.numCol, 1 To Me.numRowSub, 1 To Me.numColSub)
+    End If
+    Exit Sub
+ErrorHandle:
+    MsgBox "Error, " + Err.Source + " in AGrid.initialize " + Err.Description
+End Sub
+
+
+'''
+'   Reset array to empty array
+'''
+Public Sub initializeToZero()
+    Me.numRow = 0
+    Me.numCol = 0
+    Me.numRowSub = 0
+    Me.numColSub = 0
+    Me.iRow = 0
+    Me.iCol = 0
+    Me.iRowSub = 0
+    Me.iColSub = 0
+    ReDim GridArray(0, 0, 0, 0)
+End Sub
+
+'''
+'   Redimension the array and preserve size
+'''
+Public Sub updateGridSizePreserve(Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    Dim iRow As Long
+    Dim iCol As Long
+    Dim iRowSub As Long
+    Dim iColSub As Long
+    Dim TmpGridArray() As GridPoint
+    TmpGridArray = GridArray
+    Me.iRow = 1
+    Me.iCol = 1
+    Me.iRowSub = 1
+    Me.iColSub = 1
+    
+    If Me.numRow = Row And Me.numCol = Col And Me.numRowSub = RowSub Then
+        ReDim Preserve GridArray(1 To Me.numRow, 1 To Me.numCol, 1 To Me.numRowSub, 1 To ColSub)
+    Else
+        'can only update last dimension
+        ReDim GridArray(1 To Row, 1 To Col, 1 To RowSub, 1 To ColSub)
+        
+        For iRow = 1 To Me.numRow
+            For iCol = 1 To Me.numCol
+                For iRowSub = 1 To numRowSub
+                    For iColSub = 1 To Me.numColSub
+                        GridArray(iRow, iCol, iRowSub, iColSub) = TmpGridArray(iRow, iCol, iRowSub, iColSub)
+                    Next iColSub
+                Next iRowSub
+            Next iCol
+        Next iRow
+    End If
+    
+    Me.numRow = Row
+    Me.numCol = Col
+    Me.numRowSub = RowSub
+    Me.numColSub = ColSub
+
+    ReDim Preserve GridArray(1 To Me.numRow, 1 To Me.numCol, 1 To Me.numRowSub, 1 To Me.numColSub)
+End Sub
+
+Public Function isGridEmpty() As Boolean
+    If LBound(GridArray) = 0 And UBound(GridArray) = 0 Then
+        isGridEmpty = True
+    End If
+End Function
+
+'''
+' Check if indeces are in the allowable range
+'''
+Private Function correctIndeces(Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Boolean
+    If Row > 0 And Row <= Me.numRow And Col > 0 And Col <= Me.numCol And RowSub > 0 And RowSub <= Me.numRowSub And ColSub > 0 And ColSub <= Me.numColSub Then
+        correctIndeces = True
+    Else
+        MsgBox "Grid getPt: was not able to access grid pt. Gridposition does not correspond to grid size"
+    End If
+End Function
+
+'''
+' suffix is WxxxxPxxxx created at current position of grid
+'''
+Public Function thisSuffix() As String
+    'convert numbers into a string
+    Dim iWell As Long
+    Dim iPosition As Long
+    Dim Name As String
+    Dim nrZero As Integer
+    Name = ""
+    iWell = (Me.iRow - 1) * numCol + Me.iCol
+    iPosition = (Me.iRowSub - 1) * numColSub + Me.iColSub
+    If iWell >= 0 Then
+        nrZero = maxZeros - Len(CStr(iWell))
+        Name = Name + "W" + ZeroString(nrZero) + CStr(iWell)
+    End If
+    If iPosition >= 0 Then
+        nrZero = maxZeros - Len(CStr(iPosition))
+        Name = Name + "_P" + ZeroString(nrZero) + CStr(iPosition)
+    End If
+    thisSuffix = Name
+End Function
+
+'''
+'   Suffix without subposition indication
+'''
+Public Function thisSuffixWell() As String
+    'convert numbers into a string
+    Dim iWell As Long
+    Dim iPosition As Long
+    Dim Name As String
+    Dim nrZero As Integer
+    Name = ""
+    iWell = (Me.iRow - 1) * numCol + Me.iCol
+    If iWell >= 0 Then
+        nrZero = maxZeros - Len(CStr(iWell))
+        Name = Name + "W" + ZeroString(nrZero) + CStr(iWell)
+    End If
+    thisSuffixWell = Name
+End Function
+
+'''
+' Suffix given a Row, Col etc.
+'''
+Public Function suffix(Row As Long, Col As Long, RowSub As Long, ColSub As Long) As String
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        'convert numbers into a string
+        Dim iWell As Long
+        Dim iPosition As Long
+        Dim Name As String
+        Dim nrZero As Integer
+        Name = ""
+        iWell = (Row - 1) * numCol + Col
+        iPosition = (RowSub - 1) * numColSub + ColSub
+        If iWell >= 0 Then
+            nrZero = maxZeros - Len(CStr(iWell))
+            Name = Name + "W" + ZeroString(nrZero) + CStr(iWell)
+        End If
+        If iPosition >= 0 Then
+            nrZero = maxZeros - Len(CStr(iPosition))
+            Name = Name + "_P" + ZeroString(nrZero) + CStr(iPosition)
+        End If
+        suffix = Name
+    End If
+End Function
+
+
+
+Public Function getThisName() As String
+    getThisName = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Name
+End Function
+
+
+Public Function getName(Row As Long, Col As Long, RowSub As Long, ColSub As Long) As String
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        getName = GridArray(Row, Col, RowSub, ColSub).Name
+    End If
+End Function
+
+
+Public Sub setThisName(Value As String)
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Name = Value
+End Sub
+
+
+Public Sub setName(Value As String, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        GridArray(Row, Col, RowSub, ColSub).Name = Value
+        If Value <> "" Then
+            If Right(Value, 1) <> "_" Then
+                GridArray(Row, Col, RowSub, ColSub).Name = Value & "_"
+            End If
+        End If
+    End If
+End Sub
+
+
+
+
+
+Public Function getIndeces(Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    Row = Me.iRow
+    Col = Me.iCol
+    RowSub = Me.iRowSub
+    ColSub = Me.iColSub
+End Function
+
+
+
+Public Function setIndeces(Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        Me.iRow = Row
+        Me.iCol = Col
+        Me.iRowSub = RowSub
+        Me.iColSub = ColSub
+    End If
+End Function
+
+'''
+'   get/set current grid position
+'''
+Public Sub getThisPt(pos As Vector, Valid As Boolean)
+    pos.X = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).X
+    pos.Y = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Y
+    pos.Z = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Z
+    Valid = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Valid
+End Sub
+
+Public Function getThisX() As Double
+    getThisX = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).X
+End Function
+
+
+Public Function getThisY() As Double
+    getThisY = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Y
+End Function
+
+
+Public Function getThisZ() As Double
+    getThisZ = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Z
+End Function
+
+
+Public Function getThisValid() As Boolean
+    getThisValid = GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Valid
+End Function
+
+
+Public Sub setThisPt(pos As Vector, Valid As Boolean)
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).X = pos.X
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Y = pos.Y
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Z = pos.Z
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Valid = Valid
+End Sub
+
+
+Public Sub setThisX(Value As Double)
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).X = Value
+End Sub
+
+Public Sub setThisY(Value As Double)
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Y = Value
+End Sub
+
+Public Sub setThisZ(Value As Double)
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Z = Value
+End Sub
+
+
+Public Sub setThisValid(Value As Boolean)
+    GridArray(Me.iRow, Me.iCol, Me.iRowSub, Me.iColSub).Valid = Value
+End Sub
+
+
+
+
+'''
+'   get/set position defined by Row, Colm RowSub and ColSub
+''''
+Public Sub getPt(pos As Vector, Valid As Boolean, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        pos.X = GridArray(Row, Col, RowSub, ColSub).X
+        pos.Y = GridArray(Row, Col, RowSub, ColSub).Y
+        pos.Z = GridArray(Row, Col, RowSub, ColSub).Z
+        Valid = GridArray(Row, Col, RowSub, ColSub).Valid
+    End If
+End Sub
+
+'''
+' get nr of points in grid
+'''
+Public Function getNrPts() As Long
+    getNrPts = Me.numCol * Me.numRow * Me.numRowSub * Me.numColSub
+End Function
+
+
+'''
+'   get nr of valid points in grid
+'''
+Public Function getNrValidPts() As Long
+    Dim iRow As Long
+    Dim iCol As Long
+    Dim iRowSub As Long
+    Dim iColSub As Long
+    Dim nrValid As Long
+    nrValid = 0
+    ' All points are true as default
+    For iRow = 1 To Me.numRow
+        For iCol = 1 To Me.numCol
+            For iRowSub = 1 To numRowSub
+                For iColSub = 1 To Me.numColSub
+                    If GridArray(iRow, iCol, iRowSub, iColSub).Valid Then
+                        nrValid = nrValid + 1
+                    End If
+                Next iColSub
+            Next iRowSub
+        Next iCol
+    Next iRow
+    getNrValidPts = nrValid
+End Function
+
+
+
+Public Function getX(Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Double
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        getX = GridArray(Row, Col, RowSub, ColSub).X
+    End If
+End Function
+
+Public Function getY(Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Double
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        getY = GridArray(Row, Col, RowSub, ColSub).Y
+    End If
+End Function
+
+Public Function getZ(Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Double
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        getZ = GridArray(Row, Col, RowSub, ColSub).Z
+    End If
+End Function
+
+Public Function getValid(Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Boolean
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        getValid = GridArray(Row, Col, RowSub, ColSub).Valid
+    End If
+End Function
+
+Public Sub setPt(pos As Vector, Valid As Boolean, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        GridArray(Row, Col, RowSub, ColSub).X = pos.X
+        GridArray(Row, Col, RowSub, ColSub).Y = pos.Y
+        GridArray(Row, Col, RowSub, ColSub).Z = pos.Z
+        GridArray(Row, Col, RowSub, ColSub).Valid = Valid
+    End If
+End Sub
+
+Public Sub setX(X As Double, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        GridArray(Row, Col, RowSub, ColSub).X = X
+    End If
+End Sub
+
+Public Sub setY(Y As Double, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        GridArray(Row, Col, RowSub, ColSub).Y = Y
+    End If
+End Sub
+
+Public Sub setZ(Z As Double, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        GridArray(Row, Col, RowSub, ColSub).Z = Z
+    End If
+End Sub
+
+
+Public Sub setValid(Valid As Boolean, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If correctIndeces(Row, Col, RowSub, ColSub) Then
+        GridArray(Row, Col, RowSub, ColSub).Valid = Valid
+    End If
+End Sub
+
+Public Sub setAllValid(Valid As Boolean)
+    ' All points are true as default
+    For iRow = 1 To Me.numRow
+        For iCol = 1 To Me.numCol
+            For iRowSub = 1 To numRowSub
+                For iColSub = 1 To Me.numColSub
+                    GridArray(iRow, iCol, iRowSub, iColSub).Valid = Valid
+                Next iColSub
+            Next iRowSub
+        Next iCol
+    Next iRow
+End Sub
+
+
+
+'''
+' Go to next gridPt according to meandering. True if there is a next grid pt. False if Grid has reached an end
+'''
+Public Function nextGridPt() As Boolean
+    'update GridSub
+    If Me.iRowSub Mod 2 <> 0 Then
+        Me.iColSub = Me.iColSub + 1
+    Else
+        Me.iColSub = Me.iColSub - 1
+    End If
+    
+    If Me.iColSub > numColSub Then
+        Me.iColSub = Me.numColSub
+        Me.iRowSub = Me.iRowSub + 1
+    End If
+    
+    If Me.iColSub < 1 Then
+        Me.iColSub = 1
+        Me.iRowSub = Me.iRowSub + 1
+    End If
+        
+    'update mainGrid
+    If Me.iRowSub > Me.numRowSub Then
+        Me.iRowSub = 1
+        If Me.iRow Mod 2 <> 0 Then
+            Me.iCol = Me.iCol + 1
+        Else
+            Me.iCol = Me.iCol - 1
+        End If
+        If Me.iCol > Me.numCol Then
+            Me.iCol = numCol
+            Me.iRow = Me.iRow + 1
+        End If
+        If Me.iCol < 1 Then
+            Me.iCol = 1
+            Me.iRow = Me.iRow + 1
+        End If
+    End If
+    
+    ''end of grid has been reached
+    If Me.iRow > Me.numRow Then
+        nextGridPt = False
+    Else
+        nextGridPt = True
+    End If
+                    
+End Function
+
+
+'''''
+'   makeGridFromOnePt( pos As Vector, posGridY() As Double, posGridXY_valid() )
+'   Create a Grid and a Subgrid use using  pos as starting coordinates
+'       dX, dY:         Gridspacing main Grid. The main grid is the center of the subgrid
+'       dXsub, dYsub:   Gridspacing subGrid
+'       refRow:         reference row where main grid starts
+'       refCol:         reference column where main grid starts
+'''''
+Public Sub makeGridFromOnePt(pos As Vector, Row As Long, Col As Long, RowSub As Long, ColSub As Long, dRow As Double, dCol As Double, _
+dRowSub As Double, dColSub As Double, Optional refRow As Integer = 1, Optional refCol As Integer = 1)
+        
+        initialize Row, Col, RowSub, ColSub
+        ' A row correspond to Y movement and Column to X shift
+        'Make main grid
+        Dim iRow As Long
+        Dim iCol As Long
+        Dim iRowSub As Long
+        Dim iColSub As Long
+        'Make grid and subgrid
+        For iRow = 1 To Me.numRow
+            For iCol = 1 To Me.numCol
+                For iRowSub = 1 To Me.numRowSub
+                    For iColSub = 1 To Me.numColSub
+                        GridArray(iRow, iCol, iRowSub, iColSub).X = Round(pos.X + (1 - refCol) * dCol + (iCol - 1) * dCol + (iColSub - 1 - (Me.numColSub - 1) / 2) * dColSub, PrecXY)
+                        GridArray(iRow, iCol, iRowSub, iColSub).Y = Round(pos.Y + (1 - refRow) * dRow + (iRow - 1) * dRow + (iRowSub - 1 - (Me.numRowSub - 1) / 2) * dRowSub, PrecXY)
+                        GridArray(iRow, iCol, iRowSub, iColSub).Z = Round(pos.Z, PrecZ)
+                    Next iColSub
+                Next iRowSub
+            Next iCol
+        Next iRow
+            
+        ' All points are true as default
+        For iRow = 1 To Me.numRow
+            For iCol = 1 To Me.numCol
+                For iRowSub = 1 To numRowSub
+                    For iColSub = 1 To Me.numColSub
+                        GridArray(iRow, iCol, iRowSub, iColSub).Valid = True
+                    Next iColSub
+                Next iRowSub
+            Next iCol
+        Next iRow
+End Sub
+
+
+'''''
+'   makeGridFromManyPts(X() As Double, Y() As Double, Z() As Double, dXsub As Double, dYsub As Double  )
+'   Create a Grid and a Subgrid use using X, Y and Z as coordinates for the main grid. A row corresponds to
+'   Y movement and Column to X shift\
+'       X, Y, Z:        Array containing coordinates of main grid.
+'       dXsub, dYsub:   Gridspacing subGrid
+'''''
+Public Sub makeGridFromManyPts(pos() As Vector, Row As Long, Col As Long, RowSub As Long, ColSub As Long, dColSub As Double, dRowSub As Double)
+        Dim iCol As Long
+        Dim iRow As Long
+        Dim iRowSub As Long
+        Dim iColSub As Long
+        initialize Row, Col, RowSub, ColSub
+        
+        If UBound(pos) + 1 <> Me.numCol Then
+            MsgBox "Number of positions does not correspond to number of gridPts"
+            Exit Sub
+        End If
+        'Make grid and subgri
+        For iCol = 1 To Me.numCol
+            For iRowSub = 1 To Me.numRowSub
+                For iColSub = 1 To Me.numColSub
+                    GridArray(1, iCol, iRowSub, iColSub).X = Round(pos(iCol - 1).X + (iColSub - 1 - (Me.numColSub - 1) / 2) * dColSub, PrecXY)
+                    GridArray(1, iCol, iRowSub, iColSub).Y = Round(pos(iCol - 1).Y + (iRowSub - 1 - (Me.numRowSub - 1) / 2) * dRowSub, PrecXY)
+                    GridArray(1, iCol, iRowSub, iColSub).Z = Round(pos(iCol - 1).Z, PrecZ)
+                Next iColSub
+            Next iRowSub
+        Next iCol
+        
+        ' All points are true as default
+        For iCol = 1 To Me.numCol
+            For iRowSub = 1 To Me.numRowSub
+                For iColSub = 1 To Me.numColSub
+                    GridArray(1, iCol, iRowSub, iColSub).Valid = True
+                Next iColSub
+            Next iRowSub
+        Next iCol
+
+End Sub
+
+''''
+' isPositionGridFile
+' Check that entries of first line correspond to 4 specified values
+''''
+Public Function isPositionGridFile(ByVal sFile As String, ByVal Row As Integer, ByVal Col As Integer, ByVal RowSub As Integer, ByVal ColSub As Integer) As Boolean
+    If FileExist(sFile) Then
+        Close
+        On Error GoTo ErrorPosFile:
+        Dim iFileNum As Integer
+        Dim Fields As String
+        Dim FieldEntries() As String
+        iFileNum = FreeFile()
+        Open sFile For Input As iFileNum
+        Line Input #iFileNum, Fields
+        While Left(Fields, 1) = "%"
+            Line Input #iFileNum, Fields
+        Wend
+        FieldEntries = Split(Fields, " ")
+        If FieldEntries(0) = Row And FieldEntries(1) = Col And FieldEntries(2) = RowSub And FieldEntries(3) = ColSub Then
+            isPositionGridFile = True
+        Else
+           MsgBox ("CheckPosfile: Position file " & sFile & " needs to have same number of rows/col subrows/subcol as grid in form." & vbCrLf & _
+           "File: Row= " & FieldEntries(0) & ", Col= " & FieldEntries(1) & ", RowSub= " & FieldEntries(2) _
+           & ", ColSub= " & FieldEntries(3) & vbCrLf & _
+            "Form: Row= " & Row & ", Col= " & Col & ", RowSub= " & RowSub _
+           & ", ColSub= " & ColSub)
+           isPositionGridFile = False
+        End If
+        Close #iFileNum
+    Else
+       MsgBox ("CheckPosfile: Was not able to load position file " & sFile & ". File does not exist.")
+    End If
+    Exit Function
+ErrorPosFile:
+    If Err.number = 70 Then
+        MsgBox ("CheckPosfile: Was not able to load position file " & sFile & ". File is open by another program.")
+    End If
+End Function
+
+'''''''
+' loadPositionGridFile(ByVal sFile As String)
+'       [sFile] In  - Output file name
+'   Function loads a file and write entries in Double arrays. First entry of file is structure of grid
+'   Format is Me.numRow numCol numRowSub numColSub
+'   X Y Z X Y Z X Y Z etc
+'   This is not working!!!
+''''''''
+Public Function loadPositionGridFile(ByVal sFile As String) As Boolean
+    Dim iRow As Integer
+    Dim iCol As Integer
+    Dim iRowSub As Integer
+    Dim iColSub As Integer
+    Close
+    On Error GoTo ErrorPosFile:
+    Dim iFileNum As Integer
+    Dim Fields As String
+    Dim FieldEntries() As String
+    iFileNum = FreeFile()
+    Open sFile For Input As iFileNum
+    Line Input #iFileNum, Fields
+    ''jump comments
+    While Left(Fields, 1) = "%"
+        Line Input #iFileNum, Fields
+    Wend
+    FieldEntries = Split(Fields, " ")
+    initialize CLng(FieldEntries(0)), CLng(FieldEntries(1)), CLng(FieldEntries(2)), CLng(FieldEntries(3))
+    
+    For iRow = 1 To Me.numRow
+      For iCol = 1 To Me.numCol
+          Line Input #iFileNum, Fields
+          While Left(Fields, 1) = "%"
+            Line Input #iFileNum, Fields
+          Wend
+          FieldEntries = Split(Fields, " ")
+          For iRowSub = 1 To Me.numRowSub
+            'needs to check this
+              For iColSub = 1 To Me.numColSub
+'                  GridArray(iRow, iCol, iRowSub, iColSub).X = CDbl(FieldEntries((iColSub - 1) * 3 + (iRowSub - 1) * UBound(posGridX, 3) * 3))
+'                  GridArray(iRow, iCol, iRowSub, iColSub).Y = CDbl(FieldEntries((iColSub - 1) * 3 + (iRowSub - 1) * UBound(posGridX, 3) * 3 + 1))
+'                  GridArray(iRow, iCol, iRowSub, iColSub).Z = CDbl(FieldEntries((iColSub - 1) * 3 + (iRowSub - 1) * UBound(posGridX, 3) * 3 + 2))
+              Next iColSub
+          Next iRowSub
+      Next iCol
+    Next iRow
+    Close #iFileNum
+    loadPositionGridFile = True
+    Exit Function
+ErrorPosFile:
+    If Err.number = 70 Then
+        MsgBox ("LoadPosFile: Was not able to load position file " & sFile & ". File is open by another program.")
+    Else
+        MsgBox ("LoadPosFile: Was not able to load position file " & sFile)
+    End If
+    MsgBox ("Was not able to load position file " & sFile)
+End Function
+    
+ 
+'''''''
+'   writePositionGridFile (ByVal sFile As String)
+'       [sFile] In  - Output file name
+'   Write out position of grid. The first uncommented line is the structure of the grid. Comments are preceeded by %
+'   Format is
+'   numRow numCol numRowSub numColSub
+'   X Y Z X Y Z X Y Z etc
+''''''''
+Public Function writePositionGridFile(ByVal sFile As String) As Boolean
+    Dim iRow As Integer
+    Dim iCol As Integer
+    Dim iRowSub As Integer
+    Dim iColSub As Integer
+    Dim Line As String
+    Dim LineComm As String
+    Close
+    On Error GoTo ErrorPosFile:
+    Dim iFileNum As Integer
+    Dim Fields As String
+    Dim FieldEntries() As String
+    iFileNum = FreeFile()
+    Open sFile For Output As iFileNum
+    Print #iFileNum, "%nrRows nrColumns nrRowSubs nrColSubumns"
+    Print #iFileNum, Me.numRow & " " & Me.numCol & " " & Me.numRowSub & " " & Me.numColSub
+    For iRow = 1 To Me.numRow
+      For iCol = 1 To Me.numCol
+          LineComm = "%Row: " & iRow & ", Col: " & iCol & " "
+          Print #iFileNum, LineComm
+          Line = ""
+          LineComm = "%Rowsub Colsub: "
+          For iRowSub = 1 To Me.numRowSub
+              For iColSub = 1 To Me.numColSub
+                 LineComm = LineComm & iRowSub & " " & iColSub & ", "
+                 Line = Line & GridArray(iRow, iCol, iRowSub, iColSub).X & " " & GridArray(iRow, iCol, iRowSub, iColSub).Y & " " _
+                  & GridArray(iRow, iCol, iRowSub, iColSub).Z & " "
+              Next iColSub
+          Next iRowSub
+        Print #iFileNum, LineComm
+        Print #iFileNum, Line
+      Next iCol
+    Next iRow
+    Close #iFileNum
+    writePositionGridFile = True
+    Exit Function
+ErrorPosFile:
+    If Err.number = 70 Then
+        MsgBox ("WritePosFile: Was not able to load position file " & sFile & ". File is open by another program")
+    Else
+        MsgBox ("WritePosFile: Was not able to load position file " & sFile)
+    End If
+    Close #iFileNum
+End Function
+
+''''
+'   Check if file has a validGrid default format
+''''
+Public Function isValidGridFile(ByVal sFile As String, Row As Long, Col As Long, RowSub As Long, ColSub As Long) As String
+    Dim CellBase As String
+    Dim Default As String
+    Dim last_entry  As String
+    Dim Active As Boolean
+    Dim GoodMatch As Boolean
+    Dim RegEx As VBScript_RegExp_55.RegExp
+    Set RegEx = CreateObject("vbscript.regexp")
+    Dim Match As MatchCollection
+    Dim format As String
+    'Well--Row--Col--(Row,Col)--TypeofWell
+    CellBase = "(\d+)--(\d+)--(\d+)--(\S+)--(\S+)"
+    
+    If FileExist(sFile) Then
+        Close
+        Dim iFileNum As Integer
+        Dim Fields As String
+        Dim FieldEntries() As String
+        iFileNum = FreeFile()
+        Open sFile For Input As iFileNum
+        
+        'read first line
+        Line Input #iFileNum, Fields
+        While Left(Fields, 1) = "%"
+           Line Input #iFileNum, Fields
+        Wend
+        RegEx.Pattern = CellBase
+        If RegEx.Test(Fields) Then
+            format = "cellbase"
+        Else
+            'standard format
+            FieldEntries = Split(Fields, " ")
+            If UBound(FieldEntries) = 3 Then
+                If FieldEntries(0) = Row And FieldEntries(1) = Col And FieldEntries(2) = RowSub And FieldEntries(3) = ColSub Then
+                    isValidGridFile = "default"
+                Else
+                    MsgBox ("isValidGridFile: Valid Grid file " & sFile & " needs to have same number of rows/col subrows/subcol as grid in form." & vbCrLf & _
+                    "File: Row= " & FieldEntries(0) & ", Col= " & FieldEntries(1) & ", RowSub= " & FieldEntries(2) _
+                    & ", ColSub= " & FieldEntries(3) & vbCrLf & _
+                     "Form: Row= " & Row & ", Col= " & Col & ", RowSub= " & RowSub _
+                    & ", ColSub= " & ColSub)
+                    isValidGridFile = "none"
+                End If
+            Else
+                MsgBox sFile & " has not the correct format to set a validGrid and names! " & vbCrLf & "The format should be " & vbCrLf & "(In)active(0 or 1) Row(>=1)--Col(>=1) e.g." & vbCrLf & "0 1--1" & vbCrLf & "1 1--2" & vbCrLf _
+                & "or CellBase format Well--Row--Col--(Row,Col)--Identifier Identifier = none=> InactiveWell e.g." & vbCrLf & "1--2--1--(1,1)--empty" & vbCrLf _
+                & "1--1--2--(1,2)--MyCoolGene or empty" & vbCrLf & "or a list of 1 1 1 1 per subposition"
+                isValidGridFile = "none"
+            End If
+        End If
+        Close
+    Else
+        MsgBox "isValidGridFile: Could not load " & sFile
+        isValidGridFile = "none"
+    End If
+End Function
+
+
+'''''''
+'   need to be updated
+''''''''
+Public Function loadValidGridFile(ByVal sFile As String, format As String) As Boolean
+    
+    Close
+    Dim iRow As Long
+    Dim iCol As Long
+    Dim iRowSub As Long
+    Dim iColSub As Long
+    Dim iFileNum As Integer
+    Dim Fields As String
+    Dim FieldEntries() As String
+    Dim GoodMatch As Boolean
+    Dim CellBase As String
+    Dim RegEx As VBScript_RegExp_55.RegExp
+    Set RegEx = CreateObject("vbscript.regexp")
+    Dim Match As MatchCollection
+    CellBase = "(\d+)--(\d+)--(\d+)--(\S+)--(\S+)"
+    Dim Active As Boolean
+    If format <> "none" Or format <> "" Then
+        iFileNum = FreeFile()
+        Open sFile For Input As iFileNum
+        If format = "default" Then
+            Line Input #iFileNum, Fields
+            While Left(Fields, 1) = "%"
+                Line Input #iFileNum, Fields
+            Wend
+            FieldEntries = Split(Fields, " ")
+            For iRow = 1 To Me.numRow
+                For iCol = 1 To Me.numCol
+                  Line Input #iFileNum, Fields
+                  While Left(Fields, 1) = "%"
+                    Line Input #iFileNum, Fields
+                  Wend
+                  FieldEntries = Split(Fields, " ")
+                  For iRowSub = 1 To Me.numRowSub
+                      For iColSub = 1 To Me.numColSub
+                          GridArray(iRow, iCol, iRowSub, iColSub).Valid = CBool(FieldEntries((iColSub - 1) + (iRowSub - 1) * Me.numRowSub))
+                      Next iColSub
+                  Next iRowSub
+                Next iCol
+            Next iRow
+        ElseIf format = "cellbase" Then
+            Do While Not EOF(iFileNum)
+                Line Input #iFileNum, Fields
+                GoodMatch = False
+                RegEx.Pattern = CellBase
+                If RegEx.Test(Fields) Then
+                    Set Match = RegEx.Execute(Fields)
+                    Active = (Match.Item(0).SubMatches.Item(4) <> "none")
+                    GoodMatch = True
+                End If
+                'check it
+                'if this gridposition exists then update activity
+'                If GoodMatch And CInt(Match.Item(0).SubMatches.Item(1)) <= UBound(posGridXY_Valid, 1) And CInt(Match.Item(0).SubMatches.Item(1)) >= LBound(posGridXY_Valid, 1) _
+'                And CInt(Match.Item(0).SubMatches.Item(2)) <= UBound(posGridXY_Valid, 2) And CInt(Match.Item(0).SubMatches.Item(2)) >= LBound(posGridXY_Valid, 2) Then
+'                    For iRowSub = 1 To UBound(posGridXY_Valid, 3)
+'                        For iColSub = 1 To UBound(posGridXY_Valid, 4)
+'                            GridArray(CInt(Match.Item(0).SubMatches.Item(1)), CInt(Match.Item(0).SubMatches.Item(2)), iRowSub, iColSub).Valid = Active
+'                            setName Match.Item(0).SubMatches.Item(3) & "_" & Match.Item(0).SubMatches.Item(4), CInt(Match.Item(0).SubMatches.Item(1)), CInt(Match.Item(0).SubMatches.Item(2)), iRowSub, iColSub
+'                        Next iColSub
+'                    Next iRowSub
+'                End If
+            Loop
+        End If
+    Else
+        MsgBox ("loadValidGridFile: was not able to understand format " & format & " of " & sFile)
+    End If
+End Function
+
+    
+'''''''
+'
+'''''''
+Public Function writeValidGridFile(ByVal sFile As String) As Boolean
+    Dim iRow As Integer
+    Dim iCol As Integer
+    Dim iRowSub As Integer
+    Dim iColSub As Integer
+    Dim Line As String
+    Dim LineComm As String
+    Close
+    On Error GoTo ErrorPosFile:
+    Dim iFileNum As Integer
+    Dim Fields As String
+    Dim FieldEntries() As String
+    iFileNum = FreeFile()
+    Open sFile For Output As iFileNum
+    Print #iFileNum, "%nrRows nrColumns nrRowSubs nrColSubumns"
+    Print #iFileNum, Me.numRow & " " & Me.numCol & " " & Me.numRowSub & " " & Me.numColSub
+    For iRow = 1 To Me.numRow
+      For iCol = 1 To Me.numCol
+          LineComm = "%Row: " & iRow & ", Col: " & iCol & " "
+          Print #iFileNum, LineComm
+          Line = ""
+          LineComm = "%Rowsub Colsub: "
+          For iRowSub = 1 To Me.numRowSub
+              For iColSub = 1 To Me.numColSub
+                 LineComm = LineComm & iRowSub & " " & iColSub & ", "
+                 Line = Line & -GridArray(iRow, iCol, iRowSub, iColSub).Valid * 1 & " "
+              Next iColSub
+          Next iRowSub
+        Print #iFileNum, LineComm
+        Print #iFileNum, Line
+      Next iCol
+    Next iRow
+    Close #iFileNum
+    writeValidGridFile = True
+    Exit Function
+ErrorPosFile:
+    If Err.number = 70 Then
+        MsgBox ("WriteValidPosFile: Was not able to write valid position file " & sFile & ". File is open by another program")
+    Else
+        MsgBox ("WriteValidPosFile: Was not able to write valid position file " & sFile)
+    End If
+    Close #iFileNum
+End Function
+
+
+
diff --git a/AutofocusScreen/src/AutofocusScreen/AJob.cls b/AutofocusScreen/src/AutofocusScreen/AJob.cls
new file mode 100644
index 0000000..7a8873a
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/AJob.cls
@@ -0,0 +1,506 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "AJob"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+''''
+'   AJob stores the parameters for a imaging job
+'''''
+
+Option Explicit
+
+Public Name As String
+Public Recording As DsRecording
+Private pAcquireTrack() As Boolean 'must be private for no obvious reasons of VBA
+Public pixelDwell As Double      'pixelDwell of acquisition
+Public TrackNumber As Integer
+Public TimeBetweenStacks As Double
+Public UseRoi As Boolean
+Public CorrX  As Double ' corretion for double directional scanning
+Public CorrY As Double  ' corretion for double directional scanning
+'''a Job can also have Rois associated to it
+Private Rois() As Roi
+''Number of Rois associated to the Job
+Private pRoiMaxNr As Integer
+
+
+
+''''DON'T USE YET''''
+'''If True swicth lasers instead of Tracks
+Const SwitchLaserLines = False ' this is not clear whether it works or not properly. Sometimes it is fast sometimes slow?
+'''record which lasers are on or off
+Private LaserOnOff() As Boolean
+
+
+Public Property Get AcquireTrack() As Boolean()
+    AcquireTrack = pAcquireTrack
+End Property
+
+Public Property Let AcquireTrack(Value() As Boolean)
+    Dim i As Integer
+    ReDim pAcquireTrack(UBound(Value))
+    For i = 0 To UBound(Value)
+        pAcquireTrack(i) = Value(i)
+    Next i
+End Property
+
+''''
+' setJob load settings from recording/ZEN into macro
+''''
+Public Function setJob(RecordingLoc As DsRecording, ZEN As Object) As Boolean
+    On Error GoTo ErrorHandle:
+    Dim AcquisitionController As AimAcquisitionController40.AimScanController
+    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
+    Dim AcquisitionParameters As AimAcquisitionController40.AimAcquisitionParameters
+    Set AcquisitionParameters = AcquisitionController.AcquisitionParameters
+    Dim iTrack As Integer
+    Dim iLaser As Integer
+    SetRecording RecordingLoc
+    TrackNumber = RecordingLoc.GetNormalTrackCount
+    TimeBetweenStacks = RecordingLoc.TrackObjectByMultiplexOrder(0, 1).TimeBetweenStacks
+    
+    If ZENv > 2010 Then
+        Set ZEN = Application.ApplicationInterface
+        If Recording.ScanDirection = 1 Then
+            CorrX = ZEN.gui.Acquisition.AcquisitionMode.Bidirectional.CorrX.Value
+            CorrY = ZEN.gui.Acquisition.AcquisitionMode.Bidirectional.CorrY.Value
+        End If
+        'Debug.Print "nr Lasers " & ZEN.gui.Acquisition.Channels.Track.LaserLine.ItemCount
+        ReDim LaserOnOff(0 To TrackNumber - 1, 0 To ZEN.gui.Acquisition.Channels.Track.LaserLine.ItemCount - 1)
+    End If
+    
+    pixelDwell = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime
+    ReDim pAcquireTrack(TrackNumber - 1)
+    For iTrack = 0 To TrackNumber - 1
+        pAcquireTrack(iTrack) = Recording.TrackObjectByMultiplexOrder(iTrack, 1).Acquire
+        If ZENv > 2010 Then
+            If SwitchLaserLines Then 'this is experimental it should only switch laserLines and keep the same Track
+                ZEN.gui.Acquisition.Channels.Track.ByIndex = iTrack
+                For iLaser = 0 To UBound(LaserOnOff, 2)
+                    ZEN.gui.Acquisition.Channels.Track.LaserLine.ByIndex = iLaser
+                    LaserOnOff(iTrack, iLaser) = ZEN.gui.Acquisition.Channels.Track.LaserLine.Acquire.Value
+                    'Debug.Print " iTrack " & iTrack & " Laser " & iLaser & " status " & ZEN.gui.Acquisition.Channels.Track.LaserLine.Acquire.Value
+                Next iLaser
+            End If
+        End If
+    Next iTrack
+    UseRoi = AcquisitionParameters.UseROIs
+    setRoiFromZen
+    setJob = True
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in AJob.setJob " + Err.Description
+End Function
+
+''''
+' putJob put settings from Me.recording into ZEN
+''''
+Public Function putJob(ZEN As Object)
+    On Error GoTo ErrorHandle:
+    Dim AcquisitionController As AimAcquisitionController40.AimScanController
+    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
+    Dim AcquisitionParameters As AimAcquisitionController40.AimAcquisitionParameters
+    Set AcquisitionParameters = AcquisitionController.AcquisitionParameters
+    Dim iTrack As Integer
+    Dim iLaser As Integer
+    Dim Time As Double
+    If TrackNumber <> Lsm5.DsRecording.GetNormalTrackCount Then
+        MsgBox "Nr of Tracks of  Job " + Name + " is " + CStr(TrackNumber) + ". Available tracks " + CStr(Lsm5.DsRecording.GetNormalTrackCount) + vbCrLf + "This may cause problems"
+        
+        'Exit Function
+    End If
+    
+    Time = Timer
+    If Not Recording Is Nothing Then
+        Lsm5.DsRecording.Copy Recording
+    Else
+        MsgBox "No Recording initialized for Job " + Name
+        Exit Function
+    End If
+    Debug.Print "Time put Recording " & Round(Timer - Time, 3)
+    'at the moment we just set the active/inactive track and TimeBetweenStacks
+    'consistency check for TrackNumber. May be pass error only to log?
+    'this seems to be not recquired in Zen 2012
+    
+    Time = Timer
+    For iTrack = 0 To TrackNumber - 1
+        If ZENv > 2010 Then
+            'ZEN.gui.Acquisition.Channels.Track.ByIndex = iTrack '(it does not display properly anyway)
+            'ZEN.gui.Acquisition.Channels.Track.Acquire.Value = pAcquireTrack(iTrack)
+            Lsm5.DsRecording.TrackObjectByMultiplexOrder(iTrack, 1).Acquire = pAcquireTrack(iTrack)
+            If Not isArrayEmpty(LaserOnOff) And pAcquireTrack(iTrack) And SwitchLaserLines Then
+                For iLaser = 0 To UBound(LaserOnOff, 2)
+                    ZEN.gui.Acquisition.Channels.Track.LaserLine.ByIndex = iLaser
+                    If LaserOnOff(iTrack, iLaser) <> ZEN.gui.Acquisition.Channels.Track.LaserLine.Acquire.Value Then
+                        ZEN.gui.Acquisition.Channels.Track.LaserLine.Acquire.Value = LaserOnOff(iTrack, iLaser)
+                    End If
+                Next iLaser
+            End If
+        Else
+            Lsm5.DsRecording.TrackObjectByMultiplexOrder(iTrack, 1).Acquire = pAcquireTrack(iTrack)
+        End If
+        Lsm5.DsRecording.TrackObjectByMultiplexOrder(iTrack, 1).TimeBetweenStacks = TimeBetweenStacks
+        Lsm5.DsRecording.TrackObjectByMultiplexOrder(iTrack, 1).SampleObservationTime = pixelDwell
+    Next iTrack
+    Debug.Print "Times set tracks " & Round(Timer - Time, 3)
+    
+    AcquisitionParameters.UseROIs = UseRoi
+    Time = Timer
+  
+   If ZENv > 2010 Then
+      'this is slow ~1 sec (and can be only used for acquisition only
+       'ZEN.gui.Acquisition.AcquisitionMode.ScanArea.Zoom.Value = Recording.ZoomX
+       'ZEN.SetListEntrySelected "Scan.Mode.DirectionX", Recording.ScanDirection
+        If Recording.ScanDirection Then
+            If ZEN.gui.Acquisition.AcquisitionMode.Bidirectional.CorrX.Value <> CorrX Then
+               ZEN.gui.Acquisition.AcquisitionMode.Bidirectional.CorrX.Value = CorrX
+            End If
+            If ZEN.gui.Acquisition.AcquisitionMode.Bidirectional.CorrY.Value <> CorrY Then
+                ZEN.gui.Acquisition.AcquisitionMode.Bidirectional.CorrY.Value = CorrY
+            End If
+        End If
+    End If
+    Debug.Print "Time update Corr.X " & Round(Timer - Time, 3)
+    createRois
+    'testDescriptor
+    putJob = True
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in AJob.putJob " + Name + " " + Err.Description
+End Function
+
+Public Sub setAcquireTrack(iTrack As Integer, Value As Boolean)
+    If UBound(pAcquireTrack) >= iTrack Then
+        pAcquireTrack(iTrack) = Value
+    End If
+End Sub
+
+Public Function isAcquiring() As Boolean
+    Dim i As Integer
+    For i = 0 To UBound(pAcquireTrack)
+        If pAcquireTrack(i) = True Then
+            isAcquiring = True
+            Exit Function
+        End If
+    Next i
+End Function
+
+Public Function getAcquireTrack(iTrack As Integer) As Boolean
+    If UBound(pAcquireTrack) >= iTrack Then
+        getAcquireTrack = pAcquireTrack(iTrack)
+    End If
+End Function
+
+Public Sub ReDimAcquireTrack(Value As Integer)
+    ReDim Preserve pAcquireTrack(Value)
+End Sub
+
+
+Public Function GetRecording() As DsRecording
+    Set GetRecording = Recording
+End Function
+
+Public Sub SetRecording(Value As DsRecording)
+   Set Recording = Lsm5.CreateBackupRecording
+   Recording.Copy Value
+   TrackNumber = Recording.GetNormalTrackCount
+End Sub
+
+Public Function isBleaching() As Boolean
+    Dim Success As Integer
+    isBleaching = Recording.TrackObjectBleach(Success).Acquire And Recording.TrackObjectBleach(Success).UseBleachParameters
+End Function
+
+Public Function isZStack() As Boolean
+    Dim ScanMode As String
+    ScanMode = Recording.ScanMode
+    If ScanMode = "ZScan" Or ScanMode = "Stack" Then
+        isZStack = True
+    Else
+        isZStack = False
+    End If
+End Function
+
+
+Public Sub setRoiMaxNr(roiMaxNr As Integer)
+    Dim i As Integer
+    pRoiMaxNr = roiMaxNr
+    If pRoiMaxNr = 0 Then
+        Erase Rois
+    Else
+        ReDim Rois(0 To pRoiMaxNr - 1)
+        For i = 0 To pRoiMaxNr - 1
+            Set Rois(i) = New Roi
+        Next i
+    End If
+End Sub
+
+Public Function getRoiMaxNr() As Integer
+    getRoiMaxNr = pRoiMaxNr
+End Function
+
+Public Sub clearRois()
+    ClearVectorElements
+    pRoiMaxNr = 0
+    Erase Rois
+End Sub
+
+''
+' load Roi from ARoi inti class
+''
+Public Sub setRoi(ARoi As Roi, roiNr As Integer)
+    If UBound(Rois) <= roiNr Then
+        Rois(roiNr).setRoi ARoi.roiType, ARoi.roiAim, ARoi.getX, ARoi.getY
+    Else
+        MsgBox (" No Roi of nr" + roiNr + " initialize Rois first ")
+    End If
+End Sub
+
+''
+' load Rois into class
+''
+Public Sub setRois(RoisIn() As Roi)
+    If isArrayEmpty(RoisIn) Then
+         ErrorLog.UpdateLog "AJob.setRois tried to initialize Rois with empty vector"
+    Else
+        Rois = RoisIn
+        pRoiMaxNr = UBound(Rois) + 1
+    End If
+End Sub
+
+'''
+' getRoi: returns a Roi
+'''
+Public Function getRoi(roiNr As Integer) As Roi
+    If UBound(Rois) <= roiNr Then
+        Set getRoi = Rois(roiNr)
+    Else
+        MsgBox (" No Roi of nr" + roiNr + " initialize Rois first ")
+    End If
+End Function
+
+'''
+' gets Roi directly from ZEN and save it. This is only used at the beginning
+'''
+Public Function setRoiFromZen() As Boolean
+    On Error GoTo ErrorHandle:
+    Dim i As Integer
+    Dim vo As AimImageVectorOverlay
+    Set vo = Lsm5.ExternalDsObject.Scancontroller.AcquisitionRegions
+    'there are Rois already defined
+    'Debug.Print "nr Elements " & vo.GetNumberElements
+    setRoiMaxNr vo.GetNumberElements
+    If vo.GetNumberElements > 0 Then
+        For i = 0 To vo.GetNumberElements - 1
+            Rois(i).setRoiFomZen i
+        Next i
+    End If
+    setRoiFromZen = True
+    Exit Function
+ErrorHandle:
+    MsgBox "Error AJob.setRoiFromZen " & Err.Description
+    
+End Function
+
+
+
+Public Function createRois() As Boolean
+    Dim ARoi As Roi
+    Dim i As Integer
+    ClearVectorElements
+    For i = 0 To pRoiMaxNr - 1
+        If Not Rois(i).MakeVectorElement Then
+            Exit Function
+        End If
+    Next i
+    createRois = True
+End Function
+
+
+
+''''
+' Create a string with the description of a Job
+''''
+Public Function jobDescriptor() As String
+    Dim ABoolean As Boolean
+    Dim Description As String
+    Dim iTrack As Integer
+    Dim ScanMode As String
+    ScanMode = Recording.ScanMode
+    If ScanMode = "Line" Or ScanMode = "ZScan" Then
+        Description = Description & "ScanMode = Line" & vbCrLf
+        Description = Description & "       X = " & Recording.SamplesPerLine & ", Y = 1" & vbCrLf
+    End If
+    If ScanMode = "Frame" Or ScanMode = "Stack" Or ScanMode = "Plane" Then
+        Description = Description & "ScanMode = Frame" & vbCrLf
+        Description = Description & "       X = " & Recording.SamplesPerLine & ", Y = " & Recording.LinesPerFrame & vbCrLf
+        Description = Description & "LineStep = " & Recording.LineStepNumber & vbCrLf
+    End If
+    If ScanMode = "Point" Then
+        Description = Description & "ScanMode = Spot" & vbCrLf
+        Description = Description & "       X =  1, Y = 1 " & vbCrLf
+    End If
+   
+    Description = Description & "Bleaching = " & isBleaching & vbCrLf
+    Description = Description & "Regions = " & Me.UseRoi & vbCrLf
+    Description = Description & "PixelDwell = " & Round(Me.pixelDwell * 1000000#, 2) & " us" & vbCrLf
+    Description = Description & "Zoom = " & Recording.ZoomX & vbCrLf
+    Description = Description & "pixelSize = " & Round(Recording.SampleSpacing, 3) & " um" & vbCrLf
+    If Recording.SpecialScanMode = "ZScanner" Then
+        Description = Description & "Piezo = True" & vbCrLf
+    Else
+        Description = Description & "Piezo = False" & vbCrLf
+    End If
+    
+    If Recording.SpecialScanMode = "OnTheFly" Then
+        Description = Description & "Fast-Z-Line = True" & vbCrLf
+    Else
+        Description = Description & "Fast-Z-Line = False" & vbCrLf
+    End If
+    
+    If isZStack Then
+        Description = Description & "Z-Stack = True" & vbCrLf
+        Description = Description & "       Z-Slices    = " & Recording.framesPerStack & vbCrLf
+        Description = Description & "       Z-Interval  = " & Round(Recording.frameSpacing, 2) & " um" & vbCrLf
+        Description = Description & "       Z-Range   = " & Round(Recording.frameSpacing, 2) * (Recording.framesPerStack - 1) & " um" & vbCrLf
+    Else
+        Description = Description & "Z-Stack = False" & vbCrLf
+    End If
+
+     If Recording.TimeSeries Then
+        Description = Description & "TimeSeries = " & Recording.TimeSeries & vbCrLf
+        Description = Description & "       Cycles     = " & Recording.StacksPerRecord & vbCrLf
+        Description = Description & "       Interval    = " & Me.TimeBetweenStacks & " sec"
+    Else
+        Description = Description & "TimeSeries = " & Recording.TimeSeries
+    End If
+
+    jobDescriptor = Description
+End Function
+
+'''
+' split a String into two different Strigs depending on their maximal length
+''''
+Public Function splittedJobDescriptor(MaxLines As Integer, jobDescription As String) As String()
+    Dim i As Integer
+    Dim Label1() As String
+    Dim Label2() As String
+    Dim Output() As String
+    ReDim Output(1)
+    Label1 = Split(jobDescription, vbCrLf)
+    If UBound(Label1) > MaxLines - 1 Then
+        ReDim Label2(0 To UBound(Label1) - MaxLines)
+        For i = 0 To UBound(Label1) - MaxLines
+            Label2(i) = Label1(MaxLines + i)
+        Next i
+        ReDim Preserve Label1(0 To MaxLines - 1)
+    Else
+        ReDim Label2(0)
+    End If
+    Output(0) = Join(Label1, vbCrLf)
+    Output(1) = Join(Label2, vbCrLf)
+    splittedJobDescriptor = Output
+End Function
+
+''
+' create a String to save of the "complete" job desriptin
+''
+Public Function jobDescriptorSettings() As String
+    Dim Descriptor As String
+    Descriptor = "JobName " & Me.Name & vbCrLf
+    Descriptor = Descriptor & "pixelDwell " & Me.pixelDwell & vbCrLf
+    Descriptor = Descriptor & "ScanMode " & Recording.ScanMode & vbCrLf
+    Descriptor = Descriptor & "SamplesPerLine " & Recording.SamplesPerLine & vbCrLf
+    Descriptor = Descriptor & "LinesPerFrame " & Recording.LinesPerFrame & vbCrLf
+    Descriptor = Descriptor & "LineStepNumber " & Recording.LineStepNumber & vbCrLf
+    Descriptor = Descriptor & "FramesPerStack " & Recording.framesPerStack & vbCrLf
+    Descriptor = Descriptor & "FrameSpacing " & Recording.frameSpacing & vbCrLf
+    Descriptor = Descriptor & "Bleaching " & isBleaching & vbCrLf
+    Descriptor = Descriptor & "UseRoi " & Me.UseRoi & vbCrLf
+    Descriptor = Descriptor & "Zoom " & Recording.ZoomX & vbCrLf
+    Descriptor = Descriptor & "SpecialScanMode " & Recording.SpecialScanMode & vbCrLf
+    Descriptor = Descriptor & "TimeSeries " & Recording.TimeSeries & vbCrLf
+    Descriptor = Descriptor & "StacksPerRecord " & Recording.StacksPerRecord & vbCrLf
+    Descriptor = Descriptor & "TimeBetweenStacks " & Me.TimeBetweenStacks & vbCrLf
+    Descriptor = Descriptor & "EndJobDef " & vbCrLf
+    jobDescriptorSettings = Descriptor
+End Function
+
+Public Sub testDescriptor()
+    consistencyDescriptor (jobDescriptorSettings)
+End Sub
+
+Private Function consistencyDescriptor(Descriptor As String)
+    Dim i As Integer
+    Dim DerivedDescr() As String
+    Dim KeyItem() As String
+    DerivedDescr = Split(Descriptor, vbCrLf)
+    For i = 0 To UBound(DerivedDescr)
+        'Debug.Print DerivedDescr(i)
+        Sleep (100)
+        KeyItem = Split(DerivedDescr(i), " ")
+        If UBound(KeyItem) = 1 Then
+            If Not changeJobFromDescriptor(KeyItem(0), KeyItem(1)) Then
+                Exit Function
+            End If
+        End If
+    Next i
+    consistencyDescriptor = True
+End Function
+
+''''
+' change a job from a descriptor
+'''
+Public Function changeJobFromDescriptor(Descriptor As String, Value As Variant)
+    Dim Success As Integer
+    If Recording Is Nothing Then
+        MsgBox "AJob.changeJobFromDescriptor Recording has not been initiated!"
+    End If
+    
+    Select Case Descriptor
+        Case "JobName":
+            Name = CStr(Value)
+        Case "pixelDwell":
+            pixelDwell = CDbl(Value)
+        Case "ScanMode":
+            Recording.ScanMode = CStr(Value)
+        Case "SamplesPerLine":
+            Recording.SamplesPerLine = CLng(Value)
+        Case "LinesPerFrame":
+            Recording.LinesPerFrame = CLng(Value)
+        Case "LineStepNumber":
+            Recording.LineStepNumber = CLng(Value)
+        Case "FramesPerStack":
+            Recording.framesPerStack = CLng(Value)
+        Case "FrameSpacing":
+            Recording.frameSpacing = CDbl(Value)
+        Case "Bleaching":
+            If CBool(Value) Then
+                Recording.TrackObjectBleach(Success).Acquire = CBool(Value)
+                Recording.TrackObjectBleach(Success).UseBleachParameters = CBool(Value)
+            End If
+        Case "UseRoi":
+            Me.UseRoi = CBool(Value)
+        Case "Zoom":
+            Recording.ZoomX = CDbl(Value)
+            Recording.ZoomY = CDbl(Value)
+        Case "SpecialScanMode":
+            Recording.SpecialScanMode = CStr(Value)
+        Case "TimeSeries":
+            Recording.TimeSeries = CBool(Value)
+        Case "StacksPerRecord":
+            Recording.StacksPerRecord = CLng(Value)
+        Case "TimeBetweenStacks":
+            Me.TimeBetweenStacks = CDbl(Value)
+        Case "EndJobDef":
+            
+        Case Else:
+            MsgBox " No Item " & Descriptor
+            Exit Function
+    End Select
+    changeJobFromDescriptor = True
+End Function
diff --git a/AutofocusScreen/src/AutofocusScreen/ARepetition.cls b/AutofocusScreen/src/AutofocusScreen/ARepetition.cls
new file mode 100644
index 0000000..5860592
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/ARepetition.cls
@@ -0,0 +1,79 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "ARepetition"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''
+' A Class to manage repetitions
+'''
+Option Explicit
+Public Name As String            ' this is should belong to the upper class but to see what is inside you need the name
+Public number As Integer        'Number of repetitions
+Public index As Integer          'currentindex of repetition
+Public Time As Double         ' Time between repetition
+Private TimeStart As Double     'Time start of current repetition this will be updated if Interval is used
+Public interval As Boolean
+Const maxZeros = 4
+
+'''
+' Update index of Repetition and store timeStart
+'''
+Public Function nextRep() As Boolean
+    If index < number Then
+        index = index + 1
+        TimeStart = CDbl(GetTickCount) * 0.001
+        nextRep = True
+    End If
+End Function
+
+Public Sub updateTimeStart()
+    If Not interval Then
+        TimeStart = CDbl(GetTickCount) * 0.001
+    End If
+End Sub
+
+Public Function thisSuffix() As String
+    Dim nrZero As Integer
+    nrZero = maxZeros - Len(CStr(index))
+    thisSuffix = "_T" + ZeroString(nrZero) + CStr(index)
+End Function
+
+
+Public Function suffix(Value As Integer) As String
+    Dim nrZero As Integer
+    nrZero = maxZeros - Len(CStr(Value))
+    suffix = "_T" + ZeroString(nrZero) + CStr(Value)
+End Function
+
+
+'''
+'   Calculate that remains to wait
+'''
+Public Function wait() As Double
+    wait = Time + TimeStart - CDbl(GetTickCount) * 0.001
+End Function
+
+'''
+' Constructor initialize the class
+'''
+Public Function initialize(repetitionName As String, RepetitionTime As Double, RepetitionNumber As Integer, RepetitionInterval As Boolean)
+    index = 0
+    number = RepetitionNumber
+    Name = repetitionName
+    Time = RepetitionTime
+    interval = RepetitionInterval
+End Function
+
+'''''''''''
+''''TYPES''
+'''''''''''
+'Public Type RepetitionType     'Contains Number and Time interval for repetition of acquisition protocol
+'    Number As Integer   'Number of repetitions
+'    Time As Double      'Interval between repetitions
+'    Interval As Boolean ' If Interval is True than one computes interval between first and second image = Time other wise
+'End Type
+'
diff --git a/AutofocusScreen/src/AutofocusScreen/AutofocusForm.frm b/AutofocusScreen/src/AutofocusScreen/AutofocusForm.frm
index 241c0bf..ccb483a 100644
--- a/AutofocusScreen/src/AutofocusScreen/AutofocusForm.frm
+++ b/AutofocusScreen/src/AutofocusScreen/AutofocusForm.frm
@@ -4,7 +4,7 @@ Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} AutofocusForm
    ClientHeight    =   13530
    ClientLeft      =   45
    ClientTop       =   330
-   ClientWidth     =   7305
+   ClientWidth     =   7200
    OleObjectBlob   =   "AutofocusForm.frx":0000
    ShowModal       =   0   'False
    StartUpPosition =   3  'Windows Default
@@ -14,7 +14,7 @@ Attribute VB_GlobalNameSpace = False
 Attribute VB_Creatable = False
 Attribute VB_PredeclaredId = True
 Attribute VB_Exposed = False
-'Option Explicit 'force to declare all variables
+Option Explicit 'force to declare all variables
 
 Private shlShell As Shell32.Shell
 Private shlFolder As Shell32.Folder
@@ -23,452 +23,340 @@ Private Const BIF_RETURNONLYFSDIRS = &H1
 ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
 ''''''''''''''''''''''Version Description''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
 '
-' AutofocusScreen_ZEN_v2.1.3.14
+' AutofocusScreen_ZEN_v3.0.9
 '''''''''''''''''''''End: Version Description'''''''''''''''''''''''''''''''''''''''''''''''''''''
 '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
 Public Version As String
-Public posTempZ  As Double                  'This is position at start after pushing AutofocusButton
-Private Const DebugCode = False           'sets key to run tests visible or not
+Private Const DebugCode = False             'sets key to run tests visible or not
 Private Const ReleaseName = True            'this adds the ZEN version
 Private Const LogCode = True                'sets key to run tests visible or not
 
-Private AlterImageInitialize As Boolean ' first time aternative image is activated values from acquisition are loaded. Then variable is ste to false
-Private ZoomImageInitialize As Boolean  ' first time ZoomImage/Micropilot is activated values from acquisition are loaded
-
 
+Private Sub ShowOiaKeys_Click()
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    OiaSettings.initializeDefault
+    KeyReport.Show
+    KeyReport.KeyReportLabel.Caption = OiaSettings.createKeyReport
+End Sub
 
-Private Sub AutofocusAlgorithm_Change()
-    If AutofocusAlgorithm.Value = "external" Then
-        SaveAFImage.Value = True
-    End If
+''commodity function to recognize which job is ob top
+Private Sub MultiPage1_Change()
+    
+    On Error GoTo StandardColor:
+        If MultiPage1.Value <= UBound(JobNames) Then
+            AutofocusForm.BackColor = Me.Controls(JobNames(MultiPage1.Value) & "Label").BackColor
+        ElseIf (MultiPage1.Value - UBound(JobNames) - 1) <= UBound(JobFcsNames) And (MultiPage1.Value - UBound(JobNames) - 1) >= 0 Then
+            AutofocusForm.BackColor = Me.Controls(JobFcsNames(MultiPage1.Value - UBound(JobNames) - 1) & "Label").BackColor
+        Else
+            AutofocusForm.BackColor = &H80000003
+        End If
+    Exit Sub
+StandardColor:
+    AutofocusForm.BackColor = &H80000003
 End Sub
 
+'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
+' WARNING ZEN does not use spatial units in a consistent way. Switches between um and meter and pixel WARNING''''''''''''''''''''
+' for imaging and moving the stage
+' Lsm5.Hardware.Cpstages.PositionX: Absolute coordinate in um
+' Lsm5.Hardware.CpFocus.Position: Absolute coordinate in meter
+' Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing: in meter. this is the pixelSize
+' Lsm5.DsRecording.SampleSpacing: in um. this is the pixelSize. In both cases we access the same object
+'
+' All FCS positions are given in um. For X and Y with respect to center of the image. So 0 0 is in the middle of the image. For
+' Z one provides an absolute position also un um
+'
+' For ROI the coordinates are in pixels
+''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
+
+
 ''''''
 ' UserForm_Initialize()
 '   Function called from e.g. AutoFocusForm.Show
 '   Load and initialize form
 '''''
 Public Sub UserForm_Initialize()
-    Version = " v2.1.3.14"
+    DisplayProgress "Initializing Macro ...", RGB(&HC0, &HC0, 0)
+    Version = " v3.0.9"
     Dim i As Integer
+    ZENv = getVersionNr
     'find the version of the software
-    Dim VersionNr As String
-    VersionNr = Lsm5.Info.VersionIs
-    VersionNr = Left(VersionNr, 1)
-    Select Case VersionNr
-        Case "6":
-            ZEN = 2010
-        Case "7":
-            ZEN = 2011
-        Case "8":
-            ZEN = 2012
-        Case Default:
-            MsgBox "Don't understand the version of ZEN used. Set to ZEN2010"
-            ZEN = 2010
-    End Select
-    'Setting of some global variables
+    If ZENv > 2010 Then
+        'On Error GoTo ErrorMsg
+        Set ZEN = Lsm5.CreateObject("Zeiss.Micro.AIM.ApplicationInterface.ApplicationInterface")
+        GoTo NoError
+errorMsg:
+        MsgBox "Version is ZEN" & ZENv & " but can't find Zeiss.Micro.AIM.ApplicationInterface." & vbCrLf _
+        & "Using ZEN2010 settings instead." & vbCrLf _
+        & "Check if Zeiss.Micro.AIM.ApplicationInterface.dll is registered?" _
+        & "See also the manual how to register a dll into windows."
+        ZENv = 2010
+NoError:
+    End If
+    'Setting ome global variables
     LogFileNameBase = ""
+    ErrFileNameBase = ""
     Log = LogCode
+        
+    
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    OiaSettings.resetRegistry
+    
+    
+    ''''This variable contains all the imagingJobs
+    Set Jobs = New ImagingJobs
+    ReDim JobNames(4)
+    JobNames(0) = "Autofocus"
+    JobNames(1) = "Acquisition"
+    JobNames(2) = "AlterAcquisition"
+    JobNames(3) = "Trigger1"
+    JobNames(4) = "Trigger2"
+            
+    Set JobShortNames = New Collection
+    JobShortNames.Add "AF", JobNames(0)
+    JobShortNames.Add "AQ", JobNames(1)
+    JobShortNames.Add "AL", JobNames(2)
+    JobShortNames.Add "TR1", JobNames(3)
+    JobShortNames.Add "TR2", JobNames(4)
+    
+    Jobs.initialize JobNames, Lsm5.DsRecording, ZEN
+    Jobs.setZENv ZENv
+
+    For i = 0 To UBound(JobNames)
+        If Jobs.GetScanMode(JobNames(i)) = "ZScan" Or Jobs.GetScanMode(JobNames(i)) = "Line" Then
+            Me.Controls(JobNames(i) + "TrackXY").Value = False
+            Me.Controls(JobNames(i) + "TrackXY").Enabled = False
+        Else
+            Me.Controls(JobNames(i) + "TrackXY").Enabled = True
+        End If
+    Next i
+
+    If Lsm5.Info.IsFCS Then
+        Set JobsFcs = New FcsJobs
+        ReDim JobFcsNames(0)
+        JobFcsNames(0) = "Fcs1"
+        Set JobFcsShortNames = New Collection
+        JobFcsShortNames.Add "FCS1", JobFcsNames(0)
+        JobsFcs.initialize JobFcsNames, ZEN
+    End If
     
     Me.Caption = Me.Caption + Version + " for ZEN "
     
     If ReleaseName Then
-        Me.Caption = Me.Caption & ZEN
+        Me.Caption = Me.Caption + CStr(ZENv)
     End If
     FormatUserForm (Me.Caption) ' make minimizing button available
     AutofocusForm.Show
-    
     StageSettings MirrorX, MirrorY, ExchangeXY
-    Re_Start                    ' Initialize some of the variables
-
     
+    'set file format
+    If Not fileFormatlsm And Not fileFormatczi Then
+        fileFormatlsm.Value = True
+    End If
+    If fileFormatlsm Then
+        imgFileFormat = eAimExportFormatLsm5
+        imgFileExtension = ".lsm"
+    End If
+    If fileFormatczi Then
+        imgFileFormat = eAimExportFormatCzi
+        imgFileExtension = ".czi"
+    End If
+    MultiPage1_Change
+    ControlTipText
+    Re_Start                    ' Initialize some of the variables
 End Sub
 
+
+
+
+
 ''''
 ' Re_Start()
 ' Initializations that need to be performed only at the first start of the Macro
 ''''
 Private Sub Re_Start()
-    Dim delay As Single
+    Dim i As Integer
+    Dim Delay As Single
     Dim bLSM As Boolean
     Dim bLIVE As Boolean
     Dim bCamera As Boolean
+    Dim Name As Variant
 
-    
-    Set tools = Lsm5.tools
-    GlobalMacroKey = "Autofocus"
-    
-    delay = 1
-    flgEvent = 7
-    flg = 0
+    Delay = 1
     Lsm5.StopScan
-    Wait (delay)
-    LoopingTimerUnit = 1
-    CommandTimeSec.BackColor = &HFF8080
-    BlockRepetitions = 1
-    ReDim Preserve GlobalImageIndex(BlockRepetitions)
-    ScanLineToggle.Value = True
+    wait (Delay)
+    GlobalRepetitionSec.BackColor = &HFF8080
+   
     LocationTextLabel.Caption = ""
-    GlobalProject = "AutofocusScreen2.1"
-    GlobalProjectName = GlobalProject + ".lvb"
-    HelpNamePDF = "AutofocusScreen_help.pdf"
     UsedDevices40 bLSM, bLIVE, bCamera
     SystemVersionOffset         ' extra offset depending on macroscope
 
     ' Set standard values for Autofocus
-    ' blSM is a flag to decide weather systen is LSM (ZEN is LSM for instance). LIVE is 5Live not anymore in use?
-    If bLSM Then
-        SystemName = "LSM"
-        AutofocusMaxSpeed.Value = True
-        AutofocusFrameSize.Min = 16
-        AutofocusFrameSize.Max = 1024
-        AutofocusLineSize.Min = 16
-        AutofocusLineSize.Max = 1024
-        AutofocusFrameSize.Step = 8
-        AutofocusLineSize.Step = 8
-        AutofocusFrameSize.StepSmall = 4
-        AutofocusLineSize.StepSmall = 4
-        'Lsm5Vba.Application.ThrowEvent eRootReuse, 0 ' not clear what it does. On ZEN2012 the marked positions are reset
-        DoEvents
-    ElseIf bLIVE Then
-        SystemName = "LIVE"
-        AutofocusFrameSize.Min = 128
-        AutofocusFrameSize.Max = 1024
-        AutofocusFrameSize.Step = 128
-        AutofocusFrameSize.StepSmall = 128
-        AutofocusLineSize.Min = 128
-        AutofocusLineSize.Max = 1024
-        AutofocusLineSize.Step = 128
-        AutofocusLineSize.StepSmall = 128
-        'Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-        DoEvents
-    ElseIf bCamera Then
-        SystemName = "Camera"
-    End If
-    
+    ' blSM is a flag to decide whether systen is LSM (ZEN is LSM for instance). LIVE is 5Live not anymore in use?
     'TODO: Check if GUI is available (ZEN2011 onward). How do you do this!!
-
+    '
+    
+    'Set default value
+    For Each Name In JobNames
+        Me.Controls(CStr(Name) + "Active").Value = False
+        SwitchEnablePage CStr(Name), Me.Controls(CStr(Name) + "Active").Value
+    Next Name
+    
     'Set default value
-    ScanLineToggle.Value = True
-    AutofocusZOffset.Value = 0
-    AutofocusZRange.Value = 80
-    AutofocusZStep.Value = 0.1
-    AutofocusLowZoom.Value = False
-    ActiveAutofocus.Value = True
-    FillAutofocusAlgorithm
+    For Each Name In JobFcsNames
+        Me.Controls(CStr(Name) + "Active").Value = False
+        SwitchEnableFcsPage CStr(Name), Me.Controls(CStr(Name) + "Active").Value
+    Next Name
+    
+    'Trigger2Autofocus.Value = False
+
+    'Trigger2Autofocus.Value = False
+    
+    Set Reps = New ImagingRepetitions
+    ReDim RepNames(2)
+    RepNames(0) = "Global"    'this is Autofocus Acquisition and AlterAcquisition job
+    RepNames(1) = "Trigger1"
+    RepNames(2) = "Trigger2"
+    
+    For i = 0 To 2
+        Reps.AddRepetition RepNames(i), CDbl(Me.Controls(RepNames(i) + "RepetitionTime")), _
+        CInt(Me.Controls(RepNames(i) + "RepetitionNumber")), CBool(Me.Controls(RepNames(i) + "RepetitionInterval"))
+    Next i
     
-    'Set standard values for Post-Acquisition tracking
-    TrackingToggle.Value = False
-    SwitchEnableTrackingToggle (False)
-    TrackingToggle.Enabled = False
     
     'Set standard values for Looping
-    LoopingRepetitions = 300
-    LoopingRepetitionTime = 1
+    GlobalRepetitionNumber = 300
+    GlobalRepetitionTime = 1
     
-    'Set standard values for Micropilot
-    ActiveMicropilot.Value = False
-    SwitchEnableMicropilotPage (False)
-    MicropilotAutofocus.Value = False
-    SwitchEnableZoomAutofocus (False)
+
     
     'Set standard values for Gridscan
-    ActiveGridScan.Value = False
+    GridScanActive.Value = False
     SwitchEnableGridScanPage (False)
     
-    'Set standard values for Additional Acquisition
-    ActiveAlterImage.Value = False
-    SwitchEnableAlterImagePage (False)
-    
-    'Set default for bleach
-    ActiveBleach.Value = False
-    SwitchEnableBleachPage (False)
+    Set Grids = New ImagingGrids
+    ' this adds grids with LBound 0.
+    Grids.AddGrid "Global"
+    Grids.AddGrid "Trigger1"
+    Grids.AddGrid "Trigger2"
     
+    'Set standard values for Additional Acquisition
+    AlterAcquisitionActive.Value = False
+    SwitchEnablePage "AlterAcquisition", AlterAcquisitionActive
     
     'Set Database name
-    DatabaseTextbox.Value = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="OutputFolder")
-    
+    'DatabaseTextbox.Value = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="OutputFolder")
+    DatabaseTextbox.Value = ""
     'Set repetition and locations
-    RepetitionNumber = 1
-    locationNumber = 1
+    'RepetitionNumber = 1
+    'locationNumber = 1
     Set FileSystem = New FileSystemObject
-    'If we log a new logfile is created
+    'If we log a new logfile is created and closed again
     If LogCode And LogFileNameBase <> "" Then
         LogFileName = LogFileNameBase
-        SafeOpenTextFile LogFileName, LogFile, FileSystem
-        LogFile.Close
-        Log = True
+        ErrFileName = ErrFileNameBase
+        If SafeOpenTextFile(LogFileName, LogFile, FileSystem) And SafeOpenTextFile(ErrFileName, ErrFile, FileSystem) Then
+            LogFile.Close
+            ErrFile.Close
+            Log = True
+        Else
+            Log = False
+        End If
     Else
         Log = False
     End If
-
-    AutofocusTrackZ.Visible = DebugCode
-    MultiPage1.Pages("TestsPage").Visible = DebugCode
     
+    If Lsm5.Info.IsFCS Then
+        MultiPage1.Pages("Fcs1Page").Visible = True
+    Else
+        MultiPage1.Pages("Fcs1Page").Visible = False
+    End If
+        
+    MultiPage1.Pages("TestsPage").Visible = DebugCode
     
-    AlterImageInitialize = True
-    ZoomImageInitialize = True
     
-    If ZEN = 2010 Then
+    If ZENv = 2010 Then
         ZBacklash = 0.5
-    ElseIf ZEN > 2010 Then
+    ElseIf ZENv > 2010 Then
         ZBacklash = 0.5
     End If
+    
+    '''Contains all settings for the repetitions of the jobs
+        
     Re_Initialize
 End Sub
 
+
 '''''
 '   Re_Initialize()
 '   Initializations that need to be performed only when clicking the "Reinitialize" button
 '''''
 Public Sub Re_Initialize()
-    Dim delay As Single
+    Dim i As Integer
+    Dim Name As Variant
+    Dim Delay As Single
     Dim standType As String
     Dim count As Long
     Dim SuccessRecenter As Boolean
+    Dim posTempZ As Double
     AutoFindTracks
-    SwitchEnableAutofocusPage ActiveAutofocus
-    SwitchEnableAlterImagePage ActiveAlterImage
-    SwitchEnableMicropilotPage ActiveMicropilot
-    
-    PubSearchScan = False
-    NoReflectionSignal = False
-    PubSentStageGrid = False
+    SwitchEnablePage "Autofocus", AutofocusActive
+    SwitchEnablePage "Acquisition", AcquisitionActive
+    SwitchEnablePage "AlterAcquisition", AlterAcquisitionActive
+    SwitchEnablePage "Trigger1", Trigger1Active
+    SwitchEnablePage "Trigger2", Trigger2Active
+    SwitchEnableFcsPage "Fcs1", Fcs1Active
     
-    '  AutofocusForm.Caption = GlobalProject + " for " + SystemName
-    BleachingActivated = False
     FocusMapPresent = False
     'This sets standard values for all task we want to do. This will be changed by the macro
     
-    If AutofocusHRZ Then
+    If Lsm5.Hardware.CpHrz.Exist(0) Then
         Lsm5.Hardware.CpHrz.Leveling
         While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy Or Lsm5.Hardware.CpFocus.IsBusy
             Sleep (20)
             DoEvents
         Wend
     End If
-    
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    Recenter_pre posTempZ, SuccessRecenter, ZEN
-    
-    Set GlobalAutoFocusRecording = Lsm5.CreateBackupRecording
-    Set GlobalAcquisitionRecording = Lsm5.CreateBackupRecording
-    Set GlobalMicropilotRecording = Lsm5.CreateBackupRecording
-    Set GlobalBleachRecording = Lsm5.CreateBackupRecording
-    Set GlobalAltRecording = Lsm5.CreateBackupRecording
-    Set GlobalBackupRecording = Lsm5.CreateBackupRecording
-    GlobalAutoFocusRecording.Copy Lsm5.DsRecording
-    GlobalAcquisitionRecording.Copy Lsm5.DsRecording
-    GlobalMicropilotRecording.Copy Lsm5.DsRecording
-    GlobalBleachRecording.Copy Lsm5.DsRecording
-    GlobalAltRecording.Copy Lsm5.DsRecording
-    GlobalBackupRecording.Copy Lsm5.DsRecording ' this will not be changed remains always the same
-    GlobalBackupSampleObservationTime = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime
-    Dim i As Long
-    Dim NrTracks As Long
-    ReDim GlobalBackupActiveTracks(Lsm5.DsRecording.TrackCount)
-    For i = 0 To Lsm5.DsRecording.TrackCount - 1
-       GlobalBackupActiveTracks(i) = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i, 1).Acquire
-    Next i
-    If Not Recenter_post(posTempZ, SuccessRecenter, ZEN) Then
+
+    Jobs.initialize JobNames, Lsm5.DsRecording, ZEN
+    Jobs.setZENv ZENv
+    posTempZ = Lsm5.Hardware.CpFocus.position
+    Recenter_pre posTempZ, SuccessRecenter, ZENv
+    If Not Recenter_post(posTempZ, SuccessRecenter, ZENv) Then
         Exit Sub
     End If
     Set FileSystem = New FileSystemObject
     'If we log a new logfile is created
     If LogCode And LogFileNameBase <> "" Then
         LogFileName = LogFileNameBase
-        SafeOpenTextFile LogFileName, LogFile, FileSystem
-        LogFile.Close
-        Log = True
+        ErrFileName = ErrFileNameBase
+        If SafeOpenTextFile(LogFileName, LogFile, FileSystem) And SafeOpenTextFile(ErrFileName, ErrFile, FileSystem) Then
+            LogFile.Close
+            ErrFile.Close
+            Log = True
+        Else
+            Log = False
+        End If
     Else
         Log = False
     End If
+    '''UpdateJobs from current form
+    For Each Name In JobNames
+        UpdateFormFromJob Jobs, CStr(Name)
+    Next Name
+    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
 End Sub
 
 
-'''''
-'   SaveSettings(FileName As String)
-'   SaveSettings of the UserForm AutofocusForm in file name FileName.
-'   Name should correspond exactly to name used in Form
-'''''
-Private Sub SaveSettings(fileName As String)
-    Dim iFileNum As Integer
-    Close
-    On Error GoTo ErrorHandle
-    iFileNum = FreeFile()
-    Open fileName For Output As iFileNum
-    
-    Print #iFileNum, "% Settings for AutofocusMacro for ZEN " & ZEN & "  " & Version
-
-    'Single MultipelocationToggle
-    Print #iFileNum, "% Single Multiple "
-    Print #iFileNum, "MultipleLocationToggle " & MultipleLocationToggle.Value
-    Print #iFileNum, "SingleLocationToggle " & SingleLocationToggle.Value
-    
-    'Autofocus
-    Print #iFileNum, "% Autofocus "
-    Print #iFileNum, "ActiveAutofocus " & ActiveAutofocus.Value
-    Print #iFileNum, "AutofocusTrack1 " & AutofocusTrack1.Value
-    Print #iFileNum, "AutofocusTrack2 " & AutofocusTrack2.Value
-    Print #iFileNum, "AutofocusTrack3 " & AutofocusTrack3.Value
-    Print #iFileNum, "AutofocusTrack4 " & AutofocusTrack4.Value
-    Print #iFileNum, "AutofocusMaxSpeed " & AutofocusMaxSpeed.Value
-    Print #iFileNum, "AutofocusLowZoom " & AutofocusLowZoom.Value
-    Print #iFileNum, "AutofocusHRZ " & AutofocusHRZ.Value
-    Print #iFileNum, "AutofocusFastZline " & AutofocusFastZline.Value
-    Print #iFileNum, "AFeveryNth " & AFeveryNth.Value
-    Print #iFileNum, "AutofocusTrackZ " & AutofocusTrackZ.Value
-    Print #iFileNum, "AutofocusTrackXY " & AutofocusTrackXY.Value
-    Print #iFileNum, "ScanLineToggle " & ScanLineToggle.Value
-    Print #iFileNum, "ScanFrameToggle " & ScanFrameToggle.Value
-    Print #iFileNum, "AutofocusLineSize " & AutofocusLineSize.Value
-    Print #iFileNum, "AutofocusFrameSize " & AutofocusFrameSize.Value
-    Print #iFileNum, "AutofocusZOffset " & AutofocusZOffset.Value
-    Print #iFileNum, "AutofocusZRange " & AutofocusZRange.Value
-    Print #iFileNum, "AutofocusZStep " & AutofocusZStep.Value
-    Print #iFileNum, "SaveAFImage " & SaveAFImage.Value
-    Print #iFileNum, "AutofocusAlgorithm " & AutofocusAlgorithm.Value
-    
-    'Acquisition
-    Print #iFileNum, "% Acquisition "
-    Print #iFileNum, "AcquisitionTrack1 " & AcquisitionTrack1.Value
-    Print #iFileNum, "AcquisitionTrack2 " & AcquisitionTrack2.Value
-    Print #iFileNum, "AcquisitionTrack3 " & AcquisitionTrack3.Value
-    Print #iFileNum, "AcquisitionTrack4 " & AcquisitionTrack4.Value
-
-    
-    'PostAcquisitionTracking
-    Print #iFileNum, "% PostAcquisitionTracking "
-    Print #iFileNum, "TrackingToggle " & TrackingToggle.Value
-    Print #iFileNum, "ComboBoxTrackingChannel " & ComboBoxTrackingChannel.Value
-    Print #iFileNum, "PostTrackXY " & PostTrackXY.Value
-    Print #iFileNum, "PostTrackZ " & PostTrackZ.Value
-    
-    'Looping
-    Print #iFileNum, "% Looping "
-    Print #iFileNum, "LoopingTimerUnit " & LoopingTimerUnit
-    Print #iFileNum, "LoopingRepetitionTime " & LoopingRepetitionTime.Value
-    Print #iFileNum, "LoopingInterval " & LoopingInterval.Value
-    Print #iFileNum, "LoopingRepetitions " & LoopingRepetitions.Value
-    
-    'Output
-    Print #iFileNum, "% Output "
-    Print #iFileNum, "DatabaseTextbox " & DatabaseTextbox.Value
-    Print #iFileNum, "TextBoxFileName " & TextBoxFileName.Value
-    
-    'Micropilot
-    Print #iFileNum, "% MicroPilot "
-    Print #iFileNum, "ActiveMicropilot " & ActiveMicropilot.Value
-    Print #iFileNum, "MicropilotTrack1 " & MicropilotTrack1.Value
-    Print #iFileNum, "MicropilotTrack2 " & MicropilotTrack2.Value
-    Print #iFileNum, "MicropilotTrack3 " & MicropilotTrack3.Value
-    Print #iFileNum, "MicropilotTrack4 " & MicropilotTrack4.Value
-    Print #iFileNum, "MicropilotRepetitions " & MicropilotRepetitions.Value
-    Print #iFileNum, "MicropilotRepetitionTime " & MicropilotRepetitionTime.Value
-    Print #iFileNum, "MicropilotMaxPositions " & MicropilotMaxPositions.Value
-    Print #iFileNum, "MicropilotFrameSize " & MicropilotFrameSize.Value
-    Print #iFileNum, "MicropilotZOffset " & MicropilotZOffset.Value
-    Print #iFileNum, "MicropilotZSlices " & MicropilotZSlices.Value
-    Print #iFileNum, "MicropilotZStep " & MicropilotZStep.Value
-    Print #iFileNum, "MicropilotZoom " & MicropilotZoom.Value
-    Print #iFileNum, "MicropilotAutofocus " & MicropilotAutofocus.Value
-    
-    'Additional Acquisition
-    Print #iFileNum, "% Additional Acquisition "
-    Print #iFileNum, "ActiveAlterImage " & ActiveAlterImage.Value
-    Print #iFileNum, "AlterTrack1 " & AlterTrack1.Value
-    Print #iFileNum, "AlterTrack2 " & AlterTrack2.Value
-    Print #iFileNum, "AlterTrack3 " & AlterTrack3.Value
-    Print #iFileNum, "AlterTrack4 " & AlterTrack4.Value
-    Print #iFileNum, "RoundAlterTrack " & RoundAlterTrack.Value
-    Print #iFileNum, "RoundAlterLocation " & RoundAlterLocation.Value
-    Print #iFileNum, "AlterFrameSize " & AlterFrameSize.Value
-    Print #iFileNum, "AlterZOffset " & AlterZOffset.Value
-    Print #iFileNum, "AlterZSlices " & AlterZSlices.Value
-    Print #iFileNum, "AlterZStep " & AlterZStep.Value
-    Print #iFileNum, "AlterZoom " & AlterZoom.Value
-
-    'Grid Acquisition
-    Print #iFileNum, "% Additional Acquisition "
-    Print #iFileNum, "ActiveGridScan " & ActiveGridScan.Value
-    Print #iFileNum, "GridScan_validGridDefault " & GridScan_validGridDefault.Value
-    Print #iFileNum, "GridScan_nRow " & GridScan_nRow.Value
-    Print #iFileNum, "GridScan_nColumn " & GridScan_nColumn.Value
-    Print #iFileNum, "GridScan_dRow " & GridScan_dRow.Value
-    Print #iFileNum, "GridScan_dColumn " & GridScan_dColumn.Value
-    Print #iFileNum, "GridScan_refRow " & GridScan_refRow.Value
-    Print #iFileNum, "GridScan_refColumn " & GridScan_refColumn.Value
-    Print #iFileNum, "GridScan_nRowsub " & GridScan_nRowsub.Value
-    Print #iFileNum, "GridScan_nColumnsub " & GridScan_nColumnsub.Value
-    Print #iFileNum, "GridScan_dRowsub " & GridScan_dRowsub.Value
-    Print #iFileNum, "GridScan_dColumnsub " & GridScan_dColumnsub.Value
-
-       'Additional Acquisition
-    Print #iFileNum, "% Bleach Acquisition "
-    Print #iFileNum, "ActiveBleach " & ActiveBleach.Value
-    Print #iFileNum, "BleachTrack1 " & BleachTrack1.Value
-    Print #iFileNum, "BleachTrack2 " & BleachTrack2.Value
-    Print #iFileNum, "BleachTrack3 " & BleachTrack3.Value
-    Print #iFileNum, "BleachTrack4 " & BleachTrack4.Value
-    Print #iFileNum, "BleachRepetitions " & BleachRepetitions.Value
-    Print #iFileNum, "BleachRepetitionTime " & BleachRepetitionTime.Value
-    Print #iFileNum, "BleachFrameSize " & BleachFrameSize.Value
-    Print #iFileNum, "BleachZOffset " & BleachZOffset.Value
-    Print #iFileNum, "BleachZSlices " & BleachZSlices.Value
-    Print #iFileNum, "BleachZStep " & BleachZStep.Value
-    Print #iFileNum, "BleachZoom " & BleachZoom.Value
-
-    Close #iFileNum
-    Exit Sub
-ErrorHandle:
-    MsgBox "Not able to open " & fileName & " for saving settings"
-End Sub
-
-''''
-'   LoadSettings(FileName As String)
-'   LoadSettings of Form from FileName
-''''
-Private Sub LoadSettings(fileName As String)
-    Dim iFileNum As Integer
-    Dim Fields As String
-    Dim FieldEntries() As String
-    Dim Entries() As String
-    Close
-    On Error GoTo ErrorHandle
-    iFileNum = FreeFile()
-    Open fileName For Input As iFileNum
-    Do While Not EOF(iFileNum)
-  
-            Line Input #iFileNum, Fields
-            While Left(Fields, 1) = "%"
-                Line Input #iFileNum, Fields
-            Wend
-            FieldEntries = Split(Fields, " ", 2)
-            If FieldEntries(0) = "LoopingTimerUnit" Then
-                LoopingTimerUnit = CDbl(FieldEntries(1))
-                If LoopingTimerUnit = 60 Then
-                    CommandTimeMin_Click
-                Else
-                    CommandTimeSec_Click
-                End If
-            Else
-                On Error GoTo nextLine
-                Me.Controls(FieldEntries(0)).Value = FieldEntries(1)
-nextLine:
-            End If
-    Loop
-    Close #iFileNum
-    Exit Sub
-ErrorHandle:
-    MsgBox "Not able to read " & fileName & " for AutofocusScreen settings"
-End Sub
 
 ''''
 '   ButtonSaveSettings_Click()
 '   Open a dialog to save setting of the macro
 ''''
 Private Sub ButtonSaveSettings_Click()
-    Dim Filter As String, fileName As String
+    Dim Filter As String, FileName As String
     Dim Flags As Long
   
     Flags = OFN_FILEMUSTEXIST Or OFN_HIDEREADONLY Or _
@@ -476,15 +364,15 @@ Private Sub ButtonSaveSettings_Click()
     Filter$ = "Settings (*.ini)" & Chr$(0) & "*.ini" & Chr$(0) & "All files (*.*)" & Chr$(0) & "*.*"
             
     
-    fileName = CommonDialogAPI.ShowSave(Filter, Flags, "", DatabaseTextbox.Value, "Save AutofocusScreen settings")
-    
-    If fileName <> "" Then
-        If Right(fileName, 4) <> ".ini" Then
-            fileName = fileName & ".ini"
+    FileName = CommonDialogAPI.ShowSave(Filter, Flags, "", DatabaseTextbox.Value, "Save AutofocusScreen settings")
+    DisplayProgress "Save setings...", RGB(&HC0, &HC0, 0)
+    If FileName <> "" Then
+        If Right(FileName, 4) <> ".ini" Then
+            FileName = FileName & ".ini"
         End If
-        SaveSettings fileName
+        SaveFormSettings FileName
     End If
-    
+    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
 End Sub
 
 ''''
@@ -492,7 +380,7 @@ End Sub
 '   Open a dialog to save setting of the macro
 ''''
 Private Sub ButtonLoadSettings_Click()
-    Dim Filter As String, fileName As String
+    Dim Filter As String, FileName As String
     Dim Flags As Long
   
     Flags = OFN_FILEMUSTEXIST Or OFN_HIDEREADONLY Or _
@@ -501,12 +389,50 @@ Private Sub ButtonLoadSettings_Click()
             
     'Filter = "ini file (*.ini) |*.ini"
     
-    fileName = CommonDialogAPI.ShowOpen(Filter, Flags, "", DatabaseTextbox.Value, "Load AutofocusScreen settings")
+    FileName = CommonDialogAPI.ShowOpen(Filter, Flags, "", DatabaseTextbox.Value, "Load AutofocusScreen settings")
+    DisplayProgress "Load Settings...", RGB(&HC0, &HC0, 0)
+    If FileName <> "" Then
+        LoadFormSettings FileName
+    End If
+    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
     
-    If fileName <> "" Then
-        LoadSettings fileName
+End Sub
+
+
+'''''''
+'   MultipleLocationToggle_Change()
+'   Activate MultipleLocation and deactivate SingleLocation
+'''''''
+Private Sub MultipleLocationToggle_Change()
+                
+    If MultipleLocationToggle.Value = True Then
+        If Lsm5.Hardware.CpStages.MarkCount = 0 Then
+            MsgBox "To use MultipleLocations you need to define at least one position with the Stage (Not the positions) dialog!"
+            MultipleLocationToggle.Value = False
+        End If
+    End If
+    SingleLocationToggle.Value = Not MultipleLocationToggle.Value
+    If GridScanActive Then
+        
+        If MultipleLocationToggle.Value Then
+            GridScan_nRow = 1
+            GridScan_nColumn = Lsm5.Hardware.CpStages.MarkCount
+            Grids.updateGridSize "Global", GridScan_nRow, GridScan_nColumn, GridScan_nRowsub, GridScan_nColumnsub
+        End If
+        SwitchEnableGridScanPage (GridScanActive)
     End If
+    
+End Sub
+
+
+'''''''
+'   SingleLocationToggle_Change()
+'   Activate Singlelocation and deactivate MultipleLocation
+'''''''
+Private Sub SingleLocationToggle_Change()
+    MultipleLocationToggle.Value = Not SingleLocationToggle
 End Sub
+  
 
 ''''
 '   FocusMap_Click()
@@ -514,3585 +440,1832 @@ End Sub
 ''''
 Private Sub FocusMap_Click()
     ' This will run just in the AutofocusMode all the AcquisitionTracks are set off
-    SetDatabase
-    SaveSettings GlobalDataBaseName & "\tmpSettings.ini"
-    AcquisitionTracksSetOff
-    'change values
-    LoopingRepetitions.Value = 1
-    BlockTimeDelay = 0
-    CommandTimeSec_Click
-    ActiveMicropilot.Value = False
-    ActiveAlterImage.Value = False
-    StartButton_Click
-    WritePosFile GlobalDataBaseName & "\" & TextBoxFileName.Value & "positionsGrid.csv", posGridX, posGridY, posGridZ
-    'Return to original values for the
-    LoadSettings GlobalDataBaseName & "\tmpSettings.ini"
-End Sub
-
-
-Private Sub AutofocusTrackXY_Click()
-    If AutofocusTrackXY Then
-        PostTrackXY.Value = Not AutofocusTrackXY
-    End If
+'    SetDatabase
+'    SaveFormSettings GlobalDataBaseName & "\tmpSettings.ini"
+'    AcquisitionTracksSetOff
+'    'change values
+'    GlobalRepetitionNumber.Value = 1
+'    BlockTimeDelay = 0
+'    GlobalRepetitionSec_Click
+'    AlterAcquisitionActive.Value = False
+'    StartButton_Click
+'    WritePosFile GlobalDataBaseName & "\" & TextBoxFileName.Value & "positionsGrid.csv", posGridX, posGridY, posGridZ
+'    'Return to original values for the
+'    LoadFormSettings GlobalDataBaseName & "\tmpSettings.ini"
 End Sub
 
-Private Sub AutofocusFastZline_Click()
-    If AutofocusFastZline Then
-        LocationTextLabel.Caption = "WARNING: " & vbCrLf & _
-        "ScanLine with FastZLine is fast but can have low reliability." & vbCrLf & _
-        "Please test reproducibility of LineScan with FastZLine before using AutofocusScreen. Otherwise use piezo or normal mode with large Z Step and smaller Z Range."
-        LocationTextLabel.BackColor = &H80FF&
+
+
+
+'''''
+' Enable/disable a general set of functions common to all pages
+'''''
+Private Sub SwitchEnablePage(JobName As String, Enable As Boolean)
+
+    Dim i As Integer
+    Me.Controls(JobName + "Label").Enabled = Enable
+    For i = 1 To 4
+        Me.Controls(JobName + "Track" + CStr(i)).Enabled = Enable
+    Next i
+    If JobName <> "Autofocus" Then
+        Me.Controls(JobName + "ZOffset").Enabled = Enable
+        Me.Controls(JobName + "ZOffsetLabel").Enabled = Enable
+    End If
+    
+    
+    Me.Controls(JobName + "Period").Enabled = Enable
+    Me.Controls(JobName + "PeriodLabel").Enabled = Enable
+    
+    Me.Controls(JobName + "SetJob").Enabled = Enable
+    Me.Controls(JobName + "PutJob").Enabled = Enable
+    Me.Controls(JobName + "Acquire").Enabled = Enable
+            
+    Me.Controls(JobName + "TrackZ").Enabled = Enable
+    Me.Controls(JobName + "TrackXY").Enabled = Enable And (Jobs.GetScanMode(JobName) <> "ZScan") And (Jobs.GetScanMode(JobName) <> "Line")
+    Me.Controls(JobName + "CenterOfMass").Enabled = Enable And (Me.Controls(JobName + "TrackZ") Or Me.Controls(JobName + "TrackXY"))
+    Me.Controls(JobName + "CenterOfMassChannel").Enabled = Enable And (Me.Controls(JobName + "TrackZ") Or Me.Controls(JobName + "TrackXY"))
+    Me.Controls(JobName + "OiaActive").Enabled = Enable
+    If Me.Controls(JobName + "OiaActive") Then
+        Me.Controls(JobName + "OiaParallel").Enabled = Enable
+        Me.Controls(JobName + "OiaSequential").Enabled = Enable
     Else
-        LocationTextLabel.Caption = " "
-        LocationTextLabel.BackColor = &HFFFF&
+        Me.Controls(JobName + "OiaParallel").Enabled = False
+        Me.Controls(JobName + "OiaSequential").Enabled = False
     End If
         
-End Sub
+    Me.Controls(JobName + "SaveImage").Enabled = Enable
 
-Private Sub AutofocusHRZ_Click()
-    AutofocusFastZline.Enabled = Not AutofocusHRZ
-    If AutofocusFastZline And Not AutofocusHRZ Then
-        LocationTextLabel.Caption = "WARNING: " & vbCrLf & _
-        "ScanLine with FastZLine is fast but can have low reliability." & vbCrLf & _
-        "Please test reproducibility of LineScan with FastZLine before using AutofocusScreen. Otherwise use piezo or normal mode with large Z Step and smaller Z Range."
-        LocationTextLabel.BackColor = &H80FF&
-    Else
-        LocationTextLabel.Caption = " "
-        LocationTextLabel.BackColor = &HFFFF&
+    If JobName = "Trigger1" Or JobName = "Trigger2" Then
+        Me.Controls(JobName + "Autofocus").Enabled = Enable
+        Me.Controls(JobName + "RepetitionTime").Enabled = Enable
+        Me.Controls(JobName + "RepetitionTimeLabel").Enabled = Enable
+        Me.Controls(JobName + "RepetitionSec").Enabled = Enable
+        Me.Controls(JobName + "RepetitionMin").Enabled = Enable
+        Me.Controls(JobName + "RepetitionInterval").Enabled = Enable
+        Me.Controls(JobName + "RepetitionNumber").Enabled = Enable
+        Me.Controls(JobName + "RepetitionNumberLabel").Enabled = Enable
+        Me.Controls(JobName + "maxWaitLabel").Enabled = Enable
+        Me.Controls(JobName + "maxWait").Enabled = Enable
+        Me.Controls(JobName + "OptimalPtNumber").Enabled = Enable
+        Me.Controls(JobName + "OptimalPtNumberLabel").Enabled = Enable
     End If
+    
+    
+    Me.Controls(JobName + "Label1").Enabled = Enable
+    Me.Controls(JobName + "Label2").Enabled = Enable
+    
+    '' not super clean
+    Dim jobDescription() As String
+    jobDescription = Jobs.splittedJobDescriptor(JobName, 8)
+    Me.Controls(JobName + "Label1").Caption = jobDescription(0)
+    If UBound(jobDescription) > 0 Then
+        Me.Controls(JobName + "Label2").Caption = jobDescription(1)
+    End If
+    
 End Sub
 
-
-Private Sub PostTrackXY_Click()
-    If PostTrackXY Then
-        AutofocusTrackXY.Value = Not PostTrackXY
+'''''
+' Enable/disable a general set of functions common to all pages
+'''''
+Private Sub SwitchEnableFcsPage(JobName As String, Enable As Boolean)
+    Me.Controls(JobName + "Label").Enabled = Enable
+    Me.Controls(JobName + "Label1").Enabled = Enable
+    Me.Controls(JobName + "Label2").Enabled = Enable
+    Me.Controls(JobName + "SetJob").Enabled = Enable
+    Me.Controls(JobName + "PutJob").Enabled = Enable
+    Me.Controls(JobName + "Acquire").Enabled = Enable
+    Me.Controls(JobName + "ZOffset").Enabled = Enable
+    Me.Controls(JobName + "ZOffsetLabel").Enabled = Enable
+    
+    Dim jobDescription() As String
+    jobDescription = JobsFcs.splittedJobDescriptor(JobName, 8)
+    Me.Controls(JobName + "Label1").Caption = jobDescription(0)
+    If UBound(jobDescription) > 0 Then
+        Me.Controls(JobName + "Label2").Caption = jobDescription(1)
     End If
 End Sub
+    
 
 
-
-Private Sub StopAfterRepetition_Click()
-    If Not Running Then
-        StopAfterRepetition.Value = False
-        StopAfterRepetition.BackColor = &H8000000F
-    Else
-        If StopAfterRepetition.Value Then
-            StopAfterRepetition.BackColor = 12648447
-        Else
-            StopAfterRepetition.BackColor = &H8000000F
+'fills popup menu for chosing a track for post-acquisition tracking
+' TODO: move in form
+Public Sub FillTrackingChannelList(JobName As String)
+    Dim Success As Integer
+    Dim iTrack As Integer
+    Dim c As Integer
+    Dim ca As Integer
+    Dim channel As DsDetectionChannel
+    Dim Track As DsTrack
+    Dim TrackOn As Boolean
+    
+    Me.Controls(JobName + "CenterOfMassChannel").Clear 'Content of popup menu for chosing track for post-acquisition tracking is deleted
+    ca = 0
+    For iTrack = 0 To Jobs.TrackNumber(JobName) - 1
+        Set Track = Jobs.GetRecording(JobName).TrackObjectByMultiplexOrder(iTrack, Success)
+        If Jobs.getAcquireTrack(JobName, iTrack) Then
+            For c = 1 To Track.DetectionChannelCount 'for every detection channel of track
+                If Track.DetectionChannelObjectByIndex(c - 1, Success).Acquire Then 'if channel is activated
+                    ca = ca + 1 'counter for active channels will increase by one
+                    Me.Controls(JobName + "CenterOfMassChannel").AddItem Track.Name & " " & Track.DetectionChannelObjectByIndex(c - 1, Success).Name & "-T" & iTrack + 1   'entry is added to combo box to chose track for post-acquisition tracking
+                    TrackOn = True
+                End If
+            Next c
         End If
+    Next iTrack
+    
+    If TrackOn Then
+        Me.Controls(JobName + "CenterOfMassChannel").Value = Me.Controls(JobName + "CenterOfMassChannel").List(0) 'initially displayed text in popup menu is a blank line (first channel is 1)
     End If
 End Sub
 
-Private Sub PauseButton_Click()
-    If Not Running Then
-        ScanPause = False
-        PauseButton.Value = False
-        PauseButton.Caption = "PAUSE"
-        PauseButton.BackColor = &H8000000F
+'''
+'   TrackClick(JobName As String, thisTrack As Integer, Exclusive As Boolean)
+'       Activate iTrack-th track for a specific JobName
+'       If Exclusive all other tracks are inactivated
+'''
+Private Sub TrackClick(JobName As String, iTrack As Integer, Optional Exclusive As Boolean = False)
+    Dim i As Integer
+    Dim AutofocusTrackOn As Boolean
+
+    If Me.Controls(JobName + "Track" + CStr(iTrack)).Value Then
+        For i = 1 To TrackNumber
+            If i <> iTrack And Exclusive Then
+                Me.Controls(JobName + "Track" + CStr(i)).Value = Not Me.Controls(JobName + "Track" + CStr(iTrack)).Value
+            End If
+        Next i
+        Jobs.setAcquireTrack JobName, iTrack - 1, Me.Controls(JobName + "Track" + CStr(iTrack)).Value
+        'CheckAutofocusTrack (thisTrack)
     Else
-        If PauseButton.Value Then
-            ScanPause = True
-            PauseButton.Caption = "RESUME"
-            PauseButton.BackColor = 12648447
-        Else
-            ScanPause = False
-            PauseButton.Caption = "PAUSE"
-            PauseButton.BackColor = &H8000000F
-        End If
+        Jobs.setAcquireTrack JobName, iTrack - 1, Me.Controls(JobName + "Track" + CStr(iTrack)).Value
     End If
+    FillTrackingChannelList JobName
 End Sub
 
 
-Private Sub MicropilotZSlices_Change()
-    MicropilotZSlices.Value = Round(MicropilotZSlices.Value)
+''''
+' JobActive_Click
+' Enables the corresponding page
+'''''
+Private Sub AutofocusActive_Click()
+    SwitchEnablePage "Autofocus", AutofocusActive
 End Sub
 
+Private Sub AcquisitionActive_Click()
+    SwitchEnablePage "Acquisition", AcquisitionActive
+End Sub
 
-''''''
-'   ActiveAutofocus_Click()
-'       Activates Autofocus. If not toggled only Acquisition track is used
-'''''
-Private Sub ActiveAutofocus_Click()
-    If ActiveAutofocus.Value Then
-        SwitchEnableAutofocusPage (True)
-        AutofocusTrackZ.Value = False
-    Else
-        SwitchEnableAutofocusPage (False)
-    End If
-    
+Private Sub AlterAcquisitionActive_Click()
+    SwitchEnablePage "AlterAcquisition", AlterAcquisitionActive
 End Sub
 
-''''''
-'   SwitchEnableAutofocusPage(Enable As Boolean)
-'   Disable or enable all buttons and slider
-'       [Enable] In - Sets the mini page enable status
-''''''
-Private Sub SwitchEnableAutofocusPage(Enable As Boolean)
-    AutofocusMaxSpeed.Enabled = Enable
-    AutofocusHRZ.Enabled = Enable
-    AutofocusLowZoom.Enabled = Enable
-    AFeveryNth.Enabled = Enable
-    AFeveryNthLabel.Enabled = Enable
-    AFeveryNthLabel2.Enabled = Enable
-    ScanLineToggle.Enabled = Enable
-    ScanFrameToggle.Enabled = Enable
-    FrameSizeLabel.Enabled = Enable
-    AutofocusFrameSize.Enabled = Enable
-    AutofocusLineSize.Enabled = Enable
-    AutofocusZOffset.Enabled = Enable
-    SliderZOffsetLabel.Enabled = Enable
-    AutofocusZRange.Enabled = Enable
-    SliderZRangeLabel.Enabled = Enable
-    AutofocusZStep.Enabled = Enable
-    SliderZStepLabel.Enabled = Enable
-    AutofocusTrack1.Enabled = Enable
-    AutofocusTrack2.Enabled = Enable
-    AutofocusTrack3.Enabled = Enable
-    AutofocusTrack4.Enabled = Enable
-    AutofocusTrackZ.Enabled = Enable
-    AutofocusTrackXY.Enabled = Enable
-    AutofocusAlgorithmLabel.Enabled = Enable
-    AutofocusAlgorithmLabel.Enabled = Enable
-    
-    AutofocusFastZline.Enabled = Enable
-    SaveAFImage.Enabled = Enable
-    
+Private Sub Trigger1Active_Click()
+    SwitchEnablePage "Trigger1", Trigger1Active
 End Sub
 
-'''
-' fills popup menu for UseAF compo box
-'''
-Private Sub FillAutofocusAlgorithm()
-    AutofocusAlgorithm.AddItem "internal"
-    AutofocusAlgorithm.AddItem "external"
-    AutofocusAlgorithm.Value = AutofocusAlgorithm.List(0)
+Private Sub Trigger2Active_Click()
+    SwitchEnablePage "Trigger2", Trigger2Active
 End Sub
 
 
-''''''
-'   AutofocusZOffset_Change()
-'   AutofocusZOffset is the offset added after AF
-''''''
-Private Sub AutofocusZOffset_Change()
-    'make range checks
-     If Abs(AutofocusZOffset.Value) > Range() * 0.9 Then
-            AutofocusZOffset.Value = 0
-            MsgBox "ZOffset has to be less than the working distance of the objective: " + CStr(Range) + " um"
-    End If
-End Sub
+''''
+' JobActive_Click
+' Enables the corresponding page
+''''
 
-''''''
-'   AutofocusZRange_Change()
-'   Set the range in um during AF
-''''''
-Private Sub AutofocusZRange_Change()    ' It should be possible to change the limit of the range to bigger values than half of the working distance
-    If AutofocusZRange.Value > Range * 0.9 Then 'make range checks
-            AutofocusZRange.Value = Range * 0.9
-            MsgBox "ZRange has to be less or equal to the working distance of the objective: " + CStr(Range) + " um"
-    End If
+Private Sub Fcs1Active_Click()
+    SwitchEnableFcsPage "Fcs1", Fcs1Active
 End Sub
 
-
-'''''
-'   CheckZRanges()
-'   Check if Z movements are in agreement with range of microscope
-'''''
-Public Function CheckZRanges() As Boolean
-    If ScanStop Then
-        Exit Function
-    End If
-    If Range() = 0 Then
-        MsgBox "Objective's working distance not defined! Cannot Autofocus!"
-        CheckZRanges = False
-        Exit Function
-    Else
-        CheckZRanges = True
-    End If
-    
-    If AutofocusZRange.Value > Range() * 0.9 Then 'this is already tested in the slider could be removed
-        AutofocusForm.AutofocusZRange.Value = Range() * 0.9
-        MsgBox "Autofocus range is too large! Has been reduced to " + Str(AutofocusForm.AutofocusZRange.Value)
-    End If
-    
-    If Abs(AutofocusZOffset.Value) > Range() * 0.9 Then 'this is already tested in the slider could be removed
-        AutofocusForm.AutofocusZOffset = 0
-        MsgBox "ZOffset has to be less than the working distance of the objective: " + CStr(Range) + " um. Has been put back to " + Str(AutofocusForm.AutofocusZOffset)
-    End If
-    
-End Function
-  
 ''''''
-'   The tracks for Autofocus
+'   Activte Tracks for Jobs (For Autofocus need to be Click as the tracks are exclusive)
 ''''''
 Private Sub AutofocusTrack1_Click()
-    If AutofocusTrack1.Value Then 'if track 1 checked others are not autofocus track but false
-        AutofocusTrack2.Value = Not AutofocusTrack1.Value
-        AutofocusTrack3.Value = Not AutofocusTrack1.Value
-        AutofocusTrack4.Value = Not AutofocusTrack1.Value
-        CheckAutofocusTrack (1) 'sets SelectedTrack to 1, see below
-    End If
+   TrackClick "Autofocus", 1, False
 End Sub
 
 Private Sub AutofocusTrack2_Click()
-    If AutofocusTrack2.Value Then
-        AutofocusTrack1.Value = Not AutofocusTrack2.Value
-        AutofocusTrack3.Value = Not AutofocusTrack2.Value
-        AutofocusTrack4.Value = Not AutofocusTrack2.Value
-        CheckAutofocusTrack (2)
-    End If
+    TrackClick "Autofocus", 2, False
 End Sub
 
 Private Sub AutofocusTrack3_Click()
-    If AutofocusTrack3.Value Then
-        AutofocusTrack1.Value = Not AutofocusTrack3.Value
-        AutofocusTrack2.Value = Not AutofocusTrack3.Value
-        AutofocusTrack4.Value = Not AutofocusTrack3.Value
-        CheckAutofocusTrack (3)
-    End If
+    TrackClick "Autofocus", 3, False
 End Sub
 
 Private Sub AutofocusTrack4_Click()
-    If AutofocusTrack4.Value Then
-        AutofocusTrack1.Value = Not AutofocusTrack4.Value
-        AutofocusTrack2.Value = Not AutofocusTrack4.Value
-        AutofocusTrack3.Value = Not AutofocusTrack4.Value
-        CheckAutofocusTrack (4)
-    End If
+    TrackClick "Autofocus", 4, False
 End Sub
 
+Private Sub AcquisitionTrack1_Change()
+   TrackClick "Acquisition", 1
+End Sub
 
-''''''
-'   ActiveMicropilot_Click()
-'   Activate online image analysis, micropilot. Also enable the complete micropilot page
-''''''
-Private Sub ActiveMicropilot_Click()
-
-    SwitchEnableMicropilotPage (ActiveMicropilot.Value)
-    If ActiveMicropilot.Value And ZoomImageInitialize Then
-        MicropilotZOffset.Value = AutofocusZOffset.Value
-        MicropilotZSlices.Value = GlobalAcquisitionRecording.FramesPerStack
-        MicropilotFrameSize.Value = GlobalAcquisitionRecording.SamplesPerLine
-        MicropilotZoom.Value = GlobalAcquisitionRecording.ZoomX
-        MicropilotZStep.Value = GlobalAcquisitionRecording.FrameSpacing
-        ZoomImageInitialize = False
-    End If
-        
+Private Sub AcquisitionTrack2_Change()
+   TrackClick "Acquisition", 2
 End Sub
 
-''''''
-'   SwitchEnableMicropilotPage(Enable As Boolean)
-'   Disable or enable all buttons and slider (aka Micropilot)
-'       [Enable] In -  Sets the mini page enable status
-''''''
-Private Sub SwitchEnableMicropilotPage(Enable As Boolean)
-    MicropilotTrack1.Enabled = Enable
-    MicropilotTrack2.Enabled = Enable
-    MicropilotTrack3.Enabled = Enable
-    MicropilotTrack4.Enabled = Enable
-    LabelZoom.Enabled = Enable
-    MicropilotZoom.Enabled = Enable
-    ZoomNumSlicesLabel.Enabled = Enable
-    MicropilotZSlices.Enabled = Enable
-    ZoomIntervalLabel.Enabled = Enable
-    MicropilotZStep.Enabled = Enable
-    MicropilotZOffset.Enabled = Enable
-    MicropilotAutofocus.Enabled = Enable
-    ZoomFrameSizeLabel.Enabled = Enable
-    MicropilotFrameSize.Enabled = Enable
-    ZoomCyclesLabel.Enabled = Enable
-    MicropilotRepetitions.Enabled = Enable
-    ZoomCycleDelayLabel.Enabled = Enable
-    MicropilotRepetitionTime.Enabled = Enable
-    SwitchEnableGridScanPage (ActiveGridScan.Value)
-    MicropilotZOffset.Enabled = Enable
-    ZoomAutofocusZOffsetLabel.Enabled = Enable
-    MicropilotZOffset.Value = AutofocusZOffset.Value
-    MicropilotMaxPositions.Enabled = Enable
-    MicropilotMaxPositionsLabel1.Enabled = Enable
-    MicroPilotMaxPositionsLabel2.Enabled = Enable
-    
+Private Sub AcquisitionTrack3_Change()
+   TrackClick "Acquisition", 3
 End Sub
 
-''''''
-'   MicropilotAutofocus_Click()
-'   Activate extra autofocus for image analysis. Enable Z-offset box to be viewed
-''''''
-Private Sub MicropilotAutofocus_Click()
-    
-    SwitchEnableZoomAutofocus (MicropilotAutofocus.Value) 'Show Zoffset only when extra autofocus is clicked
-    
+Private Sub AcquisitionTrack4_Change()
+   TrackClick "Acquisition", 4
 End Sub
 
-''''''
-'   SwitchEnableZoomAutofocus(Enable As Boolean)
-'   Enable/disable Z-offset form for Micropilot minipage
-'       [Enable] In - Sets the visibility of box
-''''''
-Private Sub SwitchEnableZoomAutofocus(Enable As Boolean)
-'    MicropilotZOffset.Visible = Enable
-'    ZoomAutofocusZOffsetLabel.Visible = Enable
-'    MicropilotZOffset.Value = AutofocusZOffset.Value
+Private Sub AlterAcquisitionTrack1_Change()
+   TrackClick "AlterAcquisition", 1
 End Sub
 
-''''''
-'   ActiveAlterImage_Click()
-'   Activate additional image that is acquired only from time to time
-''''''
-Private Sub ActiveAlterImage_Click()
-
-    SwitchEnableAlterImagePage (ActiveAlterImage.Value)
-    If ActiveAlterImage.Value And AlterImageInitialize Then
-        AlterFrameSize.Value = GlobalAcquisitionRecording.SamplesPerLine
-        AlterZoom.Value = GlobalAcquisitionRecording.ZoomX
-        AlterZOffset.Value = AutofocusZOffset.Value
-        AlterZStep.Value = GlobalAcquisitionRecording.FrameSpacing
-        AlterZSlices.Value = GlobalAcquisitionRecording.FramesPerStack
-        AlterImageInitialize = False
-    End If
+Private Sub AlterAcquisitionTrack2_Change()
+   TrackClick "AlterAcquisition", 2
 End Sub
 
-''''''
-'   SwitschEnableAlterImagePage(Enable As Boolean)
-'   Enable/disable Additional acquisition page
-'       [Enable] In - Sets the enable Enable of minpage
-''''''
-Private Sub SwitchEnableAlterImagePage(Enable As Boolean)
-
-    AlterTrack1.Enabled = Enable
-    AlterTrack2.Enabled = Enable
-    AlterTrack3.Enabled = Enable
-    AlterTrack4.Enabled = Enable
-    AlterFrameSizeLabel.Enabled = Enable
-    AlterFrameSize.Enabled = Enable
-    AlterZoomLabel.Enabled = Enable
-    AlterZoom.Enabled = Enable
-    AlterNumSlicesLabel.Enabled = Enable
-    AlterZSlices.Enabled = Enable
-    AlterIntervalLabel.Enabled = Enable
-    AlterZStep.Enabled = Enable
-    RoundAlterTrackLabel1.Enabled = Enable
-    RoundAlterTrackLabel2.Enabled = Enable
-    RoundAlterTrack.Enabled = Enable
-    RoundAlterLocationLabel1.Enabled = Enable
-    RoundAlterLocationLabel2.Enabled = Enable
-    AlterZOffset.Enabled = Enable
-    AlterZOffsetLabel.Enabled = Enable
-    
+Private Sub AlterAcquisitionTrack3_Change()
+   TrackClick "AlterAcquisition", 3
+End Sub
+
+Private Sub AlterAcquisitionTrack4_Change()
+   TrackClick "AlterAcquisition", 4
 End Sub
 
-Private Sub ActiveBleach_Click()
-      SwitchEnableBleachPage (ActiveBleach.Value)
+Private Sub Trigger1Track1_Change()
+   TrackClick "Trigger1", 1
+End Sub
+
+Private Sub Trigger1Track2_Change()
+   TrackClick "Trigger1", 2
+End Sub
+
+Private Sub Trigger1Track3_Change()
+   TrackClick "Trigger1", 3
+End Sub
+
+Private Sub Trigger1Track4_Change()
+   TrackClick "Trigger1", 4
 End Sub
 
 
+Private Sub Trigger2Track1_Change()
+   TrackClick "Trigger2", 1
+End Sub
 
-Private Sub SwitchEnableBleachPage(Enable As Boolean)
-    BleachTrack1.Enabled = Enable
-    BleachTrack2.Enabled = Enable
-    BleachTrack3.Enabled = Enable
-    BleachTrack4.Enabled = Enable
-    BleachFrameSizeLabel.Enabled = Enable
-    BleachFrameSize.Enabled = Enable
-    BleachZoomLabel.Enabled = Enable
-    BleachZoom.Enabled = Enable
-    BleachZSlicesLabel.Enabled = Enable
-    BleachZSlices.Enabled = Enable
-    BleachZStepLabel.Enabled = Enable
-    BleachZStep.Enabled = Enable
-    BleachZOffset.Enabled = Enable
-    BleachZOffsetLabel.Enabled = Enable
-    BleachRepetitionsLabel.Enabled = Enable
-    BleachRepetitions.Enabled = Enable
-    BleachRepetitionTimeLabel.Enabled = Enable
-    BleachRepetitionTime.Enabled = Enable
+Private Sub Trigger2Track2_Change()
+   TrackClick "Trigger2", 2
+End Sub
 
+Private Sub Trigger2Track3_Change()
+   TrackClick "Trigger2", 3
 End Sub
 
+Private Sub Trigger2Track4_Change()
+   TrackClick "Trigger2", 4
+End Sub
+'''
+' ZOffset: This is offset added to current central slice position. This position depends on previous history
 ''''
-' ActiveGridScan_Click()
-'   Set the grid scan on or off. Changes also
-''
-Private Sub ActiveGridScan_Click()
-    SwitchEnableGridScanPage (ActiveGridScan.Value)
-    If ActiveGridScan.Value Then
-        MultipleLocationToggle.Value = False
+Private Sub JobZOffsetChange(JobName As String)
+    If Me.Controls(JobName + "ZOffset").Value > Range() * 0.9 Then
+            Me.Controls(JobName + "ZOffset").Value = 0
+            MsgBox "ZOffset has to be less than the working distance of the objective: " + CStr(Range) + " um"
     End If
 End Sub
 
+Private Sub AcquisitionZOffset_Change()
+    JobZOffsetChange "Acquisition"
+End Sub
+
+Private Sub AlterAcquisitionZOffset_Change()
+    JobZOffsetChange "AlterAcquisition"
+End Sub
+
+Private Sub Trigger1ZOffset_Change()
+    JobZOffsetChange "Trigger1"
+End Sub
+
+Private Sub Trigger2ZOffset_Change()
+    JobZOffsetChange "Trigger2"
+End Sub
+
 ''''
-'   SwitchEnableGridScanPage(Enable As Boolean)
-'   Disable or enable all buttons and slider
-'       [Enable] In - Sets the mini page enable status
+' TrackZ: If on the Z position will be updated to the latest Z position
 ''''
-Private Sub SwitchEnableGridScanPage(Enable As Boolean)
+Private Sub JobTrackXYZChange(JobName As String)
+    Me.Controls(JobName + "CenterOfMassChannel").Enabled = (Me.Controls(JobName + "TrackZ") Or Me.Controls(JobName + "TrackXY")) _
+    And Me.Controls(JobName + "CenterOfMass")
+    Me.Controls(JobName + "CenterOfMass").Enabled = Me.Controls(JobName + "TrackZ") Or Me.Controls(JobName + "TrackXY")
+    If Not (Me.Controls(JobName + "TrackZ") Or Me.Controls(JobName + "TrackXY")) Then
+        Me.Controls(JobName + "CenterOfMass").Value = False
+    End If
+End Sub
 
-    GridScan_validGridDefault.Enabled = Enable
-    GridScan_posLabel.Enabled = Enable
-    GridScan_nColumnLabel.Enabled = Enable
-    GridScan_nRowLabel.Enabled = Enable
-    GridScan_nColumn.Enabled = Enable
-    GridScan_nRow.Enabled = Enable
-    GridScan_dColumnLabel.Enabled = Enable
-    GridScan_dRowLabel.Enabled = Enable
-    GridScan_dColumn.Enabled = Enable
-    GridScan_dRow.Enabled = Enable
-    GridScan_refColumn.Enabled = Enable
-    GridScan_refRow.Enabled = Enable
-    GridScan_refColumnLabel.Enabled = Enable
-    GridScan_refRowLabel.Enabled = Enable
-    GridScan_subLabel.Enabled = Enable
-    GridScan_nColumnsub.Enabled = Enable
-    GridScan_nRowsub.Enabled = Enable
-    GridScan_nColumnsubLabel.Enabled = Enable
-    GridScan_nRowsubLabel.Enabled = Enable
-    
-    GridScan_dColumnsubLabel.Enabled = Enable
-    GridScan_dRowsubLabel.Enabled = Enable
-    GridScan_dColumnsub.Enabled = Enable
-    GridScan_dRowsub.Enabled = Enable
-    GridScanDescriptionLabel.Enabled = Enable
-    
+Private Sub AutofocusTrackZ_Change()
+    JobTrackXYZChange "Autofocus"
 End Sub
 
+Private Sub AcquisitionTrackZ_Change()
+    JobTrackXYZChange "Acquisition"
+End Sub
 
+Private Sub Trigger1TrackZ_Change()
+    JobTrackXYZChange "Trigger1"
+End Sub
 
+Private Sub Trigger2TrackZ_Change()
+    JobTrackXYZChange "Trigger2"
+End Sub
 
+''''
+' TrackXY: If on the XY position will be updated to the latest XY position
+''''
+Private Sub AutofocusTrackXY_Change()
+    JobTrackXYZChange "Autofocus"
+End Sub
 
-''''''''
-'   CommandButtonHelp_Click()
-'   Look for Help file
-'   TODO: Test
-''''''''
-Private Sub CommandButtonHelp_Click()
+Private Sub AcquisitionTrackXY_Change()
+    JobTrackXYZChange "Acquisition"
+End Sub
 
-    Dim dblTask As Double
-    Dim MacroPath As String
-    Dim MyPath As String
-    Dim MyPathPDF As String
-    
-    Dim bslash As String
-    Dim Success As Integer
-    Dim pos As Integer
-    Dim Start As Integer
-    Dim count As Long
-    Dim ProjName As String
-    Dim indx As Integer
-    Dim AcrobatObject As Object
-    Dim AcrobatViewer As Object
-    Dim OK As Boolean
-    Dim StrPath As String
-    Dim ExecName As String
-        
-    count = ProjectCount()
-    For indx = 0 To count - 1
-        MacroPath = ProjectPath(indx, Success)
-        ProjName = ProjectTitle(indx, Success)
-        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, MacroPath, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            MyPath = Strings.Left(MacroPath, Start - 1)
-            MyPathPDF = MyPath + HelpNamePDF
-
-            OK = False
-            On Error GoTo RTFhelp
-            OK = FServerFromDescription("AcroExch.Document", StrPath, ExecName)
-            dblTask = Shell(ExecName + " " + MyPathPDF, vbNormalFocus)
-            
-RTFhelp:
-            If Not OK Then
-                MsgBox "Install Acrobat Viewer!"
-            End If
-            Exit For
-        End If
-    Next indx
+Private Sub Trigger1TrackXY_Change()
+    JobTrackXYZChange "Trigger1"
 End Sub
 
-'''''''''
-'   StopButton_Click()
-'   ScanStop is used to tell different functions to stop execution and acquisition
-'   A second routine is called to stop the processes
-'       [ScanStop] Global/Out - Set to true
-'''''''
-Private Sub StopButton_Click()
-    If Not Running Then
-        StopButton.Value = False
-        StopButton.BackColor = &H8000000F
-        ScanStop = False
-    Else
-        If StopButton.Value Then
-            StopButton.BackColor = 12648447
-            ScanStop = True
-        Else
-            StopButton.BackColor = &H8000000F
-            ScanStop = False
-        End If
-    End If
+Private Sub Trigger2TrackXY_Change()
+    JobTrackXYZChange "Trigger2"
+End Sub
 
+'''
+' If CenterOfMass = True an internal analysis of center of mass is done
+'''
+Private Sub AutofocusCenterOfMass_Change()
+    AutofocusCenterOfMassChannel.Enabled = AutofocusCenterOfMass
 End Sub
 
+Private Sub AcquisitionCenterOfMass_Change()
+    AcquisitionCenterOfMassChannel.Enabled = AcquisitionCenterOfMass
+End Sub
 
-''''''''
-'   StopAcquisition()
-'   Stop scan and reset buttons of the form
-''''''''
-Public Sub StopAcquisition()
+Private Sub Trigger1CenterOfMass_Change()
+    Trigger1CenterOfMassChannel.Enabled = Trigger1CenterOfMass
+End Sub
 
-    If ScanStop Then
-        Lsm5.StopScan
-        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-        RestoreAcquisitionParameters
-        DoEvents
-    Else
-        DisplayProgress "Restore Settings", RGB(&HC0, &HC0, 0)
-        RestoreAcquisitionParameters
-        DoEvents
-    End If
-    
-    ReDim BleachTable(BlockRepetitions)
-    ReDim BleachStartTable(BlockRepetitions)
-    ReDim BleachStopTable(BlockRepetitions)
-    ChangeButtonStatus True
-    Running = False
-    ScanStop = False
-    ScanPause = False
-    PauseButton.Value = False
-    PauseButton.Caption = "PAUSE"
-    PauseButton.BackColor = &H8000000F
-    ExtraBleach = False
-    ExtraBleachButton.Caption = "Bleach"
-    ExtraBleachButton.BackColor = &H8000000F
-    StopAfterRepetition.Value = False
-    StopAfterRepetition.BackColor = &H8000000F
-    StopButton.BackColor = &H8000000F
-    StopButton.Value = False
-    BleachingActivated = False
-    LocationTextLabel.Caption = ""
-    Sleep (1000)
-    If Log Then
-        SafeOpenTextFile LogFileName, LogFile, FileSystem
-        If Not LogFile Is Nothing Then
-            LogFile.Close
-        End If
-    End If
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
+Private Sub Trigger2CenterOfMass_Change()
+    Trigger2CenterOfMassChannel.Enabled = Trigger2CenterOfMass
+End Sub
 
+
+''''
+' Online image analysis. If True then VBAMacro listen to external program (Fiji, Macropilot, Cellprofiler)
+''''
+Private Sub JobOiaActiveClick(JobName As String)
+    Me.Controls(JobName + "SaveImage") = True
+    Me.Controls(JobName + "OiaParallel").Enabled = Me.Controls(JobName + "OiaActive")
+    Me.Controls(JobName + "OiaSequential").Enabled = Me.Controls(JobName + "OiaActive")
 End Sub
 
-'''''
-'   CommandButtonNewDataBase_Click()
-'   Open a Dialog to set output folder where to save the results. then cal SetDatabase to set global variables
-'''''
-Private Sub CommandButtonNewDataBase_Click()
-    Dim Filter As String, fileName As String
-    Dim Flags As Long
-  
-    Flags = OFN_PATHMUSTEXIST Or OFN_HIDEREADONLY Or OFN_NOCHANGEDIR Or OFN_EXPLORER Or OFN_NOVALIDATE
-            
-    Filter = "Alle Dateien (*.*)" & Chr$(0) & "*.*"
-    
-    fileName = CommonDialogAPI.ShowOpen(Filter, Flags, "*.*", "", "Select output folder")
-    
-    If Len(fileName) > 3 Then
-        fileName = Left(fileName, Len(fileName) - 3)
-        DatabaseTextbox.Value = fileName
-        SetDatabase
-    End If
-    
+Private Sub AutofocusOiaActive_Click()
+    JobOiaActiveClick "Autofocus"
 End Sub
 
-'''''
-'   DatabaseTextbox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
-'   Only update the outputfolder when enter is pressed. This avoids creating a folded at every keystroke
-'''''
-Private Sub DatabaseTextbox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
-    If KeyCode = 13 Then 'this is the enter key
-        SetDatabase
-    End If
+Private Sub AcquisitionOiaActive_Click()
+    JobOiaActiveClick "Acquisition"
 End Sub
 
-'''''
-'   SetDatabase()
-'       [GlobalDataBaseName] Out/Global - The name of Outputfolder
-'       [LogFileNameBase]    Out/Global - The name of the LogfileName
-'       [Log]                Out/Global - If yes results are logged
-'       Set global variables and check if we can create Outputfolder
-'''''
-Private Sub SetDatabase()
-    GlobalDataBaseName = DatabaseTextbox.Value
-    If GlobalDataBaseName = "" Then
-        DatabaseLable.Caption = "No output folder"
-    End If
+Private Sub AlterAcquisitionOiaActive_Click()
+    JobOiaActiveClick "AlterAcquisition"
+End Sub
 
-    If Not GlobalDataBaseName = "" Then
-        On Error GoTo ErrorHandleDataBase
-        If Not CheckDir(GlobalDataBaseName) Then
-            Exit Sub
-        End If
-        DatabaseLable.Caption = GlobalDataBaseName
-        SaveSetting "OnlineImageAnalysis", "macro", "OutputFolder", GlobalDataBaseName
-        LogFileNameBase = GlobalDataBaseName & "\AutofocusScreen.log"
-        If Right(GlobalDataBaseName, 1) = "\" Then
-            BackSlash = ""
-        Else
-            BackSlash = "\"
-        End If
-    End If
+Private Sub Trigger1OiaActive_Click()
+    JobOiaActiveClick "Trigger1"
+End Sub
 
-    If LogCode And LogFileNameBase <> "" Then
-        On Error GoTo ErrorHandleLogFile
-        'Set FileSystem = New FileSystemObject
-        LogFileName = LogFileNameBase
-        'SafeOpenTextFile LogFileName, LogFile, FileSystem
-        'LogFile.Close
-        Log = True
-    Else
-        Log = False
+Private Sub Trigger2OiaActive_Click()
+    JobOiaActiveClick "Trigger2"
+End Sub
+
+
+Private Sub TriggermaxWait(JobName As String)
+On Error GoTo ErrorHandle:
+    If Me.Controls(JobName + "maxWait").Value < 0 Then
+        MsgBox JobName + "waiting time for setting positions is >=0"
+        Me.Controls(JobName + "maxWait").Value = 0
     End If
     Exit Sub
-ErrorHandleDataBase:
-    MsgBox "Could not create output Directory " & GlobalDataBaseName
-    Exit Sub
-ErrorHandleLogFile:
-    MsgBox "Could not create LogFile " & LogFileName
+ErrorHandle:
+    MsgBox "There is no property in form called " + JobName + "maxWait!"
 End Sub
 
-
-''''''
-'   BleachRegion(XShift As Double, YShift As Double)
-'       [XShift] In - Shifts origin of x
-'       [YShift] In - Shifts origin of y
-'   Todo: function is never been used and does not belong to form or being called. Check it
-''''''
-Private Sub BleachRegion(XShift As Double, YShift As Double)
-    Dim RecordingDoc As DsRecordingDoc
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim Laser As DsLaser
-    Dim DetectionChannel As DsDetectionChannel
-    Dim IlluminationChannel As DsIlluminationChannel
-    Dim DataChannel As DsDataChannel
-    Dim BeamSplitter As DsBeamSplitter
-    Dim Timers As DsTimers
-    Dim Markers As DsMarkers
-    Dim Success As Integer
-    Set Recording = Lsm5.DsRecording
-    Dim SampleObservationTime As Double
-    Dim SampleOX As Double
-    Dim SampleOY As Double
-    
-    
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-     
-    SampleOX = Recording.Sample0X
-    SampleOY = Recording.Sample0Y
-    Recording.Sample0X = XShift
-    Recording.Sample0Y = YShift
-    'x = Lsm5.Hardware.CpStages.PositionX - XShift
-    'y = Lsm5.Hardware.CpStages.PositionY - YShift
-    'Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-    ' maybe wait here till it is finished moving
-    Recording.SpecialScanMode = "NoSpecialMode"
-    Recording.ScanMode = "Point"
-    Recording.TimeSeries = True
-    Recording.FramesPerStack = 1
-    Recording.StacksPerRecord = 50  ' timepoints x 1000
-    SampleObservationTime = Track.SampleObservationTime
-    MsgBox "SampleObservationTime = " + CStr(SampleObservationTime)
-    Track.SampleObservationTime = 0.0001 ' pixel-dwell time in seconds
-    Track.TimeBetweenStacks = 0#
-    'Timers.TimeInterval = 0#
-    
-    TakeImage
-    
-    Recording.Sample0X = SampleOX
-    Recording.Sample0Y = SampleOY
-    'x = Lsm5.Hardware.CpStages.PositionX + XShift
-    'y = Lsm5.Hardware.CpStages.PositionY + YShift
-    'Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-    ' maybe wait here till it is finished moving
-    Recording.SpecialScanMode = "NoSpecialMode"
-    Recording.ScanMode = "Frame"
-    Recording.TimeSeries = False
-    Recording.FramesPerStack = 1
-    Recording.StacksPerRecord = 1  ' timepoints x 1000
-    Track.SampleObservationTime = SampleObservationTime ' pixel-dwell time in seconds
-    MsgBox "SampleObservationTime = " + CStr(SampleObservationTime)
-    
- 
-    'Recording.ScanMode = "Plane"
-    'Recording.FrameSpacing = 0.636243
-       
-        
+Private Sub Trigger2maxWait_Change()
+    TriggermaxWait ("Trigger1")
 End Sub
 
+Private Sub Trigger1maxWait_Change()
+    TriggermaxWait ("Trigger1")
+End Sub
 
-''''''
-'   TakeImage()
-'   Acquire an image. Allow to stop acquisition and displaqy progress
 '''''''
-Private Sub TakeImage()
+'  Sequential online image analysis. VBA Macro waits after acquisition of image for a change in registry code
+'''''''
+Private Sub AutofocusOiaSequential_Change()
+    AutofocusOiaParallel.Value = Not AutofocusOiaSequential.Value
+End Sub
 
-    Dim ScanImage As DsRecordingDoc
-    
-    Set ScanImage = Lsm5.StartScan
+Private Sub AcquisitionOiaSequential_Change()
+    AcquisitionOiaParallel.Value = Not AcquisitionOiaSequential.Value
+End Sub
 
-    DisplayProgress "Taking Image.......", RGB(0, &HC0, 0)
-    Do While ScanImage.IsBusy ' Waiting until the image acquisition is done
-        Sleep (100)
-        If GetInputState() <> 0 Then
-            DoEvents
-            If ScanStop Then
-                StopAcquisition
-                Exit Sub
-            End If
-        End If
-    Loop
-    DisplayProgress "Taking Image...DONE.", RGB(0, &HC0, 0)
+Private Sub Trigger1OiaSequential_Change()
+    Trigger1OiaParallel.Value = Not Trigger1OiaSequential.Value
 End Sub
 
+Private Sub Trigger2OiaSequential_Change()
+    Trigger2OiaParallel.Value = Not Trigger2OiaSequential.Value
+End Sub
 
+'''''''
+' Parallel online image analysis. VBA Macro reads before starting job in a text file with name of image file chopped of "_Txxx.lsm"
+'''''''
+Private Sub ButtonOiaParallel(JobName As String)
+    MsgBox "Parallel mode not implemented yet"
+    Me.Controls(JobName + "OiaSequential").Value = True
+    Me.Controls(JobName + "OiaParallel").Value = False
+    ' to be changed to
+    'Me.Controls(JobName + "OiaSequential").Value = Not Me.Controls(JobName + "OiaParallel").Value
+End Sub
 
-''''''
-'   RestoreAcquisitionParameters()
-'   Restores the image acquisition recording parameters from GlobalBackupRecording
-'   recenter acquisition
-'   Lsm5.DsRecording Out - Recording settings
-''''''
-Public Sub RestoreAcquisitionParameters()
-    Dim i As Integer
-    Dim pos As Double
-    Dim Time As Double
-    Dim LogMsg As String
-    Dim SuccessRecenter As Boolean
-    
-    Time = Timer
-    Lsm5.DsRecording.Copy GlobalBackupRecording
-    Lsm5.DsRecording.FrameSpacing = GlobalBackupRecording.FrameSpacing
-    Lsm5.DsRecording.FramesPerStack = GlobalBackupRecording.FramesPerStack
-    For i = 0 To Lsm5.DsRecording.TrackCount - 1
-       Lsm5.DsRecording.TrackObjectByMultiplexOrder(i, 1).Acquire = GlobalBackupActiveTracks(i)
-    Next i
-    Time = Round(Timer - Time, 2)
-    LogMsg = "% Restore settings: time to return to backuprecording " & Time
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    
-    Sleep (1000)
- 
-    Time = Timer
-    Recenter_pre posTempZ, SuccessRecenter, ZEN
-    pos = Lsm5.Hardware.CpFocus.Position
-    'move to posTempZ
-    If ZEN > 2010 Or ZEN = 2010 Then
-        If Round(pos, PrecZ) <> Round(posTempZ, PrecZ) Then
-            If Not FailSafeMoveStageZ(posTempZ) Then
-                Exit Sub
-            End If
-        End If
-        Recenter_post posTempZ, SuccessRecenter, ZEN
-    End If
-    Time = Round(Timer - Time, 2)
-    LogMsg = "% Restore settings: recenter Z " & posTempZ & ", Time required " & Time & ", success within rep. " & SuccessRecenter & vbCrLf
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    
-    ''' close LogFile
-    If Log Then
-        SafeOpenTextFile LogFileName, LogFile, FileSystem
-        If LogFile Is Nothing Then
-            Exit Sub
-        Else
-            LogFile.Close
-        End If
-    End If
+Private Sub AutofocusOiaParallel_Change()
+    ButtonOiaParallel ("Autofocus")
 End Sub
 
-Public Function SetGetLaserPower(power As Double)
-    
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim IlluminationChannel As DsIlluminationChannel
-    
-    Set Recording = Lsm5.DsRecording
-    Set Track = Recording.TrackObjectByIndex(0, Success)
-    Set IlluminationChannel = Track.IlluminationObjectByIndex(0, Success)
+Private Sub AcquisitionOiaParallel_Change()
+     ButtonOiaParallel ("Acquisition")
+End Sub
 
-    If (power > 0) Then
-        IlluminationChannel.power = power
-    End If
-    
-    power = IlluminationChannel.power
-       
-End Function
- 
+Private Sub AlterAcquisitionOiaParallel_Change()
+     ButtonOiaParallel ("AlterAcquisition")
+End Sub
 
-Public Function MeasureExposure(fractionMax As Double, fractionSat As Double)
-   
-'    Lsm5Vba.Application.ThrowEvent eRootReuse, 0                   'Was there in the initial Zeiss macro, but it seems notnecessary
- '   DoEvents
-    
-    'Dim ColMax As Integer
-    Dim iRow As Integer
-    Dim nRow As Integer
-    Dim iFrame As Integer
-    Dim gvRow As Variant  ' gv = gray value
-    Dim iCol As Long
-    Dim nCol As Long
-    Dim bitDepth As Long
-    Dim channel As Integer
-    Dim gvMax As Double
-    Dim gvMaxBitRange As Double
-    Dim nSaturatedPixels As Long
-    Dim maxGV_nSat(2) As Double
-    
-    
-    DisplayProgress "Measuring Exposure...", RGB(0, &HC0, 0)
-  
-    'ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth '/ Lsm5.DsRecordingActiveDocObject.Recording.RtBinning
-    
-    nRow = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-    'MsgBox "nRow = " + CStr(nRow)
-    
-'        ElseIf SystemName = "LSM" Then
-'            ColMax = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
-'            LineMax = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-'        Else
-'            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-''            Exit Sub
- '       End If
- '   End If
-    
-    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
-    'ReDim Intline(nLines) As Long
-    
-    iFrame = 0
-    gvMax = -1
-        
-    iRow = 0
-    channel = 0
-    bitDepth = 0 ' leaves the internal bit depth
-    gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-    'MsgBox "nCol = " + CStr(nCol)
-    'MsgBox "bytes per pixel = " + CStr(bitDepth)
-
-    ' todo: is there another function to find this out??
-    If (bitDepth = 1) Then
-        gvMaxBitRange = 255
-    ElseIf (bitDepth = 2) Then
-        gvMaxBitRange = 65536
-    End If
-    
-    nSaturatedPixels = 0
-    
-    For iRow = 0 To nRow - 1
-        gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-        For iCol = 0 To nCol - 1            'Now I'm scanning all the pixels in the line
-            
-            If (gvRow(iCol) > gvMax) Then
-                gvMax = gvRow(iCol)
-            End If
-            
-            If (gvRow(iCol) = gvMaxBitRange) Then
-                nSaturatedPixels = nSaturatedPixels + 1
-                ' TODO: measure neighbouring saturated pixels
-            End If
 
-        Next iCol
-    Next iRow
-        
-    fractionMax = gvMax / gvMaxBitRange
-    fractionSat = nSaturatedPixels / (nRow * nCol)
-        
-    'MsgBox "maximal gray value in image = " + CStr(gvMax)
-    'MsgBox "fractional brightness of maximal gray value in image = " + CStr(fractionMax)
-    'MsgBox "number of saturated pixles = " + CStr(nSaturatedPixels)
-    'MsgBox "fraction of saturated pixles = " + CStr(fractionSat)
-      
-    DisplayProgress "Measuring Exposure...DONE", RGB(0, &HC0, 0)
-  
-End Function
+Private Sub Trigger1OiaParallel_Change()
+     ButtonOiaParallel ("Trigger1")
+End Sub
+
+Private Sub Trigger2OiaParallel_Change()
+     ButtonOiaParallel ("Trigger2")
+End Sub
 
 '''
-'   ScanLineToggle_Click()
-'   Switch setting for Line Autofocus on and FrameAutofocus off
+' Load settings from ZEN into Form/Joblist
 '''
-Private Sub ScanLineToggle_Click()
-    ScanFrameToggle.Value = Not ScanLineToggle.Value 'if ScanFrame is true ScanLine is false (you can only chose one of them)
-    FrameSizeLabel.Visible = ScanLineToggle.Value   'FrameSize Label is only displayed if ScanFrame is activated
-    AutofocusFrameSize.Visible = ScanFrameToggle.Value 'FrameSize Slider is only displayed if ScanFrame is activated
-    AutofocusTrackXY.Visible = ScanFrameToggle.Value
-    AutofocusLineSize.Visible = ScanLineToggle.Value 'LineSize is only displayed if ScanFrame is activated
-    If ScanLineToggle.Value Then
-        FrameSizeLabel.Caption = "LineSize (px)"
-    End If
-    AutofocusFastZline.Enabled = ScanLineToggle And Not AutofocusHRZ
+Private Sub setJob(JobName As String)
+    Jobs.setJob JobName, Lsm5.DsRecording, ZEN
+    UpdateFormFromJob Jobs, JobName
+    AutoFindTracks
+End Sub
+
+Private Sub AutofocusSetJob_Click()
+    setJob "Autofocus"
+End Sub
+
+Private Sub AcquisitionSetJob_Click()
+    setJob "Acquisition"
+End Sub
+
+Private Sub AlterAcquisitionSetJob_Click()
+    setJob "AlterAcquisition"
 End Sub
 
+Private Sub Trigger1SetJob_Click()
+    setJob "Trigger1"
+End Sub
+
+Private Sub Trigger2SetJob_Click()
+    setJob "Trigger2"
+End Sub
+
+
 '''
-'   ScanFrameToggle_Click()
-'   Switch setting for FrameAutofocus on and LineAutofocus off
+' Load Settings from ZEN into Form for using it later
 '''
-Private Sub ScanFrameToggle_Click()
-    ScanLineToggle.Value = Not ScanFrameToggle.Value 'if ScanLine is chosen, ScanFrame will be unchecked
-    FrameSizeLabel.Visible = ScanFrameToggle.Value
-    AutofocusFrameSize.Visible = ScanFrameToggle.Value
-    AutofocusTrackXY.Visible = ScanFrameToggle.Value
-    If ScanFrameToggle.Value Then
-        FrameSizeLabel.Caption = "FrameSize (px)"
+Private Sub FcsSetJob(JobName As String)
+    Dim jobDescriptor() As String
+    AutofocusForm.Hide
+    ErrorLog.Hide
+    JobsFcs.setJob JobName, ZEN
+    jobDescriptor = JobsFcs.splittedJobDescriptor(JobName, 8)
+    AutofocusForm.Controls(JobName + "Label1").Caption = jobDescriptor(0)
+    If UBound(jobDescriptor) > 0 Then
+        AutofocusForm.Controls(JobName + "Label2").Caption = jobDescriptor(1)
     End If
-    AutofocusFastZline.Enabled = Not ScanFrameToggle.Value And Not AutofocusHRZ
+    AutofocusForm.Show
 End Sub
 
+Private Sub Fcs1SetJob_Click()
+    FcsSetJob "Fcs1"
+End Sub
 
-''''''
-'   GetCurrentPositionOffsetButton_Click()
-'       Performs Autofocus and update ZOffset according to ZShift
-''''''
-Private Sub GetCurrentPositionOffsetButton_Click()
-    If Not GetCurrentPositionOffsetButtonRun Then
-        ScanStop = True
-        StopAcquisition
-    Else
-        StopAcquisition
-    End If
+'''
+' Put Fcs settings from Fcs Job into ZEN
+'''
+Private Sub FcsPutJob(JobName As String)
+    JobsFcs.putJob JobName, ZEN
 End Sub
 
-Private Function GetCurrentPositionOffsetButtonRun() As Boolean
-    Dim X As Double
-    Dim Y As Double
-    Dim Z As Double
-    Dim DeltaZ As Double
-    Dim GridPos As GridPosType
-    Dim Time As Double
-    Dim pos As Double
-    Dim LogMsg As String
-    Dim SuccessRecenter As Boolean
-    Running = True
-    Dim NewPicture As DsRecordingDoc
-    DisplayProgress "Get Current Position Offset - Autofocus", RGB(0, &HC0, 0)             'Gives information to the user
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    Z = posTempZ
-    X = Lsm5.Hardware.CpStages.PositionX
-    Y = Lsm5.Hardware.CpStages.PositionY
+'''
+' Put Fcs settings from Fcs Job into ZEN
+'''
+Private Sub Fcs1PutJob_Click()
+    FcsPutJob "Fcs1"
+End Sub
 
-    'recenter only after activation of new track
-    If ActiveAutofocus Then
-        StopScanCheck
-        If AutofocusHRZ Then
-            Lsm5.Hardware.CpHrz.Leveling
-        End If
-       'FailSafeMoveStageZ (posTempZ) 'move at position
-        ' Acquire image and calculate center of mass stored in XMass, YMass and ZMass
-        DisplayProgress "Autofocus Activate Tracks", RGB(0, &HC0, 0)
-        Time = Timer
-        If Not AutofocusForm.ActivateTrack(GlobalAutoFocusRecording, "Autofocus") Then
-            MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-            Exit Function
-        End If
-        
-        LogMessage "% Get current position: time activate AF track " & Round(Timer - Time), Log, LogFileName, LogFile, FileSystem
-        
-        'DoEvents
-        'Sample0Z = Lsm5.DsRecording.Sample0Z
-        DisplayProgress "Autofocus: Recenter prior AF acquisition.... ", RGB(0, &HC0, 0)
-        DoEvents
-        Time = Timer
-        If Not Recenter_pre(posTempZ, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        pos = Lsm5.Hardware.CpFocus.Position
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% Get current position: center Z (pre AFimg) " & posTempZ & ", time required" & Time & ", succes within rep. " & SuccessRecenter
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        'Use internal agorithm to compute Xmass etc.
-        If Not MicroscopeIO.Autofocus_StackShift(NewPicture) Then
-                Exit Function
-        End If
-        
-        DisplayProgress "Autofocus compute", RGB(0, &HC0, 0)
-        
-        If Not ComputeNewCoordinatesAfterAF(NewPicture, X, Y, Z, DeltaZ, "Autofocus") Then
-            Exit Function
-        End If
-        AutofocusZOffset.Value = posTempZ - Z
-                    
-        DisplayProgress "Autofocus: Recenter after AF acquisition...", RGB(0, &HC0, 0)
-        
-        Time = Timer
-        If Not Recenter_post(posTempZ, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% Get current position: recenter Z (post AFImg) " & posTempZ
-        If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-                LogMsg = LogMsg & "; obtained central slide " & pos & "; position " & pos & ", time required " & Time & ", succes within rep. " & SuccessRecenter
-        Else
-            LogMsg = LogMsg & "; obtained central slide " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 _
-            - Lsm5.DsRecording.Sample0Z + pos & "; position " & pos & ", time required " & Time & ", succes within rep. " & SuccessRecenter
-        End If
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        posTempZ = Z
-        Time = Timer
-        If Not Recenter_pre(posTempZ, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% Get current position: center Z (end) " & posTempZ & ", time required" & Time & ", success" & SuccessRecenter
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
+'''
+' Put Fcs settings from Fcs Job into ZEN
+'''
+Private Sub putJob(JobName As String)
+    If ZENv > 2010 And Not ZEN Is Nothing Then
+        ZEN.gui.Acquisition.Regions.Delete.Execute
     End If
-    GetCurrentPositionOffsetButtonRun = True
-End Function
+    Jobs.putJob JobName, ZEN
+    'This is just for visualising the job in the Gui
+    If ZENv > 2010 Then
+        UpdateGuiFromJob Jobs, JobName, ZEN
+    End If
+End Sub
 
-'''''''
-'   AutofocusButton_Click()
-'   calls AutofocusButtonRun
-''''''''
-Public Sub AutofocusButton_Click()
-    Dim RecordingDoc As DsRecordingDoc
-    Dim SuccessRecenter As Boolean
-    Running = True
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    Recenter_pre posTempZ, SuccessRecenter, ZEN
-    Set GlobalAutoFocusRecording = Lsm5.CreateBackupRecording
-    Set GlobalAcquisitionRecording = Lsm5.CreateBackupRecording
-    Set GlobalMicropilotRecording = Lsm5.CreateBackupRecording
-    Set GlobalBleachRecording = Lsm5.CreateBackupRecording
-    Set GlobalAltRecording = Lsm5.CreateBackupRecording
-    Set GlobalBackupRecording = Lsm5.CreateBackupRecording
-    GlobalAutoFocusRecording.Copy Lsm5.DsRecording
-    GlobalAcquisitionRecording.Copy Lsm5.DsRecording
-    GlobalMicropilotRecording.Copy Lsm5.DsRecording
-    GlobalBleachRecording.Copy Lsm5.DsRecording
-    GlobalAltRecording.Copy Lsm5.DsRecording
-    GlobalBackupRecording.Copy Lsm5.DsRecording ' this will not be changed remains always the same
-    GlobalBackupSampleObservationTime = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime
-    Dim i As Long
-    Dim NrTracks As Long
-    ReDim GlobalBackupActiveTracks(Lsm5.DsRecording.TrackCount)
-    For i = 0 To Lsm5.DsRecording.TrackCount - 1
-       GlobalBackupActiveTracks(i) = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i, 1).Acquire
-    Next i
-    AutofocusButtonRun RecordingDoc, GlobalDataBaseName
-    StopAcquisition
+Private Sub AutofocusPutJob_Click()
+    putJob "Autofocus"
 End Sub
 
-'''''''
-'   AutofocusButtonRun (Optional AutofocusDoc As DsRecordingDoc = Nothing) As Boolean
-'   Runs a Z-stacks, compute center of mass, if selected acquire an image at computed position + ZOffset
-'   If AutofocusTrackZ : position is updated to computed position from autofocus (without ZOffset!)
-'   If AutofocusTrackXY and FrameToggle: position of X and Y are changed
-'   Function uses a posTempZ to remember starting position
-'       [AutofocusDoc] - A recording Doc. If = Nothing then it will create a new recording
-'
-'   Additional comments: The function works best with piezo. With Fast-Zline (Onthefly) acquisition is less precise
-'                        Lots of test to check that focus returned to workingposition. Lsm5.Hardware.CpFocus.Position
-'                        does not give actual position when stage is moving after acquisition.
-'                        Lsm5.DsRecording.Sample0Z provides the actual shift to the central slice
-''''''''
-Private Function AutofocusButtonRun(Optional AutofocusDoc As DsRecordingDoc = Nothing, Optional FilePath As String = "") As Boolean
-    Running = True
-    Dim Time As Double
-    Dim X As Double
-    Dim Y As Double
-    Dim Z As Double
-    Dim DeltaZ As Double
-    Dim GridPos As GridPosType
-    Dim Sample0Z As Double ' test variable
-    Dim pos As Double ' test variable for position
-    Dim LogMsg  As String
-    Dim SuccessRecenter As Boolean
-    DisplayProgress "Autofocus move initial position", RGB(0, &HC0, 0)
-    
-    StopScanCheck
-    ' Recenter and move where it should be
+Private Sub AcquisitionPutJob_Click()
+    putJob "Acquisition"
+End Sub
 
+Private Sub AlterAcquisitionPutJob_Click()
+   putJob "AlterAcquisition"
+End Sub
 
-    Z = posTempZ
-    X = Lsm5.Hardware.CpStages.PositionX
-    Y = Lsm5.Hardware.CpStages.PositionY
+Private Sub Trigger1PutJob_Click()
+    putJob "Trigger1"
+End Sub
 
-    'recenter only after activation of new track
-    If ActiveAutofocus Then
-    
-        If AutofocusAlgorithm.Value = "external" Then
-            SaveSetting "OnlineImageAnalysis", "macro", "codeIn", "wait"     'this causes to wait as defaults
-            If FilePath = "" Then
-                MsgBox "Define an Outputfolder to save AF image for external image analysis!"
-                Exit Function
-            End If
-            If Not SaveAFImage Then
-                MsgBox "Tick Save AFImage to use external image analysis for focus!"
-                Exit Function
-            End If
-        End If
-        
-        If AutofocusHRZ Then
-            Lsm5.Hardware.CpHrz.Leveling
-        End If
-        
-        ' Acquire image and calculate center of mass stored in XMass, YMass and ZMass
-        DisplayProgress "Autofocus Activate Tracks", RGB(0, &HC0, 0)
-        Time = Timer
-        If Not AutofocusForm.ActivateTrack(GlobalAutoFocusRecording, "Autofocus") Then
-            MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-            Exit Function
-        End If
-        
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% AutofocusButton: time activate AF tracks " & Time
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        '''''center
-        DisplayProgress "Autofocus: Recenter prior AF acquisition.... ", RGB(0, &HC0, 0)
-        DoEvents
-        Sleep (200)
-        Time = Timer
-        If Not Recenter_pre(posTempZ, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% AutofocusButton: center Z (pre AFImg) " & posTempZ
-        pos = Lsm5.Hardware.CpFocus.Position
-        If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-            LogMsg = LogMsg & ", Obtained Z " & pos & "; actual position " & pos & ", time required " & Time & ", succes within rep. " & SuccessRecenter
-        Else
-            LogMsg = LogMsg & ", Obtained Z " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos _
-            & "; actual position " & pos & ", time required " & Time & ", succes within rep. " & SuccessRecenter
-        End If
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        '''''''acquire
-        DisplayProgress "Autofocus: Acquire AFimg.... ", RGB(0, &HC0, 0)
-        Time = Timer
-        'Just acquire image and save
-        If Not MicroscopeIO.Autofocus_StackShift(AutofocusDoc) Then
-            Exit Function
-        End If
-        
-        DisplayProgress "Autofocus compute", RGB(0, &HC0, 0)
-        
-        If SaveAFImage Then
-            If Not SaveDsRecordingDoc(AutofocusDoc, FilePath & "\" & "AFImg.lsm") Then
-                Exit Function
-            End If
-        End If
-        
-        If Not ComputeNewCoordinatesAfterAF(AutofocusDoc, X, Y, Z, DeltaZ, "AutoFocus", AutofocusAlgorithm.Value) Then
-            Exit Function
-        End If
-        LogMsg = "% AutofocusButton: computed position XYZ " & X & " " & Y & " " & Z
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        ''''''recenter
-        DisplayProgress "Autofocus: Recenter after AF acquisition...", RGB(0, &HC0, 0)
-        Time = Timer
-        If Not Recenter_post(posTempZ, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        
-        pos = Lsm5.Hardware.CpFocus.Position
-        LogMsg = "% AutofocusButton: wait return to center Z (post AFImg) " & posTempZ
-        Time = Round(Timer - Time, 2)
-        If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-            LogMsg = LogMsg & ", Obtained Z " & pos & "; actual position " & pos & ", Time required " & Time & ", success within rep. " & SuccessRecenter
-        Else
-            LogMsg = LogMsg & ", Obtained Z " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos _
-            & "; actual position " & pos & ", Time required " & Time & ", success within rep. " & SuccessRecenter
-        End If
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        'move X and Y if tracking is on
-        If ScanFrameToggle And AutofocusTrackXY Then
-            If Not FailSafeMoveStageXY(X, Y) Then
-                Exit Function
-            End If
-        End If
-        
-        If AutofocusHRZ Then
-            Lsm5.Hardware.CpHrz.Position = 0
-        End If
-    End If
+Private Sub Trigger2PutJob_Click()
+    putJob "Trigger2"
+End Sub
 
-    ''''Acquisition
-    If ActivateTrack(GlobalAcquisitionRecording, "Acquisition", DeltaZ) Then
-        Dim Offset As Double
-        If ActiveAutofocus Then
-            Offset = AutofocusZOffset
-        Else
-            Offset = 0
-        End If
 
-        DisplayProgress "Autofocus: Center AQimg at ZOffset position...", RGB(0, &HC0, 0)
-        '''''''center
-        Time = Timer
-        If Not Recenter_pre(Z + Offset, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% AutofocusButton: center Z + Offset (pre AQimg) " & Z + Offset & ", time required " & Time & ", succes within rep. " & SuccessRecenter
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        ''''''''''Acquire
-        DisplayProgress "Autofocus: Center AQimg at ZOffset position...", RGB(0, &HC0, 0)
-        Time = Timer
-        If Not ScanToImage(AutofocusDoc) Then
-            Exit Function
-        End If
-        
-        Time = Timer - Time
-        LogMsg = "% AutofocusButton: Time acquire AQImg " & Round(Time, 2)
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        ''''''''''recenter
-        DisplayProgress "Autofocus: Recenter after AQimg ...", RGB(0, &HC0, 0)
-        Time = Timer
-        If Not Recenter_post(Z + Offset, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        Time = Round(Timer - Time, 2)
-        pos = Lsm5.Hardware.CpFocus.Position
-        LogMsg = "% AutofocusButton: wait return to center Z + Offset (post AQImg) " & Z + Offset
-        If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-            LogMsg = LogMsg & ", Obtained Z " & pos & "; actual position " & pos & ", time required " & Time & ", succes within rep. " & SuccessRecenter
-        Else
-            LogMsg = LogMsg & ", Obtained Z " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos _
-            & "; actual position " & pos & ", time required " & Time & ", succes within rep. " & SuccessRecenter
-        End If
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    End If
 
-    If AutofocusHRZ Then
-        Lsm5.Hardware.CpHrz.Position = 0
+'''Acquire one image for a job
+Private Sub JobAcquire(JobName As String)
+    If Not GlobalRecordingDoc Is Nothing Then
+        GlobalRecordingDoc.BringToTop
     End If
-
-    '''Update position to the position without offset and move there
-    If AutofocusTrackZ Then
-        'wait that slice recentered after acquisition
-        DisplayProgress "Autofocus: move to new Z...", RGB(0, &HC0, 0)
-        posTempZ = Z
-    Else
-        DisplayProgress "Autofocus: return to initial Z...", RGB(0, &HC0, 0)
+    If ZENv > 2010 And Not ZEN Is Nothing Then
+        ZEN.gui.Acquisition.Regions.Delete.Execute
     End If
+    Dim position As Vector
+    position.X = Lsm5.Hardware.CpStages.PositionX
+    position.Y = Lsm5.Hardware.CpStages.PositionY
+    position.Z = Lsm5.Hardware.CpFocus.position
+    Running = True
+    'for imaging the position to image can be passed directly to AcquireJob. ZEN uses the absolute position in um
+    NewRecordGui GlobalRecordingDoc, JobName & "Job", ZEN, ZENv
+    DisplayProgress "Acquiring Job " & JobName, RGB(&HC0, &HC0, 0)
+    Jobs.putJob JobName, ZEN
     
-    Time = Timer
-    Recenter_pre posTempZ, SuccessRecenter, ZEN
-    pos = Lsm5.Hardware.CpFocus.Position
-    ' move stage to posTempZ
-    If ZEN > 2010 Or ZEN = 2010 Then
-        If Round(pos, PrecZ) <> Round(posTempZ, PrecZ) Then
-            If Not FailSafeMoveStageZ(posTempZ) Then
-                Exit Function
-            End If
-        End If
-        Recenter_post posTempZ, SuccessRecenter, ZEN
+    If Not AcquireJob(JobName, GlobalRecordingDoc, JobName & "Job", position) Then
+        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
+        StopAcquisition
     End If
-    Time = Round(Timer - Time, 2)
-    pos = Lsm5.Hardware.CpFocus.Position
-    LogMsg = "% AutofocusButton: wait return to center Z (end) " & posTempZ
-    If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-        LogMsg = LogMsg & ", Obtained Z " & pos & "; actual position " & pos & ", time required " & Time & ", succes within rep. " & SuccessRecenter
-    Else
-        LogMsg = LogMsg & ", Obtained Z " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos _
-        & "; actual position " & pos & ", Time required " & Time & ", succes within rep. " & SuccessRecenter
+    
+    'this is just for visualizing the zoom value in the gui
+    If ZENv > 2010 Then
+       ZEN.gui.Acquisition.AcquisitionMode.ScanArea.Zoom.Value = Jobs.GetRecording(JobName).ZoomX
+       ZEN.SetListEntrySelected "Scan.Mode.DirectionX", Jobs.GetRecording(JobName).ScanDirection
+       'ZEN.gui.Document.Reuse.Execute this will delete all extra tracks
     End If
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    AutofocusButtonRun = True
+    RestoreAcquisitionParameters
+End Sub
 
-End Function
 
+Private Sub AutofocusAcquire_Click()
+    JobAcquire "Autofocus"
+End Sub
 
-Private Sub StartBleachButton_Click()
-    
-    Dim Success As Integer
-    Dim nt As Integer
-    
-    BleachingActivated = True
-    AutomaticBleaching = False
-    
-    If TrackingToggle And TrackingChannelString = "" Then
-        MsgBox ("Select a channel for tracking, or uncheck the tracking button")
-        Exit Sub
-    End If
-    If MultipleLocationToggle.Value And Lsm5.Hardware.CpStages.MarkCount < 1 Then
-        MsgBox ("Select at least one location in the stage control window, or uncheck the multiple location button")
-        Exit Sub
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No Output Folder selected ! Cannot start acquisition.")
-        Exit Sub
-    End If
-    
-    
-    Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
-    
-    If Success Then
-        If Track.BleachPositionZ <> 0 Then
-            MsgBox ("This macro does not enable to bleach at a different Z position. Please uncheck the corresponding box in the Bleach Control Window")
-            Exit Sub
-        End If
-        
-        If Lsm5.IsValidBleachRoi Then
-            
-            If ActiveMicropilot Then
-                nt = MicropilotRepetitions
-            Else
-                nt = BlockRepetitions
-            End If
-                    
-            If (Track.BleachScanNumber + 1) > nt Then
-                MsgBox ("Not enough repetitions to bleach; either increase the Number of Acquisitions, or, when using MicroPilot, the Cycles")
-                Exit Sub
-            End If
-            
-            FillBleachTable
-            AutomaticBleaching = True
-           'Track.UseBleachParameters = True ' deleted 20100818 , can probably not work with Micropilot
-        Else
-            MsgBox ("A bleaching ROI needs to be defined to start the macro in the bleaching mode")
-            Exit Sub
-        End If
-    Else
-        MsgBox ("A bleach track needs to be defined to start the macro in the bleaching mode")
-        Exit Sub
-    End If
-        
-    StartAcquisition BleachingActivated
+Private Sub AcquisitionAcquire_Click()
+    JobAcquire "Acquisition"
+End Sub
 
+Private Sub AlterAcquisitionAcquire_Click()
+    JobAcquire "AlterAcquisition"
 End Sub
 
-Private Sub FillBleachTable()  'Fills a table for the macro to know when the bleaches have to occur. This works for FRAPs (and FLIPS if working with LSM 3.2)
-    
-    Dim i As Integer
-    Dim nt As Integer
-    Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
-    If Success Then
-        
-        If ActiveMicropilot Then
-            nt = MicropilotRepetitions.Value
-        Else
-            nt = BlockRepetitions
-        End If
-            
-        ReDim BleachTable(nt)               'The bleach table contains as many timepoints as blockrepetitions
-        
-        'When working with the Lsm 2.8, remove all this test, except the one indicated line
-        If Track.EnableBleachRepeat Then
-            For i = Track.BleachScanNumber + 1 To nt Step Track.BleachRepeat
-                BleachTable(i) = True
-            Next
-        Else
-        '    BleachTable(Track.BleachScanNumber + 1) = True  'This is the only line to be kept when working with the Lsm 2.8
-        End If
-        
-    End If
+Private Sub Trigger1Acquire_Click()
+    JobAcquire "Trigger1"
 End Sub
 
+Private Sub Trigger2Acquire_Click()
+    JobAcquire "Trigger2"
+End Sub
 
-'''''
-'   StartButton_Click()
-'''''
-Private Sub StartButton_Click()
-
-    If Not StartSetting() Then
-        ScanStop = True
+Private Sub JobFcsAcquire(JobName As String)
+    Dim newPosition() As Vector
+    ReDim newPosition(0) ' position where FCS will be done
+    Dim currentPosition As Vector
+   
+    'for Fcs the position for ZEN are passed in meter!! (different to Lsm5.Hardware.CpStages is in um!!)
+    ' For X and Y relative position to center. For Z absolute position in meter
+    newPosition(0).X = 0
+    newPosition(0).Y = 0
+    newPosition(0).Z = Lsm5.Hardware.CpFocus.position * 0.000001 'convet from um to meter
+    'eventually force creation of FcsRecord
+    NewFcsRecordGui GlobalFcsRecordingDoc, GlobalFcsData, JobName & "Job", ZEN, ZENv
+    'this brings record to top
+    If Not GlobalFcsRecordingDoc Is Nothing Then
+        GlobalFcsRecordingDoc.BringToTop
+    End If
+    Running = True
+    DisplayProgress "Acquiring Job " & JobName, RGB(&HC0, &HC0, 0)
+    JobsFcs.putJob JobName, ZEN
+    If Not AcquireFcsJob(JobName, GlobalFcsRecordingDoc, GlobalFcsData, JobName & "Job", newPosition) Then
+        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
         StopAcquisition
-        Exit Sub
     End If
-    
-    'Set counters back to 1
-    RepetitionNumber = 1 ' first time point
-    
-    StartAcquisition BleachingActivated 'This is the main function of the macro
+    RestoreAcquisitionParameters
+    'DisplayProgress "Ready ", RGB(0, &HC0, 0)
 End Sub
 
 
-Private Sub ContinueFromCurrentLocation_Click()
-    If Not StartSetting Then
-        ScanStop = True
-        StopAcquisition
-        Exit Sub
+
+Private Sub Fcs1Acquire_Click()
+    JobFcsAcquire "Fcs1"
+End Sub
+'''''
+' Looping/RepetitionSettings
+'''''
+Private Sub RepetitionTime(Name As String)
+    If Me.Controls(Name + "RepetitionSec").Value Then
+        Reps.setRepetitionTime Name, CDbl(Me.Controls(Name + "RepetitionTime").Value)
+    ElseIf Me.Controls(Name + "RepetitionMin").Value Then
+        Reps.setRepetitionTime Name, CDbl(Me.Controls(Name + "RepetitionTime").Value * 60)
     End If
-    StartAcquisition BleachingActivated 'This is the main function of the macro
 End Sub
 
+Private Sub RepetitionMin(Name As String)
+    'if previously it was in sec divide by 60
+    Me.Controls(Name + "RepetitionTime").Value = CDbl(Me.Controls(Name + "RepetitionTime").Value / 60)
+    Me.Controls(Name + "RepetitionMin").BackColor = &HFF8080
+    Me.Controls(Name + "RepetitionSec").BackColor = &H8000000F
+    Me.Controls(Name + "RepetitionTime").Max = 60
+    RepetitionTime (Name)
+End Sub
 
-''''''
-'   StartSetting()
-'   Setups and controls before start of experiment
-'       Create list of positions for Grid or Multiposition
-''''''
-Private Function StartSetting() As Boolean
-    Dim i As Integer
-    Dim initPos As Boolean   'if False and gridsize correspond positions are taken from file positionsGrid.csv
-    Dim initValid As Boolean 'if False and gridsize correspond positions are taken from file validGrid.csv
-    Dim SuccessRecenter As Boolean
-    
-    initPos = True
-    initValid = True
-    StartSetting = False
-    BleachingActivated = False
-    AutomaticBleaching = False                                  'We do not do FRAps or FLIPS in this case. Bleaches can still be done with the "ExtraBleach" button.
-    Set FileSystem = New FileSystemObject
-    ' Do some checking
-    If TrackingToggle And TrackingChannelString = "" Then
-        MsgBox ("Select a channel for tracking, or uncheck the tracking button")
-        Exit Function
-    End If
-    If MultipleLocationToggle.Value And Lsm5.Hardware.CpStages.MarkCount < 1 Then
-        MsgBox ("Select at least one location in the stage control window, or uncheck the multiple location button")
-        Exit Function
-    End If
-    'This loads value of Databasename
-    SetDatabase
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No outputfolder selected ! Cannot start acquisition.")
-        Exit Function
+
+Private Sub RepetitionSec(Name As String)
+    Me.Controls(Name + "RepetitionTime").Max = 360
+    Debug.Print CDbl(Me.Controls(Name + "RepetitionTime").Value)
+    Me.Controls(Name + "RepetitionTime").Value = CDbl(Me.Controls(Name + "RepetitionTime").Value) * 60
+    Me.Controls(Name + "RepetitionSec").BackColor = &HFF8080
+    Me.Controls(Name + "RepetitionMin").BackColor = &H8000000F
+    RepetitionTime (Name)
+End Sub
+
+Private Sub RepetitionMinChange(Name As String)
+    If Me.Controls(Name + "RepetitionMin").Value Then
+        RepetitionMin Name
     Else
-        If Not CheckDir(GlobalDataBaseName) Then
-            Exit Function
-        End If
-        LogFileNameBase = GlobalDataBaseName & "\AutofocusScreen.log"
-        If LogCode And LogFileNameBase <> "" Then
-            On Error GoTo ErrorHandleLogFile
-            LogFileName = LogFileNameBase
-            Close
-            SafeOpenTextFile LogFileName, LogFile, FileSystem
-            LogFile.WriteLine "% ZEN software version " & ZEN & " " & Version
-            LogFile.Close
-            Log = True
-        Else
-            Log = False
-        End If
+        RepetitionSec Name
     End If
+    Me.Controls(Name + "RepetitionSec").Value = Not Me.Controls(Name + "RepetitionMin").Value
+End Sub
 
-    If Not AcquisitionTracksOn And Not ActiveAutofocus And Not ActiveAlterImage Then
-        MsgBox ("Nothing to do! Check at least one imaging option!")
-        Exit Function
-    End If
-    If Not AcquisitionTracksOn Then
-        If MsgBox("Acquisition Track has not been clicked!! Do you want to continue", VbYesNo) = vbNo Then
-            Exit Function
-        End If
-    End If
-    
-    ' do not log if logfilename has not been defined
-    If LogCode And LogFileName = "" Then
-        Log = False
-    End If
-    'As default we do not overwrite files
-    OverwriteFiles = False
-    
-    '''''''''''''''''''''''
-    '***Set up GridScan***'
-    '''''''''''''''''''''''
-    If ActiveGridScan Then
-        'Load starting position from stage
-        Dim MarkCount As Long
-        MarkCount = Lsm5.Hardware.CpStages.MarkCount
-        If MarkCount = 0 Then  ' No marked position
-            MsgBox "GridScan: Use stage to Mark the initial position "
-            ScanStop = True
-            StopAcquisition
-            Exit Function
-        End If
-        If GridScan_nColumn.Value * GridScan_nRow.Value * GridScan_nColumnsub.Value * GridScan_nRowsub.Value > 10000 Then
-            MsgBox "GridScan: Maximal number of locations is 10000. Please change Numbers  X and/or Y."
-            ScanStop = True
-            StopAcquisition
-            Exit Function
-        End If
-        
-        If CheckPosFile(GlobalDataBaseName & "\positionsGrid.csv", GridScan_nRow.Value, GridScan_nColumn.Value, _
-            GridScan_nRowsub.Value, GridScan_nColumnsub.Value) Then
-            If MsgBox("Position file " & "positionsGrid.csv exists. Do you want to reset positions?", VbYesNo) = vbNo Then
-                 If LoadPosFile(GlobalDataBaseName & "\positionsGrid.csv", posGridX, posGridY, posGridZ) Then
-                    initPos = False
-                    FocusMapPresent = True
-                 End If
-            End If
-        End If
-        
-        If initPos Then
-            DisplayProgress "Initialize all grid positions. First Gridpoint is first Marked point on stage....", RGB(0, &HC0, 0)
-            'MsgBox " GridScan: Uses as initial position the first Marked point on stage "
-            'Store starting position for later restart. This is the first marked point
-            Lsm5.Hardware.CpStages.MarkGetZ 0, XStart, YStart, ZStart
-            Sleep (1000)
-            ReDim posGridX(1 To GridScan_nRow.Value, 1 To GridScan_nColumn.Value, 1 To GridScan_nRowsub.Value, 1 To GridScan_nColumnsub.Value)
-            ReDim posGridY(1 To GridScan_nRow.Value, 1 To GridScan_nColumn.Value, 1 To GridScan_nRowsub.Value, 1 To GridScan_nColumnsub.Value)
-            ReDim posGridZ(1 To GridScan_nRow.Value, 1 To GridScan_nColumn.Value, 1 To GridScan_nRowsub.Value, 1 To GridScan_nColumnsub.Value)
-            MakeGrid posGridX, posGridY, posGridZ, XStart, YStart, ZStart, GridScan_dColumn.Value, GridScan_dRow.Value, _
-            GridScan_dColumnsub.Value, GridScan_dRowsub.Value, GridScan_refColumn.Value, GridScan_refRow.Value
-            DisplayProgress "Initialize all grid positions...DONE", RGB(0, &HC0, 0)
-            WritePosFile GlobalDataBaseName & "\positionsGrid.csv", posGridX, posGridY, posGridZ
-            FocusMapPresent = False
-        End If
-        
-        If CheckPosFile(GlobalDataBaseName & "\validGrid.csv", GridScan_nRow.Value, GridScan_nColumn.Value, _
-            GridScan_nRowsub.Value, GridScan_nColumnsub.Value) Then
-            If MsgBox("Valid file " & "validGrid.csv exists. Do you want to reset valid positions?", VbYesNo) = vbNo Then
-                 If LoadValidFile(GlobalDataBaseName & "\validGrid.csv", posGridXY_Valid) Then
-                    initValid = False
-                 End If
-            End If
-        End If
-        
-        If initValid Then
-            ReDim posGridXY_Valid(1 To GridScan_nRow.Value, 1 To GridScan_nColumn.Value, 1 To GridScan_nRowsub.Value, 1 To GridScan_nColumnsub.Value) ' A position may be active or not
-            WriteValidFile GlobalDataBaseName & "\validGrid.csv", posGridXY_Valid
-
-            If GridScan_validGridDefault Then
-                If isValidGridDefault(GlobalDataBaseName & "\validGridDefault.txt") Then
-                    MakeValidGrid posGridXY_Valid, GlobalDataBaseName & "\validGridDefault.txt"
-                Else
-                    Exit Function
-                End If
-            Else
-               MakeValidGrid posGridXY_Valid
-            End If
-            WriteValidFile GlobalDataBaseName & "\validGrid.csv", posGridXY_Valid
-        End If
-    End If
-    '''''''''''''''''''''''''''
-    '***End Set up GridScan***'
-    '''''''''''''''''''''''''''
-    
-    ''''''''''''''''''''''''''''''''
-    '***Set up MultiLocationScan***'
-    ''''''''''''''''''''''''''''''''
-    If MultipleLocationToggle Then
-    
-        If FileExist(GlobalDataBaseName & "\" & "PositionsMultiLoc.txt") Then
-            MsgBox ("File Exist")
-        End If
-        
-        If Lsm5.Hardware.CpStages.MarkCount > 0 Then
-            ReDim posGridX(1 To 1, 1 To Lsm5.Hardware.CpStages.MarkCount, 1 To 1, 1 To 1)
-            ReDim posGridY(1 To 1, 1 To Lsm5.Hardware.CpStages.MarkCount, 1 To 1, 1 To 1)
-            ReDim posGridZ(1 To 1, 1 To Lsm5.Hardware.CpStages.MarkCount, 1 To 1, 1 To 1)
-            ReDim posGridXY_Valid(1 To 1, 1 To Lsm5.Hardware.CpStages.MarkCount, 1 To 1, 1 To 1) ' A well may be active or not
-            For i = 1 To Lsm5.Hardware.CpStages.MarkCount
-                Lsm5.Hardware.CpStages.MarkGetZ i - 1, posGridX(1, i, 1, 1), posGridY(1, i, 1, 1), _
-                posGridZ(1, i, 1, 1)
-                posGridXY_Valid(1, i, 1, 1) = True
-            Next i
-        End If
-    End If
-    
-  
-    If SingleLocationToggle And Not ActiveGridScan Then
-            ReDim posGridX(1 To 1, 1 To 1, 1 To 1, 1 To 1)
-            ReDim posGridY(1 To 1, 1 To 1, 1 To 1, 1 To 1)
-            ReDim posGridZ(1 To 1, 1 To 1, 1 To 1, 1 To 1)
-            ReDim posGridXY_Valid(1 To 1, 1 To 1, 1 To 1, 1 To 1) 'A well may be active or not
-            Lsm5.Hardware.CpStages.GetXYPosition posGridX(1, 1, 1, 1), posGridY(1, 1, 1, 1)
-            posGridZ(1, 1, 1, 1) = Lsm5.Hardware.CpFocus.Position
-            posGridXY_Valid(1, 1, 1, 1) = 1
-    End If
-    
-    ''''
-    'load acquisition settings again
-    '''''
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    Recenter (posTempZ)
-    
-    Set GlobalAutoFocusRecording = Lsm5.CreateBackupRecording
-    Set GlobalAcquisitionRecording = Lsm5.CreateBackupRecording
-    Set GlobalMicropilotRecording = Lsm5.CreateBackupRecording
-    Set GlobalBleachRecording = Lsm5.CreateBackupRecording
-    Set GlobalAltRecording = Lsm5.CreateBackupRecording
-    Set GlobalBackupRecording = Lsm5.CreateBackupRecording
-    GlobalAutoFocusRecording.Copy Lsm5.DsRecording
-    GlobalAcquisitionRecording.Copy Lsm5.DsRecording
-    GlobalMicropilotRecording.Copy Lsm5.DsRecording
-    GlobalBleachRecording.Copy Lsm5.DsRecording
-    GlobalAltRecording.Copy Lsm5.DsRecording
-    GlobalBackupRecording.Copy Lsm5.DsRecording ' this will not be changed remains always the same
-    GlobalBackupSampleObservationTime = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime
-    Dim NrTracks As Long
-    ReDim GlobalBackupActiveTracks(Lsm5.DsRecording.TrackCount)
-    For i = 0 To Lsm5.DsRecording.TrackCount - 1
-       GlobalBackupActiveTracks(i) = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i, 1).Acquire
-    Next i
-    If Not Recenter_post(posTempZ, SuccessRecenter, ZEN) Then
-        Exit Function
-    End If
-    
-    'SaveSettings
-    If GlobalDataBaseName <> "" Then
-        SetDatabase
-        SaveSettings GlobalDataBaseName & "\AutofocusScreen.ini"
-    End If
-    StartSetting = True
-    Exit Function
-ErrorHandleDataBase:
-    MsgBox "Could not create directory " & GlobalDataBaseName
-    Exit Function
-ErrorHandleLogFile:
-    MsgBox "Could not create LogFile " & LogFileName
-    Exit Function
-End Function
+Private Sub RepetitionSecChange(Name As String)
+    Me.Controls(Name + "RepetitionMin").Value = Not Me.Controls(Name + "RepetitionSec").Value
+End Sub
 
 
+Public Sub GlobalRepetitionMin_Change()
+    RepetitionMinChange ("Global")
+End Sub
 
-''''''
-'   StartAcquisition(BleachingActivated)
-'   Perform many things (TODO: write more). Pretty much the whole macro runs through here
-''''''
-Private Sub StartAcquisition(BleachingActivated As Boolean)
-    
-    'measure time required
-    Dim rettime, DiffTime As Double
-    Dim GlobalPrvTime As Double
-    Dim StartTime As Double
-    
-    'Counters
-    Dim GridPos As GridPosType
-    Dim RowMax As Long
-    Dim ColMax  As Long
-    Dim RowSubMax As Long
-    Dim ColSubMax As Long
-    Dim StartCol As Long
-    Dim StartColSub As Long
-    Dim EndCol As Long
-    Dim EndColSub As Long
-    Dim StepCol As Integer    'forward or backward step
-    Dim StepColSub As Integer 'forward or backward step
-    Dim Cnt As Integer        'a local counter
-    Dim TotPos As Long        'total number of positions
-    
-    Dim SuccessRecenter As Boolean
-    'coordinates
-    Dim previousZ As Double   'remember position of previous position in Z
-    
-    HighResExperimentCounter = 1
-    HighResCounter = 0
-    
-    ' ActiveMicropilot  refers to the MicroPilot
-    Erase HighResArrayX()
-    Erase HighResArrayY()
-    Erase HighResArrayZ()
-    SaveSetting "OnlineImageAnalysis", "macro", "codeIn", ""     'this causes to do anything as defaults
-    SaveSetting "OnlineImageAnalysis", "macro", "codeOut", ""     'this causes to do anything as defaults
-    SaveSetting "OnlineImageAnalysis", "macro", "offsetx", ""
-    SaveSetting "OnlineImageAnalysis", "macro", "offsety", ""
-    SaveSetting "OnlineImageAnalysis", "macro", "offsetz", ""
-    SaveSetting "OnlineImageAnalysis", "macro", "deltaZ", ""
-'    SaveSetting "OnlineImageAnalysis", "macro", "roiType", ""
-'    SaveSetting "OnlineImageAnalysis", "macro", "roiAim", ""
-'    SaveSetting "OnlineImageAnalysis", "macro", "roiX", ""
-'    SaveSetting "OnlineImageAnalysis", "macro", "roiY", ""
-    
 
-    'Coordinates
-    Dim X As Double              ' x value where to move the stage (this is used as reference)
-    Dim Y As Double              ' y value where to move the stage
-    Dim Z As Double              ' z value where to move the stage
-    Dim Xold As Double
-    Dim Yold As Double
-    Dim Zold As Double
-    
-    'test variables
-    Dim Success As Integer       ' Check if something was sucessfull
-    Dim SuccessAF As Boolean     ' Check if AF was succesful
-    Dim LocationSoFarBest As Integer
-    Dim soFarBestGoodCellsPerImage As Integer
-    
-    'Recording stuff
-    Dim FileNameID As String ' ID name of file (Well/Position, Subpositio, Timepoint)
-    Dim FilePath As String   ' full path of file to save (changes through function)
-    Dim RecordingDoc As DsRecordingDoc  ' contains the images
-    Dim FcsData As AimFcsData           ' contains the data of the FCS measurement
-    Dim Scancontroller As AimScanController ' the controller
-  
-        'do once leveling
-    If AutofocusHRZ Then
-        Lsm5.Hardware.CpHrz.Leveling ' not sure if this is needed
-        Sleep (1000)
-    End If
-    
-    
-    ' Set the offset in z-stack to 0; otherwise there can be errors...
-    Recenter (Lsm5.Hardware.CpFocus.Position)
-    ' set up the imaging
-    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-    NewRecord RecordingDoc, "W001_P001_T001", 0
-'    Set RecordingDoc = Lsm5.DsRecordingActiveDocObject
-'    ' set up RecordingDoc
-'    If RecordingDoc Is Nothing Then
-'        Set RecordingDoc = Lsm5.NewScanWindow
-'        While RecordingDoc.IsBusy
-'            Sleep (20)
-'            DoEvents
-'        Wend
-'    End If
+Private Sub Trigger1RepetitionMin_Change()
+    RepetitionMinChange ("Trigger1")
+End Sub
 
-    InitializeStageProperties
-    SetStageSpeed 9, True
+Private Sub Trigger2RepetitionMin_Change()
+    RepetitionMinChange ("Trigger2")
+End Sub
 
-    Running = True  'Now we're starting. This will be set to false if the stop button is pressed or if we reached the total number of repetitions.
-    ChangeButtonStatus False ' disable buttons
-    TotPos = 1
-    previousZ = posGridZ(1, 1, 1, 1)
-    Do While Running   'As long as the macro is running we're in this loop. At everystop one will save actual location, and repetition
-                
-        RowMax = UBound(posGridX, 1)
-        ColMax = UBound(posGridX, 2)
-        
-        RowSubMax = UBound(posGridX, 3)
-        ColSubMax = UBound(posGridX, 4)
-        
-        GlobalPrvTime = CDbl(GetTickCount) * 0.001
-        For GridPos.Row = 1 To RowMax
-            'Meander
-            If GridPos.Row Mod 2 = 0 Then
-                StartCol = ColMax
-                EndCol = 1
-                StepCol = -1
-            Else
-                StartCol = 1
-                EndCol = ColMax
-                StepCol = 1
-            End If
-            GridPos.Col = StartCol
-            For GridPos.Col = StartCol To EndCol Step StepCol
-                ' Move in the subGrid
-                For GridPos.RowSub = 1 To RowSubMax
-                    'Meander in the subgrid
-                    If GridPos.RowSub Mod 2 = 0 Then
-                        StartColSub = ColSubMax
-                        EndColSub = 1
-                        StepColSub = -1
-                    Else
-                        StartColSub = 1
-                        EndColSub = ColSubMax
-                        StepColSub = 1
-                    End If
-                    GridPos.ColSub = StartColSub
-                    For GridPos.ColSub = StartColSub To EndColSub Step StepColSub
-                        ' Here comes the check for good or bad location ...
-                        If posGridXY_Valid(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub) Then
-                            'define actual positions and move there
-                            X = posGridX(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub)
-                            Y = posGridY(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub)
-                            Z = posGridZ(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub)
-                            'In gridscan mode use initially Z of previous position to find new position
-                            If RepetitionNumber = 1 And ActiveGridScan And Not FocusMapPresent Then
-                                Z = previousZ
-                            Else
-                                Z = posGridZ(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub)
-                            End If
-                            'move in X and Y
-                            Xold = Lsm5.Hardware.CpStages.PositionX
-                            Yold = Lsm5.Hardware.CpStages.PositionY
-                            If Round(Xold, PrecXY) <> Round(X, PrecXY) Or Round(Yold, PrecXY) <> Round(Y, PrecXY) Then
-                                If Not FailSafeMoveStageXY(X, Y) Then
-                                    StopAcquisition
-                                    Exit Sub
-                                End If
-                            End If
-                            
-                            Recenter_pre Z, SuccessRecenter, ZEN
-                            If Round(Lsm5.Hardware.CpFocus.Position, PrecZ) <> Round(Z, PrecZ) Then 'Need to move now! May cause problems!
-                                If Not FailSafeMoveStageZ(Z) Then
-                                    StopAcquisition
-                                    Exit Sub
-                                End If
-                            End If
-                            Recenter_post Z, SuccessRecenter, ZEN
-                            DoEvents
-                        Else ' jump to next location
-                            GoTo NextLocation
-                        End If
-                        
-                        ' Show position of stage
-                        LocationTextLabel.Caption = SetLocationTextLabel(X, Y, Z, GridPos, TotPos, RepetitionNumber)
-                        
-                        
-                        If ScanPause Then
-                            If Not Pause Then ' Pause is true is Resume
-                                ScanStop = True
-                                StopAcquisition
-                                Exit Sub
-                            End If
-                        End If
-                        
-                        If RepetitionNumber = 1 Then
-                            StartTime = GetTickCount    'Get the time when the acquisition was started
-                        End If
-                        
-                        'Do the imaging
-                        
-                        If Not ImagingWorkFlow(RecordingDoc, FcsData, StartTime, GridPos, TotPos, RepetitionNumber) Then
-                            StopAcquisition
-                            Exit Sub
-                        End If
-        
-NextLocation:
-                        TotPos = TotPos + 1
-                        If ScanPause Then
-                            If Not Pause Then ' Pause is true is Resume
-                                ScanStop = True
-                                StopAcquisition
-                                Exit Sub
-                            End If
-                        End If
-                        If ScanStop Then
-                            StopAcquisition
-                            Exit Sub
-                        End If
-                        previousZ = posGridZ(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub)
-                   Next GridPos.ColSub
-            Next GridPos.RowSub
-        Next GridPos.Col
-    Next GridPos.Row
-    TotPos = 1
-    If StopAfterRepetition.Value Then
-        ScanStop = True
-        StopAcquisition
-        Exit Sub
-    End If
-    ' DONE WITH THE IMAGING....NOW POSTPROCESSING...
-    
-    If AutomaticBleaching Then
-        FillBleachTable     ' Updating the bleaching table before the next acquisitions, just in case there were changes n the bleaching window
-    End If
-    
-        
-    If (RepetitionNumber < LoopingRepetitions.Value) Then
-        
-        If (LoopingInterval) Then
-            ' do nothing => leave GlobalPrvTime as the time that set at the beginng of the position loop
-        Else ' delay
-            GlobalPrvTime = CDbl(GetTickCount) * 0.001    'Reset the time to NOW
-        End If
-        
-        rettime = CDbl(GetTickCount) * 0.001
-        DiffTime = rettime - GlobalPrvTime
-        'TODO: Check this
-        'This loops define the waiting delay before going back to the first location
-        Do While (DiffTime <= CDbl(LoopingRepetitionTime.Value * LoopingTimerUnit)) And Not (BleachTable(RepetitionNumber + 1) = True)
-            Sleep (100)
-            If GetInputState() <> 0 Then
-                DoEvents
-                If ScanPause = True Then
-                    If Not Pause Then ' Pause is true is Resume
-                        ScanStop = True
-                        StopAcquisition
-                        Exit Sub
-                    End If
-                End If
-                If ExtraBleach Then                                 'Modifies the bleaching table to do an Extrableach for al locatins at the next repetition
-                    ExtraBleach = False
-                    BleachTable(RepetitionNumber + 1) = True
-                End If
-                If ScanStop Then
-                    StopAcquisition
-                    Exit Sub
-                End If
-            End If
-            DisplayProgress "Waiting " & CStr(CInt(LoopingRepetitionTime.Value * LoopingTimerUnit - DiffTime)) + " s before scanning repetition  " & (RepetitionNumber + 1), RGB(&HC0, &HC0, 0)
-            rettime = CDbl(GetTickCount) * 0.001
-            DiffTime = rettime - GlobalPrvTime
-        Loop
-        
-    Else
-        
-        Running = False  ' done with everything done all repetitions
-    
-    End If
-    
-    RepetitionNumber = RepetitionNumber + 1
-    ' TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    
-    DoEvents
-    
-    Loop ' RepetitonLoop ; Do While Running
-    
-    
-    StopAcquisition
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
+Public Sub GlobalRepetitionSec_Change()
+    RepetitionSecChange ("Global")
+End Sub
 
+Private Sub Trigger1RepetitionSec_Change()
+    RepetitionSecChange ("Trigger1")
 End Sub
 
+Private Sub Trigger2RepetitionSec_Change()
+    RepetitionSecChange ("Trigger1")
+End Sub
 
-'''''
-'   Contains all the jobs performed at one position
-'   It will check for Autofocus, Additional image acquisition, normal acquisitions, Micropilot acquisition
-'       [Row] In - Actual Row of Well/Position
-'       [Col] In - Actual Column of Well/Position
-'       [RowSub] In - Row of subpositions grid
-'       [ColSub] In - Column of subpositions grid
-'''''
-Private Function ImagingWorkFlow(RecordingDoc As DsRecordingDoc, FcsData As AimFcsData, StartTime As Double, GridPos As GridPosType, TotPos As Long, RepetitionNumber As Integer) As Boolean
-    
-    ImagingWorkFlow = False
-    Dim Xnew As Double
-    Dim Ynew As Double
-    Dim Znew As Double
-    Dim Xold As Double
-    Dim Yold As Double
-    Dim Zold As Double
-    Dim DeltaZ As Double
-    DeltaZ = -1
-    Dim FileNameID As String
-    Dim FilePath As String
-    Dim FilePathAF  As String
-    Dim Cnt As Integer
-    Dim Time As Double
-    Dim Offset As Double ' a localyy used Zoffset variable
-    Dim pos As Double ' a tmp variable for position
-    Dim Sample0Z As Double
-    Dim LogMsg As String
-    Dim SuccessRecenter As Boolean
-    Dim WarningAcq As Boolean
-    Xnew = posGridX(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub)
-    Ynew = posGridY(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub)
-    If RepetitionNumber = 1 And ActiveGridScan And Not FocusMapPresent Then
-        Znew = Lsm5.Hardware.CpFocus.Position
-    Else
-        Znew = posGridZ(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub)
-    End If
-    Xold = Xnew
-    Yold = Ynew
-    Zold = Znew
+Private Sub GlobalRepetitionTime_Click()
+    RepetitionTime ("Global")
+End Sub
 
-    FileNameID = fileName(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub, RepetitionNumber)
+Private Sub Trigger1RepetitionTime_Click()
+    RepetitionTime ("Trigger1")
+End Sub
 
-    
-    FilePath = DatabaseTextbox.Value & BackSlash & TextBoxFileName.Value & UnderScore & FileNameID
-    FilePathAF = DatabaseTextbox.Value & BackSlash & TextBoxFileName.Value & UnderScore & "AFImg_" & FileNameID
-'
-'    If AutofocusHRZ Then
-'        Lsm5.Hardware.CpHrz.Leveling is this needed
-'    End If
-    
-    LogMsg = vbCrLf & vbCrLf & "% StartButton: Acquire image " & FilePath & vbCrLf _
-    & "% StartButton: Imaging position Row " & GridPos.Row & ", Col " & GridPos.Col & ", Row (subpos) " & GridPos.RowSub & ", Col (subpos) " & GridPos.ColSub & vbCrLf _
-    & "% StartButton: Current position  XYZ " & Round(Xold, PrecXY) & ", " & Round(Yold, PrecXY) & ", " & Round(Zold, PrecZ)
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    
-    
-    ' At every positon and repetition  check if Autofocus needs to be required. Update of positions in Z is only done at the end of acquisition
-    If ActiveAutofocus And ((RepetitionNumber - 1) Mod AFeveryNth = 0) Then    ' Perform Autofocus if active
-        If AutofocusAlgorithm.Value = "external" Then
-            SaveSetting "OnlineImageAnalysis", "macro", "codeIn", "wait"     'this causes to do wait
-            If Not SaveAFImage Then
-                MsgBox "Tick Save AFImage if you want to use an external image analysis for computing the focus!"
-                Exit Function
-            End If
-            SaveSetting "OnlineImageAnalysis", "macro", "filepath", FilePathAF & ".lsm"
-        End If
-        
-        StopScanCheck 'stop any running jobs
-        ' Acquire image and calculate center of mass stored in XMass, YMass and ZMass
-        DisplayProgress "Autofocus Activate Tracks", RGB(0, &HC0, 0)
-        If Not AutofocusForm.ActivateTrack(GlobalAutoFocusRecording, "Autofocus") Then
-            MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-            Exit Function
-        End If
+Private Sub Trigger2RepetitionTime_Click()
+    RepetitionTime ("Trigger2")
+End Sub
 
-        DisplayProgress "Autofocus center Z", RGB(0, &HC0, 0)
-        Time = Timer
-        pos = Lsm5.Hardware.CpFocus.Position
-        If Not Recenter_pre(Zold, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% StartButton:  center Z (pre AFimg) " & Zold & ", time required " & Time & ", Success " & SuccessRecenter
+Private Sub RepetitionNumber(Name As String)
+    Reps.setRepetitionNumber Name, CInt(Me.Controls(Name + "RepetitionNumber"))
+End Sub
 
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        ' take a z-stack and finds the brightest plane:
-        If Not MicroscopeIO.Autofocus_StackShift(RecordingDoc) Then
-           Exit Function
-        End If
-        
+Private Sub GlobalRepetitionNumber_Change()
+    RepetitionNumber "Global"
+End Sub
 
-        
-        If SaveAFImage Then
-            If Not SaveDsRecordingDoc(RecordingDoc, FilePathAF & ".lsm") Then
-                Exit Function
-            End If
-            If AutofocusAlgorithm.Value = "external" Then
-               SaveSetting "OnlineImageAnalysis", "macro", "filepath", FilePathAF & ".lsm"
-               SaveSetting "OnlineImageAnalysis", "macro", "codeOut", "newImage"
-            End If
-        End If
-        
-        If Not ComputeNewCoordinatesAfterAF(RecordingDoc, Xnew, Ynew, Znew, DeltaZ, "Autofocus", AutofocusAlgorithm.Value) Then
-            Exit Function
-        End If
-        
-        LogMsg = "% StartButton:  center of mass XYZ  " & Xnew - Xold & ", " & Ynew - Yold & ", " & Znew - Zold & ". Computed position XYZ " & Xnew & ", " & Ynew & ", " & Znew
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        If AutofocusTrackXY.Value And ScanFrameToggle.Value Then
-            DisplayProgress "Autofocus move XY stage", RGB(0, &HC0, 0)
-            If Not FailSafeMoveStageXY(Xnew, Ynew) Then
-                Exit Function
-            End If
-            posGridX(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub) = Xnew
-            posGridY(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub) = Ynew
-        Else
-            Xnew = Xold
-            Ynew = Yold
-        End If
-        
-        'wait for recentering
-        DisplayProgress "Autofocus: recentering Z after AF", RGB(0, &HC0, 0)
-        Time = Timer
-        If Not Recenter_post(Zold, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-            
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% StartButton:  wait to return center Z (post AFimg) " & Zold
-        pos = Lsm5.Hardware.CpFocus.Position
-        If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-            LogMsg = LogMsg & ", obtained Z " & pos & ", position " & pos & ", time required " & Time & ", success within rep. " & SuccessRecenter
-        Else
-             LogMsg = LogMsg & ", obtained Z " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos _
-             & ", position " & pos & ", time required " & Time & ", success within rep. " & SuccessRecenter
-        End If
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        If ScanPause Then
-            If Not Pause Then ' Pause is true if Resume
-                Exit Function
-            End If
-        End If
-    End If '(RepetitionNumber - 1) Mod AFeveryNth = 0
+Private Sub Trigger1RepetitionNumber_Change()
+    RepetitionNumber "Trigger1"
+End Sub
 
-    FilePath = FilePath & ".lsm"
+Private Sub Trigger2RepetitionNumber_Change()
+    RepetitionNumber "Trigger2"
+End Sub
 
-    LocationTextLabel.Caption = SetLocationTextLabel(Xnew, Ynew, Znew, GridPos, TotPos, RepetitionNumber)
+''''
+' Set Interval or delay
+'''
+Private Sub RepetitionInterval(Name As String)
+    Reps.setInterval Name, Me.Controls(Name + "RepetitionInterval").Value
+End Sub
 
-       
-    If ScanPause Then
-        If Not Pause Then ' Pause is true if Resume
-            Exit Function
-        End If
-    End If
+Private Sub GlobalRepetitionInterval_Click()
+    RepetitionInterval "Global"
+End Sub
 
-    '''''''''''''''''''''''''''''''''''''
-    '*Begin Normal acquisition imaging**'
-    '''''''''''''''''''''''''''''''''''''
-    DisplayProgress "Acquiring  Location   " & TotPos & "/" & UBound(posGridX, 1) * UBound(posGridX, 2) * UBound(posGridX, 3) * UBound(posGridX, 4) & vbCrLf & _
-                    "                   Repetition  " & RepetitionNumber & "/" & LoopingRepetitions.Value, RGB(&HC0, &HC0, 0)
-    Time = Timer
-    If ActivateTrack(GlobalAcquisitionRecording, "Acquisition", DeltaZ) Then       ' If DeltaZ > 0 then new number of slices is set
-        If ActiveMicropilot Or ActiveBleach Then
-            SaveSetting "OnlineImageAnalysis", "macro", "codeIn", "wait"
-        End If
-        LogMsg = "% Startbutton: Time activate AQ track " & Round(Timer - Time, 2)
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        If ActiveAutofocus Then
-            Offset = AutofocusZOffset
-        Else
-            Offset = 0
-        End If
-        
-        DisplayProgress "Acquisition: recentering Z + Offset ", RGB(0, &HC0, 0)
-        'center the slide
-        Time = Timer
-        'Sleep (200)
-        If Not Recenter_pre(Znew + Offset, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        'Sleep (200)
-    
-        
-        Time = Round(Timer - Time, 2)
-        LogMsg = "% Startbutton: Center Z + Offset (pre AQimg) " & Znew + Offset & ", time required " & Time & ", repeats " & Round(Time / 0.4)
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        DoEvents
-        DisplayProgress "Acquiring  Location   " & TotPos & "/" & UBound(posGridX, 1) * UBound(posGridX, 2) * UBound(posGridX, 3) * UBound(posGridX, 4) & vbCrLf & _
-                    "                   Repetition  " & RepetitionNumber & "/" & LoopingRepetitions.Value, RGB(&HC0, &HC0, 0)
-        Time = Timer
-        If Not ScanToImage(RecordingDoc) Then
-            Exit Function
-        End If
-        LogMsg = "% Startbutton: Time acquire AQ track " & Round(Timer - Time)
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-        
-        ''''''''''''''''''''''''''''''''''''
-        '*** Save Acquisition Image *******'
-        ''''''''''''''''''''''''''''''''''''
-        RecordingDoc.SetTitle TextBoxFileName.Value & FileNameID
-        'this is the name of the file to be saved
-        'Check existance of file and warn
-        If Not OverwriteFiles Then
-            If FileExist(FilePath) Then
-                If MsgBox("File " & FilePath & " exists. Do you want to overwrite this and subsequent files? ", VbYesNo) = vbYes Then
-                    OverwriteFiles = True
-                Else
-                    ScanStop = True
-                    Exit Function
-                End If
-            End If
-        End If
-        
-        
-        
-        If Not SaveDsRecordingDoc(RecordingDoc, FilePath) Then    ' HERE THE IMAGE IS FINALLY SAVED
-            Exit Function
-        End If
-        
-        SaveSetting "OnlineImageAnalysis", "macro", "filepath", FilePath
-        
-        
-        Time = Timer
-        'wait that slice recentered after acquisition
-        If Not Recenter_post(Znew + Offset, SuccessRecenter, ZEN) Then
-            Exit Function
-        End If
-        
-        LogMsg = "% StartButton:  recenter Z (post AQImg) " & Znew + Offset
-        pos = Lsm5.Hardware.CpFocus.Position
-        Time = Round(Timer - Time, 2)
-        If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-            LogMsg = LogMsg & ", obtained Z " & pos & ", position " & pos & ", time required " & Time & ", success within rep. " & SuccessRecenter
-        Else
-            LogMsg = LogMsg & ", obtained Z " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos _
-            & ", position " & pos & ", time required " & Time & ", success within rep. " & SuccessRecenter
-        End If
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    End If
-    
-    If ScanPause Then
-        If Not Pause Then ' Pause is true is Resume
-            Exit Function
-        End If
-    End If
-
-    ''''''''''''''''''''''''''''''
-    '*Begin Alternative imaging**'
-    ''''''''''''''''''''''''''''''
-    If ActiveAlterImage.Value And ((RepetitionNumber - 1) Mod RoundAlterTrack = 0) Then
-        Dim FilePathAlt As String ' name of path for alternative imaging
-        Dim FileNameAlt As String ' name of file for alternative imaging
-        Dim AcquireAltImage As Boolean
-        AcquireAltImage = False
-        'if we have subpositions
-        If GridScan_nColumnsub.Value * GridScan_nRowsub.Value > 1 Then
-            If ((GridPos.RowSub - 1) * UBound(posGridX, 4) + GridPos.ColSub) Mod RoundAlterLocation = 0 Then
-                AcquireAltImage = True
-            End If
-        ElseIf ((GridPos.Row - 1) * UBound(posGridX, 2) + GridPos.Col) Mod RoundAlterLocation = 0 Then
-            AcquireAltImage = True
-        End If
+Private Sub Trigger1RepetitionInterval_Click()
+    RepetitionInterval "Trigger1"
+End Sub
 
-        If AcquireAltImage Then
-            Time = Timer
-            If ActiveAutofocus Then
-                Offset = AutofocusZOffset
-            Else
-                Offset = 0
-            End If
-            DisplayProgress "Addition acquisition: prepeare settings at ZOffset position...", RGB(0, &HC0, 0)
-            ' setup acquisition paramneters
-            If Not ActivateTrack(GlobalAltRecording, "AlterAcquisition", DeltaZ) Then            'An additional control....
-                MsgBox "No track selected for Additional Acquisition! Cannot Acquire!"
-                Exit Function
-            End If
-            'center the slide
-            If Not Recenter_pre(Znew + Offset, SuccessRecenter, ZEN) Then
-                Exit Function
-            End If
 
-            FilePathAlt = DatabaseTextbox.Value & BackSlash & TextBoxFileName.Value & UnderScore & "Alt_" & FileNameID & ".lsm" ' fullpath of alternative file
-            FileNameAlt = TextBoxFileName.Value & UnderScore & "Alt_" & FileNameID & ".lsm"
-            
-            LogMsg = "% Start button: Additional acquisition " & FilePathAlt
-            LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-            
-            DisplayProgress "Additional acquisition: acquire...", RGB(0, &HC0, 0)
-            If Not StartAlternativeImaging(RecordingDoc, FilePathAlt, FileNameAlt) Then
-                    Exit Function
-            End If
-             
-            
-            ''' Recenter
-            DisplayProgress "Additional acquisition:  wait recenter ...", RGB(0, &HC0, 0)
-            
-            If Not Recenter_post(Znew + Offset, SuccessRecenter, ZEN) Then
-                Exit Function
-            End If
-            
-            LogMsg = "% StartButton:  wait to return center Z (post AltImg) " & Znew + Offset
-            pos = Lsm5.Hardware.CpFocus.Position
-            If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-                LogMsg = LogMsg & ", obtained Z " & pos & ", position " & pos & ", success within rep." & SuccessRecenter
-            Else
-                LogMsg = LogMsg & ", obtained Z " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos _
-                & ", position " & pos & ", success within rep." & SuccessRecenter
-            End If
-            LogMsg = LogMsg & vbCrLf & "% Startbutton:  time for additional acquisition + centering " & Round(Timer - Time)
-            LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-            
-        End If
-    End If
+Private Sub Trigger2RepetitionInterval_Click()
+    RepetitionInterval "Trigger2"
+End Sub
 
 
-    ''''''''''''''''''''''''''
-    '*** Store bleachTable ***'
-    ''''''''''''''''''''''''''
-    If BleachStartTable(RepetitionNumber) > 0 Then          'If a bleach was performed we add the information to the image metadata
-        Lsm5.DsRecordingActiveDocObject.AddEvent (BleachStartTable(RepetitionNumber) - StartTime) / 1000, eEventTypeBleachStart, "Bleach Start"
-        Lsm5.DsRecordingActiveDocObject.AddEvent (BleachStopTable(RepetitionNumber) - StartTime) / 1000, eEventTypeBleachStop, "Bleach End"
-    End If
+Public Sub UpdateRepetitionTimes()
     
-    If ScanPause Then
-        If Not Pause Then ' Pause is true if Resume
-            ScanStop = True
-            Exit Function
-        End If
-    End If
-
-    If Not ActiveMicropilot Then ' without MicroPilot
-        ' TODO: Revise all this code
-        If BleachTable(RepetitionNumber) = True Then   'Check if we're performing a bleach before image acquisition
-            Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
-            If Success Then
-                DisplayProgress "Bleaching...", &HFF00FF
-                DoEvents
-                Track.UseBleachParameters = True            'Bleach parameters are lasers lines, bleach iterations... stored in the bleach control window
-    '                   BleachStartTable(RepetitionNumber) = Lsm5.ExternalCpObject.pHardwareObjects.pScanController.GetDspTime
-                BleachStartTable(RepetitionNumber) = GetTickCount      'Get the time right before bleach to store this in the image metadata
-                Lsm5.Bleach 0
-                Lsm5.tools.WaitForScanEnd False, 1                     'Waits for the end of the bleach during one second, I think this is not long enough
-                BleachStopTable(RepetitionNumber) = GetTickCount       'Get the time right after bleach to store this in the image metadata
-    '                   BleachStopTable(RepetitionNumber) = Lsm5.ExternalCpObject.pHardwareObjects.pScanController.GetDspTime
-                Track.UseBleachParameters = False  'switch off the bleaching
-            Else
-                MsgBox ("Could not set bleach track. Did not bleach.")
-            End If
-            If GridPos.Row = UBound(posGridX, 1) And GridPos.Col = UBound(posGridX, 2) Then
-                If GridPos.RowSub = UBound(posGridX, 3) And GridPos.Col = UBound(posGridX, 4) Then  'Allows again to do an extrableach at the end (Why???)
-                    ExtraBleachButton.Caption = "Bleach"
-                    ExtraBleachButton.BackColor = &H8000000F
-                End If
-            End If
-        End If
-        ' todo:
-        ' but where is the bleaching image stored ?? Bleaching should be revised !!
-    End If
-                    
-    ''''redefine new position
-    Xold = Xnew
-    Yold = Ynew
-    Zold = Znew
-    'compute potential new positions for later acquistion
-    If TrackingToggle And Not ActiveGridScan Then 'This is if we're doing some postacquisition tracking (not possible with Grid) this is done before Micropilot analysis
-        DisplayProgress "Tracking and computing new coordinates of " & vbCrLf & _
-                        "Well/Position Row: " & GridPos.Row & ", Column: " & GridPos.Col & vbCrLf & _
-                        "subposition   Row: " & GridPos.RowSub & ", Column: " & GridPos.ColSub & vbCrLf, RGB(&HC0, &HC0, 0)
-        DoEvents
-        Time = Timer
-        If Not ComputeNewCoordinatesAfterAF(RecordingDoc, Xnew, Ynew, Znew, DeltaZ, "Tracking") Then
-            Exit Function
-        End If
-        LogMsg = " StartButton: Time compute center of mass AQ img " & Round(Timer - Time, 2)
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    End If
+    Dim i As Integer
+    For i = LBound(RepNames) To UBound(RepNames)
+        RepetitionNumber RepNames(i)
+        RepetitionTime RepNames(i)
+        RepetitionInterval RepNames(i)
+    Next i
 
+End Sub
 
 
-    ' COMMUNICATION WITH MICROPILOT: START *****************
-      
-    If ActiveMicropilot Or ActiveBleach Then
-  
-        'Wait for anything to sto
-        Do While RecordingDoc.IsBusy
-            Sleep (100)
-            If GetInputState() <> 0 Then
-                DoEvents
-                If ScanStop Then
-                    StopAcquisition
-                    Exit Function
-                End If
-            End If
-        Loop
-        SaveSetting "OnlineImageAnalysis", "macro", "codeOut", "newImage"
-        'recenter
-        Recenter_pre Zold, SuccessRecenter, ZEN
-        
-        If Not MicroscopePilot(RecordingDoc, GridPos, Xold, Yold, Zold, FileNameID, HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ, FcsData) Then
-            Exit Function
-        End If
-    End If
-    ' one could monitor weather this position was any good at all here. Goodpositions
-    ' COMMUNICATION WITH MICROPILOT: END *****************
-    
-    If AutofocusTrackZ And ActiveAutofocus Then
-        posGridZ(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub) = Znew
-        Recenter_pre Znew, SuccessRecenter, ZEN
-    Else
-        Recenter_pre Zold, SuccessRecenter, ZEN
+''''
+'  AcquisitionTracksOn()
+'  Checks if at least one track for acquisition is on
+'''
+Private Function AcquisitionTracksOn() As Boolean
+    If AcquisitionTrack1 Then
+        AcquisitionTracksOn = True
     End If
-    
-    If TrackingToggle Then
-        'move to new position
-        If PostTrackXY.Value Then
-            If Not FailSafeMoveStageXY(Xnew, Ynew) Then
-                Exit Function
-            End If
-        End If
-        ' update positions for next acquistion
-        posGridX(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub) = Xnew
-        posGridY(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub) = Ynew
-        If AutofocusTrackZ Then
-            posGridZ(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub) = Znew
-        End If
-    Else ' no location tracking
-        Lsm5.Hardware.CpHrz.Leveling   'This I think puts the HRZ to its resting position, and moves the focuswheel correspondingly. Do we need this?
+    If AcquisitionTrack2 Then
+        AcquisitionTracksOn = True
     End If
-    ''  End: Setting new (x,y)z positions *******************************
-    If Log Then
-        SafeOpenTextFile LogFileName, LogFile, FileSystem
-        LogFile.Close
+    If AcquisitionTrack3 Then
+        AcquisitionTracksOn = True
     End If
-
-    ImagingWorkFlow = True
-
-End Function
-    
-Private Function SetLocationTextLabel(X As Double, Y As Double, Z As Double, GridPos As GridPosType, TotPos As Long, iRep As Integer) As String
-    Dim Caption As String
-    Caption = "Locations : " & TotPos & "/" & UBound(posGridX, 1) * UBound(posGridX, 2) * UBound(posGridX, 3) * UBound(posGridX, 4) & "; X= " & X & ", Y = " & Y & ", Z = " & Z & vbCrLf & _
-                                "Repetition :" & iRep & "/" & LoopingRepetitions.Value & vbCrLf & _
-                                "Well/Position Row: " & GridPos.Row & "/" & UBound(posGridX, 1) & "; Column: " & GridPos.Col & "/" & UBound(posGridX, 2) & vbCrLf
-
-                                
-     If MultipleLocationToggle Or ActiveGridScan Then
-        If GridScan_nRowsub.Value > 1 Or GridScan_nColumnsub.Value > 1 Then
-            Caption = Caption & "Subposition   Row: " & GridPos.RowSub & "/" & UBound(posGridX, 3) & "; Column: " & GridPos.ColSub & "/" & UBound(posGridX, 4) & vbCrLf
-        End If
+    If AcquisitionTrack4 Then
+        AcquisitionTracksOn = True
     End If
-    SetLocationTextLabel = Caption
 End Function
 
-'''''
-'   Pause()
-'   Function called when ScanPause = True
-'   Checks state and wait for action in Form
-'''''
-Public Function Pause() As Boolean
-    
-    Dim rettime As Double
-    Dim GlobalPrvTime As Double
-    Dim DiffTime As Double
-    
-    GetCurrentPositionOffsetButton.Enabled = True
-    AutofocusButton.Enabled = True
-    GlobalPrvTime = CDbl(GetTickCount) * 0.001
-    rettime = GlobalPrvTime
-    DiffTime = rettime - GlobalPrvTime
-    'TODO: test this function
-    DoEvents
-    Do While True
-        Sleep (100)
-        DoEvents
-        If ScanStop Then
-            StopAcquisition
-            Pause = False
-            Exit Function
-        End If
-        If ScanPause = False Then
-            GetCurrentPositionOffsetButton.Enabled = False
-            AutofocusButton.Enabled = False
-            Pause = True
-            Exit Function
-        End If
-
-        DisplayProgress "Pause " & CStr(CInt(DiffTime)) & " s", RGB(&HC0, &HC0, 0)
-        rettime = CDbl(GetTickCount) * 0.001
-        DiffTime = rettime - GlobalPrvTime
-    Loop
+'''
+' Sets all acquisitions to off
+'''
+Private Function AcquisitionTracksSetOff() As Boolean
+    AcquisitionTrack1.Value = 0
+    AcquisitionTrack2.Value = 0
+    AcquisitionTrack3.Value = 0
+    AcquisitionTrack4.Value = 0
 End Function
 
 
-Private Sub ExtraBleachButton_Click()
-    
-    If Running Then
-        ExtraBleach = True
-        ExtraBleachButton.Caption = "Will Bleach"
-        ExtraBleachButton.BackColor = 12648447
-    Else
-        MsgBox "The acquisition has not started yet or is already finished. Cannot bleach."
-    End If
-
-End Sub
-
-'''''''
-'   MultipleLocationToggle_Change()
-'   Activate MultipleLocation and deactivate SingleLocation
-'''''''
-Private Sub MultipleLocationToggle_Change()
-        
-    If MultipleLocationToggle.Value = True Then
-        ActiveGridScan.Value = False
-        SetMultipleLocationToggle_True
-    Else
-        SingleLocationToggle.Value = True
+''''
+' GridScanActive_Click()
+'   Set the grid scan on or off. Changes also
+''
+Private Sub GridScanActive_Click()
+    SwitchEnableGridScanPage (GridScanActive.Value)
+    If GridScanActive Then
+        If MultipleLocationToggle.Value Then
+            GridScan_nRow = 1
+            GridScan_nColumn = Lsm5.Hardware.CpStages.MarkCount
+            Grids.updateGridSize "Global", GridScan_nRow, GridScan_nColumn, GridScan_nRowsub, GridScan_nColumnsub
+        End If
     End If
-    
 End Sub
 
 
-'''''''
-'   SingleLocationToggle_Change()
-'   Activate Singlelocation and deactivate MultipleLocation
-'''''''
-Private Sub SingleLocationToggle_Change()
-    
-    If SingleLocationToggle.Value = True Then
-        SetSingleLocationToggle_True
-    Else
-        MultipleLocationToggle.Value = True
-    End If
-
+Private Sub GridScan_nRow_Click()
+     Grids.updateGridSize "Global", GridScan_nRow, GridScan_nColumn, GridScan_nRowsub, GridScan_nColumnsub
 End Sub
 
-Private Sub SetSingleLocationToggle_True()
-                
-        ' MsgBox "Setting Single Locations True"
-        
-        SingleLocationToggle.Value = True
-        MultipleLocationToggle.Value = False
-        LocationTextLabel.Caption = ""
-        
-        ' CheckBoxScannAll.Visible = False
-        ' GridObjectsandVarialbles False
-        ' StartBleachButton.Visible = True
-        ' ExtraBleachButton.Visible = True
-        ' Frame15.Visible = False
-        ' If GridToggle.Value = True Then GridToggle.Value = Not SingleLocationToggle.Value
+Private Sub GridScan_nColumn_Click()
+     Grids.updateGridSize "Global", GridScan_nRow, GridScan_nColumn, GridScan_nRowsub, GridScan_nColumnsub
+End Sub
 
+Private Sub GridScan_nColumnSub_Click()
+     Grids.updateGridSize "Global", GridScan_nRow, GridScan_nColumn, GridScan_nRowsub, GridScan_nColumnsub
 End Sub
-  
-Private Sub SetMultipleLocationToggle_True()
-  
-        ' MsgBox "Setting Multiple Locations True"
-        
-        SingleLocationToggle.Value = False
-        MultipleLocationToggle.Value = True
-        LocationTextLabel.Caption = "Define locations using the Stage (NOT the Positions) dialog !"
-        
-        ActiveGridScan.Value = False ' currently not compatible
-        
-        
-        ' CheckBoxScannAll.Visible = False
-        ' GridObjectsandVarialbles False
-        ' StartBleachButton.Visible = True
-        ' ZMapButton.Left = 12
-        ' ZMapButton.Top = 258
-        ' CheckBoxZMap.Left = 80
-        ' CheckBoxZMap.Top = 258
-        'ZMapButton.Visible = True
-        'CheckBoxZMap.Visible = True
-        'ExtraBleachButton.Visible = True
-        'Frame15.Visible = True
-        'TextBoxTileX.Visible = True
-        'TextBoxTileY.Visible = True
-        'Tileframe.Visible = True
-        'Label17.Visible = True
-        'Label18.Visible = True
-        'Label20.Visible = True
-        'CreateLocationsButton.Visible = True
-        'TextBoxOverlap.Visible = True
-        'If GridToggle.Value = True Then GridToggle.Value = Not MultipleLocationToggle.Value
-        
+
+Private Sub GridScan_nRowSub_Click()
+     Grids.updateGridSize "Global", GridScan_nRow, GridScan_nColumn, GridScan_nRowsub, GridScan_nColumnsub
 End Sub
-  
-  
 
 
-Public Sub AutoFindTracks()
+''''
+'   SwitchEnableGridScanPage(Enable As Boolean)
+'   Disable or enable all buttons and slider
+'       [Enable] In - Sets the mini page enable status
+''''
+Public Sub SwitchEnableGridScanPage(Enable As Boolean)
 
-    Dim i, j As Integer
-    Dim ChannelOK As Boolean
-    Dim DataChannel As DsDataChannel
-    Dim Color As Long
-    Dim ConfiguredTracks As Integer
-    Dim GoodTracks As Integer
+    GridScan_validGridDefault.Enabled = Enable
+    GridScan_posLabel.Enabled = Enable
+    GridScan_nColumnLabel.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_nRowLabel.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_nColumn.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_nRow.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_dColumnLabel.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_dRowLabel.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_dColumn.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_dRow.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_refColumn.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_refRow.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_refColumnLabel.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_refRowLabel.Enabled = Enable And Not MultipleLocationToggle
+    GridScan_subLabel.Enabled = Enable
+    GridScan_nColumnsub.Enabled = Enable
+    GridScan_nRowsub.Enabled = Enable
+    GridScan_nColumnsubLabel.Enabled = Enable
+    GridScan_nRowsubLabel.Enabled = Enable
+    GridScan_dColumnsubLabel.Enabled = Enable
+    GridScan_dRowsubLabel.Enabled = Enable
+    GridScan_dColumnsub.Enabled = Enable
+    GridScan_dRowsub.Enabled = Enable
+    GridScanDescriptionLabel.Enabled = Enable
+End Sub
 
+
+'''''
+'   Open a Dialog to set file name for storage of valid positions
+'''''
+Private Sub GridScanValidFileButton_Click()
+    Dim Filter As String, FileName As String
+    Dim Flags As Long
+  
+    Flags = OFN_PATHMUSTEXIST Or OFN_HIDEREADONLY Or OFN_NOCHANGEDIR Or OFN_EXPLORER Or OFN_NOVALIDATE
+            
+    Filter = "Alle Dateien (*.*)" & Chr$(0) & "*.*"
     
-    AutofocusTrack1.Visible = False
-    AutofocusTrack1.Enabled = False
-    AutofocusTrack1.Value = False
-    AcquisitionTrack1.Visible = False
-    AcquisitionTrack1.Enabled = False
-    AcquisitionTrack1.Value = False
-    MicropilotTrack1.Visible = False
-    MicropilotTrack1.Enabled = False
-    MicropilotTrack1.Value = False
-    AlterTrack1.Visible = False
-    AlterTrack1.Enabled = False
-    AlterTrack1.Value = False
-    BleachTrack1.Visible = False
-    BleachTrack1.Enabled = False
-    BleachTrack1.Value = False
-    
-    AutofocusTrack2.Visible = False
-    AutofocusTrack2.Enabled = False
-    AutofocusTrack2.Value = False
-    AcquisitionTrack2.Visible = False
-    AcquisitionTrack2.Enabled = False
-    AcquisitionTrack2.Value = False
-    MicropilotTrack2.Visible = False
-    MicropilotTrack2.Enabled = False
-    MicropilotTrack2.Value = False
-    AlterTrack2.Visible = False
-    AlterTrack2.Enabled = False
-    AlterTrack2.Value = False
-    BleachTrack2.Visible = False
-    BleachTrack2.Enabled = False
-    BleachTrack2.Value = False
-    
-    AutofocusTrack3.Visible = False
-    AutofocusTrack3.Enabled = False
-    AutofocusTrack3.Value = False
-    AcquisitionTrack3.Visible = False
-    AcquisitionTrack3.Enabled = False
-    AcquisitionTrack3.Value = False
-    MicropilotTrack3.Visible = False
-    MicropilotTrack3.Enabled = False
-    MicropilotTrack3.Value = False
-    AlterTrack3.Visible = False
-    AlterTrack3.Enabled = False
-    AlterTrack3.Value = False
-    BleachTrack3.Visible = False
-    BleachTrack3.Enabled = False
-    BleachTrack3.Value = False
-   
-    AutofocusTrack4.Visible = False
-    AutofocusTrack4.Enabled = False
-    AutofocusTrack4.Value = False
-    AcquisitionTrack4.Visible = False
-    AcquisitionTrack4.Enabled = False
-    AcquisitionTrack4.Value = False
-    MicropilotTrack4.Visible = False
-    MicropilotTrack4.Enabled = False
-    MicropilotTrack4.Value = False
-    AlterTrack4.Visible = False
-    AlterTrack4.Enabled = False
-    AlterTrack4.Value = False
-    BleachTrack4.Visible = False
-    BleachTrack4.Enabled = False
-    BleachTrack4.Value = False
-
-    ConfiguredTracks = Lsm5.DsRecording.TrackCount
-    ChannelOK = False
-    GoodTracks = 0
+    FileName = CommonDialogAPI.ShowOpen(Filter, Flags, "*.*", "", "Select file containing valid grid positions")
     
-    'The next line and the following "if" should be removed when working with the LSM 2.8 software (where the lambda mode is not defined)
-    Set Track = Lsm5.DsRecording.TrackObjectLambda(Success)
-    If Success Then
-        If Track.Acquire Then
-            MsgBox ("This macro does not work in the Lambda Mode. Please switch to the Channel Mode and reinitialize the Macro.")
-            Exit Sub
-        End If
+    If Right(FileName, 3) <> "*.*" Then
+        GridScanValidFile.Value = FileName
+    Else
+        GridScanValidFile.Value = ""
     End If
+    
+End Sub
+
+'''''
+'   Open a dialog to set filename where positions of grid are stored
+'''''
+Private Sub GridScanPositionFileButton_Click()
+    Dim Filter As String, FileName As String
+    Dim Flags As Long
+  
+    Flags = OFN_PATHMUSTEXIST Or OFN_HIDEREADONLY Or OFN_NOCHANGEDIR Or OFN_EXPLORER Or OFN_NOVALIDATE
             
-    For i = 1 To ConfiguredTracks
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, Success)
-        TrackName = Track.name
-        j = 0
-        'In the next line remove "Or Track.IslambdaTrack" when working with the LSM 2.8 software
-        If Not (Track.IsBleachTrack Or Track.IsLambdaTrack) Then
-            Do While (Not ChannelOK) And (j < Track.DataChannelCount)
-                Set DataChannel = Track.DataChannelObjectByIndex(j, Success)
-                If DataChannel.Acquire = True Then ChannelOK = True
-                Color = DataChannel.ColorRef
-                j = j + 1
-            Loop
-            If ChannelOK Then
-                If Not Track.IsRatioTrack Then
-                    GoodTracks = GoodTracks + 1
-                    If GoodTracks = 5 Then
-                        MsgBox ("This Macro only accepts 4 different tracks")
-                    End If
-                    If GoodTracks = 1 Then
-                        AutofocusTrack1.Visible = True
-                        AutofocusTrack1.Caption = TrackName
-                        AutofocusTrack1.Enabled = ActiveAutofocus.Value
-                        AutofocusTrack1.BackColor = Color
-                        
-                        AcquisitionTrack1.Visible = True
-                        AcquisitionTrack1.Caption = TrackName
-                        AcquisitionTrack1.Enabled = True
-                        AcquisitionTrack1.BackColor = Color
-                        
-                        MicropilotTrack1.Visible = True
-                        MicropilotTrack1.Caption = TrackName
-                        MicropilotTrack1.Enabled = ActiveMicropilot.Value
-                        MicropilotTrack1.BackColor = Color
-                        
-                        AlterTrack1.Visible = True
-                        AlterTrack1.Caption = TrackName
-                        AlterTrack1.Enabled = ActiveAlterImage.Value
-                        AlterTrack1.BackColor = Color
-                        
-                        BleachTrack1.Visible = True
-                        BleachTrack1.Caption = TrackName
-                        BleachTrack1.Enabled = ActiveBleach.Value
-                        BleachTrack1.BackColor = Color
-                        
-                    End If
-                    If GoodTracks = 2 Then
-                        AutofocusTrack2.Visible = True
-                        AutofocusTrack2.Caption = TrackName
-                        AutofocusTrack2.Enabled = ActiveAutofocus
-                        AutofocusTrack2.BackColor = Color
-                        
-                        AcquisitionTrack2.Visible = True
-                        AcquisitionTrack2.Caption = TrackName
-                        AcquisitionTrack2.Enabled = True
-                        AcquisitionTrack2.BackColor = Color
-                        
-                        MicropilotTrack2.Visible = True
-                        MicropilotTrack2.Caption = TrackName
-                        MicropilotTrack2.Enabled = ActiveMicropilot.Value
-                        MicropilotTrack2.BackColor = Color
-                        
-                        AlterTrack2.Visible = True
-                        AlterTrack2.Caption = TrackName
-                        AlterTrack2.Enabled = ActiveAlterImage.Value
-                        AlterTrack2.BackColor = Color
-                        
-                        BleachTrack2.Visible = True
-                        BleachTrack2.Caption = TrackName
-                        BleachTrack2.Enabled = ActiveBleach.Value
-                        BleachTrack2.BackColor = Color
-                        
-                    End If
-                    If GoodTracks = 3 Then
-                        AutofocusTrack3.Visible = True
-                        AutofocusTrack3.Caption = TrackName
-                        AutofocusTrack3.Enabled = ActiveAutofocus
-                        AutofocusTrack3.BackColor = Color
-                        
-                        AcquisitionTrack3.Visible = True
-                        AcquisitionTrack3.Caption = TrackName
-                        AcquisitionTrack3.Enabled = True
-                        AcquisitionTrack3.BackColor = Color
-                        
-                        MicropilotTrack3.Visible = True
-                        MicropilotTrack3.Caption = TrackName
-                        MicropilotTrack3.Enabled = ActiveMicropilot.Value
-                        MicropilotTrack3.BackColor = Color
-                        
-                        AlterTrack3.Visible = True
-                        AlterTrack3.Caption = TrackName
-                        AlterTrack3.Enabled = ActiveAlterImage.Value
-                        AlterTrack3.BackColor = Color
-                        
-                        BleachTrack3.Visible = True
-                        BleachTrack3.Caption = TrackName
-                        BleachTrack3.Enabled = ActiveBleach.Value
-                        BleachTrack3.BackColor = Color
-                        
-                    End If
-                    If GoodTracks = 4 Then
-                        AutofocusTrack4.Visible = True
-                        AutofocusTrack4.Caption = TrackName
-                        AutofocusTrack4.Enabled = ActiveAutofocus
-                        AutofocusTrack4.BackColor = Color
-                        
-                        AcquisitionTrack4.Visible = True
-                        AcquisitionTrack4.Caption = TrackName
-                        AcquisitionTrack4.Enabled = True
-                        AcquisitionTrack4.BackColor = Color
-                        
-                        MicropilotTrack4.Visible = True
-                        MicropilotTrack4.Caption = TrackName
-                        MicropilotTrack4.Enabled = ActiveMicropilot.Value
-                        MicropilotTrack4.BackColor = Color
-                        
-                        AlterTrack4.Visible = True
-                        AlterTrack4.Caption = TrackName
-                        AlterTrack4.Enabled = ActiveAlterImage.Value
-                        AlterTrack4.BackColor = Color
-                        
-                        BleachTrack4.Visible = True
-                        BleachTrack4.Caption = TrackName
-                        BleachTrack4.Enabled = ActiveBleach.Value
-                        BleachTrack4.BackColor = Color
-                        
-                    End If
-                Else
-                    MsgBox ("This macro does not allow to use a Ratio Channel. The Ratio Channel will thus be disabled.")
-                    For j = 0 To Track.DataChannelCount - 1
-                        Set DataChannel = Track.DataChannelObjectByIndex(j, Success)
-                        DataChannel.Acquire = False
-                    Next
-                End If
-                ChannelOK = False
-            End If
-        End If
-    Next
-    If GoodTracks < 4 Then
-        TrackNumber = GoodTracks
+    Filter = "Alle Dateien (*.*)" & Chr$(0) & "*.*"
+    
+    FileName = CommonDialogAPI.ShowOpen(Filter, Flags, "*.*", "", "Select file containing positions of grid")
+       
+    If Right(FileName, 3) <> "*.*" Then
+        GridScanPositionFile.Value = FileName
     Else
-        TrackNumber = 4
+        GridScanPositionFile.Value = ""
     End If
 End Sub
 
 
 
 
+''''
+' Stop all jobs after current repetition of current job
+''''
+Private Sub StopAfterRepetition_Click()
 
-Private Sub CloseButton_Click()
-    RestoreAcquisitionParameters
-    Sleep (1000)
-    End
-End Sub
 
-Private Sub ReInitializeButton_Click()
-    Re_Initialize
+    If StopAfterRepetition.Value Then
+        StopAfterRepetition.BackColor = 12648447
+    Else
+        StopAfterRepetition.BackColor = &H8000000F
+    End If
+
 End Sub
 
-
-Private Sub CreditButton_Click()
-    CreditForm.Show
-End Sub
-
-''''''
-'  TrackingToggle_Click()
-'  Add extra tracking channel.
-'  Tracking is the wrong word. It just uses an extra channel for the calculation of center of mass which is then used to move the stage
-'''''
-Private Sub TrackingToggle_Click()
-    SwitchEnableTrackingToggle (TrackingToggle.Value)
-End Sub
-
-'''''
-'   SwitchEnableTrackingToggle(Enable As Boolean)
-'   Changes Enable visibility of AcquiistionForm Tracking part
-'       [Enable] In - Enable of tracking
-'''''
-Private Sub SwitchEnableTrackingToggle(Enable As Boolean)
-    ComboBoxTrackingChannel.Visible = Enable
-    If Enable Then
-       FillTrackingChannelList
-        If GlobalAcquisitionRecording.ScanMode = "Stack" Or GlobalAcquisitionRecording.ScanMode = "ZScanner" Then
-            PostTrackZ.Enabled = True
-        Else
-            PostTrackZ.Enabled = False
-            PostTrackZ.Value = False
-        End If
-    End If
-    PostTrackXY.Visible = Enable
-    PostTrackZ.Visible = Enable
-    PostAcquisitionLabel.Visible = Enable
-
-End Sub
-    
-
-'''''''
-' AutofocusTrackZ_Click()
-'   Activate post-acquisition Z-tracking.
-'   Inactivates Autofocus
+'''''''''
+'   StopButton_Click()
+'   ScanStop is used to tell different functions to stop execution and acquisition
+'   A second routine is called to stop the processes
+'       [ScanStop] Global/Out - Set to true
 '''''''
-Private Sub PostTrackZ_Click()
-    If PostTrackZ.Value = True Then
-        ActiveAutofocus.Value = False 'inactivate Autofocus
-        SwitchEnableAutofocusPage (False)
+Private Sub StopButton_Change()
+    If Not Running Then
+        ScanStop = StopButton.Value
+        StopButton.Value = False
+        StopButton.BackColor = &H8000000F
     Else
-        ActiveAutofocus.Value = True
-        SwitchEnableAutofocusPage (True)
-    End If
-End Sub
-
-
-'fills popup menu for chosing a track for post-acquisition tracking
-' TODO: move in form
-Private Sub FillTrackingChannelList()
-    Dim T As Integer
-    Dim c As Integer
-    Dim ca As Integer
-    Dim channel As DsDetectionChannel
-    Dim Track As DsTrack
-    
-    ReDim ActiveChannels(Lsm5.Constants.MaxActiveChannels)  'ActiveChannels is a dynamic array (variable size), ReDim defines array size required next
-                                                            'Array size is (MaxActiveChannels gets) the total max number of active channels in all tracks
-    ComboBoxTrackingChannel.Clear 'Content of popup menu for chosing track for post-acquisition tracking is deleted
-    ca = 0
-    
-    If ActivateTrack(GlobalAcquisitionRecording, "Acquisition") Then
-        For T = 1 To TrackNumber 'This loop goes through all tracks and will collect all activated channels to display them in popup menu
-            Set Track = GlobalAcquisitionRecording.TrackObjectByMultiplexOrder(T - 1, Success)
-            If Track.Acquire Then 'if track is activated for acquisition
-                For c = 1 To Track.DetectionChannelCount 'for every detection channel of track
-                    Set channel = Track.DetectionChannelObjectByIndex(c - 1, Success)
-                    If channel.Acquire Then 'if channel is activated
-                        ca = ca + 1 'counter for active channels will increase by one
-                        ComboBoxTrackingChannel.AddItem Track.name & " " & channel.name 'entry is added to combo box to chose track for post-acquisition tracking
-                        ActiveChannels(ca) = channel.name & "-T" & Track.MultiplexOrder + 1  'adds entry to ActiveChannel Array with name of channel + name of track
-                    End If
-                Next c
-            End If
-        Next T
-        ComboBoxTrackingChannel.Value = ComboBoxTrackingChannel.List(0) 'initially displayed text in popup menu is a blank line (first channel is 1).
+        ScanStop = StopButton.Value
+        If StopButton.Value Then
+            StopButton.BackColor = 12648447
+        Else
+             StopButton.BackColor = &H8000000F
+        End If
     End If
 End Sub
 
-Private Sub ComboBoxTrackingChannel_Change()        'Sets the name of the channel for PostAcquisition tracking.
-If AcquisitionTracksOn Then
-    TrackingChannelString = ActiveChannels(ComboBoxTrackingChannel.ListIndex + 1)
-End If
-End Sub
-
 
 
-Private Sub CommandTimeMin_Click()
-    LoopingTimerUnit = 60
-    LoopingRepetitionTime.Max = 60                        'When workings with minutes the maximum delay that can be set with the slider is 1 hour
-    LoopingRepetitionTime.Value = BlockTimeDelay / 60
-    CommandTimeMin.BackColor = &HFF8080
-    CommandTimeSec.BackColor = &H8000000F
-End Sub
 
-Private Sub CommandTimeSec_Click()
-    LoopingTimerUnit = 1
-    LoopingRepetitionTime.Max = 180                       'When workings with seconds the maximum delay that can be set with the slider is 3 minutes
-    LoopingRepetitionTime.Value = BlockTimeDelay
-    CommandTimeSec.BackColor = &HFF8080
-    CommandTimeMin.BackColor = &H8000000F
-End Sub
 
-Private Sub LoopingRepetitionTime_Click()
-    BlockTimeDelay = LoopingRepetitionTime.Value * LoopingTimerUnit                      'BlockTimedelay gets the value of the slider in seconds
-End Sub
 
-Private Sub LoopingRepetitions_Change()
+'''
+' Pause a job
+''''
+Private Sub PauseButton_Click()
     If Not Running Then
-        BlockRepetitions = LoopingRepetitions.Value
-    ElseIf Not (LoopingRepetitions.Value <= (RepetitionNumber + 1)) Then
-        BlockRepetitions = LoopingRepetitions.Value
-    Else
-        LoopingRepetitions.Value = RepetitionNumber + 1
-        BlockRepetitions = LoopingRepetitions.Value
-    End If
-    
-    ReDim Preserve GlobalImageIndex(BlockRepetitions)           'The global image index I'm not sure how this is working.
-    ReDim Preserve BleachTable(BlockRepetitions)                'BleachTable defines when bleaching will have to occur
-    If AutomaticBleaching Then FillBleachTable                  'Reads the parameters defined in the Bleach control window of the main software
-    ReDim Preserve BleachStartTable(BlockRepetitions)           'This is to store the timepoints when the bleaches started. Preserve is to keep the timepoints if the slider is moved during an experiment
-    ReDim Preserve BleachStopTable(BlockRepetitions)            'This is to store the timepoints when the bleaches stopped. Preserve is to keep the timepoints if the slider is moved during an experiment
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub TextBoxFileName_Change()
-    GlobalFileName = TextBoxFileName.Value
-    If AutofocusForm.TextBoxFileName.Value <> "" Then
-        UnderScore = "_"
+        ScanPause = False
+        PauseButton.Value = False
+        PauseButton.Caption = "PAUSE"
+        PauseButton.BackColor = &H8000000F
     Else
-        UnderScore = ""
+        If PauseButton.Value Then
+            ScanPause = True
+            PauseButton.Caption = "RESUME"
+            PauseButton.BackColor = 12648447
+        Else
+            ScanPause = False
+            PauseButton.Caption = "PAUSE"
+            PauseButton.BackColor = &H8000000F
+        End If
     End If
 End Sub
 
+
+
+
+
+
 '''''
-'   ActivateTrack(ByRef Recording As DsRecording, ByVal Track As String) As Boolean
-'   Wrapper function to call activate functions for track given a Track Name
-'
+'   CommandButtonNewDataBase_Click()
+'   Open a Dialog to set output folder where to save the results. then cal SetDatabase to set global variables
 '''''
-Public Function ActivateTrack(ByRef Recording As DsRecording, ByVal Track As String, Optional DeltaZ As Double = -1) As Boolean
-    Select Case Track
-        Case "Autofocus":
-            ActivateTrack = ActivateAutofocusTrack(Recording)
-        Case "Acquisition":
-            ActivateTrack = ActivateAcquisitionTrack(Recording, DeltaZ)
-        Case "AlterAcquisition":
-            ActivateTrack = ActivateAlterAcquisitionTrack(Recording, DeltaZ)
-        Case "Micropilot":
-            ActivateTrack = ActivateMicropilotTrack(Recording, DeltaZ)
-        Case "Bleach":
-            ActivateTrack = ActivateBleachTrack(Recording, DeltaZ)
-        Case Else:
-            MsgBox "ActivateTrack: Not able to find appropriate imging track to activate! Exit function now!"
-    End Select
-End Function
- 
-'''''''
-'   ActivateAutofocusTrack(Recording As DsRecording, posZ As Double, pixelDwell As Double)
-'   Check which Track should be used for Autofocus and update passed DsRercoding.
-'   posZ is position with respect to which calculate central slice (often the CpFocus still moves after acquisition)
-'   This sets also the Z acquisition parameters for Acquisition document. For this one uses parameters of the AutofocusForm
-'       [Recording] In/Out - a DsRecording
-'   TODO: test
-''''''
-Private Function ActivateAutofocusTrack(Recording As DsRecording) As Boolean
-    Dim i As Integer
-    Dim iZoom As Integer
-    Dim TrackSuccess As Integer
-    Dim FunSuccess As Boolean
-    Dim pixelDwell As Double
-    Dim ZoomPixelSlice(1 To 9, 1 To 3) As Double
-    iZoom = -1
-    
-    ' This may be different depending on the setting and microscope
-    ' define here the Zoom pixelSize slice relation specificed for 256x1 line. pixeldWell rescales with 256/FrameSize
-    ZoomPixelSlice(1, 1) = 5
-    ZoomPixelSlice(2, 1) = 3.1
-    ZoomPixelSlice(3, 1) = 2
-    ZoomPixelSlice(4, 1) = 1.2
-    ZoomPixelSlice(5, 1) = 0.8
-    ZoomPixelSlice(6, 1) = 0
-    ZoomPixelSlice(7, 1) = 0
-    ZoomPixelSlice(8, 1) = 0
-    ZoomPixelSlice(9, 1) = 0
-    'pixel dwell
-    ZoomPixelSlice(1, 1) = 0.00000128 '1.28 us
-    ZoomPixelSlice(2, 2) = 0.0000016  '1.6
-    ZoomPixelSlice(3, 2) = 0.00000192 '1.92
-    ZoomPixelSlice(4, 2) = 0.00000256 '2.56
-    ZoomPixelSlice(5, 2) = 0.0000032  '3.2
-    ZoomPixelSlice(6, 2) = 0.00000512 '5.12
-    ZoomPixelSlice(7, 2) = 0.0000064  '6.4
-    ZoomPixelSlice(8, 2) = 0.0000128  '12.8
-    ZoomPixelSlice(9, 2) = 0.0000256  '25.6
-    
-    'slice size
-    ZoomPixelSlice(1, 3) = 0.08
-    ZoomPixelSlice(2, 3) = 0.1
-    ZoomPixelSlice(3, 3) = 0.12
-    ZoomPixelSlice(4, 3) = 0.15
-    ZoomPixelSlice(5, 3) = 0.19
-    ZoomPixelSlice(6, 3) = 0.31
-    ZoomPixelSlice(7, 3) = 0.38
-    ZoomPixelSlice(8, 3) = 0.77
-    ZoomPixelSlice(9, 3) = 1.54
-    
-    FunSuccess = False
-    ' Set all tracks to non-acquisition first
-    For i = 1 To TrackNumber
-       Recording.TrackObjectByMultiplexOrder(i - 1, TrackSuccess).Acquire = 0
-    Next i
+Private Sub CommandButtonNewDataBase_Click()
+    Dim Filter As String, FileName As String
+    Dim Flags As Long
+  
+    Flags = OFN_PATHMUSTEXIST Or OFN_HIDEREADONLY Or OFN_NOCHANGEDIR Or OFN_EXPLORER Or OFN_NOVALIDATE
+            
+    Filter = "Alle Dateien (*.*)" & Chr$(0) & "*.*"
     
-    For i = 1 To TrackNumber
-        If AutofocusTrack1.Value = True And i = 1 Then
-            FunSuccess = True
-            Exit For
-        ElseIf AutofocusTrack2.Value = True And i = 2 Then
-            FunSuccess = True
-            Exit For
-        ElseIf AutofocusTrack3.Value = True And i = 3 Then
-            FunSuccess = True
-            Exit For
-        ElseIf AutofocusTrack4.Value = True And i = 4 Then
-            FunSuccess = True
-            Exit For
-        End If
-    Next i
+    FileName = CommonDialogAPI.ShowOpen(Filter, Flags, "*.*", "", "Select output folder")
     
-    If FunSuccess Then
-        AutofocusTrack = i - 1
-        Recording.TrackObjectByMultiplexOrder(AutofocusTrack, Success).Acquire = True
-        If AutofocusMaxSpeed.Value Then
-           Recording.TrackObjectByMultiplexOrder(AutofocusTrack, Success).SamplingNumber = 1  'TODO what happens here
-        End If
-    Else
-        Exit Function
+    If Len(FileName) > 3 Then
+        FileName = Left(FileName, Len(FileName) - 3)
+        DatabaseTextbox.Value = FileName
+        SetDatabase
     End If
     
-    If Not (SystemName = "LSM" Or SystemName = "LIVE") Then
-        MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-        ActivateAutofocusTrack = False
-        Exit Function
+End Sub
+
+'''''
+'   DatabaseTextbox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
+'   Only update the outputfolder when enter is pressed. This avoids creating a folded at every keystroke
+'''''
+Private Sub DatabaseTextbox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
+    If KeyCode = 13 Then 'this is the enter key
+        SetDatabase
     End If
+End Sub
+
+'''''
+'   SetDatabase()
+'       [GlobalDataBaseName] Out/Global - The name of Outputfolder
+'       [LogFileNameBase]    Out/Global - The name of the LogfileName
+'       [Log]                Out/Global - If yes results are logged
+'       Set global variables and check if we can create Outputfolder
+'''''
+Private Sub SetDatabase()
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    OiaSettings.initializeDefault
     
-    If AutofocusLowZoom.Value Then                   ' Changes the zoom if necessary
-        Recording.ZoomX = 1
-        Recording.ZoomY = 1
-    Else                                            ' Use AcquisitionRecording as default
-        Recording.ZoomX = GlobalBackupRecording.ZoomX
-        Recording.ZoomY = GlobalBackupRecording.ZoomY
-        Recording.ZoomZ = GlobalBackupRecording.ZoomZ
+    GlobalDataBaseName = DatabaseTextbox.Value
+    If GlobalDataBaseName = "" Then
+        DatabaseLabel.Caption = "No output folder"
     End If
-        
-    Recording.TimeSeries = False                     'Disable the timeseries, because autofocussing is just one image at one timepoint.
-    
-    ''''''''''''''''''''''''''''
-    '*Setting for LSM system***'
-    ''''''''''''''''''''''''''''
-    If SystemName = "LSM" Then
-        '''How to do the Z-stacks
-        If AutofocusHRZ.Value Then                'Piezo
-            Recording.SpecialScanMode = "ZScanner"
-        Else
-            Recording.SpecialScanMode = "FocusStep"
-        End If
-        'highspeed does set the pixeldwell time to its minimal possible value
-        If AutofocusMaxSpeed.Value Then
-            'compute maximal possible pixwelDwell for given zoom
-            For i = 1 To UBound(ZoomPixelSlice, 1) - 1
-                If Recording.ZoomX < ZoomPixelSlice(i, 1) And Recording.ZoomX >= ZoomPixelSlice(i + 1, 1) Then
-                    iZoom = i
-                    pixelDwell = ZoomPixelSlice(i, 2)
-                End If
-            Next i
-            'do biderectional scanning (tocheck if it is fine with Zscan)
-            If ScanFrameToggle Then
-                Recording.ScanDirection = 1
-            End If
-        Else
-            pixelDwell = GlobalBackupSampleObservationTime
-            Recording.ScanDirection = GlobalBackupRecording.ScanDirection
-        End If
-        
-        If iZoom < 0 Then
-            iZoom = 1
+
+    If Not GlobalDataBaseName = "" Then
+        If Right(GlobalDataBaseName, 1) <> "\" Then
+            DatabaseTextbox.Value = DatabaseTextbox.Value + "\"
+            GlobalDataBaseName = DatabaseTextbox.Value
         End If
-        
-        '''''''''''''''''''''''''''
-        '**Setting for line scan**'
-        '''''''''''''''''''''''''''
-        If ScanLineToggle.Value Then
-            Recording.ScanMode = "ZScan"             'This acquires  single X-Z image, like with "Range Select" button Z-stack Window.
-            Recording.SamplesPerLine = AutofocusLineSize.Value
-            Recording.LinesPerFrame = 1
-
-            If AutofocusHRZ Then
-                Recording.SpecialScanMode = "ZScanner"
-            Else
-                If AutofocusFastZline And AutofocusZStep.Value < ZoomPixelSlice(i, 3) Then
-                    Recording.SpecialScanMode = "OnTheFly" 'aka: Fast Z-line in Z-Stack menu
-                    For i = iZoom To UBound(ZoomPixelSlice, 1)
-                        If AutofocusZStep.Value < ZoomPixelSlice(i, 3) Then
-                            pixelDwell = ZoomPixelSlice(i, 2)
-                            Exit For
-                        End If
-                    Next i
-                 Else
-                    If AutofocusZStep.Value > ZoomPixelSlice(i, 3) And (AutofocusFastZline And Not AutofocusHRZ) Then
-                        DisplayProgress "Highest Z Step of 1.54 um with no piezo and Fast " & _
-                        "Z line has been reached. Autofocus uses slower Focus Step", RGB(&HC0, &HC0, 0)
-                    End If
-                    Recording.SpecialScanMode = "FocusStep"
-                 End If
-            End If
+        On Error GoTo ErrorHandleDataBase
+        If Not CheckDir(GlobalDataBaseName) Then
+            Exit Sub
         End If
-        
-        ''''''''''''''''''''''''''''
-        '**Setting for frame scan**'
-        ''''''''''''''''''''''''''''
-        If ScanFrameToggle.Value Then
-            Recording.ScanMode = "Stack"                       'This is defining to acquire a Z stack of Z-Y images
-            Recording.SamplesPerLine = AutofocusFrameSize.Value  'If doing frame autofocussing it uses the userdefined frame size
-            Recording.LinesPerFrame = AutofocusFrameSize.Value
+        DatabaseLabel.Caption = GlobalDataBaseName
+        OiaSettings.writeKeyToRegistry "OutputFolder", GlobalDataBaseName
+        LogFileNameBase = GlobalDataBaseName & "\AutofocusScreen.log"
+        ErrFileNameBase = GlobalDataBaseName & "\AutofocusScreen.err"
+        If Right(GlobalDataBaseName, 1) = "\" Then
+            BackSlash = ""
+        Else
+            BackSlash = "\"
         End If
-        pixelDwell = pixelDwell * 256 / Recording.SamplesPerLine
-    End If  ' If SystemName = "LSM"
-    
-    Sleep (100)
-    ' set the pixelDwellTime globally
-    NoFrames = CLng(AutofocusZRange.Value / AutofocusZStep.Value) + 1   'Calculates the number of frames per stack. Clng converts it to a long and rounds up the fraction
-    If NoFrames > 2048 Then                                         'overwrites the userdefined value if too many frames have been defined by the user
-        NoFrames = 2048
     End If
-    Recording.FrameSpacing = AutofocusZStep.Value
-    Recording.FramesPerStack = NoFrames
-    Recording.TimeSeries = True   ' This is for the concatenation I think: we're doing a timeseries with one timepoint. I'm not sure what is the reason for this
-    Recording.StacksPerRecord = 1 ' why only one and not more
-
-    Recording.TrackObjectByMultiplexOrder(AutofocusTrack, 1).SampleObservationTime = pixelDwell
-    Lsm5.DsRecording.Copy Recording
-    Lsm5.DsRecording.TrackObjectByMultiplexOrder(AutofocusTrack, 1).SampleObservationTime = pixelDwell
-    Lsm5.DsRecording.FrameSpacing = AutofocusZStep.Value
-    Lsm5.DsRecording.FramesPerStack = NoFrames
-    
-    ' need to do it twice:  set new pixelDwell and FrameSpacing This is asolutely required
-    Lsm5.DsRecording.TrackObjectByMultiplexOrder(AutofocusTrack, 1).SampleObservationTime = pixelDwell
-    Lsm5.DsRecording.FrameSpacing = AutofocusZStep.Value
-    Lsm5.DsRecording.SpecialScanMode = Recording.SpecialScanMode
 
-    ActivateAutofocusTrack = FunSuccess
-End Function
+    If LogCode And LogFileNameBase <> "" Then
+        On Error GoTo ErrorHandleLogFile
+        LogFileName = LogFileNameBase
+        ErrFileName = ErrFileNameBase
+        Log = True
+    Else
+        Log = False
+    End If
+    Exit Sub
+ErrorHandleDataBase:
+    MsgBox "Could not create output Directory " & GlobalDataBaseName
+    Exit Sub
+ErrorHandleLogFile:
+    MsgBox "Could not create LogFile " & LogFileName
+End Sub
 
-'''''''''
-' ActivateAcquisitionTrack()
-' If any of the checkboxes in the AutoFocusForm Acquisition are checked activates themin DsRecording
-'   [Recording] In/Out - a DsRecording
-' TODO: Test
-''''''''''
-Private Function ActivateAcquisitionTrack(Recording As DsRecording, Optional DeltaZ As Double = -1) As Boolean
+
+''''''
+'   RestoreAcquisitionParameters()
+'   Restores the image acquisition recording parameters from GlobalBackupRecording
+'   recenter acquisition
+'   Lsm5.DsRecording Out - Recording settings
+''''''
+Public Sub RestoreAcquisitionParameters()
     Dim i As Integer
-    Dim TrackSuccess As Integer
-    Dim FunSuccess As Boolean
-    Dim ToActivate() As Boolean
-    ReDim ToActivate(1 To TrackNumber)
-    FunSuccess = False
-
-    For i = 1 To TrackNumber
-        ToActivate(i) = False
-        If AcquisitionTrack1.Value = True And i = 1 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf AcquisitionTrack2.Value = True And i = 2 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf AcquisitionTrack3.Value = True And i = 3 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf AcquisitionTrack4.Value = True And i = 4 Then
-            ToActivate(i) = True
-            FunSuccess = True
+    Dim pos As Double
+    Dim Time As Double
+    Dim LogMsg As String
+    Dim SuccessRecenter As Boolean
+    
+    Time = Timer
+    ChangeButtonStatus True
+    Running = False
+    ScanStop = False
+    ScanPause = False
+    ChangeButtonStatus True
+    PauseButton.Value = False
+    PauseButton.Caption = "PAUSE"
+    PauseButton.BackColor = &H8000000F
+    StopAfterRepetition.Value = False
+    StopAfterRepetition.BackColor = &H8000000F
+    StopButton.BackColor = &H8000000F
+    StopButton.Value = False
+    LocationTextLabel.Caption = ""
+    Sleep (1000)
+    ''Close LogFile and ErrFile
+    If Log Then
+        If SafeOpenTextFile(LogFileName, LogFile, FileSystem) And SafeOpenTextFile(ErrFileName, ErrFile, FileSystem) Then
+            ErrFile.Close
+            LogFile.Close
         End If
-    Next i
+    End If
+    SwitchEnableGridScanPage True
+    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
+
+End Sub
 
 
-    Recording.TimeSeries = True   ' This is for the concatenation I think: we're doing a timeseries with one timepoint. I'm not sure what is the reason for this
-    Recording.StacksPerRecord = 1 ' why only one and not more
-    'can't put Lsm5.DsRecording here. as it is not followed. Why?
-    If FunSuccess Then
-        Lsm5.DsRecording.Copy Recording
-        'Activate the tracks
-        For i = 1 To TrackNumber
-            Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, 1).Acquire = ToActivate(i)
-        Next i
-        Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime = GlobalBackupSampleObservationTime
-        'change number of Slices
-        If DeltaZ > 0 Then
-            Lsm5.DsRecording.FramesPerStack = CLng(DeltaZ / Recording.FrameSpacing) + 1
-        End If
-    End If
-    If Not ScanStop Then
-        ActivateAcquisitionTrack = FunSuccess
-    End If
-End Function
 
+''''''
+'   GetCurrentPositionOffsetButton_Click()
+'       Performs Autofocus and update ZOffset according to ZShift
+''''''
+Private Sub GetCurrentPositionOffsetButton_Click()
+    If Not GetCurrentPositionOffsetButtonRun Then
+        StopAcquisition
+    End If
+    RestoreAcquisitionParameters
+End Sub
 
+Private Function GetCurrentPositionOffsetButtonRun() As Boolean
+ '   Dim X As Double
+'    Dim Y As Double
+'    Dim Z As Double
+'    Dim deltaZ As Double
+'    Dim GridPos As GridPosType
+'    Dim time As Double
+'    Dim pos As Double
+'    Dim LogMsg As String
+'    Dim SuccessRecenter As Boolean
+'    Running = True
+'    Dim NewPicture As DsRecordingDoc
+'    DisplayProgress "Get Current Position Offset - Autofocus", RGB(0, &HC0, 0)             'Gives information to the user
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    Z = posTempZ
+'    X = Lsm5.Hardware.CpStages.PositionX
+'    Y = Lsm5.Hardware.CpStages.PositionY
+'
+'    'recenter only after activation of new track
+'    If AutofocusActive Then
+'        StopScanCheck
+'        If AutofocusHRZ Then
+'            Lsm5.Hardware.CpHrz.Leveling
+'        End If
+'       'FailSafeMoveStageZ (posTempZ) 'move at position
+'        ' Acquire image and calculate center of mass stored in XMass, YMass and ZMass
+'        DisplayProgress "Autofocus Activate Tracks", RGB(0, &HC0, 0)
+'        time = Timer
+'        If Not AutofocusForm.ActivateTrack(GlobalAutoFocusRecording, "Autofocus") Then
+'            MsgBox "No track selected for Autofocus! Cannot Autofocus!"
+'            Exit Function
+'        End If
+'
+'        LogMessage "% Get current position: time activate AF track " & Round(Timer - time), Log, LogFileName, LogFile, FileSystem
+'
+'        'DoEvents
+'        'Sample0Z = Lsm5.DsRecording.Sample0Z
+'        DisplayProgress "Autofocus: Recenter prior AF acquisition.... ", RGB(0, &HC0, 0)
+'        DoEvents
+'        time = Timer
+'        If Not Recenter_pre(posTempZ, SuccessRecenter, ZENv) Then
+'            Exit Function
+'        End If
+'        pos = Lsm5.Hardware.CpFocus.Position
+'        time = Round(Timer - time, 2)
+'        LogMsg = "% Get current position: center Z (pre AFimg) " & posTempZ & ", time required" & time & ", succes within rep. " & SuccessRecenter
+'        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
+'        'Use internal agorithm to compute Xmass etc.
+'        If Not MicroscopeIO.Autofocus_StackShift(NewPicture) Then
+'                Exit Function
+'        End If
+'
+'        DisplayProgress "Autofocus compute", RGB(0, &HC0, 0)
+'
+'        If Not ComputeNewCoordinatesAfterAF(NewPicture, X, Y, Z, deltaZ, "Autofocus") Then
+'            Exit Function
+'        End If
+'        AcquisitionZOffset.Value = posTempZ - Z
+'
+'        DisplayProgress "Autofocus: Recenter after AF acquisition...", RGB(0, &HC0, 0)
+'
+'        time = Timer
+'        If Not Recenter_post(posTempZ, SuccessRecenter, ZENv) Then
+'            Exit Function
+'        End If
+'        time = Round(Timer - time, 2)
+'        LogMsg = "% Get current position: recenter Z (post AFImg) " & posTempZ
+'        If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
+'                LogMsg = LogMsg & "; obtained central slide " & pos & "; position " & pos & ", time required " & time & ", succes within rep. " & SuccessRecenter
+'        Else
+'            LogMsg = LogMsg & "; obtained central slide " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 _
+'            - Lsm5.DsRecording.Sample0Z + pos & "; position " & pos & ", time required " & time & ", succes within rep. " & SuccessRecenter
+'        End If
+'        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
+'
+'        posTempZ = Z
+'        time = Timer
+'        If Not Recenter_pre(posTempZ, SuccessRecenter, ZENv) Then
+'            Exit Function
+'        End If
+'        time = Round(Timer - time, 2)
+'        LogMsg = "% Get current position: center Z (end) " & posTempZ & ", time required" & time & ", success" & SuccessRecenter
+'        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
+'    End If
+'    GetCurrentPositionOffsetButtonRun = True
+End Function
 
 '''''''
-'   ActivateAlterAcquisitionTrack
-'   Check which track has been activated and for AlternativeAcquisitionTrack set the track properties accordingly
-'   TODO: Test
-''''''
-Private Function ActivateAlterAcquisitionTrack(Recording As DsRecording, Optional DeltaZ As Double = -1) As Boolean
-    Dim i As Integer
-    Dim FunSuccess As Boolean
-    Dim ToActivate() As Boolean
-    ReDim ToActivate(1 To TrackNumber)
-    FunSuccess = False
-    
-    For i = 1 To TrackNumber
-        ToActivate(i) = False
-        If AlterTrack1.Value = True And i = 1 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf AlterTrack2.Value = True And i = 2 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf AlterTrack3.Value = True And i = 3 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf AlterTrack4.Value = True And i = 4 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        End If
+'   AutofocusButton_Click()
+'   calls AutofocusButtonRun
+''''''''
+Public Sub AutofocusButton_Click()
+    Dim posTempZ As Double
+    Dim node As AimExperimentTreeNode
+    Set viewerGuiServer = Lsm5.viewerGuiServer
+    Dim RecordingDoc As DsRecordingDoc
+    Dim SuccessRecenter As Boolean
+    Running = True
+    posTempZ = Lsm5.Hardware.CpFocus.position
+    Recenter_pre posTempZ, SuccessRecenter, ZENv
+    Dim i As Long
+    Dim NrTracks As Long
+    ReDim GlobalBackupActiveTracks(Lsm5.DsRecording.TrackCount)
+    For i = 0 To Lsm5.DsRecording.TrackCount - 1
+       GlobalBackupActiveTracks(i) = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i, 1).Acquire
     Next i
     
-    If FunSuccess Then
-        Recording.TimeSeries = True  ' This is for the concatenation I think: we're doing a timeseries with one timepoint. I'm not sure what is the reason for this
-        Recording.StacksPerRecord = 1 ' This is time series stack!
-            ' get and set the values from the Form
-        Recording.ZoomX = AlterZoom.Value
-        Recording.ZoomY = AlterZoom.Value
-        Recording.ScanMode = "Stack"
-        Recording.FrameSpacing = CDbl(AlterZStep.Value)
-        Recording.FramesPerStack = CDbl(AlterZSlices.Value)
-        Recording.SamplesPerLine = AlterFrameSize.Value
-        Recording.LinesPerFrame = AlterFrameSize.Value
-        Recording.SpecialScanMode = GlobalAcquisitionRecording.SpecialScanMode
-        'Activate the tracks
-        For i = 1 To TrackNumber
-            Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, 1).Acquire = ToActivate(i)
-        Next i
-        Lsm5.DsRecording.Copy Recording
-        Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime = GlobalBackupSampleObservationTime
-        'change number of Slices
-        If DeltaZ > 0 Then
-            Lsm5.DsRecording.FramesPerStack = CLng(DeltaZ / Recording.FrameSpacing) + 1
+    'Check if there is an existing document then start acquisition
+    Set node = viewerGuiServer.ExperimentTreeNodeSelected
+    If Not node Is Nothing Then
+        If node.type <> eExperimentTeeeNodeTypeLsm Then
+            Lsm5.NewScanWindow
         End If
+        Set RecordingDoc = Lsm5.DsRecordingActiveDocObject
     End If
-    If Not ScanStop Then
-        ActivateAlterAcquisitionTrack = FunSuccess
+    If Not AutofocusButtonRun(RecordingDoc, GlobalDataBaseName) Then
+        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
+        StopAcquisition
     End If
-End Function
+    AutofocusForm.RestoreAcquisitionParameters
+End Sub
 
 
 
-'''''''''
-' ActivateMicropilotTrack()
-' Micropilotpage. This is extra track for micropilot
-' TODO: Test and change name
-''''''''''
-Private Function ActivateBleachTrack(Recording As DsRecording, Optional DeltaZ As Double = -1) As Boolean
-    Dim i As Integer
-    Dim FunSuccess As Boolean
-    Dim ToActivate() As Boolean
-    ReDim ToActivate(1 To TrackNumber)
-    
-    FunSuccess = False
-    ' Set all tracks to non-acquisition first
-
-    For i = 1 To TrackNumber
-        ToActivate(i) = False
-        If BleachTrack1.Value = True And i = 1 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf BleachTrack2.Value = True And i = 2 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf BleachTrack3.Value = True And i = 3 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf BleachTrack4.Value = True And i = 4 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        End If
-    Next i
-    
-    If FunSuccess Then
-        If BleachZSlices.Value = 1 Then
-            Recording.ScanMode = "Plane"
-        Else
-            Recording.ScanMode = "Stack"
-        End If
-        Recording.SamplesPerLine = BleachFrameSize.Value
-        Recording.LinesPerFrame = BleachFrameSize.Value
-        Recording.ZoomX = BleachZoom.Value
-        Recording.ZoomY = BleachZoom.Value
-        Recording.FramesPerStack = BleachZSlices.Value
-        Recording.FrameSpacing = BleachZStep.Value
-        Recording.StacksPerRecord = BleachRepetitions.Value
-        Set Track = Recording.TrackObjectBleach(Success)
-        If Success Then
-            Track.Acquire = True
-            Track.UseBleachParameters = True            'Bleach parameters are lasers lines, bleach iterations... stored in the bleach control window
-        End If
-        
-        Lsm5.DsRecording.Copy Recording
-        
-        Lsm5.DsRecording.TimeSeries = True
-
 
 
-        'set the correct dwelltime
-        For i = 1 To TrackNumber
-            Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, 1).Acquire = ToActivate(i)
-        Next i
-        Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime = GlobalBackupSampleObservationTime
-        Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).TimeBetweenStacks = BleachRepetitionTime.Value
-    Else
-        Exit Function
-    End If
-    If Not ScanStop Then
-        ActivateBleachTrack = FunSuccess
-    End If
-End Function
-
 
 
-'''''''''
-' ActivateBleachTrack()
-' Micropilotpage. This is extra track for micropilot
-' TODO: Test and change name
-''''''''''
-Private Function ActivateMicropilotTrack(Recording As DsRecording, Optional DeltaZ As Double = -1) As Boolean
-    Dim i As Integer
-    Dim FunSuccess As Boolean
-    Dim ToActivate() As Boolean
-    ReDim ToActivate(1 To TrackNumber)
-    
-    FunSuccess = False
-    ' Set all tracks to non-acquisition first
-
-    For i = 1 To TrackNumber
-        ToActivate(i) = False
-        If MicropilotTrack1.Value = True And i = 1 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf MicropilotTrack2.Value = True And i = 2 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf MicropilotTrack3.Value = True And i = 3 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        ElseIf MicropilotTrack4.Value = True And i = 4 Then
-            ToActivate(i) = True
-            FunSuccess = True
-        End If
-    Next i
-    
-    If FunSuccess Then
-        Recording.ScanMode = "Stack"
-        Recording.SamplesPerLine = MicropilotFrameSize.Value
-        Recording.LinesPerFrame = MicropilotFrameSize.Value
-        Recording.ZoomX = MicropilotZoom.Value
-        Recording.ZoomY = MicropilotZoom.Value
-        Recording.FrameSpacing = MicropilotZStep.Value
-        Recording.FramesPerStack = MicropilotZSlices.Value
+'''''''
+'   AutofocusButtonRun (Optional AutofocusDoc As DsRecordingDoc = Nothing) As Boolean
+'   Runs a Z-stacks, compute center of mass, if selected acquire an image at computed position + ZOffset
+'   If AutofocusTrackZ : position is updated to computed position from autofocus (without ZOffset!)
+'   If AutofocusTrackXY and FrameToggle: position of X and Y are changed
+'       [AutofocusDoc] - A recording Doc. If = Nothing then it will create a new recording
+'
+'   Additional comments: The function works best with piezo. With Fast-Zline (Onthefly) acquisition is less precise
+'                        Lots of test to check that focus returned to workingposition. Lsm5.Hardware.CpFocus.Position
+'                        does not give actual position when stage is moving after acquisition.
+'                        Lsm5.DsRecording.Sample0Z provides the actual shift to the central slice
+''''''''
+Private Function AutofocusButtonRun(Optional AutofocusDoc As DsRecordingDoc = Nothing, Optional FilePath As String = "") As Boolean
+    Running = True
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    Dim StgPos As Vector
+    Dim newStgPos As Vector
+    Dim posTempZ  As Double
+    Dim FileName As String
+    Dim Time As Double
+    Dim NewCoord() As Double
+    Dim deltaZ As Double
+    Dim Sample0Z As Double ' test variable
+    Dim pos As Double ' test variable for position
+    Dim LogMsg  As String
+    Dim SuccessRecenter As Boolean
+    DisplayProgress "Autofocus move initial position", RGB(0, &HC0, 0)
+    Dim JobName As String
+    StopAcquisition
+    ' Recenter and move where it should be
+    posTempZ = Lsm5.Hardware.CpFocus.position
     
-        Lsm5.DsRecording.Copy Recording
-        Lsm5.DsRecording.TimeSeries = True
-        Lsm5.DsRecording.StacksPerRecord = 1
-        Lsm5.DsRecording.FrameSpacing = MicropilotZStep.Value
-        Lsm5.DsRecording.FramesPerStack = MicropilotZSlices.Value
+    StgPos.Z = posTempZ
+    StgPos.X = Lsm5.Hardware.CpStages.PositionX
+    StgPos.Y = Lsm5.Hardware.CpStages.PositionY
     
+    OiaSettings.resetRegistry
     
-        Lsm5.DsRecording.ScanMode = "Stack"
-        If AutofocusHRZ.Value Then
-            Lsm5.DsRecording.SpecialScanMode = "ZScanner"
-        Else
-            Lsm5.DsRecording.SpecialScanMode = "FocusStep"
-        End If
-        'set the correct dwelltime
-        For i = 1 To TrackNumber
-            Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, 1).Acquire = ToActivate(i)
-        Next i
-        Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime = GlobalBackupSampleObservationTime
-        If DeltaZ > 0 Then
-            Lsm5.DsRecording.FramesPerStack = CLng(DeltaZ / Recording.FrameSpacing) + 1
+    FileName = "AF_T000" & imgFileExtension
+
+    'recenter only after activation of new track
+    If AutofocusActive Then
+        JobName = "Autofocus"
+        ExecuteJob JobName, AutofocusDoc, FilePath, FileName, StgPos, CInt(deltaZ)
+        StgPos = TrackOffLine(JobName, AutofocusDoc, StgPos)
+        If AutofocusForm.Controls(JobName + "OiaActive") And AutofocusForm.Controls(JobName + "OiaSequential") Then
+            OiaSettings.writeKeyToRegistry "codeOia", "newImage"
+            newStgPos = ComputeJobSequential(JobName, "Global", StgPos, FilePath, FileName, AutofocusDoc)
+            If Not checkForMaximalDisplacement(JobName, StgPos, newStgPos) Then
+                newStgPos = StgPos
+            End If
+                
+            Debug.Print "X =" & StgPos.X & ", " & newStgPos.X & ", " & StgPos.Y & ", " & newStgPos.Y & ", " & StgPos.Z & ", " & newStgPos.Z
+            StgPos = TrackJob(JobName, StgPos, newStgPos)
+        End If
+    End If
+    
+    If AcquisitionActive Then
+        FileName = "AQ_T000" & imgFileExtension
+        JobName = "Acquisition"
+        StgPos.Z = StgPos.Z + AcquisitionZOffset.Value
+        ExecuteJob JobName, AutofocusDoc, FilePath, FileName, StgPos, CInt(deltaZ)
+        StgPos = TrackOffLine(JobName, AutofocusDoc, StgPos)
+        If AutofocusForm.Controls(JobName + "OiaActive") And AutofocusForm.Controls(JobName + "OiaSequential") Then
+            OiaSettings.writeKeyToRegistry "codeOia", "newImage"
+            newStgPos = ComputeJobSequential(JobName, "Global", StgPos, FilePath, FileName, AutofocusDoc)
+            If Not checkForMaximalDisplacement(JobName, StgPos, newStgPos) Then
+                newStgPos = StgPos
+            End If
+                
+            Debug.Print "X =" & StgPos.X & ", " & newStgPos.X & ", " & StgPos.Y & ", " & newStgPos.Y & ", " & StgPos.Z & ", " & newStgPos.Z
+            StgPos = TrackJob(JobName, StgPos, newStgPos)
         End If
+        StgPos.Z = StgPos.Z - AcquisitionZOffset.Value
+        
     End If
-    If Not ScanStop Then
-        ActivateMicropilotTrack = FunSuccess
+    
+    If AlterAcquisitionActive Then
+        FileName = "AL_T000" & imgFileExtension
+        JobName = "AlterAcquisition"
+        StgPos.Z = StgPos.Z + AlterAcquisitionZOffset.Value
+        ExecuteJob JobName, AutofocusDoc, FilePath, FileName, StgPos, CInt(deltaZ)
+         StgPos = TrackOffLine(JobName, AutofocusDoc, StgPos)
+        If AutofocusForm.Controls(JobName + "OiaActive") And AutofocusForm.Controls(JobName + "OiaSequential") Then
+            OiaSettings.writeKeyToRegistry "codeOia", "newImage"
+            newStgPos = ComputeJobSequential(JobName, "Global", StgPos, FilePath, FileName, AutofocusDoc)
+            If Not checkForMaximalDisplacement(JobName, StgPos, newStgPos) Then
+                newStgPos = StgPos
+            End If
+                
+            Debug.Print "X =" & StgPos.X & ", " & newStgPos.X & ", " & StgPos.Y & ", " & newStgPos.Y & ", " & StgPos.Z & ", " & newStgPos.Z
+            StgPos = TrackJob(JobName, StgPos, newStgPos)
+        End If
+        StgPos.Z = StgPos.Z - AlterAcquisitionZOffset.Value
     End If
-End Function
 
-' TODO a long does it wait
-'Wait time in sec?
-Sub Wait(PauseTime As Single)
-    Dim Start As Single
-    Start = Timer   ' Set start time.
-    Do While Timer < Start + PauseTime
-       DoEvents    ' Yield to other processes.
-       'Lsm5.DsRecording.StartScanTriggerIn
-    Loop
-End Sub
+    Recenter_post posTempZ, True, ZENv
+    FailSafeMoveStageZ StgPos.Z
+    Recenter_post StgPos.Z, True, ZENv
+    If ZENv > 2010 Then
+        ZEN.gui.Acquisition.ZStack.CenterPositionZ.Value = StgPos.Z
+    End If
+    AutofocusButtonRun = True
 
+End Function
 
-Public Sub SetBlockValues()
-'    Dim Position As Long
-'    Dim Range As Double
- 
-    AutofocusMaxSpeed.Value = BlockHighSpeed
-    AutofocusLowZoom.Value = BlockLowZoom
-    AutofocusHRZ.Value = BlockHRZ
-'    Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-'    If Position >= 0 Then
-'        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-'    Else
-'        Range = 0#
-'    End If
-'substituted29.06.2010 by Function Range
-    If AutofocusZRange.Value > Range() * 0.9 Then
-        AutofocusZRange.Value = Range() * 0.9
-    End If
-    If Abs(AutofocusZOffset.Value) > Range() * 0.9 Then
-        AutofocusZOffset.Value = 0
-    End If
-    AutofocusZOffset.Value = AutofocusZOffset.Value
-    AutofocusZRange.Value = AutofocusZRange.Value
-    AutofocusZStep.Value = BlockZStep
 
-End Sub
 
 
 '''''
-' TODO: All block values should use the checkboxes directly
+'   StartButton_Click()
 '''''
-Public Sub GetBlockValues()
-   
-    BlockHighSpeed = AutofocusMaxSpeed.Value
-    BlockLowZoom = AutofocusLowZoom.Value
-    HRZ = AutofocusHRZ.Value  ' this is for the piezo
-    BlockZOffset = AutofocusZOffset.Value
-    BlockZRange = AutofocusZRange.Value
-    BlockZStep = AutofocusZStep.Value
+Private Sub StartButton_Click()
+    DisplayProgress "Prepare acquisition...", RGB(&HC0, &HC0, 0)
+    If Not StartSetting() Then
+        DisplayProgress "Problems in creating settings (StartSetting). Stopped", RGB(&HC0, 0, 0)
+        StopAcquisition
+        AutofocusForm.RestoreAcquisitionParameters
+        Exit Sub
+    End If
+    Grids.updateGridSize "Trigger1", 0, 0, 0, 0
+    Grids.updateGridSize "Trigger2", 0, 0, 0, 0
+    
+    Running = True
+    ChangeButtonStatus False
+    ErrorLog.ResetLog
+    
+    InitializeStageProperties
+    SetStageSpeed 9, True    'What do we do here
+    'block usage of grid during acquisition
+    AutofocusForm.SwitchEnableGridScanPage False
+    
+    ''Force creation of GUI entry of recording documents if they are missing
+    If Lsm5.Info.IsFCS Then
+        If Fcs1Active Then
+            NewFcsRecordGui GlobalFcsRecordingDoc, GlobalFcsData, "MacroFcs", ZEN, ZENv
+            'Sleep (1000)
+        End If
+    End If
+    NewRecordGui GlobalRecordingDoc, "MacroImaging", ZEN, ZENv
 
+    If Not StartJobOnGrid("Global", "Global", GlobalRecordingDoc, GlobalDataBaseName) Then  'This is the main function of the macro
+        StopAcquisition
+    End If
+    AutofocusForm.RestoreAcquisitionParameters
+    
 End Sub
 
 
-
-Private Function TimeDisplay(Value As Double) As String         'Calculates the String to display in a "user frindly format". Value is in seconds
-    Dim Hour, Min As Integer
-    Dim Sec As Double
-
-    Hour = Int(Value / 3600)                                        'calculates number of full hours                           '
-    Min = Int(Value / 60) - (60 * Hour)                             'calculates number of left minutes
-    Sec = (Fix((Value - (60 * Min) - (3600 * Hour)) * 100)) / 100   'calculates the number of left seconds
-    If (Hour = 0) And (Min = 0) Then                                'Defines a "user friendly" string to display the time
-        TimeDisplay = Sec & " sec"
-    ElseIf (Hour = 0) And (Sec = 0) Then
-        TimeDisplay = Min & " min"
-    ElseIf (Hour = 0) Then
-        TimeDisplay = Min & " min " & Sec
+''''''
+'   StartSetting()
+'   Setups and controls before start of experiment
+'       Create list of positions for Grid or Multiposition
+''''''
+Private Function StartSetting() As Boolean
+    Dim i As Integer
+    Dim initPos As Boolean   'if False and gridsize correspond positions are taken from file positionsGrid.csv
+    Dim SuccessRecenter As Boolean
+    Dim pos() As Vector
+    
+    
+    initPos = True
+    StartSetting = False
+    Set FileSystem = New FileSystemObject
+    
+    Dim MarkCount As Long
+    MarkCount = Lsm5.Hardware.CpStages.MarkCount
+    
+    If MultipleLocationToggle.Value And MarkCount < 1 Then
+        MsgBox ("Select at least one location in the stage control window, or uncheck the multiple location button")
+        Exit Function
+    End If
+    'This loads value of Databasename
+    SetDatabase
+    If GlobalDataBaseName = "" Then
+        MsgBox ("No outputfolder selected ! Cannot start acquisition.")
+        Exit Function
     Else
-        TimeDisplay = Hour & " h " & Min
+        If Not CheckDir(GlobalDataBaseName) Then
+            Exit Function
+        End If
+        LogFileNameBase = GlobalDataBaseName & "\AutofocusScreen.log"
+        ErrFileNameBase = GlobalDataBaseName & "\AutofocusScreen.err"
+        If LogCode And LogFileNameBase <> "" Then
+            'On Error GoTo ErrorHandleLogFile
+            LogFileName = LogFileNameBase
+            ErrFileName = ErrFileNameBase
+            Close
+            If SafeOpenTextFile(LogFileName, LogFile, FileSystem) And SafeOpenTextFile(ErrFileName, ErrFile, FileSystem) Then
+                LogFile.WriteLine "% ZEN software version " & ZENv & " " & Version
+                ErrFile.WriteLine "% ZEN software version " & ZENv & " " & Version
+            
+                LogFile.Close
+                ErrFile.Close
+                Log = True
+            Else
+                Log = False
+            End If
+        Else
+            Log = False
+        End If
     End If
-End Function
-
-
-Public Function AcquisitionTime() As Double
-    Dim Track1Speed, Track2Speed, Track3Speed, Track4Speed As Double
-    Dim Pixels As Long
-    Dim FrameNumber As Integer
-    Dim ScanDirection As Integer
-    Dim i As Integer
-   
-    Track1Speed = 0
-    Track2Speed = 0
-    Track3Speed = 0
-    Track4Speed = 0
-    If AcquisitionTrack1.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, Success)
-        Track1Speed = Track.SampleObservationTime
+    SetFileName
+    If Not AcquisitionTracksOn And Not AutofocusActive And Not AlterAcquisitionActive Then
+        MsgBox ("Nothing to do! Check at least one imaging option!")
+        Exit Function
     End If
-    If AcquisitionTrack2.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-        Track2Speed = Track.SampleObservationTime
+    
+    ' do not log if logfilename has not been defined
+    If LogCode And LogFileName = "" Then
+        Log = False
     End If
-    If AcquisitionTrack3.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(2, Success)
-        Track3Speed = Track.SampleObservationTime
+    'As default we do not overwrite files
+    OverwriteFiles = False
+    
+    If MultipleLocationToggle Then
+        If GridScanActive Then
+            If MarkCount = 0 Then  ' No marked position
+                MsgBox "GridScan: Use stage to Mark at least the initial position "
+                Exit Function
+            End If
+            GridScan_nColumn.Value = MarkCount
+            GridScan_nRow.Value = 1
+            Grids.updateGridSize "Global", GridScan_nRow, GridScan_nColumn, GridScan_nRowsub, GridScan_nColumnsub
+        Else
+            Grids.updateGridSize "Global", 1, MarkCount, 1, 1
+        End If
     End If
-    If AcquisitionTrack4.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(3, Success)
-        Track4Speed = Track.SampleObservationTime
+    
+    If SingleLocationToggle Then
+        If GridScanActive Then
+            If MarkCount = 0 Then  ' No marked position
+                MsgBox "GridScan: Use stage to Mark at least the initial position "
+                Exit Function
+            End If
+            ReDim pos(0)
+            Lsm5.Hardware.CpStages.MarkGetZ 0, pos(0).X, pos(0).Y, pos(0).Z
+            Grids.makeGridFromOnePt "Global", pos(0), GridScan_nRow.Value, GridScan_nColumn.Value, _
+            GridScan_nRowsub.Value, GridScan_nColumnsub.Value, GridScan_dRow.Value, GridScan_dColumn.Value, _
+            GridScan_dRowsub.Value, GridScan_dColumnsub.Value, GridScan_refRow.Value, GridScan_refColumn.Value
+            DisplayProgress "Initialize all grid positions...DONE", RGB(0, &HC0, 0)
+        Else
+            ReDim pos(0)
+            Lsm5.Hardware.CpStages.GetXYPosition pos(0).X, pos(0).Y
+            pos(0).Z = Lsm5.Hardware.CpFocus.position
+            Grids.makeGridFromOnePt "Global", pos(0), 1, 1, 1, 1, 0, 0, 0, 0
+        End If
+        GoTo GridReady
     End If
-    Pixels = Lsm5.DsRecording.LinesPerFrame * Lsm5.DsRecording.SamplesPerLine
-    FrameNumber = Lsm5.DsRecording.FramesPerStack
-    If Lsm5.DsRecording.ScanDirection = 0 Then
-        ScanDirection = 1
-    Else
-        ScanDirection = 2
+    
+   
+        
+    
+    If GridScan_nColumn.Value * GridScan_nRow.Value * GridScan_nColumnsub.Value * GridScan_nRowsub.Value > 10000 Then
+        MsgBox "GridScan: Maximal number of locations is 10000. Please change Numbers  X and/or Y."
+        Exit Function
     End If
-    AcquisitionTime = (Track1Speed + Track2Speed + Track3Speed + Track4Speed) * Pixels * FrameNumber / ScanDirection * 3.3485
-End Function
-
-
-
-Private Sub AcquisitionTrack1_Change()
-    TrackingToggle.Enabled = AcquisitionTracksOn
-    If Not TrackingToggle.Enabled Then
-        TrackingToggle.Value = False
+    
+    
+    If GridScanPositionFile <> "" Then
+        If Grids.isPositionGridFile("Global", GridScanPositionFile, Grids.numRow("Global"), Grids.numCol("Global"), _
+        Grids.numRowSub("Global"), Grids.numCol("Global")) Then
+            If Grids.loadPositionGridFile("Global", GridScanPositionFile) Then
+                DisplayProgress "Loading grid positions from file. " & GridScanPositionFile & "....", RGB(0, &HC0, 0)
+                initPos = False
+            Else
+                MsgBox "Not able to use " & GridScanPositionFile & ". Resetting the positions."
+            End If
+        End If
     End If
-    SwitchEnableTrackingToggle TrackingToggle.Value
-End Sub
-
-Private Sub AcquisitionTrack2_Change()
-    TrackingToggle.Enabled = AcquisitionTracksOn
-    If Not TrackingToggle.Enabled Then
-        TrackingToggle.Value = False
+        
+    If initPos Then
+            DisplayProgress "Initialize all positions....", RGB(0, &HC0, 0)
+            If MultipleLocationToggle.Value Then
+                ReDim pos(MarkCount - 1)
+                For i = 0 To MarkCount - 1
+                    Lsm5.Hardware.CpStages.MarkGetZ i, pos(i).X, pos(i).Y, pos(i).Z
+                Next i
+                Grids.makeGridFromManyPts "Global", pos, 1, MarkCount, GridScan_nRowsub.Value, GridScan_nColumnsub.Value, GridScan_dRowsub.Value, GridScan_dColumnsub.Value
+            Else
+                ReDim pos(0)
+                Lsm5.Hardware.CpStages.MarkGetZ 0, pos(0).X, pos(0).Y, pos(0).Z
+                Grids.makeGridFromOnePt "Global", pos(0), GridScan_nRow.Value, GridScan_nColumn.Value, _
+                GridScan_nRowsub.Value, GridScan_nColumnsub.Value, GridScan_dRow.Value, GridScan_dColumn.Value, _
+                GridScan_dRowsub.Value, GridScan_dColumnsub.Value, GridScan_refRow.Value, GridScan_refColumn.Value
+                DisplayProgress "Initialize all grid positions...DONE", RGB(0, &HC0, 0)
+            End If
     End If
-    SwitchEnableTrackingToggle TrackingToggle.Value
-End Sub
-
-Private Sub AcquisitionTrack3_Change()
-    TrackingToggle.Enabled = AcquisitionTracksOn
-    If Not TrackingToggle.Enabled Then
-        TrackingToggle.Value = False
+        
+    
+    If GridScanValidFile <> "" Then
+        Dim FormatValidFile As String
+        FormatValidFile = Grids.isValidGridFile("Global", GridScanValidFile, GridScan_nRow, GridScan_nColumn, GridScan_nRowsub, GridScan_nColumnsub)
+        If Grids.loadValidGridFile(Name, GridScanValidFile, FormatValidFile) Then
+            
+        Else
+            MsgBox "Not able to use " & GridScanValidFile & " for loading valid positions."
+        End If
     End If
-    SwitchEnableTrackingToggle TrackingToggle.Value
-End Sub
 
-Private Sub AcquisitionTrack4_Change()
-    TrackingToggle.Enabled = AcquisitionTracksOn
-    If Not TrackingToggle.Enabled Then
-        TrackingToggle.Value = False
-    End If
-    SwitchEnableTrackingToggle TrackingToggle.Value
-End Sub
+GridReady:
+    Grids.writePositionGridFile "Global", GlobalDataBaseName & "positionsGrid.csv"
+    Grids.writeValidGridFile "Global", GlobalDataBaseName & "validGrid.csv"
 
-''''
-'  AcquisitionTracksOn()
-'  Checks if at least one track for acquisition is on
-'''
-Private Function AcquisitionTracksOn() As Boolean
-    If AcquisitionTrack1 Then
-        AcquisitionTracksOn = True
-    End If
-    If AcquisitionTrack2 Then
-        AcquisitionTracksOn = True
-    End If
-    If AcquisitionTrack3 Then
-        AcquisitionTracksOn = True
-    End If
-    If AcquisitionTrack4 Then
-        AcquisitionTracksOn = True
+    'SaveSettings
+    If GlobalDataBaseName <> "" Then
+        SetDatabase
+        SaveFormSettings GlobalDataBaseName & "\AutofocusScreen.ini"
     End If
+    StartSetting = True
+    Exit Function
+ErrorHandleDataBase:
+    MsgBox "Could not create directory " & GlobalDataBaseName
+    Exit Function
+ErrorHandleLogFile:
+    MsgBox "Could not create LogFile " & LogFileName
+    Exit Function
 End Function
 
-'''
-' Sets all acquisitions to off
-'''
-Private Function AcquisitionTracksSetOff() As Boolean
-    AcquisitionTrack1.Value = 0
-    AcquisitionTrack2.Value = 0
-    AcquisitionTrack3.Value = 0
-    AcquisitionTrack4.Value = 0
-End Function
 
-Public Function AutofocusTime() As Double
-    Dim Speed As Double
-    Dim Pixels As Long
-    Dim FrameNumber As Integer
-    Dim ScanDirection As Integer
-    Dim i As Integer
 
-    Speed = 0
-    If AutofocusMaxSpeed.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, Success)
-        Speed = 1.76 * 10 ^ -6
-    Else
-        If AutofocusTrack1.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-            Speed = Track.SampleObservationTime
+    
+
+
+'''''
+'   Pause()
+'   Function called when ScanPause = True
+'   Checks state and wait for action in Form
+'''''
+Public Function Pause() As Boolean
+    
+    Dim rettime As Double
+    Dim GlobalPrvTime As Double
+    Dim DiffTime As Double
+    
+    GlobalPrvTime = CDbl(GetTickCount) * 0.001
+    rettime = GlobalPrvTime
+    DiffTime = rettime - GlobalPrvTime
+    'TODO: test this function
+    DoEvents
+    Do While True
+        Sleep (100)
+        DoEvents
+        If ScanStop Then
+            Exit Function
+        End If
+        If ScanPause = False Then
+            Pause = True
+            Exit Function
         End If
-        If AutofocusTrack2.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-            Speed = Track.SampleObservationTime
+
+        DisplayProgress "Pause " & CStr(CInt(DiffTime)) & " s", RGB(&HC0, &HC0, 0)
+        rettime = CDbl(GetTickCount) * 0.001
+        DiffTime = rettime - GlobalPrvTime
+    Loop
+End Function
+
+
+
+
+
+  
+
+'''''
+'   AutoFindTracks()
+'   Set the names of the tracks and find possible tracks
+'''''
+Public Sub AutoFindTracks()
+    Dim Track As DsTrack
+    Dim Success As Integer
+    Dim i, j As Integer
+    Dim ChannelOK As Boolean
+    Dim MaxTracks As Integer
+    Dim iTrack As Integer
+    Dim Name As Variant
+    Dim ActiveJobTracks As Collection
+    Dim Active() As Boolean
+    Set ActiveJobTracks = New Collection
+
+    
+    For Each Name In JobNames
+        ReDim Active(3)
+        For i = 1 To 4
+            Active(i - 1) = Me.Controls(Name + "Track" + CStr(i)).Value
+            Me.Controls(Name + "Track" + CStr(i)).Visible = False
+            Me.Controls(Name + "Track" + CStr(i)).Value = False
+        Next i
+        ActiveJobTracks.Add Active, Name
+    Next Name
+
+    
+    'The next line and the following "if" should be removed when working with the LSM 2.8 software (where the lambda mode is not defined)
+    Set Track = Lsm5.DsRecording.TrackObjectLambda(Success)
+    If Success Then
+        If Track.Acquire Then
+            MsgBox ("This macro does not work in the Lambda Mode. Please switch to the Channel Mode and reinitialize the Macro.")
+            Exit Sub
         End If
-        If AutofocusTrack3.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-            Speed = Track.SampleObservationTime
+    End If
+    
+    'ConfiguredTracks = Lsm5.DsRecording.TrackCount
+    MaxTracks = Lsm5.DsRecording.GetNormalTrackCount
+    If MaxTracks > 4 Then
+        MsgBox ("This Macro only accepts 4 different tracks")
+    End If
+
+    iTrack = 1
+    For i = 0 To MaxTracks - 1
+        If iTrack < 5 Then
+            ChannelOK = False
+            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i, Success)
+            For j = 0 To Track.DataChannelCount - 1
+                If Track.DataChannelObjectByIndex(j, Success).Acquire = True Then
+                    ChannelOK = True
+                End If
+            Next j
+            If ChannelOK And (Not Track.IsLambdaTrack) And (Not Track.IsBleachTrack) Then
+                For Each Name In JobNames
+                    Me.Controls(Name + "Track" + CStr(iTrack)).Visible = True
+                    Me.Controls(Name + "Track" + CStr(iTrack)).Value = ActiveJobTracks(Name)(i)
+                    Me.Controls(Name + "Track" + CStr(iTrack)).Caption = Track.Name
+                Next Name
+                iTrack = iTrack + 1
+            End If
         End If
-        If AutofocusTrack4.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-            Speed = Track.SampleObservationTime
+    Next i
+        
+    If iTrack < 5 Then
+        TrackNumber = iTrack - 1
+    Else
+        TrackNumber = 4
+    End If
+End Sub
+
+
+
+
+
+Private Sub CloseButton_Click()
+    RestoreAcquisitionParameters
+    Sleep (1000)
+    End
+End Sub
+
+Private Sub ReInitializeButton_Click()
+    Re_Initialize
+End Sub
+
+
+Private Sub CreditButton_Click()
+    CreditForm.Show
+End Sub
+
+
+
+
+
+
+Private Sub TextBoxFileName_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
+    If KeyCode = 13 Then 'this is the enter key
+        SetFileName
+    End If
+End Sub
+
+Private Sub SetFileName()
+    If TextBoxFileName.Value <> "" Then
+        If Right(TextBoxFileName.Value, 1) <> "_" Then
+            TextBoxFileName.Value = TextBoxFileName.Value & "_"
         End If
     End If
-    Pixels = 512
-    AutofocusForm.GetBlockValues
-    FrameNumber = CLng(AutofocusZRange.Value / AutofocusZStep.Value) + 1
+End Sub
+
+Private Sub fileFormatlsm_Click()
+    imgFileFormat = eAimExportFormatLsm5
+    imgFileExtension = ".lsm"
+End Sub
+
+Private Sub fileFormatczi_Click()
+    imgFileFormat = eAimExportFormatCzi
+    imgFileExtension = ".czi"
+End Sub
+ 
+'''''''
+
+' TODO a long does it wait
+'Wait time in sec?
+Sub wait(PauseTime As Single)
+    Dim Start As Single
+    Start = Timer   ' Set start time.
+    Do While Timer < Start + PauseTime
+       DoEvents    ' Yield to other processes.
+       'Lsm5.DsRecording.StartScanTriggerIn
+    Loop
+End Sub
+
+
+
+
+Private Function TimeDisplay(Value As Double) As String         'Calculates the String to display in a "user frindly format". Value is in seconds
+    Dim Hour, MIN As Integer
+    Dim Sec As Double
+
+    Hour = Int(Value / 3600)                                        'calculates number of full hours                           '
+    MIN = Int(Value / 60) - (60 * Hour)                             'calculates number of left minutes
+    Sec = (Fix((Value - (60 * MIN) - (3600 * Hour)) * 100)) / 100   'calculates the number of left seconds
+    If (Hour = 0) And (MIN = 0) Then                                'Defines a "user friendly" string to display the time
+        TimeDisplay = Sec & " sec"
+    ElseIf (Hour = 0) And (Sec = 0) Then
+        TimeDisplay = MIN & " min"
+    ElseIf (Hour = 0) Then
+        TimeDisplay = MIN & " min " & Sec
+    Else
+        TimeDisplay = Hour & " h " & MIN
+    End If
+End Function
+
+
+Public Function AcquisitionTime() As Double
+    Dim Track As DsTrack
+    Dim Success As Integer
+    Dim Track1Speed, Track2Speed, Track3Speed, Track4Speed As Double
+    Dim Pixels As Long
+    Dim FrameNumber As Integer
+    Dim ScanDirection As Integer
+    Dim i As Integer
+   
+    Track1Speed = 0
+    Track2Speed = 0
+    Track3Speed = 0
+    Track4Speed = 0
+    If AcquisitionTrack1.Value = True Then
+        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, Success)
+        Track1Speed = Track.SampleObservationTime
+    End If
+    If AcquisitionTrack2.Value = True Then
+        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
+        Track2Speed = Track.SampleObservationTime
+    End If
+    If AcquisitionTrack3.Value = True Then
+        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(2, Success)
+        Track3Speed = Track.SampleObservationTime
+    End If
+    If AcquisitionTrack4.Value = True Then
+        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(3, Success)
+        Track4Speed = Track.SampleObservationTime
+    End If
+    Pixels = Lsm5.DsRecording.LinesPerFrame * Lsm5.DsRecording.SamplesPerLine
+    FrameNumber = Lsm5.DsRecording.framesPerStack
     If Lsm5.DsRecording.ScanDirection = 0 Then
         ScanDirection = 1
     Else
         ScanDirection = 2
     End If
-    If AutofocusHRZ.Value = True Then
-        AutofocusTime = Speed * Pixels * FrameNumber * 3.3485 + 4.9
-    Else
-        AutofocusTime = Speed * Pixels * FrameNumber / ScanDirection * 3.3485 + 4.9
-    End If
+    AcquisitionTime = (Track1Speed + Track2Speed + Track3Speed + Track4Speed) * Pixels * FrameNumber / ScanDirection * 3.3485
 End Function
 
 
 
 
+
+
+
+
 ''''''
 '    CheckAutofocusTrack( SelectedTrack As Integer )
 '    Checks whether the track that was selected for autofocusing only contains a single channel (alternetivly defines one of the checked channels)
@@ -4100,6 +2273,7 @@ End Function
 '       [SelectedTrack] In - Number of selected track
 ''''''
 Private Sub CheckAutofocusTrack(SelectedTrack As Integer)
+    Dim Success As Integer
     Dim Track As DsTrack 'a new track is defined
     Dim DataChannel As DsDataChannel    'a new interface to a data channel is defined
                                         'contains channel dependend parameters of the
@@ -4119,7 +2293,7 @@ Private Sub CheckAutofocusTrack(SelectedTrack As Integer)
         Set DataChannel = Track.DataChannelObjectByIndex(j, Success) 'data channel corresponding to loop index is analysed
         If DataChannel.Acquire = True Then  'checks whether the data channel corresponding to loop index is activated
             ActiveChannelNumber = ActiveChannelNumber + 1 'counts the number of activated channels
-            If ActiveChannelNumber = 1 Then AutofocusChannel = DataChannel.name 'Gets the name of the first activated channel
+            If ActiveChannelNumber = 1 Then AutofocusChannel = DataChannel.Name 'Gets the name of the first activated channel
         End If
     Next
     
@@ -4129,14 +2303,6 @@ Private Sub CheckAutofocusTrack(SelectedTrack As Integer)
 End Sub
 
 
-Public Function TotalTimeLeft() As Double
-    Dim Speed As Double
-    Dim Pixels As Long
-    Dim ScanDirection As Integer
-    Dim i As Integer
-    TotalTimeLeft = (AcquisitionTime + AutofocusTime + BlockTimeDelay) * (BlockRepetitions - RepetitionNumber + 1) - BlockTimeDelay
-End Function
-
 
 
 
@@ -4148,54 +2314,18 @@ End Function
 '''''
 Private Sub ChangeButtonStatus(Enable As Boolean)
     StartButton.Enabled = Enable
-    StartBleachButton.Enabled = Enable
+    AutofocusButton.Enabled = Enable
+    FocusMap.Enabled = Enable
+    GetCurrentPositionOffsetButton.Enabled = Enable
     CloseButton.Enabled = Enable
     ReinitializeButton.Enabled = Enable
 End Sub
 
 
-'''''
-' Sub StopScanCheck()
-' This stop all running scans. Check is the wrong name
-'''''
-Private Sub StopScanCheck()
-    Lsm5.StopScan
-    DoEvents
-End Sub
 
 
 
-''''
-' Not anymore in use
-''''
-Private Sub CreateZoomDatabase(ZoomDatabaseName, HighResExperimentCounter, ZoomExpname)
-            'Create ZoomDatabase
-            Dim Start As Integer
-            Dim bslash As String
-            Dim pos As Long
-            Dim NameLength As Long
-            Dim MyPath As String
-            
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, DatabaseTextbox.Value, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            
-            MyPath = DatabaseTextbox.Value + bslash
-            NameLength = Len(DatabaseTextbox.Value)
-            ZoomExpname = Strings.Right(DatabaseTextbox.Value, NameLength - Start + 1)
-           ' NameLength = Len(Myname)
-           ' Myname = Strings.Left(Myname, NameLength - 4)
-            ZoomDatabaseName = MyPath & ZoomExpname & "_" & TextBoxFileName.Value & LocationName & "_R" & RepetitionNumber & "_Exp" & HighResExperimentCounter & "_zoom"
-            ' Lsm5.NewDatabase (ZoomDatabaseName)
-           ' ZoomDatabaseName = ZoomDatabaseName & "\" & Myname & "_zoom.mdb"
-    
-End Sub
+
 
 Private Sub CreateAlterImageDatabase(AlterDatabaseName, MyPath)
         Dim Start As Integer
@@ -4226,41 +2356,7 @@ End Sub
 
 
 
-'''''
-'   Private Sub StartAlternativeImaging(RecordingDoc As DsRecordingDoc, StartTime As Double, _
-'   AlterDatabaseName As String, name As String)
-'   Alternative Acquisition in every .. round
-'   TODO: Bring it up to normal setting for all
-'''''
-Private Function StartAlternativeImaging(RecordingDoc As DsRecordingDoc, _
-FilePath As String, name As String) As Boolean
-    
-    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (20)
-            DoEvents
-            If ScanStop Then
-                Exit Function
-            End If
-        Wend
-    End If
-    DisplayProgress "Acquiring Additional Track...", RGB(0, &HC0, 0)
-    ' take the image
-    If Not ScanToImage(RecordingDoc) Then
-        ScanStop = True
-        Exit Function
-    End If
 
-    RecordingDoc.SetTitle name
-    
-    If Not SaveDsRecordingDoc(RecordingDoc, FilePath) Then
-        ScanStop = True
-        Exit Function
-    End If
-    StartAlternativeImaging = True
-End Function
 
 
 
@@ -4269,728 +2365,382 @@ End Function
 
 
 
-'''''
-' AFTest1_Click()
-' Perform repeatealy Autofocus with FastZline and acquisition with stage only.
-' Uses No Z-track and Z-track
-''''
-Private Sub AFTest1_Click()
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    AFTest1Run
-    StopAcquisition
-End Sub
+''''''
+''   CheckZRanges()
+''   Check if Z movements are in agreement with range of microscope
+''''''
+'Public Function CheckZRanges() As Boolean
+'    If ScanStop Then
+'        Exit Function
+'    End If
+'
+'    If Range() = 0 Then
+'        MsgBox "Objective's working distance not defined! Cannot Autofocus!"
+'        CheckZRanges = False
+'        Exit Function
+'    Else
+'        CheckZRanges = True
+'    End If
+'
+'    If AutofocusZRange.Value > Range() * 0.9 Then 'this is already tested in the slider could be removed
+'        AutofocusForm.AutofocusZRange.Value = Range() * 0.9
+'        MsgBox "Autofocus range is too large! Has been reduced to " + Str(AutofocusForm.AutofocusZRange.Value)
+'    End If
+'
+''    If Abs(AcquisitionZOffset.Value) > Range() * 0.9 Then 'this is already tested in the slider could be removed
+''        AutofocusForm.AcquisitionZOffset = 0
+''        MsgBox "ZOffset has to be less than the working distance of the objective: " + CStr(Range) + " um. Has been put back to " + Str(AutofocusForm.AutofocusZOffset)
+''    End If
+'
+'End Function
+  
 
-Private Function AFTest1Run() As Boolean
-    Running = True
-    Dim RecordingDoc As DsRecordingDoc
-    Dim FilePath As String
-    Dim MaxTestRepeats As Integer
-    Dim TestNr As Integer
-    Dim pixelDwell As Double
-    Dim i As Integer
-    Log = True
-    Dim Zold As Double
-    Zold = posTempZ
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No outputfolder selected ! Cannot start tests.")
-        Exit Function
-    End If
-    
-    'Setup a single recording doc
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    If Not CheckDir(GlobalDataBaseName) Then
-        Exit Function
-    End If
-        
-    AcquisitionTrack1.Value = AutofocusTrack1.Value
-    AcquisitionTrack2.Value = AutofocusTrack2.Value
-    AcquisitionTrack3.Value = AutofocusTrack3.Value
-    AcquisitionTrack4.Value = AutofocusTrack4.Value
-    AutofocusMaxSpeed.Value = True
-    AutofocusFastZline = True
-    AutofocusHRZ.Value = False
-    AutofocusLowZoom.Value = False
-        
-    '''''''
-    ' No Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = False
-    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
-    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
-    GlobalBackupRecording.SpecialScanMode = "FocusStep"
-    If Not RunTestAutofocusButton(RecordingDoc, True, AFTest_Repetitions.Value, "AFTest1_FastZLine_Stage_NoTrackZ") Then
-        Exit Function
-    End If
-    
-    '''''''
-    ' Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = True
-    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
-    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
-    GlobalBackupRecording.SpecialScanMode = "FocusStep"
-    If Not RunTestAutofocusButton(RecordingDoc, False, AFTest_Repetitions.Value, "AFTest1_FastZLine_Stage_TrackZ") Then
-        Exit Function
-    End If
-    
-    AFTest1Run = True
-End Function
 
 
-'''''
-' AFTest2_Click()
-' Perform repeatealy Autofocus with piezo and acquisition with piezo
-' Uses No Z-track and Z-track
-''''
-Private Sub AFTest2_Click()
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    AFTest2Run
-    StopAcquisition
-End Sub
 
-Private Function AFTest2Run() As Boolean
-    Running = True
-    Dim RecordingDoc As DsRecordingDoc
-    Log = True
-    If Not Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.name) Then
-        MsgBox ("No piezo availabe! Cannot start tests.")
-        Exit Function
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No outputfolder selected ! Cannot start tests.")
-        Exit Function
-    End If
-    
-    'Setup a single recording doc
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    If Not CheckDir(GlobalDataBaseName) Then
-        Exit Function
-    End If
-        
-    AcquisitionTrack1.Value = AutofocusTrack1.Value
-    AcquisitionTrack2.Value = AutofocusTrack2.Value
-    AcquisitionTrack3.Value = AutofocusTrack3.Value
-    AcquisitionTrack4.Value = AutofocusTrack4.Value
-    AutofocusMaxSpeed.Value = True
-    AutofocusFastZline = False
-    AutofocusHRZ.Value = True
-    AutofocusLowZoom.Value = False
-        
-    '''''''
-    ' No Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = False
-    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
-    GlobalAcquisitionRecording.SpecialScanMode = "ZScanner"
-    GlobalBackupRecording.SpecialScanMode = "ZScanner"
-    
-    If Not RunTestAutofocusButton(RecordingDoc, True, AFTest_Repetitions.Value, "AFTest2_Piezo_Piezo_NoTrackZ") Then
-        Exit Function
-    End If
-    
-    '''''''
-    ' Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = True
-    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
-    GlobalAcquisitionRecording.SpecialScanMode = "ZScanner"
-    GlobalBackupRecording.SpecialScanMode = "ZScanner"
-
-    If Not RunTestAutofocusButton(RecordingDoc, False, AFTest_Repetitions.Value, "AFTest2_Piezo_Piezo_TrackZ") Then
-        Exit Function
-    End If
-    AFTest2Run = True
-End Function
-
-
-'''''
-' AFTest3_Click()
-' Perform repeatealy Autofocus with stage and acquisition with stage
-' Uses No Z-track and Z-track
-''''
-Private Sub AFTest3_Click()
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    AFTest3Run
-    StopAcquisition
-End Sub
-
-Private Function AFTest3Run() As Boolean
-    Running = True
-    Dim RecordingDoc As DsRecordingDoc
-    Log = True
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No outputfolder selected ! Cannot start tests.")
-        Exit Function
-    End If
-    
-    'Setup a single recording doc
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    If Not CheckDir(GlobalDataBaseName) Then
-        Exit Function
-    End If
-        
-    AcquisitionTrack1.Value = AutofocusTrack1.Value
-    AcquisitionTrack2.Value = AutofocusTrack2.Value
-    AcquisitionTrack3.Value = AutofocusTrack3.Value
-    AcquisitionTrack4.Value = AutofocusTrack4.Value
-    AutofocusMaxSpeed.Value = True
-    AutofocusFastZline = False
-    AutofocusHRZ.Value = False
-    AutofocusLowZoom.Value = False
-        
-    '''''''
-    ' No Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = False
-    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
-    GlobalBackupRecording.SpecialScanMode = "FocusStep"
-    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
-    If Not RunTestAutofocusButton(RecordingDoc, True, AFTest_Repetitions.Value, "AFTest3_Stage_Stage_NoTrackZ") Then
-        Exit Function
-    End If
-    
-    '''''''
-    ' Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = True
-    GlobalBackupRecording.SpecialScanMode = "FocusStep"
-    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
-    If Not RunTestAutofocusButton(RecordingDoc, False, AFTest_Repetitions.Value, "AFTest3_Stage_Stage_TrackZ") Then
-        Exit Function
-    End If
-    AFTest3Run = True
-End Function
-
-'''''
-' AFTest4_Click()
-' Perform repeatealy Autofocus with piezo and acquisition with stage
-' Uses No Z-track and Z-track
-''''
-Private Sub AFTest4_Click()
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    AFTest4Run
-    StopAcquisition
-End Sub
-
-Private Function AFTest4Run() As Boolean
-    Running = True
-    Dim RecordingDoc As DsRecordingDoc
-    Log = True
-    If Not Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.name) Then
-        MsgBox ("No piezo availabe! Cannot start tests.")
-        Exit Function
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No outputfolder selected ! Cannot start tests.")
-        Exit Function
-    End If
-    
-    'Setup a single recording doc
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    If Not CheckDir(GlobalDataBaseName) Then
-        Exit Function
-    End If
-        
-    AcquisitionTrack1.Value = AutofocusTrack1.Value
-    AcquisitionTrack2.Value = AutofocusTrack2.Value
-    AcquisitionTrack3.Value = AutofocusTrack3.Value
-    AcquisitionTrack4.Value = AutofocusTrack4.Value
-    AutofocusMaxSpeed.Value = True
-    AutofocusFastZline = False
-    AutofocusHRZ.Value = True
-    AutofocusLowZoom.Value = False
-        
-    '''''''
-    ' No Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = False
-    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
-    GlobalBackupRecording.SpecialScanMode = "FocusStep"
-    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
-    
-    If Not RunTestAutofocusButton(RecordingDoc, True, AFTest_Repetitions.Value, "AFTest4_Piezo_Stage_NoTrackZ") Then
-        Exit Function
-    End If
-    
-    '''''''
-    ' Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = True
-    GlobalBackupRecording.SpecialScanMode = "FocusStep"
-    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
-    If Not RunTestAutofocusButton(RecordingDoc, False, AFTest_Repetitions.Value, "AFTest4_Piezo_Stage_TrackZ") Then
-        Exit Function
-    End If
-    AFTest4Run = True
-End Function
-
-
-'''''
-' AFTest5_Click()
-' Acquire reeatedly images with Fast-Z-Line
-''''
-Private Sub AFTest5_Click()
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    AFTest5Run
-    StopAcquisition
-End Sub
-
-Private Function AFTest5Run() As Boolean
-    Running = True
-    Dim RecordingDoc As DsRecordingDoc
-    
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No outputfolder selected ! Cannot start tests.")
-        Exit Function
-    End If
-    
-    'Setup a single recording doc
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    If Not CheckDir(GlobalDataBaseName) Then
-        Exit Function
-    End If
-
-    AutofocusTrackZ.Value = False
-    AcquisitionTrack1.Value = False
-    AcquisitionTrack2.Value = False
-    AcquisitionTrack3.Value = False
-    AcquisitionTrack4.Value = False
-    AutofocusMaxSpeed.Value = True
-    AutofocusHRZ.Value = False
-    AutofocusLowZoom.Value = False
-    AutofocusFastZline.Value = True
-    AutofocusLineSize.Value = 256
-    If Not RunTestFastZline(RecordingDoc, 1, AFTest_Repetitions.Value, 1, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-    AutofocusLineSize.Value = 128
-    If Not RunTestFastZline(RecordingDoc, 2, AFTest_Repetitions.Value, 1, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-    AutofocusLineSize.Value = 64
-    If Not RunTestFastZline(RecordingDoc, 3, AFTest_Repetitions.Value, 1, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-    AutofocusLineSize.Value = 256
-    If Not RunTestFastZline(RecordingDoc, 4, AFTest_Repetitions.Value, 2, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-
-
-    AutofocusLineSize.Value = 128
-    If Not RunTestFastZline(RecordingDoc, 5, AFTest_Repetitions.Value, 2, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-    AutofocusLineSize.Value = 256
-    If Not RunTestFastZline(RecordingDoc, 6, AFTest_Repetitions.Value, 3, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-
-
-    AutofocusLineSize.Value = 128
-    If Not RunTestFastZline(RecordingDoc, 7, AFTest_Repetitions.Value, 3, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-        
-    AutofocusLineSize.Value = 256
-    If Not RunTestFastZline(RecordingDoc, 8, AFTest_Repetitions.Value, 4, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-      
-    AutofocusLineSize.Value = 128
-    If Not RunTestFastZline(RecordingDoc, 9, AFTest_Repetitions.Value, 4, "AFTest5_FastZlineTest", 5000) Then
-        Exit Function
-    End If
-    AFTest5Run = True
-End Function
-
-
-
-'''''
-' AFTest6_Click()
-' Perform repeatealy Autofocus with piezo and frame acquisition with piezo at multiposition
-' Uses No Z-track and Z-track
-''''
-Private Sub AFTest6_Click()
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    AFTest6Run
-    StopAcquisition
-End Sub
-
-Private Function AFTest6Run() As Boolean
-    Running = True
-    Dim RecordingDoc As DsRecordingDoc
-    Log = True
-    If Not Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.name) Then
-        MsgBox ("No piezo availabe! Cannot start tests.")
-        Exit Function
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No outputfolder selected ! Cannot start tests.")
-        Exit Function
-    End If
-    
-    'Setup a single recording doc
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    If Not CheckDir(GlobalDataBaseName) Then
-        Exit Function
-    End If
-        
-    AcquisitionTrack1.Value = AutofocusTrack1.Value
-    AcquisitionTrack2.Value = AutofocusTrack2.Value
-    AcquisitionTrack3.Value = AutofocusTrack3.Value
-    AcquisitionTrack4.Value = AutofocusTrack4.Value
-    AutofocusMaxSpeed.Value = True
-    AutofocusFastZline = False
-    AutofocusHRZ.Value = True
-    AutofocusLowZoom.Value = False
-        
-        
-    '''''''
-    ' Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = True
-
-    MultipleLocationToggle.Value = True
-    LoopingRepetitions = AFTest_Repetitions.Value
-    LoopingRepetitionTime.Value = 0
-    If Not StartSetting() Then
-        Exit Function
-    End If
-    GlobalAcquisitionRecording.SpecialScanMode = "ZScanner"
-    
-    GlobalAcquisitionRecording.ScanMode = "Stack"                       'This is defining to acquire a Z stack of Z-Y images
-    GlobalAcquisitionRecording.SamplesPerLine = 32  'If doing frame autofocussing it uses the userdefined frame size
-    GlobalAcquisitionRecording.LinesPerFrame = 32
-    If AutofocusZStep.Value > 0 Then
-        GlobalAcquisitionRecording.FramesPerStack = Round(10 / AutofocusZStep.Value)
-        GlobalAcquisitionRecording.FrameSpacing = AutofocusZStep.Value
-    Else
-        GlobalAcquisitionRecording.FramesPerStack = 10
-        GlobalAcquisitionRecording.FrameSpacing = 10
-    End If
-    TextBoxFileName.Value = "Piezo"
-    'Set counters back to 1
-    RepetitionNumber = 1 ' first time point
-    StartAcquisition BleachingActivated 'This is the main function of the macro
-    AFTest6Run = True
-End Function
-
-
-'''''
-' AFTest6_Click()
-' Perform repeatealy Autofocus with piezo and frame acquisition with piezo at multiposition
-' Uses No Z-track and Z-track
-''''
-Private Sub AFTest7_Click()
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    AFTest7Run
-    StopAcquisition
-End Sub
-
-Private Function AFTest7Run() As Boolean
-    Running = True
-    Dim RecordingDoc As DsRecordingDoc
-    Log = True
-    If Not Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.name) Then
-        MsgBox ("No piezo availabe! Cannot start tests.")
-        Exit Function
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No outputfolder selected ! Cannot start tests.")
-        Exit Function
-    End If
-    
-    'Setup a single recording doc
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    If Not CheckDir(GlobalDataBaseName) Then
-        Exit Function
-    End If
-        
-    AcquisitionTrack1.Value = AutofocusTrack1.Value
-    AcquisitionTrack2.Value = AutofocusTrack2.Value
-    AcquisitionTrack3.Value = AutofocusTrack3.Value
-    AcquisitionTrack4.Value = AutofocusTrack4.Value
-    AutofocusMaxSpeed.Value = True
-    AutofocusFastZline = True
-    AutofocusHRZ.Value = False
-    AutofocusLowZoom.Value = False
-        
-        
-    '''''''
-    ' Z-Tracking, Acquistion after Autofocus
-    '''''''
-    AutofocusTrackZ.Value = True
-
-    MultipleLocationToggle.Value = True
-    LoopingRepetitions = AFTest_Repetitions.Value
-    LoopingRepetitionTime.Value = 0
-    If Not StartSetting() Then
-        Exit Function
-    End If
-    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
-    
-    GlobalAcquisitionRecording.ScanMode = "Stack"                       'This is defining to acquire a Z stack of Z-Y images
-    GlobalAcquisitionRecording.SamplesPerLine = 8  'If doing frame autofocussing it uses the userdefined frame size
-    GlobalAcquisitionRecording.LinesPerFrame = 8
-    If AutofocusZStep.Value > 0 Then
-        GlobalAcquisitionRecording.FramesPerStack = Round(20 / AutofocusZStep.Value)
-        GlobalAcquisitionRecording.FrameSpacing = AutofocusZStep.Value
-    Else
-        GlobalAcquisitionRecording.FramesPerStack = 10
-        GlobalAcquisitionRecording.FrameSpacing = 10
-    End If
-    TextBoxFileName.Value = "FastZline"
-    'Set counters back to 1
-    RepetitionNumber = 1 ' first time point
-    StartAcquisition BleachingActivated 'This is the main function of the macro
-    AFTest7Run = True
-End Function
-
-
-Private Sub AFTestAll_Click()
-    posTempZ = Lsm5.Hardware.CpFocus.Position
-    Running = True
-    If Not AFTest1Run Then
-        GoTo ScanStop
-    End If
-    If Not AFTest3Run Then
-        GoTo ScanStop
-    End If
+'''''''''
+''   CommandButtonHelp_Click()
+''   Look for Help file
+''   TODO: Test
+'''''''''
+'Private Sub CommandButtonHelp_Click()
+'
+'    Dim dblTask As Double
+'    Dim MacroPath As String
+'    Dim MyPath As String
+'    Dim MyPathPDF As String
+'
+'    Dim bslash As String
+'    Dim Success As Integer
+'    Dim pos As Integer
+'    Dim Start As Integer
+'    Dim count As Long
+'    Dim ProjName As String
+'    Dim indx As Integer
+'    Dim AcrobatObject As Object
+'    Dim AcrobatViewer As Object
+'    Dim OK As Boolean
+'    Dim StrPath As String
+'    Dim ExecName As String
+'
+'    count = ProjectCount()
+'    For indx = 0 To count - 1
+'        MacroPath = ProjectPath(indx, Success)
+'        ProjName = ProjectTitle(indx, Success)
+'        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
+'            Start = 1
+'            bslash = "\"
+'            pos = Start
+'            Do While pos > 0
+'                pos = InStr(Start, MacroPath, bslash)
+'                If pos > 0 Then
+'                    Start = pos + 1
+'                End If
+'            Loop
+'            MyPath = Strings.Left(MacroPath, Start - 1)
+'            MyPathPDF = MyPath + HelpNamePDF
+'
+'            OK = False
+'            On Error GoTo RTFhelp
+'            OK = FServerFromDescription("AcroExch.Document", StrPath, ExecName)
+'            dblTask = Shell(ExecName + " " + MyPathPDF, vbNormalFocus)
+'
+'RTFhelp:
+'            If Not OK Then
+'                MsgBox "Install Acrobat Viewer!"
+'            End If
+'            Exit For
+'        End If
+'    Next indx
+'End Sub
 
-    If Not AFTest5Run Then
-        GoTo ScanStop
-    End If
-    
-    If Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.name) Then
-        If Not AFTest2Run Then
-            GoTo ScanStop
-        End If
-        If Not AFTest4Run Then
-            GoTo ScanStop
-        End If
-        If Not AFTest6Run Then
-            GoTo ScanStop
-        End If
-        If Not AFTest7Run Then
-            GoTo ScanStop
-        End If
-    End If
-ScanStop:
-    ScanStop = True
-    StopAcquisition
-End Sub
 
+'
+'''''''
+''   BleachRegion(XShift As Double, YShift As Double)
+''       [XShift] In - Shifts origin of x
+''       [YShift] In - Shifts origin of y
+''   Todo: function is never been used and does not belong to form or being called. Check it
+'''''''
+'Private Sub BleachRegion(XShift As Double, YShift As Double)
+'    Dim RecordingDoc As DsRecordingDoc
+'    Dim Recording As DsRecording
+'    Dim Track As DsTrack
+'    Dim Laser As DsLaser
+'    Dim DetectionChannel As DsDetectionChannel
+'    Dim IlluminationChannel As DsIlluminationChannel
+'    Dim DataChannel As DsDataChannel
+'    Dim BeamSplitter As DsBeamSplitter
+'    Dim Timers As DsTimers
+'    Dim Markers As DsMarkers
+'    Dim Success As Integer
+'    Set Recording = Lsm5.DsRecording
+'    Dim SampleObservationTime As Double
+'    Dim SampleOX As Double
+'    Dim SampleOY As Double
+'
+'
+'    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
+'
+'    SampleOX = Recording.Sample0X
+'    SampleOY = Recording.Sample0Y
+'    Recording.Sample0X = XShift
+'    Recording.Sample0Y = YShift
+'    'x = Lsm5.Hardware.CpStages.PositionX - XShift
+'    'y = Lsm5.Hardware.CpStages.PositionY - YShift
+'    'Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
+'    ' maybe wait here till it is finished moving
+'    Recording.SpecialScanMode = "NoSpecialMode"
+'    Recording.ScanMode = "Point"
+'    Recording.TimeSeries = True
+'    Recording.FramesPerStack = 1
+'    Recording.StacksPerRecord = 50  ' timepoints x 1000
+'    SampleObservationTime = Track.SampleObservationTime
+'    MsgBox "SampleObservationTime = " + CStr(SampleObservationTime)
+'    Track.SampleObservationTime = 0.0001 ' pixel-dwell time in seconds
+'    Track.TimeBetweenStacks = 0#
+'    'Timers.TimeInterval = 0#
+'
+'    TakeImage
+'
+'    Recording.Sample0X = SampleOX
+'    Recording.Sample0Y = SampleOY
+'    'x = Lsm5.Hardware.CpStages.PositionX + XShift
+'    'y = Lsm5.Hardware.CpStages.PositionY + YShift
+'    'Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
+'    ' maybe wait here till it is finished moving
+'    Recording.SpecialScanMode = "NoSpecialMode"
+'    Recording.ScanMode = "Frame"
+'    Recording.TimeSeries = False
+'    Recording.FramesPerStack = 1
+'    Recording.StacksPerRecord = 1  ' timepoints x 1000
+'    Track.SampleObservationTime = SampleObservationTime ' pixel-dwell time in seconds
+'    MsgBox "SampleObservationTime = " + CStr(SampleObservationTime)
+'
+'
+'    'Recording.ScanMode = "Plane"
+'    'Recording.FrameSpacing = 0.636243
+'
+'
+'End Sub
 
-''''
-'   RunTestAutofocusButton(RecordingDoc As DsRecordingDoc, TestNr As Integer, MaxTestRepeats As Integer) As Boolean
-'   Using the actual setting for autofocusing function runs AutofocusButton. Save images and logfile on the GlobalDataBaseName directory
-'       [RecordingDoc] - A recording where images are overwritten
-'       [TestNr]       - Number of the test, this sets the name of the image files and logfiles.
-'       [MaxTestRepeats] - Maximal number of tests for each repeat
-''''
-Private Function RunTestAutofocusButton(RecordingDoc As DsRecordingDoc, ResetPos As Boolean, MaxTestRepeats As Integer, Optional fileName As String = "AutofocusTest", Optional Pause As Integer = 1000) As Boolean
 
-    Dim FilePath As String
-    Dim TestRepeats As Integer
-    Dim Zold As Double
-    Dim pos As Double
-    TestRepeats = 1
-    LogFileName = GlobalDataBaseName & "\" & fileName & "_Log" & ".txt"
-    
-    If Log Then
-        SafeOpenTextFile LogFileName, LogFile, FileSystem
-        LogFile.WriteLine "% Autofocus Test. Repeated AutofocusButton executions. "
-        LogFile.WriteLine "% MaxSpeed " & AutofocusMaxSpeed.Value & ", Zoom1 " & AutofocusLowZoom.Value & ", Piezo " & AutofocusHRZ.Value & ", AFTrackZ " & AutofocusTrackZ.Value & _
-        ", AFTrackXY " & AutofocusTrackXY.Value & ", FastZLine" & AutofocusFastZline.Value
-    End If
-    Zold = posTempZ
-    While TestRepeats < MaxTestRepeats + 1
-        DisplayProgress "Running Test " & fileName & ". Repeat " & TestRepeats & "/" & MaxTestRepeats & ".......", RGB(0, &HC0, 0)
-                
-        FilePath = GlobalDataBaseName & "\" & fileName & "_" & TestRepeats
-        If Log Then
-            SafeOpenTextFile LogFileName, LogFile, FileSystem
-            LogFile.WriteLine " "
+'''''''
+''   TakeImage()
+''   Acquire an image. Allow to stop acquisition and displaqy progress. Nt used anymore
+''''''''
+'Private Sub TakeImage()
+'
+'    Dim ScanImage As DsRecordingDoc
+'
+'    Set ScanImage = Lsm5.StartScan
+'
+'    DisplayProgress "Taking Image.......", RGB(0, &HC0, 0)
+'    Do While ScanImage.IsBusy ' Waiting until the image acquisition is done
+'        Sleep (100)
+'        If GetInputState() <> 0 Then
+'            DoEvents
+'            If ScanStop Then
+'                StopAcquisition
+'                Exit Sub
+'            End If
+'        End If
+'    Loop
+'    DisplayProgress "Taking Image...DONE.", RGB(0, &HC0, 0)
+'End Sub
+'
 
-            LogFile.WriteLine "% Save image in file " & FilePath & ".lsm"
-            LogFile.Close
-        End If
-        DoEvents
-        Sleep (Pause)
-        DoEvents
+'Private Sub StartBleachButton_Click()
+'
+'    Dim Success As Integer
+'    Dim nt As Integer
+'
+'    BleachingActivated = True
+'    AutomaticBleaching = False
+'
+'    If TrackingToggle And TrackingChannelString = "" Then
+'        MsgBox ("Select a channel for tracking, or uncheck the tracking button")
+'        Exit Sub
+'    End If
+'    If MultipleLocationToggle.Value And Lsm5.Hardware.CpStages.MarkCount < 1 Then
+'        MsgBox ("Select at least one location in the stage control window, or uncheck the multiple location button")
+'        Exit Sub
+'    End If
+'    If GlobalDataBaseName = "" Then
+'        MsgBox ("No Output Folder selected ! Cannot start acquisition.")
+'        Exit Sub
+'    End If
+'
+'
+'    Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
+'
+'    If Success Then
+'        If Track.BleachPositionZ <> 0 Then
+'            MsgBox ("This macro does not enable to bleach at a different Z position. Please uncheck the corresponding box in the Bleach Control Window")
+'            Exit Sub
+'        End If
+'
+'        If Lsm5.IsValidBleachRoi Then
+'
+'            If ActiveMicropilot Then
+'                nt = MicropilotRepetitions
+'            Else
+'                nt = BlockRepetitions
+'            End If
+'
+'            If (Track.BleachScanNumber + 1) > nt Then
+'                MsgBox ("Not enough repetitions to bleach; either increase the Number of Acquisitions, or, when using MicroPilot, the Cycles")
+'                Exit Sub
+'            End If
+'
+'            FillBleachTable
+'            AutomaticBleaching = True
+'           'Track.UseBleachParameters = True ' deleted 20100818 , can probably not work with Micropilot
+'        Else
+'            MsgBox ("A bleaching ROI needs to be defined to start the macro in the bleaching mode")
+'            Exit Sub
+'        End If
+'    Else
+'        MsgBox ("A bleach track needs to be defined to start the macro in the bleaching mode")
+'        Exit Sub
+'    End If
+'
+'    StartAcquisition BleachingActivated
+'
+'End Sub
 
-        If ResetPos Then
-            posTempZ = Round(Zold + (1 - 2 * Rnd) * 10, PrecZ)
-        End If
-        Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-
-        DisplayProgress "Autofocus SetupScanWindow", RGB(0, &HC0, 0)
-        If RecordingDoc Is Nothing Then
-            Set RecordingDoc = Lsm5.NewScanWindow
-            While RecordingDoc.IsBusy
-                Sleep (100)
-                DoEvents
-            Wend
-        End If
-        If Not AutofocusButtonRun(RecordingDoc, GlobalDataBaseName & "\AFimg_" & fileName & "_" & TestRepeats & ".lsm") Then
-            Exit Function
-        End If
-        'save file
-        If ActivateTrack(GlobalAcquisitionRecording, "Acquisition") Then
-            SaveDsRecordingDoc RecordingDoc, FilePath & ".lsm"
-        End If
-        TestRepeats = TestRepeats + 1
-        If ScanStop Then
-            Exit Function
-        End If
-    Wend
-    If Log Then
-        LogFile.Close
-    End If
-    RunTestAutofocusButton = True
-End Function
+'Private Sub FillBleachTable()  'Fills a table for the macro to know when the bleaches have to occur. This works for FRAPs (and FLIPS if working with LSM 3.2)
+'
+'    Dim i As Integer
+'    Dim nt As Integer
+'    Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
+'    If Success Then
+'
+'        If ActiveMicropilot Then
+'            nt = MicropilotRepetitions.Value
+'        Else
+'            nt = BlockRepetitions
+'        End If
+'
+'        ReDim BleachTable(nt)               'The bleach table contains as many timepoints as blockrepetitions
+'
+'        'When working with the Lsm 2.8, remove all this test, except the one indicated line
+'        If Track.EnableBleachRepeat Then
+'            For i = Track.BleachScanNumber + 1 To nt Step Track.BleachRepeat
+'                BleachTable(i) = True
+'            Next
+'        Else
+'        '    BleachTable(Track.BleachScanNumber + 1) = True  'This is the only line to be kept when working with the Lsm 2.8
+'        End If
+'
+'    End If
+'End Sub
 
 ''''
-'   RunTestFastZline(RecordingDoc As DsRecordingDoc, TestNr As Integer, MaxTestRepeats As Integer, pixelDwell As Double, FrameSize As Integer, pause As Integer) As Boolean
-'   Using the actual setting for autofocusing function runs AutofocusButton. Save images and logfile on the GlobalDataBaseName directory
-'       [RecordingDoc] - A recording where images are overwritten
-'       [TestNr]       - Number of the test, this sets the name of the image files and logfiles.
-'       [MaxTestRepeats] - Maximal number of tests for each repeat
+'' Not used at the moment
 ''''
-Private Function RunTestFastZline(RecordingDoc As DsRecordingDoc, TestNr As Integer, MaxTestRepeats As Integer, Optional pixelDwellfactor As Double = 1, Optional fileName As String = "AutofocusTest", Optional Pause As Integer = 5000) As Boolean
-
-    Dim FilePath As String
-    Dim TestRepeats As Integer
-    Dim SuccessRecenter As Boolean
-    Dim Time As Double
-    Dim pos As Double ' position temp variable
-    TestRepeats = 1
-    LogFileName = GlobalDataBaseName & "\" & fileName & TestNr & ".txt"
-    
-    If Log Then
-        SafeOpenTextFile LogFileName, LogFile, FileSystem
-        LogFile.WriteLine "% FastZlineTest " & TestNr & ". Repeated fast Zline executions. PixelDwellfactor: " & pixelDwellfactor & ", LineSize: " & AutofocusLineSize.Value & ", pause: " & Pause
-        LogFile.WriteLine "% MaxSpeed " & AutofocusMaxSpeed.Value & ", Zoom1 " & AutofocusLowZoom.Value & ", Piezo " & AutofocusHRZ.Value & ", AFTrackZ " & AutofocusTrackZ.Value & _
-        ", AFTrackXY " & AutofocusTrackXY.Value
-    End If
-    
-    While TestRepeats < MaxTestRepeats + 1
-        DisplayProgress "Running Test " & TestNr & ". Repeat " & TestRepeats & "/" & MaxTestRepeats & ".......", RGB(0, &HC0, 0)
-        FilePath = GlobalDataBaseName & "\" & fileName & TestNr & "_" & TestRepeats
-        If Log Then
-            SafeOpenTextFile LogFileName, LogFile, FileSystem
-            LogFile.WriteLine " "
-            LogFile.WriteLine "% Save image in file " & FilePath & ".lsm"
-            LogFile.Close
-        End If
-        DoEvents
-        Sleep (Pause)
-        DoEvents
-        If Not AutofocusForm.ActivateTrack(GlobalAutoFocusRecording, "Autofocus") Then
-            MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-            Exit Function
-        End If
-        Time = Timer
-        Recenter_pre posTempZ, SuccessRecenter, ZEN
-        
-        Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime * pixelDwellfactor
-        
-        Sleep (Pause)
-        DoEvents
-        If Log Then
-            SafeOpenTextFile LogFileName, LogFile, FileSystem
-            Time = Timer - Time
-            'pos = Lsm5.Hardware.CpFocus.Position
-            LogFile.WriteLine ("% AutofocusButton: center and wait 1st  Z = " & posTempZ & ", Time required " & Time & ", success Recenter " & SuccessRecenter)
-'            Sleep (100)
-'            If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-'                LogFile.WriteLine ("% AutofocusButton: Target Central slide AQ  " & posTempZ & "; obtained Central slide " & pos & "; position " & pos)
-'            Else
-'                LogFile.WriteLine ("% AutofocusButton: Target Central slide AQ  " & posTempZ & "; obtained Central slide " & _
-'                Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos & "; position " & pos)
+'Public Function SetGetLaserPower(power As Double)
+'
+'    Dim Recording As DsRecording
+'    Dim Track As DsTrack
+'    Dim IlluminationChannel As DsIlluminationChannel
+'
+'    Set Recording = Lsm5.DsRecording
+'    Set Track = Recording.TrackObjectByIndex(0, Success)
+'    Set IlluminationChannel = Track.IlluminationObjectByIndex(0, Success)
+'
+'    If (power > 0) Then
+'        IlluminationChannel.power = power
+'    End If
+'
+'    power = IlluminationChannel.power
+'
+'End Function
+'
+'
+'Public Function MeasureExposure(fractionMax As Double, fractionSat As Double)
+'
+''    Lsm5Vba.Application.ThrowEvent eRootReuse, 0                   'Was there in the initial Zeiss macro, but it seems notnecessary
+' '   DoEvents
+'
+'    'Dim ColMax As Integer
+'    Dim iRow As Integer
+'    Dim nRow As Integer
+'    Dim iFrame As Integer
+'    Dim gvRow As Variant  ' gv = gray value
+'    Dim iCol As Long
+'    Dim nCol As Long
+'    Dim bitDepth As Long
+'    Dim channel As Integer
+'    Dim gvMax As Double
+'    Dim gvMaxBitRange As Double
+'    Dim nSaturatedPixels As Long
+'    Dim maxGV_nSat(2) As Double
+'
+'
+'    DisplayProgress "Measuring Exposure...", RGB(0, &HC0, 0)
+'
+'    'ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth '/ Lsm5.DsRecordingActiveDocObject.Recording.RtBinning
+'
+'    nRow = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
+'    'MsgBox "nRow = " + CStr(nRow)
+'
+''        ElseIf SystemName = "LSM" Then
+''            ColMax = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
+''            LineMax = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
+''        Else
+''            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
+'''            Exit Sub
+' '       End If
+' '   End If
+'
+'    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
+'    'ReDim Intline(nLines) As Long
+'
+'    iFrame = 0
+'    gvMax = -1
+'
+'    iRow = 0
+'    channel = 0
+'    bitDepth = 0 ' leaves the internal bit depth
+'    gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
+'    'MsgBox "nCol = " + CStr(nCol)
+'    'MsgBox "bytes per pixel = " + CStr(bitDepth)
+'
+'    ' todo: is there another function to find this out??
+'    If (bitDepth = 1) Then
+'        gvMaxBitRange = 255
+'    ElseIf (bitDepth = 2) Then
+'        gvMaxBitRange = 65536
+'    End If
+'
+'    nSaturatedPixels = 0
+'
+'    For iRow = 0 To nRow - 1
+'        gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
+'        For iCol = 0 To nCol - 1            'Now I'm scanning all the pixels in the line
+'
+'            If (gvRow(iCol) > gvMax) Then
+'                gvMax = gvRow(iCol)
 '            End If
-            LogFile.Close
-        End If
-        
-        If Not ScanToImage(RecordingDoc) Then
-            Exit Function
-        End If
-        Time = Timer
-        Recenter_post posTempZ, SuccessRecenter, ZEN
-        DoEvents
-        If Log Then
-            SafeOpenTextFile LogFileName, LogFile, FileSystem
-            Time = Timer - Time
-            pos = Lsm5.Hardware.CpFocus.Position
-            LogFile.WriteLine ("% AutofocusButton: recenter 1st  Z = " & posTempZ & ", Time required " & Time & ", waiting repeats (max 9) " & Round(Time / 0.4))
-            If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
-                LogFile.WriteLine ("% AutofocusButton: Target Central slide AQ (after img) " & posTempZ & "; obtained Central slide " & Lsm5.Hardware.CpFocus.Position & "; position " & Lsm5.Hardware.CpFocus.Position)
-            Else
-                LogFile.WriteLine ("% AutofocusButton: Target Central slide AQ (after img) " & posTempZ & "; obtained Central slide " & _
-                Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + Lsm5.Hardware.CpFocus.Position & "; position " & Lsm5.Hardware.CpFocus.Position)
-            End If
-            LogFile.Close
-        End If
-        SaveDsRecordingDoc RecordingDoc, FilePath & ".lsm"
-        TestRepeats = TestRepeats + 1
-        If ScanStop Then
-            Exit Function
-        End If
-    Wend
-    If Log Then
-        LogFile.Close
-    End If
-    RunTestFastZline = True
-End Function
-
+'
+'            If (gvRow(iCol) = gvMaxBitRange) Then
+'                nSaturatedPixels = nSaturatedPixels + 1
+'                ' TODO: measure neighbouring saturated pixels
+'            End If
+'
+'        Next iCol
+'    Next iRow
+'
+'    fractionMax = gvMax / gvMaxBitRange
+'    fractionSat = nSaturatedPixels / (nRow * nCol)
+'
+'    'MsgBox "maximal gray value in image = " + CStr(gvMax)
+'    'MsgBox "fractional brightness of maximal gray value in image = " + CStr(fractionMax)
+'    'MsgBox "number of saturated pixles = " + CStr(nSaturatedPixels)
+'    'MsgBox "fraction of saturated pixles = " + CStr(fractionSat)
+'
+'    DisplayProgress "Measuring Exposure...DONE", RGB(0, &HC0, 0)
+'
+'End Function
 
diff --git a/AutofocusScreen/src/AutofocusScreen/AutofocusForm.frx b/AutofocusScreen/src/AutofocusScreen/AutofocusForm.frx
index 70d1d07..42b8437 100644
Binary files a/AutofocusScreen/src/AutofocusScreen/AutofocusForm.frx and b/AutofocusScreen/src/AutofocusScreen/AutofocusForm.frx differ
diff --git a/AutofocusScreen/src/AutofocusScreen/AutofocusFormSaveLoad.bas b/AutofocusScreen/src/AutofocusScreen/AutofocusFormSaveLoad.bas
new file mode 100644
index 0000000..62a3c87
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/AutofocusFormSaveLoad.bas
@@ -0,0 +1,251 @@
+Attribute VB_Name = "AutofocusFormSaveLoad"
+''''
+' Module contains functions to save and load Form settings from file
+'''
+
+Option Explicit
+
+
+
+
+'''''
+'   SaveSettings(FileName As String)
+'   SaveSettings of the UserForm AutofocusForm in file name FileName.
+'   Name should correspond exactly to name used in Form
+'''''
+Public Sub SaveFormSettings(FileName As String)
+    Dim i As Integer
+    Dim iFileNum As Integer
+    Close
+    On Error GoTo ErrorHandle
+    iFileNum = FreeFile()
+    Open FileName For Output As iFileNum
+    
+    Print #iFileNum, "% Settings for AutofocusMacro for ZEN " & ZENv & "  " & AutofocusForm.Version
+
+    'Single MultipelocationToggle
+    Print #iFileNum, "% Single Multiple "
+    Print #iFileNum, "MultipleLocationToggle " & AutofocusForm.MultipleLocationToggle.Value
+    Print #iFileNum, "SingleLocationToggle " & AutofocusForm.SingleLocationToggle.Value
+    
+    
+    'Looping
+    Print #iFileNum, "% GlobalRepetition "
+    Print #iFileNum, "GlobalRepetitionSec " & AutofocusForm.GlobalRepetitionSec
+    Print #iFileNum, "GlobalRepetitionMin " & AutofocusForm.GlobalRepetitionMin
+    Print #iFileNum, "GlobalRepetitionTime " & AutofocusForm.GlobalRepetitionTime.Value
+    Print #iFileNum, "GlobalRepetitionInterval " & AutofocusForm.GlobalRepetitionInterval.Value
+    Print #iFileNum, "GlobalRepetitionNumber " & AutofocusForm.GlobalRepetitionNumber.Value
+    
+    'Output
+    Print #iFileNum, "% Output "
+    Print #iFileNum, "DatabaseTextbox " & AutofocusForm.DatabaseTextbox.Value
+    Print #iFileNum, "TextBoxFileName " & AutofocusForm.TextBoxFileName.Value
+    
+    'Grid Acquisition
+    Print #iFileNum, "% Grid "
+    Print #iFileNum, "GridScanActive " & AutofocusForm.GridScanActive.Value
+    Print #iFileNum, "GridScan_validGridDefault " & AutofocusForm.GridScan_validGridDefault.Value
+    Print #iFileNum, "GridScan_nRow " & AutofocusForm.GridScan_nRow.Value
+    Print #iFileNum, "GridScan_nColumn " & AutofocusForm.GridScan_nColumn.Value
+    Print #iFileNum, "GridScan_dRow " & AutofocusForm.GridScan_dRow.Value
+    Print #iFileNum, "GridScan_dColumn " & AutofocusForm.GridScan_dColumn.Value
+    Print #iFileNum, "GridScan_refRow " & AutofocusForm.GridScan_refRow.Value
+    Print #iFileNum, "GridScan_refColumn " & AutofocusForm.GridScan_refColumn.Value
+    Print #iFileNum, "GridScan_nRowsub " & AutofocusForm.GridScan_nRowsub.Value
+    Print #iFileNum, "GridScan_nColumnsub " & AutofocusForm.GridScan_nColumnsub.Value
+    Print #iFileNum, "GridScan_dRowsub " & AutofocusForm.GridScan_dRowsub.Value
+    Print #iFileNum, "GridScan_dColumnsub " & AutofocusForm.GridScan_dColumnsub.Value
+    
+    'Save settings of all pages
+    For i = 0 To UBound(JobNames)
+        SaveFormPage JobNames(i), iFileNum
+    Next i
+    
+    'Save settings of all pages
+    For i = 0 To UBound(JobFcsNames)
+        SaveFormFcsPage JobFcsNames(i), iFileNum
+    Next i
+    Close #iFileNum
+    Exit Sub
+ErrorHandle:
+    MsgBox "SaveFormSettings: Not able to open " & FileName & " for saving settings"
+End Sub
+
+
+''''
+' SavePage(JobName As String, iFileNum As Integer)
+'   Save page of specific JobName using a file specified by iFuleNum
+'   TODO: Control that indeed iFileNum is a file
+''''
+Private Sub SaveFormPage(JobName As String, iFileNum As Integer)
+    Dim i As Integer
+    On Error GoTo ErrorHandle:
+    Print #iFileNum, ""
+    Print #iFileNum, "% " & JobName
+    Print #iFileNum, JobName & "Active " & AutofocusForm.Controls(JobName & "Active").Value
+    
+    For i = 1 To 4
+        Print #iFileNum, JobName & "Track" & CInt(i) & " " & _
+        AutofocusForm.Controls(JobName & "Track" & CInt(i)).Value
+    Next i
+    
+    If JobName <> "Autofocus" Then
+        Print #iFileNum, JobName & "ZOffset " & AutofocusForm.Controls(JobName & "ZOffset").Value
+    End If
+    
+    Print #iFileNum, JobName & "Period " & AutofocusForm.Controls(JobName & "Period").Value
+    Print #iFileNum, JobName & "TrackZ " & AutofocusForm.Controls(JobName & "TrackZ").Value
+    Print #iFileNum, JobName & "TrackXY " & AutofocusForm.Controls(JobName & "TrackXY").Value
+    Print #iFileNum, JobName & "CenterOfMass " & AutofocusForm.Controls(JobName & "CenterOfMass").Value
+    Print #iFileNum, JobName & "CenterOfMassChannel " & AutofocusForm.Controls(JobName & "CenterOfMassChannel").Value
+    Print #iFileNum, JobName & "OiaActive " & AutofocusForm.Controls(JobName & "OiaActive").Value
+    Print #iFileNum, JobName & "OiaSequential " & AutofocusForm.Controls(JobName & "OiaSequential").Value
+    Print #iFileNum, JobName & "OiaParallel " & AutofocusForm.Controls(JobName & "OiaParallel").Value
+    
+    If JobName = "Trigger1" Or JobName = "Trigger2" Then
+        Print #iFileNum, JobName & "RepetitionTime " & AutofocusForm.Controls(JobName & "RepetitionTime").Value
+        Print #iFileNum, JobName & "RepetitionSec " & AutofocusForm.Controls(JobName & "RepetitionSec").Value
+        Print #iFileNum, JobName & "RepetitionMin " & AutofocusForm.Controls(JobName & "RepetitionMin").Value
+        Print #iFileNum, JobName & "RepetitionInterval " & AutofocusForm.Controls(JobName & "RepetitionInterval").Value
+        Print #iFileNum, JobName & "RepetitionNumber " & AutofocusForm.Controls(JobName & "RepetitionNumber").Value
+        Print #iFileNum, JobName & "maxWait " & AutofocusForm.Controls(JobName & "maxWait").Value
+        Print #iFileNum, JobName & "OptimalPtNumber " & AutofocusForm.Controls(JobName & "OptimalPtNumber").Value
+        Print #iFileNum, JobName & "Autofocus " & AutofocusForm.Controls(JobName & "Autofocus").Value
+    End If
+    
+    Print #iFileNum, ""
+    Print #iFileNum, Jobs.jobDescriptorSettings(JobName)
+    Exit Sub
+ErrorHandle:
+    MsgBox "Error in SaveFormPage " + JobName + " " + Err.Description
+End Sub
+
+Public Sub ControlTipText()
+    Dim i As Integer
+    For i = 0 To UBound(JobNames)
+        JobControlTipText JobNames(i)
+    Next i
+End Sub
+
+'''
+' Sets tip text for all pages
+'''
+Private Sub JobControlTipText(JobName As String)
+    Dim i As Integer
+    On Error GoTo ErrorHandle:
+
+    AutofocusForm.Controls(JobName + "Period").ControlTipText = "Perform job " & JobName & " every xx repetitions"
+
+    If JobName <> "Autofocus" Then
+        AutofocusForm.Controls(JobName + "ZOffset").ControlTipText = "Add xx to Z from previous imaging Job"
+    End If
+    
+    AutofocusForm.Controls(JobName + "TrackZ").ControlTipText = "Update Z of current point with computed position"
+    AutofocusForm.Controls(JobName + "TrackXY").ControlTipText = "Update XY of current point with computed position"
+    AutofocusForm.Controls(JobName + "CenterOfMass").ControlTipText = "Compute new position from center of mass (done within Macro)"
+    AutofocusForm.Controls(JobName + "OiaActive").ControlTipText = "If active macro listens to online image analysis"
+    AutofocusForm.Controls(JobName + "OiaSequential").ControlTipText = "Macro waits for image analysis to finish. Acquire image -> OnlineImage analysis -> perform task"
+    AutofocusForm.Controls(JobName + "OiaParallel").ControlTipText = "Imaging and analysis run in parallel."
+    
+    If JobName = "Trigger1" Or JobName = "Trigger2" Then
+        AutofocusForm.Controls(JobName + "Active").ControlTipText = "Job " & JobName & " is performed only after online image analysis command"
+        AutofocusForm.Controls(JobName + "OptimalPtNumber").ControlTipText = "Wait to find up to xxx positions before starting job " & JobName
+        AutofocusForm.Controls(JobName + "maxWait").ControlTipText = "Wait up to xxx seconds before starting job " & JobName
+        AutofocusForm.Controls(JobName + "Autofocus").ControlTipText = "Before acquiring " & JobName & " perform Job Autofocus"
+    End If
+    Exit Sub
+    AutofocusForm.Controls(JobName + "PutJob").ControlTipText = "Put Macro acquisition settings into ZEN. Not all settings are shown in the  ZEN GUI!"
+    AutofocusForm.Controls(JobName + "SetJob").ControlTipText = "Load settings from ZEN into Macro. Not all settings are shown in the  Macro GUI!"
+    AutofocusForm.Controls(JobName + "AcquireJob").ControlTipText = "Acquire one image with settings of Job " & JobName
+    
+ErrorHandle:
+    MsgBox "Error in JobControlTipText " + JobName + " " + Err.Description
+End Sub
+
+''''
+'   Save page of specific JobFcs using a file specified by iFuleNum
+'   TODO: Control that indeed iFileNum is a file
+''''
+Private Sub SaveFormFcsPage(JobName As String, iFileNum As Integer)
+    Dim i As Integer
+    On Error GoTo ErrorHandle:
+    Print #iFileNum, ""
+    Print #iFileNum, "% " & JobName
+    Print #iFileNum, JobName & "Active " & AutofocusForm.Controls(JobName & "Active").Value
+    
+    Print #iFileNum, ""
+    Print #iFileNum, JobsFcs.jobDescriptorSettings(JobName)
+    Exit Sub
+ErrorHandle:
+    MsgBox "Error in SaveFormPage " + JobName + " " + Err.Description
+End Sub
+
+''''
+'   LoadSettings(FileName As String)
+'   LoadSettings of Form from FileName
+''''
+Public Sub LoadFormSettings(FileName As String)
+    Dim iFileNum As Integer
+    Dim Fields As String
+    Dim JobName As String
+    Dim FieldEntries() As String
+    Dim Entries() As String
+    Close
+    On Error GoTo ErrorHandle
+    iFileNum = FreeFile()
+    Open FileName For Input As iFileNum
+    Do While Not EOF(iFileNum)
+            Line Input #iFileNum, Fields
+            While Left(Fields, 1) = "%"
+                Line Input #iFileNum, Fields
+            Wend
+            
+            If Fields <> "" Then
+                FieldEntries = Split(Fields, " ", 2)
+                If FieldEntries(0) = "JobName" Then
+                    JobName = FieldEntries(1)
+                    Line Input #iFileNum, Fields
+                    FieldEntries = Split(Fields, " ", 2)
+                    While FieldEntries(0) <> "EndJobDef"
+                        Jobs.changeJobFromDescriptor JobName, FieldEntries(0), FieldEntries(1)
+                        Line Input #iFileNum, Fields
+                        FieldEntries = Split(Fields, " ", 2)
+                    Wend
+                    
+                    'put once the job and reload it to get all the proper pixelSize according to the zoom etc
+                    Jobs.putJob JobName, ZEN
+                    Jobs.setJob JobName, Lsm5.DsRecording, ZEN
+                    UpdateFormFromJob Jobs, JobName
+                    UpdateJobFromForm Jobs, JobName
+                End If
+                If FieldEntries(0) = "JobFcsName" Then
+                    JobName = FieldEntries(1)
+                    Line Input #iFileNum, Fields
+                    FieldEntries = Split(Fields, " ", 2)
+                    While FieldEntries(0) <> "EndJobFcsDef"
+                        JobsFcs.changeJobFromDescriptor JobName, FieldEntries(0), FieldEntries(1)
+                        Line Input #iFileNum, Fields
+                        FieldEntries = Split(Fields, " ", 2)
+                    Wend
+                    If JobsFcs.getLightPathConfig(JobName) <> "" Then
+                        'put once the job and reload it to get all the proper pixelSize according to the zoom etc
+                        JobsFcs.putJob JobName, ZEN
+                        JobsFcs.setJobNoAi JobName, JobsFcs.getLightPathConfig(JobName)
+                        'JobsFcs.setJob JobName, ZEN
+                    End If
+                        UpdateFormFromJobFcs JobsFcs, JobName
+                        'UpdateJobFromForm Jobs, JobName
+                End If
+                On Error Resume Next
+                AutofocusForm.Controls(FieldEntries(0)).Value = FieldEntries(1)
+            End If
+NextLine:
+    Loop
+    Close #iFileNum
+    Exit Sub
+ErrorHandle:
+    MsgBox "Not able to read " & FileName & " for AutofocusScreen settings"
+End Sub
+
+
diff --git a/AutofocusScreen/src/AutofocusScreen/CommonDialogAPI.bas b/AutofocusScreen/src/AutofocusScreen/CommonDialogAPI.bas
index 3da2bd7..39b2544 100644
--- a/AutofocusScreen/src/AutofocusScreen/CommonDialogAPI.bas
+++ b/AutofocusScreen/src/AutofocusScreen/CommonDialogAPI.bas
@@ -77,12 +77,12 @@ Public Const OFN_SHOWHELP As Long = &H10&
 
 
 
-Public Function ShowOpen(Filter As String, Flags As Long, Optional fileName As String = "", Optional initDir As String = "", Optional DialogTitle As String = "Open") As String
+Public Function ShowOpen(Filter As String, Flags As Long, Optional FileName As String = "", Optional initDir As String = "", Optional DialogTitle As String = "Open") As String
     Dim Buffer As String
     Dim Result As Long
     Dim ComDlgOpenFileName As OPENFILENAME
     
-    Buffer = fileName & String$(128 - Len(fileName), 0)
+    Buffer = FileName & String$(128 - Len(FileName), 0)
     
     With ComDlgOpenFileName
         .lStructSize = Len(ComDlgOpenFileName)
@@ -104,13 +104,13 @@ Public Function ShowOpen(Filter As String, Flags As Long, Optional fileName As S
     End If
 End Function
 
-Public Function ShowSave(Filter As String, Flags As Long, fileName As String, Optional initDir As String = "", Optional DialogTitle As String = "Save As") As String
+Public Function ShowSave(Filter As String, Flags As Long, FileName As String, Optional initDir As String = "", Optional DialogTitle As String = "Save As") As String
                            
     Dim Buffer As String
     Dim Result As Long
     Dim ComDlgOpenFileName As OPENFILENAME
     
-    Buffer = fileName & String$(128 - Len(fileName), 0)
+    Buffer = FileName & String$(128 - Len(FileName), 0)
     
     With ComDlgOpenFileName
         .lStructSize = Len(ComDlgOpenFileName)
diff --git a/AutofocusScreen/src/AutofocusScreen/ConstantsTypesWrapperVBA.bas b/AutofocusScreen/src/AutofocusScreen/ConstantsTypesWrapperVBA.bas
new file mode 100644
index 0000000..9463816
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/ConstantsTypesWrapperVBA.bas
@@ -0,0 +1,101 @@
+Attribute VB_Name = "ConstantsTypesWrapperVBA"
+'''''''''''''''''''''''''''''
+'''''CONSTANTS for VBA'''''''
+'''''''''''''''''''''''''''''
+Public Const VK_SPACE = &H20
+Public Const VK_RETURN = &HD
+Public Const VK_CANCEL = &H3
+Public Const VK_UP = &H26
+Public Const VK_DOWN = &H28
+Public Const VK_ESCAPE = &H1B
+Public Const VK_PAUSE = &H13
+Public Const VK_ADD = &H6B
+Public Const VK_SUBTRACT = &H6D
+Public Const HKEY_CLASSES_ROOT = &H80000000
+Public Const SYNCHRONIZE = &H100000
+Public Const READ_CONTROL = &H20000
+Public Const STANDARD_RIGHTS_READ = (READ_CONTROL)
+Public Const KEY_QUERY_VALUE = &H1
+Public Const KEY_ENUMERATE_SUB_KEYS = &H8
+Public Const KEY_NOTIFY = &H10
+Public Const KEY_READ = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
+
+Public Const REG_SZ = 1                         ' Unicode nul terminated string
+Public Const ERROR_SUCCESS = 0&
+
+Public Const vbOKOnly = 0   '  Display OK button only.
+Public Const VbOKCancel = 1 '  Display OK and Cancel buttons.
+Public Const VbAbortRetryIgnore = 2  ' Display Abort, Retry, and Ignore buttons.
+Public Const VbYesNoCancel = 3  '  Display Yes, No, and Cancel buttons.
+Public Const VbYesNo = 4 '  Display Yes and No buttons.
+Public Const VbRetryCancel = 5   ' Display Retry and Cancel buttons.
+Public Const VbCritical = 16 ' Display Critical Message icon.
+Public Const VbQuestion = 32 ' Display Warning Query icon.
+Public Const VbExclamation = 48  ' Display Warning Message icon.
+Public Const VbInformation = 64  ' Display Information Message icon.
+Public Const VbDefaultButton1 = 0    ' First button is default.
+Public Const VbDefaultButton2 = 256  ' Second button is default.
+Public Const VbDefaultButton3 = 512  ' Third button is default.
+Public Const VbDefaultButton4 = 768   'Fourth button is default.
+Public Const VbApplicationModal = 0  ' Application modal; the user must respond to the message box before continuing work in the current application.
+Public Const VbSystemModal = 4096   '  System modal; all applications are suspended until the user responds to the message box.
+'The first group of values (05) describes the number and type of buttons displayed in the dialog box; the second group (16, 32, 48, 64) describes the icon style; the third group (0, 256, 512) determines which button is the default; and the fourth group (0, 4096) determines the modality of the message box. When adding numbers to create a final value for the buttons argument, use only one number from each group.
+
+'Note   These constants are specified by Visual Basic for Applications. As a result, the names can be used anywhere in your code in place of the actual values.
+'Return Values
+Public Const vbOK = 1   '  OK
+Public Const vbCancel = 2    ' Cancel
+Public Const vbAbort = 3 ' Abort
+Public Const vbRetry = 4 '  Retry
+Public Const vbIgnore = 5   '  Ignore
+Public Const vbYes = 6  '  Yes
+Public Const vbNo = 7    ' No
+
+Public Const OFS_MAXPATHNAME = 128
+Public Const OF_EXIST = &H4000
+Public Const WM_COMMAND = &H111
+
+''''''''''''''''''''''''''''''''''''''''''''''''''
+'''''TYPES TO INTERACT with OTHER libraries'''''''
+'''''''''''''''''''''''''''''''''''''''''''''''''
+Public Type OFSTRUCT
+        cBytes As Byte
+        fFixedDisk As Byte
+        nErrCode As Integer
+        Reserved1 As Integer
+        Reserved2 As Integer
+        szPathName(OFS_MAXPATHNAME) As Byte
+End Type
+
+Public Type OVERLAPPED
+        Internal As Long
+        InternalHigh As Long
+        Offset As Long
+        OffsetHigh As Long
+        hEvent As Long
+End Type
+
+Public Type SECURITY_ATTRIBUTES
+        nLength As Long
+        lpSecurityDescriptor As Long
+        bInheritHandle As Long
+End Type
+
+''''''''''''''''''''''''''''''''''''''''''''''''''
+'''''Function TO INTERACT with OTHER libraries'''''''
+'''''''''''''''''''''''''''''''''''''''''''''''''
+Public Declare Function OpenFile Lib "kernel32" (ByVal lpFileName As String, lpReOpenBuff As OFSTRUCT, _
+ByVal wStyle As Long) As Long
+
+Public Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
+
+Public Declare Function DeleteFile Lib "kernel32" Alias "DeleteFileA" (ByVal lpFileName As String) As Long
+
+Public Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" _
+(ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, _
+lpNumberOfFreeClusters As Long, lpTotalNumberOfClusters As Long) As Long
+
+Public Declare Function GetTickCount Lib "kernel32" () As Long
+
+
+
diff --git a/AutofocusScreen/src/AutofocusScreen/CorrectFocusForm.frm b/AutofocusScreen/src/AutofocusScreen/CorrectFocusForm.frm
deleted file mode 100644
index 5f78e77..0000000
--- a/AutofocusScreen/src/AutofocusScreen/CorrectFocusForm.frm
+++ /dev/null
@@ -1,64 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} CorrectFocusForm 
-   Caption         =   "Correct Focus"
-   ClientHeight    =   2130
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   4410
-   OleObjectBlob   =   "CorrectFocusForm.frx":0000
-   ShowModal       =   0   'False
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "CorrectFocusForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-
-
-
-
-
-Private Sub ChangeFocusButton_Click()
-ChangeFocus = True
-FocusChanged = True
-RestoreAcquisitionParameters
-Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-DoEvents
-AutofocusForm.ActivateAcquisitionTrack
- While ChangeFocus = True
-                       DoEvents
-                        Sleep (100)
-Wend
-
-End Sub
-
-Private Sub GoOnButton_Click()
-ChangeFocus = False
-Unload CorrectFocusForm
-DoNotGoOn = False
-End Sub
-
-
-
-Private Sub UserForm_Activate()
-Dim i As Long
-Dim j As Long
-i = 5
-ChangeFocus = False
-FocusChanged = False
-While i >= 1
-    
-    Label1.Caption = "The focus couldnot be found. Do You want to change the Position of the FocusWheel manually?" _
-                     + " If you donot press the Change Button, then prgramme will go on automatically in " _
-                     + CStr(i) + " sec."
-    Sleep (1000)
-    DoEvents
-    If ChangeFocus Then Exit Sub
-    i = i - 1
-Wend
-
-If i = 0 Then Unload CorrectFocusForm
-DoNotGoOn = False
-End Sub
diff --git a/AutofocusScreen/src/AutofocusScreen/CorrectFocusForm.frx b/AutofocusScreen/src/AutofocusScreen/CorrectFocusForm.frx
deleted file mode 100644
index d1687ea..0000000
Binary files a/AutofocusScreen/src/AutofocusScreen/CorrectFocusForm.frx and /dev/null differ
diff --git a/AutofocusScreen/src/AutofocusScreen/CreditForm.frx b/AutofocusScreen/src/AutofocusScreen/CreditForm.frx
index 9c49787..91e525f 100644
Binary files a/AutofocusScreen/src/AutofocusScreen/CreditForm.frx and b/AutofocusScreen/src/AutofocusScreen/CreditForm.frx differ
diff --git a/AutofocusScreen/src/AutofocusScreen/ErrorLog.frm b/AutofocusScreen/src/AutofocusScreen/ErrorLog.frm
new file mode 100644
index 0000000..2219ea5
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/ErrorLog.frm
@@ -0,0 +1,41 @@
+VERSION 5.00
+Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} ErrorLog 
+   Caption         =   "ErrorLog"
+   ClientHeight    =   8100
+   ClientLeft      =   45
+   ClientTop       =   375
+   ClientWidth     =   7485
+   OleObjectBlob   =   "ErrorLog.frx":0000
+   ShowModal       =   0   'False
+   StartUpPosition =   1  'CenterOwner
+End
+Attribute VB_Name = "ErrorLog"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = True
+Attribute VB_Exposed = False
+Const MaxSizeLog = 10000
+
+Public Function UpdateLog(Text As String)
+    Dim iFileNum
+    Dim ErrText As String
+    ErrText = Left(ErrorLogLabel.Caption, MaxSizeLog)
+    ErrorLogLabel.Caption = Now & " " & Text & vbCrLf & ErrText
+    ErrorLog.Show
+    'write to ErrorFile
+    If Log Then
+        If SafeOpenTextFile(ErrFileName, ErrFile, FileSystem) Then
+            ErrFile.WriteLine Now & " " & Text
+            ErrFile.Close
+        Else
+            Log = False
+        End If
+    End If
+End Function
+
+Public Function ResetLog()
+    ErrorLogLabel.Caption = ""
+    ErrorLog.Hide
+End Function
+
+
diff --git a/AutofocusScreen/src/AutofocusScreen/ErrorLog.frx b/AutofocusScreen/src/AutofocusScreen/ErrorLog.frx
new file mode 100644
index 0000000..c873b52
Binary files /dev/null and b/AutofocusScreen/src/AutofocusScreen/ErrorLog.frx differ
diff --git a/AutofocusScreen/src/AutofocusScreen/FCSFunctions.bas b/AutofocusScreen/src/AutofocusScreen/FCSFunctions.bas
index 6b715e2..63f0a3d 100644
--- a/AutofocusScreen/src/AutofocusScreen/FCSFunctions.bas
+++ b/AutofocusScreen/src/AutofocusScreen/FCSFunctions.bas
@@ -1,4 +1,8 @@
 Attribute VB_Name = "FCSFunctions"
+''''
+' Module contains Functions used during Fcs
+''''
+
 Option Explicit 'force to declare all variables
 
 Public Declare Function GetInputState Lib "user32" () As Long ' Check if mouse or keyboard has been pushed
@@ -9,229 +13,10 @@ Public viewerGuiServer As AimViewerGuiServer
 Public FcsPositions As AimFcsSamplePositionParameters
 Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
 Public FcsData As AimFcsData
-'Public ScanStop As Boolean
-'Public AcquisitionController  As AimScanController
-'Public Const PrecXY = 3
 Public Const Pause = 100 'pause in ms
 
 
-'''''
-'   Set the FCS controller and data stuff
-'''''
-Private Sub Initialize_Controller()
-    Set FcsControl = Fcs 'member of Lsm5VBAProject
-    Set viewerGuiServer = Lsm5.viewerGuiServer
-    Set FcsPositions = FcsControl.SamplePositionParameters
-    viewerGuiServer.FcsSelectLsmImagePositions = True
-End Sub
-
-Public Sub NewRecord(RecordingDoc As DsRecordingDoc, Optional name As String, Optional Container As Long = 0)
-    If ZEN = 2010 Then
-        NewRecord2010 RecordingDoc, name
-    ElseIf ZEN > 2010 Then
-        NewRecord2011 RecordingDoc, name
-    End If
-End Sub
-
-Public Sub NewRecord2010(RecordingDoc As DsRecordingDoc, Optional name As String, Optional Container As Long = 0)
-    Dim node As AimExperimentTreeNode
-    Set viewerGuiServer = Lsm5.viewerGuiServer
-    If RecordingDoc Is Nothing Then
-        Set node = Lsm5.CreateObject("AimExperiment.TreeNode")
-        node.Type = eExperimentTeeeNodeTypeLsm
-        On Error Resume Next
-        viewerGuiServer.InsertExperimentTreeNode node, True '''' Do  not respond to error of compiler just comment it out and rerun the compiler (this is from late 2010 onwards not more up to date
-        Set RecordingDoc = Lsm5.DsRecordingActiveDocObject
-        While RecordingDoc.IsBusy
-            Sleep (Pause)
-            DoEvents
-        Wend
-        RecordingDoc.SetTitle name
-    End If
-End Sub
-
-Public Sub NewRecord2011(RecordingDoc As DsRecordingDoc, Optional name As String, Optional Container As Long = 0)
-    Dim node As AimExperimentTreeNode
-    Set viewerGuiServer = Lsm5.viewerGuiServer
-    If RecordingDoc Is Nothing Then
-        Set node = Lsm5.CreateObject("AimExperiment.TreeNode")
-        node.Type = eExperimentTeeeNodeTypeLsm
-        viewerGuiServer.InsertExperimentTreeNode node, True, Container
-
-        Set RecordingDoc = Lsm5.DsRecordingActiveDocObject
-        While RecordingDoc.IsBusy
-            Sleep (Pause)
-            DoEvents
-        Wend
-        RecordingDoc.SetTitle name
-    End If
-End Sub
-
-
-Public Sub NewFcsRecord(FcsData As AimFcsData, Optional name As String, Optional Container As Long = 0)
-    Dim node As AimExperimentTreeNode
-    Set viewerGuiServer = Lsm5.viewerGuiServer
-    Dim Recording As DsRecordingDoc
-    If FcsData Is Nothing Then
-        Set node = Lsm5.CreateObject("AimExperiment.TreeNode")
-        node.Type = eExperimentTeeeNodeTypeConfoCor
-        viewerGuiServer.InsertExperimentTreeNode node, True, Container
-        ' Insert an FCS document into ZEN
-        Set FcsData = node.FcsData
-        FcsData.name = name
-        Set Recording = Lsm5.DsRecordingActiveDocObject
-        Recording.SetTitle name
-    End If
-
-End Sub
-''''
-' Start Fcs Measurment
-''''
-Public Function FcsMeasurement(Optional FcsData As AimFcsData) As Boolean
-    Dim node As AimExperimentTreeNode
-    Set viewerGuiServer = Lsm5.viewerGuiServer
-    Set FcsControl = Fcs
-    Set viewerGuiServer = Lsm5.viewerGuiServer
-    
-    If FcsData Is Nothing Then
-       NewFcsRecord FcsData
-    End If
-    'FcsData.name = "Bla"
-    FcsControl.StopAcquisitionAndWait
-    FcsControl.StartMeasurement FcsData
-    Sleep (Pause)
-    While FcsControl.IsAcquisitionRunning(1)
-        Sleep (Pause)
-        If ScanStop Then
-            FcsControl.StopAcquisitionAndWait
-            Exit Function
-        End If
-        DoEvents
-    Wend
-    FcsControl.StopAcquisitionAndWait
-    FcsMeasurement = True
-End Function
-
 
-''''''
-''   ScanToImage ( RecordingDoc As DsRecordingDoc) As Boolean
-''   scan overwrite the same image, even with several z-slices
-''''''
-'Public Function ScanToImage(RecordingDoc As DsRecordingDoc) As Boolean
-'    Dim ProgressFifo As IAimProgressFifo ' what is this?
-'    Dim gui As Object, treenode As Object
-'    'Set gui = Lsm5.ViewerGuiServer
-'    If RecordingDoc Is Nothing Then
-'        NewRecord RecordingDoc
-'    End If
-'    If Not RecordingDoc Is Nothing Then
-'        Set treenode = RecordingDoc.RecordingDocument.image(0, True)
-'        'Set treenode = Lsm5.NewDocument why not this?
-'        Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller ' public variable
-'        AcquisitionController.DestinationImage(0) = treenode 'EngelImageToHechtImage(GlobalSingleImage).Image(0, True)
-'        AcquisitionController.DestinationImage(1) = Nothing
-'        Set ProgressFifo = AcquisitionController.DestinationImage(0)
-'        Lsm5.tools.CheckLockControllers True
-'        AcquisitionController.StartGrab eGrabModeSingle
-'        'Set RecordingDoc = Lsm5.StartScan this does not overwrite
-'        If Not ProgressFifo Is Nothing Then ProgressFifo.Append AcquisitionController
-'    End If
-'    Sleep (Pause)
-'    While AcquisitionController.IsGrabbing
-'        Sleep (Pause) ' this sometimes hangs if we use GetInputState. Try now without it and test if it does not hang
-'        DoEvents
-'        If ScanStop Then
-'            Lsm5.StopAcquisition
-'            Exit Function
-'        End If
-'    Wend
-'    ScanToImage = True
-'End Function
-
-
-'''''''
-'' SaveDsRecordingDoc(Document As DsRecordingDoc, FileName As String) As Boolean
-'' Copied and adapted from MultiTimeSeries macro
-'''''''
-'Public Function SaveDsRecordingDoc(Document As DsRecordingDoc, FileName As String) As Boolean
-'    Dim Export As AimImageExport
-'    Dim image As AimImageMemory
-'    Dim Error As AimError
-'    Dim Planes As Long
-'    Dim Plane As Long
-'    Dim Horizontal As enumAimImportExportCoordinate
-'    Dim Vertical As enumAimImportExportCoordinate
-'
-'
-'    'Set Image = EngelImageToHechtImage(Document).Image(0, True)
-'    If Not Document Is Nothing Then
-'        Set image = Document.RecordingDocument.image(0, True)
-'    End If
-'
-'    Set Export = Lsm5.CreateObject("AimImageImportExport.Export.4.5")
-'    'Set Export = New AimImageExport
-'    Export.FileName = FileName
-'    Export.Format = eAimExportFormatLsm5
-'    Export.StartExport image, image
-'    Set Error = Export
-'    Error.LastErrorMessage
-'
-'    Planes = 1
-'    Export.GetPlaneDimensions Horizontal, Vertical
-'
-'    Select Case Vertical
-'        Case eAimImportExportCoordinateY:
-'             Planes = image.GetDimensionZ * image.GetDimensionT
-'        Case eAimImportExportCoordinateZ:
-'            Planes = image.GetDimensionT
-'    End Select
-'
-'    'TODO check. what happens here with Export.ExportPlane Nothing why Nothing (thumbnails)
-'    For Plane = 0 To Planes - 1
-'        If GetInputState() <> 0 Then
-'            DoEvents
-'             If ScanStop Then
-'                Export.FinishExport
-'                Exit Function
-'            End If
-'        End If
-'        Export.ExportPlane Nothing
-'    Next Plane
-'    Export.FinishExport
-'    SaveDsRecordingDoc = True
-'
-'End Function
-
-''''
-' SaveFcsMeasurment to File
-''''
-Public Sub SaveFcsMeasurement(FcsData As AimFcsData, fileName As String)
-    
-    If FcsData Is Nothing Then
-        MsgBox "No Fcs Recording to Save"
-        Exit Sub
-    End If
-    ' Write to file
-    Dim writer As AimFcsFileWrite
-    Set writer = Lsm5.CreateObject("AimFcsFile.Write")
-    writer.fileName = fileName
-    writer.FileWriteType = eFcsFileWriteTypeAll
-    writer.Format = eFcsFileFormatConfoCor3WithRawData
-
-    writer.Source = FcsData
-    writer.Run
-       
-    If Not writer.DestinationFilesExist(fileName) Then
-        writer.fileName = fileName
-        writer.FileWriteType = eFcsFileWriteTypeAll
-        writer.Format = eFcsFileFormatConfoCor3WithRawData
-    
-        writer.Source = FcsData
-        writer.Run
-    Else
-    
-    End If
-End Sub
 
 '''''
 '   GetFcsPosition(PosX As Double, PosY As Double, PosZ As Double)
@@ -257,6 +42,7 @@ End Sub
 '   SetFcsPosition(PosX As Double, PosY As Double, PosZ As Double, Pos As Long)
 '   Create a new position if Pos > FcsPositions.PositionListSize
 '   then all positions inbetween are set to 0
+'
 '''''
 Public Function SetFcsPosition(PosX As Double, PosY As Double, PosZ As Double, pos As Long) As Boolean
     Set FcsControl = Fcs
@@ -268,6 +54,25 @@ Public Function SetFcsPosition(PosX As Double, PosY As Double, PosZ As Double, p
     viewerGuiServer.UpdateFcsPositions
 End Function
 
+'''''
+'   SetFcsPosition(PosX As Double, PosY As Double, PosZ As Double, Pos As Long)
+'   Create a new position if Pos > FcsPositions.PositionListSize
+'   then all positions inbetween are set to 0
+'''''
+Public Function setFcsPositions(positions() As Vector) As Boolean
+    Dim pos As Integer
+    Set FcsControl = Fcs
+    Set FcsPositions = FcsControl.SamplePositionParameters
+    For pos = 0 To UBound(positions)
+        FcsPositions.PositionX(pos) = positions(pos).X
+        FcsPositions.PositionY(pos) = positions(pos).Y
+        FcsPositions.PositionZ(pos) = positions(pos).Z
+    Next pos
+    Debug.Print FcsPositions.PositionZ(0)
+    'this shows the small crosshair
+    viewerGuiServer.UpdateFcsPositions
+End Function
+
 ''''
 '   GetFcsListPositionLength()
 '   Maximal number of positions
@@ -292,34 +97,7 @@ Public Function ClearFcsPositionList()
     viewerGuiServer.UpdateFcsPositions
 End Function
 
-Public Sub SaveFcsPositionList(sFile As String, pixelSizeXY As Double, pixelSizeZ As Double)
-    On Error GoTo ErrorHandle
-    Close
-    Dim iFileNum As Integer
-    Dim i As Long
-    Dim PosX As Double
-    Dim PosY As Double
-    Dim PosZ As Double
-    iFileNum = FreeFile()
-    Open sFile For Output As iFileNum
-    If pixelSizeXY > 0 And pixelSizeZ > 0 Then
-        Print #iFileNum, "%X Y Z (um) X Y Z (px); 0 0 is center of image"
-    Else
-        Print #iFileNum, "%X Y Z (um); 0 0 is center of image"
-    End If
-    For i = 0 To GetFcsPositionListLength - 1
-        GetFcsPosition PosX, PosY, PosZ, i
-        If pixelSizeXY > 0 And pixelSizeZ > 0 Then
-            Print #iFileNum, Round(PosX * 1000000, PrecXY) & " " & Round(PosY * 1000000, PrecXY) & " " & Round(PosZ * 1000000, PrecXY) & " " & PosX / pixelSizeXY & " " & PosY / pixelSizeXY & " " & PosZ / pixelSizeZ
-        Else
-            Print #iFileNum, Round(PosX * 1000000, PrecXY) & " " & Round(PosY * 1000000, PrecXY) & " " & Round(PosZ * 1000000, PrecXY)
-        End If
-    Next i
-    Close
-    Exit Sub
-ErrorHandle:
-    MsgBox "Can't write " & sFile & " for the FcsPositions"
-End Sub
+
 
 
 
diff --git a/AutofocusScreen/src/AutofocusScreen/FcsJobs.cls b/AutofocusScreen/src/AutofocusScreen/FcsJobs.cls
new file mode 100644
index 0000000..f37e75f
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/FcsJobs.cls
@@ -0,0 +1,168 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "FcsJobs"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''
+' A Class to manage several AFcsJob instances(commodity class in absence of inheritance in VBA)
+'''
+Option Explicit
+
+'''' We can use number or a dictionary to find a Job in Jobs
+Private Jobs() As AFcsJob
+Private JobNames As Dictionary
+Private ZoomPixelSlice(1 To 9, 1 To 3) As Double
+Public ZENv As Integer
+
+
+Private Function checkJobName(Name As String) As Boolean
+    If JobNames.Exists(Name) Then
+        checkJobName = True
+    Else
+        MsgNoJob Name
+    End If
+End Function
+
+Private Sub MsgNoJob(Name As String)
+    MsgBox "ImagingJobs: Job " & Name & " has not been defined"
+End Sub
+
+'''
+'   Initialize a series of Jobs with given name
+'''
+Public Sub initialize(Names() As String, ZEN As Object)
+    Dim i As Integer
+    ZENv = getVersionNr
+    For i = 0 To UBound(Names)
+        AddJob CStr(Names(i)), ZEN
+    Next i
+End Sub
+
+'''
+' AddJob
+'   Add Job and increase number of Jobs
+'''
+Public Sub AddJob(Name As String, ZEN As Object)
+ On Error GoTo ErrorHandle:
+    If JobNames Is Nothing Then
+        Set JobNames = New Dictionary
+    End If
+    If Not JobNames.Exists(Name) Then
+        If isArrayEmpty(Jobs) Then
+            ReDim Jobs(0)
+        Else
+            ReDim Preserve Jobs(0 To UBound(Jobs) + 1)
+        End If
+        JobNames.Add Name, UBound(Jobs)
+    End If
+    Dim i As Integer
+    Dim iJob As Integer
+    iJob = JobNames.Item(Name)
+    Set Jobs(iJob) = New AFcsJob
+    Jobs(iJob).Name = Name
+    'Jobs(iJob).setJob ZEN, ZENv
+    Exit Sub
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in FcsJobs.AddJob " + Name + " " + Err.Description
+End Sub
+
+
+
+'''
+'   Set the job with Name from ZEN
+'''
+Public Function setJob(Name As String, ZEN As Object) As Boolean
+    On Error GoTo ErrorHandle:
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    If Jobs(JobNames.Item(Name)).setJob(ZEN, ZENv) Then
+        setJob = True
+    End If
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in FcsJobs.setJob " + Name + " " + Err.Description
+End Function
+
+'''
+'   Set the job with Name from ZEN
+'''
+Public Function setJobNoAi(Name As String, ConfigName As String) As Boolean
+    On Error GoTo ErrorHandle:
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    If Jobs(JobNames.Item(Name)).setJobNoAi(ConfigName) Then
+        setJobNoAi = True
+    End If
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in FcsJobs.setJobNoAi " + Name + " " + Err.Description
+End Function
+
+'''
+'   Put the job with Name from Macro into ZEN
+'''
+Public Function putJob(Name As String, ZEN As Object) As Boolean
+    On Error GoTo ErrorHandle:
+    Dim iJob As Integer
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    If Jobs(JobNames.Item(Name)).putJob(ZEN, ZENv) Then
+        putJob = True
+    End If
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in FcsJobs.putJob " + Name + " " + Err.Description
+ End Function
+
+''''
+' Create a string with the description of a Job
+''''
+Public Function jobDescriptor(Name As String) As String
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    jobDescriptor = Jobs(JobNames.Item(Name)).jobDescriptor
+End Function
+
+
+''''
+' Create a string with the description of a Job
+''''
+Public Function splittedJobDescriptor(Name As String, MaxLines As Integer) As String()
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    splittedJobDescriptor = Jobs(JobNames.Item(Name)).splittedJobDescriptor(MaxLines, jobDescriptor(Name))
+End Function
+
+Public Function getLightPathConfig(Name As String) As String
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getLightPathConfig = Jobs(JobNames.Item(Name)).LightPathConfig
+End Function
+
+''''
+' Create a string with the description of a Job to be used as settings
+''''
+Public Function jobDescriptorSettings(Name As String) As String
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    jobDescriptorSettings = Jobs(JobNames.Item(Name)).jobDescriptorSettings
+End Function
+
+Public Function changeJobFromDescriptor(Name As String, Descriptor As String, Value As Variant)
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    changeJobFromDescriptor = Jobs(JobNames.Item(Name)).changeJobFromDescriptor(Descriptor, Value)
+End Function
+
diff --git a/AutofocusScreen/src/AutofocusScreen/FileIO.bas b/AutofocusScreen/src/AutofocusScreen/FileIO.bas
index 8c7a50f..b443173 100644
--- a/AutofocusScreen/src/AutofocusScreen/FileIO.bas
+++ b/AutofocusScreen/src/AutofocusScreen/FileIO.bas
@@ -2,13 +2,16 @@ Attribute VB_Name = "FileIO"
 ''''
 ' A list of functions to open and write text files, check their existance etc
 ''''
-
+Option Explicit
 ''''''''''''''''''''''''
 'Debug and LogVariables'
 ''''''''''''''''''''''''
 Public LogFile As TextStream 'This is the file where a log of the procedure is saved
+Public ErrFile As TextStream 'This is the file where a log of the procedure is saved
 Public LogFileName As String
+Public ErrFileName As String
 Public LogFileNameBase As String
+Public ErrFileNameBase As String
 Public FileSystem As FileSystemObject
 Public Log     As Boolean          'If true we log data during the macro
 
@@ -28,15 +31,15 @@ Public UnderScore As String
 Public Function ZeroString(NrofZeros As Integer) As String
     'convert numbers into a string
     Dim i As Integer
-    Dim name As String
-    name = ""
+    Dim Name As String
+    Name = ""
     If NrofZeros > 0 Then
         For i = 1 To NrofZeros
-            name = name + "0"
+            Name = Name + "0"
         Next i
     End If
         
-    ZeroString = name
+    ZeroString = Name
 End Function
 
 '''''
@@ -108,280 +111,41 @@ Public Function LogMessage(ByVal Msg As String, ByVal Log As Boolean, ByVal Path
 End Function
 
 
-'''''
-'   FileName(iPosition As Integer, iSubposition As Integer, iRepetition As Integer ) As String
-'   Returns string by concatanating well, and sublocation and timepoint. A negative point will omit the string
-'       [Row] In - Row
-'       [Col] In - Col
-'       [RowSub]  In - subrow
-'       [ColSub]  In - subcol
-'       [iRepetition] In - time point
-'''''
-Public Function fileName(Row As Long, Col As Long, RowSub As Long, ColSub As Long, iRepetition As Integer) As String
-    'convert numbers into a string
-    Dim iWell As Long
-    Dim iPosition As Long
-
-    Dim name As String
-    Dim nrZero As Integer
-    Dim maxZeros As Integer
-    maxZeros = 3
-    name = ""
-    iWell = (Row - 1) * UBound(posGridX, 2) + Col
-    iPosition = (RowSub - 1) * UBound(posGridX, 4) + ColSub
-    If iWell >= 0 Then
-        nrZero = maxZeros - Len(CStr(iWell))
-        name = name + "W" + ZeroString(nrZero) + CStr(iWell)
-    End If
-    If iPosition >= 0 Then
-        nrZero = maxZeros - Len(CStr(iPosition))
-        name = name + "_P" + ZeroString(nrZero) + CStr(iPosition)
-    End If
-    If iRepetition >= 0 Then
-        nrZero = maxZeros - Len(CStr(iRepetition))
-        name = name + "_T" + ZeroString(nrZero) + CStr(iRepetition)
-    End If
-    fileName = name
-End Function
-
-
+''''''
+''   FileName(iPosition As Integer, iSubposition As Integer, iRepetition As Integer ) As String
+''   Returns string by concatanating well, and sublocation and timepoint. A negative point will omit the string
+''       [Row] In - Row
+''       [Col] In - Col
+''       [RowSub]  In - subrow
+''       [ColSub]  In - subcol
+''       [iRepetition] In - time point
+''''''
+'Public Function FileName(Row As Long, Col As Long, RowSub As Long, ColSub As Long, iRepetition As Integer) As String
+'    'convert numbers into a string
+'    Dim iWell As Long
+'    Dim iPosition As Long
+'
+'    Dim Name As String
+'    Dim nrZero As Integer
+'    Dim maxZeros As Integer
+'    maxZeros = 3
+'    Name = ""
+'    iWell = (Row - 1) * UBound(posGridX, 2) + Col
+'    iPosition = (RowSub - 1) * UBound(posGridX, 4) + ColSub
+'    If iWell >= 0 Then
+'        nrZero = maxZeros - Len(CStr(iWell))
+'        Name = Name + "W" + ZeroString(nrZero) + CStr(iWell)
+'    End If
+'    If iPosition >= 0 Then
+'        nrZero = maxZeros - Len(CStr(iPosition))
+'        Name = Name + "_P" + ZeroString(nrZero) + CStr(iPosition)
+'    End If
+'    If iRepetition >= 0 Then
+'        nrZero = maxZeros - Len(CStr(iRepetition))
+'        Name = Name + "_T" + ZeroString(nrZero) + CStr(iRepetition)
+'    End If
+'    FileName = Name
+'End Function
 
-''''
-' CheckPosFile
-' Check that entries of first line correspond to 4 specific values
-''''
-Public Function CheckPosFile(ByVal sFile As String, ByVal Row As Integer, ByVal Col As Integer, ByVal RowSub As Integer, ByVal ColSub As Integer) As Boolean
-    If FileExist(sFile) Then
-        Close
-        On Error GoTo ErrorPosFile:
-        Dim iFileNum As Integer
-        Dim Fields As String
-        Dim FieldEntries() As String
-        iFileNum = FreeFile()
-        Open sFile For Input As iFileNum
-        Line Input #iFileNum, Fields
-        While Left(Fields, 1) = "%"
-            Line Input #iFileNum, Fields
-        Wend
-        FieldEntries = Split(Fields, " ")
-        If FieldEntries(0) = Row And FieldEntries(1) = Col And FieldEntries(2) = RowSub And FieldEntries(3) = ColSub Then
-            CheckPosFile = True
-        End If
-        Close #iFileNum
-    End If
-    Exit Function
-ErrorPosFile:
-    If Err.Number = 70 Then
-        MsgBox ("WritePosFile: Was not able to load position file " & sFile & ". File is open by another program.")
-    End If
-End Function
-
-'''''''
-' LoadPosFile(ByVal sFile As String, posGridX() As Double, posGridY() As Double, posGridZ() As Double)
-'       [sFile] In  - Output file name
-'       [posGridX], [posGridY], [posGridZ] In  - Array where to write coordinates of positions
-'   Function loads a file and write entries in Double arrays. First entry of file is structure of grid
-''''''''
-Public Function LoadPosFile(ByVal sFile As String, _
-  posGridX() As Double, posGridY() As Double, posGridZ() As Double) As Boolean
-    Dim iRow As Integer
-    Dim iCol As Integer
-    Dim iRowSub As Integer
-    Dim iColSub As Integer
-    Close
-    On Error GoTo ErrorPosFile:
-    Dim iFileNum As Integer
-    Dim Fields As String
-    Dim FieldEntries() As String
-    iFileNum = FreeFile()
-    Open sFile For Input As iFileNum
-    Line Input #iFileNum, Fields
-    While Left(Fields, 1) = "%"
-        Line Input #iFileNum, Fields
-    Wend
-    FieldEntries = Split(Fields, " ")
-    ReDim posGridX(1 To CDbl(FieldEntries(0)), 1 To CDbl(FieldEntries(1)), 1 To CDbl(FieldEntries(2)), 1 To CDbl(FieldEntries(3)))
-    ReDim posGridY(1 To CDbl(FieldEntries(0)), 1 To CDbl(FieldEntries(1)), 1 To CDbl(FieldEntries(2)), 1 To CDbl(FieldEntries(3)))
-    ReDim posGridZ(1 To CDbl(FieldEntries(0)), 1 To CDbl(FieldEntries(1)), 1 To CDbl(FieldEntries(2)), 1 To CDbl(FieldEntries(3)))
-    For iRow = 1 To UBound(posGridX, 1)
-      For iCol = 1 To UBound(posGridX, 2)
-          Line Input #iFileNum, Fields
-          While Left(Fields, 1) = "%"
-            Line Input #iFileNum, Fields
-          Wend
-          FieldEntries = Split(Fields, " ")
-          For iRowSub = 1 To UBound(posGridX, 3)
-              For iColSub = 1 To UBound(posGridX, 4)
-                  posGridX(iRow, iCol, iRowSub, iColSub) = CDbl(FieldEntries((iColSub - 1) * 3 + (iRowSub - 1) * UBound(posGridX, 3) * 3))
-                  posGridY(iRow, iCol, iRowSub, iColSub) = CDbl(FieldEntries((iColSub - 1) * 3 + (iRowSub - 1) * UBound(posGridX, 3) * 3 + 1))
-                  posGridZ(iRow, iCol, iRowSub, iColSub) = CDbl(FieldEntries((iColSub - 1) * 3 + (iRowSub - 1) * UBound(posGridX, 3) * 3 + 2))
-              Next iColSub
-          Next iRowSub
-      Next iCol
-    Next iRow
-    Close #iFileNum
-    LoadPosFile = True
-    Exit Function
-ErrorPosFile:
-    If Err.Number = 70 Then
-        MsgBox ("WritePosFile: Was not able to load position file " & sFile & ". File is open by another program.")
-    Else
-        MsgBox ("WritePosFile: Was not able to load position file " & sFile)
-    End If
-    MsgBox ("Was not able to load position file " & sFile)
-End Function
-    
-'''''''
-'   LoadValidFile(ByVal sFile As String, posGridXY_Valid() As Boolean) As Boolean
-'       [sFile] In - name of file
-'       [posGridXY_Valid] In/Out - the valid positions to image in the grid
-'   Function loads a file and write entries in Double arrays
-'   First non-commented line is structure of array
-''''''''
-Public Function LoadValidFile(ByVal sFile As String, posGridXY_Valid() As Boolean) As Boolean
-    Dim iRow As Integer
-    Dim iCol As Integer
-    Dim iRowSub As Integer
-    Dim iColSub As Integer
-    Close
-    On Error GoTo ErrorPosFile:
-    Dim iFileNum As Integer
-    Dim Fields As String
-    Dim FieldEntries() As String
-    iFileNum = FreeFile()
-    Open sFile For Input As iFileNum
-    Line Input #iFileNum, Fields
-    While Left(Fields, 1) = "%"
-        Line Input #iFileNum, Fields
-    Wend
-    FieldEntries = Split(Fields, " ")
-    ReDim posGridXY_Valid(1 To CDbl(FieldEntries(0)), 1 To CDbl(FieldEntries(1)), 1 To CDbl(FieldEntries(2)), 1 To CDbl(FieldEntries(3)))
-    For iRow = 1 To UBound(posGridX, 1)
-      For iCol = 1 To UBound(posGridX, 2)
-          Line Input #iFileNum, Fields
-          While Left(Fields, 1) = "%"
-            Line Input #iFileNum, Fields
-          Wend
-          FieldEntries = Split(Fields, " ")
-          For iRowSub = 1 To UBound(posGridX, 3)
-              For iColSub = 1 To UBound(posGridX, 4)
-                  posGridXY_Valid(iRow, iCol, iRowSub, iColSub) = CBool(FieldEntries((iColSub - 1) + (iRowSub - 1) * UBound(posGridX, 3)))
-              Next iColSub
-          Next iRowSub
-      Next iCol
-    Next iRow
-    Close #iFileNum
-    LoadValidFile = True
-    Exit Function
-ErrorPosFile:
-    If Err.Number = 70 Then
-        MsgBox ("WritePosFile: Was not able to load position file " & sFile & ". File is open by another program.")
-    Else
-        MsgBox ("WritePosFile: Was not able to load position file " & sFile)
-    End If
-    MsgBox ("Was not able to load position file " & sFile)
-End Function
-    
-'''''''
-'   WritePosFile (ByVal sFile As String, posGridX() As Double, posGridY() As Double, posGridZ() As Double)
-'       [sFile] In  - Output file name
-'       [posGridX], [posGridY], [posGridZ] In  - Array with coordinates of positions
-'   Write out position of grid. The first uncommented line is the structure of the grid
-''''''''
-Public Function WritePosFile(ByVal sFile As String, _
-  posGridX() As Double, posGridY() As Double, posGridZ() As Double) As Boolean
-    Dim iRow As Integer
-    Dim iCol As Integer
-    Dim iRowSub As Integer
-    Dim iColSub As Integer
-    Dim Line As String
-    Dim LineComm As String
-    Close
-    On Error GoTo ErrorPosFile:
-    Dim iFileNum As Integer
-    Dim Fields As String
-    Dim FieldEntries() As String
-    iFileNum = FreeFile()
-    Open sFile For Output As iFileNum
-    Print #iFileNum, "%nrRows nrColumns nrsubRows nrsubColumns"
-    Print #iFileNum, UBound(posGridX, 1) & " " & UBound(posGridX, 2) & " " & UBound(posGridX, 3) & " " & UBound(posGridX, 4)
-    For iRow = 1 To UBound(posGridX, 1)
-      For iCol = 1 To UBound(posGridX, 2)
-          LineComm = "%Row: " & iRow & ", Col: " & iCol & " "
-          Print #iFileNum, LineComm
-          Line = ""
-          LineComm = "%Rowsub Colsub: "
-          For iRowSub = 1 To UBound(posGridX, 3)
-              For iColSub = 1 To UBound(posGridX, 4)
-                 LineComm = LineComm & iRowSub & " " & iColSub & ", "
-                 Line = Line & posGridX(iRow, iCol, iRowSub, iColSub) & " " & posGridY(iRow, iCol, iRowSub, iColSub) & " " _
-                  & posGridZ(iRow, iCol, iRowSub, iColSub) & " "
-              Next iColSub
-          Next iRowSub
-        Print #iFileNum, LineComm
-        Print #iFileNum, Line
-      Next iCol
-    Next iRow
-    Close #iFileNum
-    WritePosFile = True
-    Exit Function
-ErrorPosFile:
-    If Err.Number = 70 Then
-        MsgBox ("WritePosFile: Was not able to load position file " & sFile & ". File is open by another program")
-    Else
-        MsgBox ("WritePosFile: Was not able to load position file " & sFile)
-    End If
-    Close #iFileNum
-End Function
-    
-'''''''
-'   WriteValidFile (ByVal sFile As String, posGridXY_Valid() As Boolean) As Boolean
-'       [sFile] In - The filename
-'        [posGridXY_Valid] In - The valid positions
-'   Write which position is active/valid, i.e. imaged
-''''''''
-Public Function WriteValidFile(ByVal sFile As String, posGridXY_Valid() As Boolean) As Boolean
-    Dim iRow As Integer
-    Dim iCol As Integer
-    Dim iRowSub As Integer
-    Dim iColSub As Integer
-    Dim Line As String
-    Dim LineComm As String
-    Close
-    On Error GoTo ErrorPosFile:
-    Dim iFileNum As Integer
-    Dim Fields As String
-    Dim FieldEntries() As String
-    iFileNum = FreeFile()
-    Open sFile For Output As iFileNum
-    Print #iFileNum, "%nrRows nrColumns nrsubRows nrsubColumns"
-    Print #iFileNum, UBound(posGridXY_Valid, 1) & " " & UBound(posGridXY_Valid, 2) & " " & UBound(posGridXY_Valid, 3) & " " & UBound(posGridXY_Valid, 4)
-    For iRow = 1 To UBound(posGridXY_Valid, 1)
-      For iCol = 1 To UBound(posGridXY_Valid, 2)
-          LineComm = "%Row: " & iRow & ", Col: " & iCol & " "
-          Print #iFileNum, LineComm
-          Line = ""
-          LineComm = "%Rowsub Colsub: "
-          For iRowSub = 1 To UBound(posGridXY_Valid, 3)
-              For iColSub = 1 To UBound(posGridXY_Valid, 4)
-                 LineComm = LineComm & iRowSub & " " & iColSub & ", "
-                 Line = Line & -posGridXY_Valid(iRow, iCol, iRowSub, iColSub) * 1 & " "
-              Next iColSub
-          Next iRowSub
-        Print #iFileNum, LineComm
-        Print #iFileNum, Line
-      Next iCol
-    Next iRow
-    Close #iFileNum
-    WriteValidFile = True
-    Exit Function
-ErrorPosFile:
-    If Err.Number = 70 Then
-        MsgBox ("WriteValidFile: Was not able to load position file " & sFile & ". File is open by another program")
-    Else
-        MsgBox ("WriteValidFile: Was not able to load position file " & sFile)
-    End If
-    Close #iFileNum
-End Function
 
 
diff --git a/AutofocusScreen/src/AutofocusScreen/Functions.bas b/AutofocusScreen/src/AutofocusScreen/Functions.bas
index 3024f4c..3b04838 100644
--- a/AutofocusScreen/src/AutofocusScreen/Functions.bas
+++ b/AutofocusScreen/src/AutofocusScreen/Functions.bas
@@ -1,28 +1,144 @@
 Attribute VB_Name = "Functions"
+'''
+' Some utility functions
+''''
+
 Option Explicit
 
 Public Sub Autofocus_Setup()
         AutofocusForm.Show
 End Sub
 
+'''
+'   Display progress in bottom labal of AutofocusForm
+'''
+Public Sub DisplayProgress(State As String, Color As Long)       'Used to display in the progress bar what the macro is doing
+    If (Color & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Then
+        AutofocusForm.ProgressLabel.ForeColor = 0
+    Else
+        AutofocusForm.ProgressLabel.ForeColor = &HFFFFFF
+    End If
+    AutofocusForm.ProgressLabel.BackColor = Color
+    AutofocusForm.ProgressLabel.Caption = State
+    DoEvents
+End Sub
+
+
+'''
+' compute a weighted mean of the positiions of an array
+'''
+Public Function weightedMean(values() As Variant) As Double
+    Dim sum As Variant
+    Dim weight As Variant
+    Dim MIN As Variant
+    Dim i As Integer
+    sum = 0
+    weight = 0
+    MIN = MINA(values)
+    For i = LBound(values) To UBound(values)
+        sum = sum + (values(i) - MIN)
+        weight = weight + i * (values(i) - MIN)
+    Next i
+    'if sum is 0
+    If sum > 0 Then
+        weightedMean = weight / sum
+    Else
+        ' then mean is in the center
+        weightedMean = (UBound(values) = LBound(values)) / 2 + LBound(values)
+    End If
+End Function
+
+
+''
+' Calculate MIN of two values
+'''
+Public Function MIN(value1 As Variant, value2 As Variant) As Variant
+    If value1 > value2 Then
+        MIN = value2
+    Else
+        MIN = value1
+    End If
+End Function
+
+
+''
+' Calculate MIN of two values
+'''
+Public Function Max(value1 As Variant, value2 As Variant) As Variant
+    If value1 < value2 Then
+        Max = value2
+    Else
+        Max = value1
+    End If
+End Function
+
+
+''
+' Calculate MIN of Array
+'''
+Public Function MINA(values() As Variant) As Variant
+    Dim minLocal As Variant
+    Dim i As Integer
+    minLocal = 2 ^ 10
+    For i = LBound(values) To UBound(values)
+        minLocal = MIN(values(i), minLocal)
+    Next i
+    MINA = minLocal
+End Function
+
+''
+' Calculate MIN of Array
+'''
+Public Function MAXA(values() As Variant) As Variant
+    Dim maxLocal As Variant
+    Dim i As Integer
+    maxLocal = 0
+    For i = LBound(values) To UBound(values)
+        maxLocal = Max(values(i), maxLocal)
+    Next i
+    MAXA = maxLocal
+End Function
+
+
+
 '''''
 '  isArrayEmpty(parArray As Variant) As Boolean
 '  Returns false if not an array or dynamic array that has not been initialised (ReDim) or has been erased (Erase)
 '''''
 Public Function isArrayEmpty(parArray As Variant) As Boolean
-
     If IsArray(parArray) = False Then isArrayEmpty = True
     On Error Resume Next
     If UBound(parArray) < LBound(parArray) Then isArrayEmpty = True: Exit Function Else: isArrayEmpty = False
-
 End Function
 
+''''
+' Check if key is in collection
+''''
+Public Function InCollection(Col As Collection, Key As String) As Boolean
+  Dim var As Variant
+  Dim errNumber As Long
 
+  InCollection = False
+  Set var = Nothing
 
+  Err.Clear
+  On Error Resume Next
+    var = Col.Item(Key)
+    errNumber = CLng(Err.number)
+  On Error GoTo 0
+
+  '5 is not in, 0 and 438 represent incollection
+  If errNumber = 5 Then ' it is 5 if not in collection
+    InCollection = False
+  Else
+    InCollection = True
+  End If
+
+End Function
 
 '''''
 '   FServerFromDescription(strName As String, StrPath As String, ExecName As String) As Boolean
-'   TODO: What is this
+'   TODO: What is this?
 '''''
 Function FServerFromDescription(strName As String, StrPath As String, ExecName As String) As Boolean
     Dim lngResult As Long
diff --git a/AutofocusScreen/src/AutofocusScreen/ImagingGrids.cls b/AutofocusScreen/src/AutofocusScreen/ImagingGrids.cls
new file mode 100644
index 0000000..b2f1edb
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/ImagingGrids.cls
@@ -0,0 +1,410 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "ImagingGrids"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''
+' A Class to manage several AGrid instances (commodity class in absence of inheritance in VBA)
+'''
+
+Option Explicit
+Private Grids() As AGrid
+Private GridNames As Dictionary
+
+Private Sub MsgNoGrid(Name As String)
+    MsgBox "ImagingGrids: Grid " & Name & " has not been defined"
+End Sub
+
+'''
+' Create a set of grids with specified names. The default size is 0,0,0,0
+'''
+Public Sub initialize(Names() As String)
+    Dim i As Integer
+    ReDim Grids(0 To UBound(Names))
+    Set GridNames = New Dictionary
+    For i = 0 To UBound(Names)
+        AddGrid (Names(i))
+    Next i
+End Sub
+
+
+
+'''
+'   Add a new grid to array
+'''
+Public Sub AddGrid(Name As String, Optional numRow As Long = 0, Optional numCol As Long = 0, _
+Optional numRowSub As Long = 0, Optional numColSub As Long = 0)
+    Dim iGrid As Integer
+    If GridNames Is Nothing Then
+        Set GridNames = New Dictionary
+    End If
+    ' only create once the grid with a specific name
+    If GridNames.Exists(Name) Then
+        Exit Sub
+    End If
+    
+    If isArrayEmpty(Grids) Then
+        ReDim Grids(0)
+    Else
+        ReDim Preserve Grids(0 To UBound(Grids) + 1)
+    End If
+    
+    GridNames.Add Name, UBound(Grids)
+    iGrid = GridNames.Item(Name)
+    Set Grids(iGrid) = New AGrid
+    Grids(iGrid).NameGrid = Name
+    Grids(iGrid).initialize numRow, numCol, numRowSub, numColSub
+End Sub
+
+Public Function checkGridName(Name As String) As Boolean
+    If GridNames.Exists(Name) Then
+        checkGridName = True
+    Else
+        MsgNoGrid Name
+    End If
+End Function
+
+
+Public Function isGridEmpty(Name As String) As Boolean
+    If checkGridName(Name) Then
+        isGridEmpty = Grids(GridNames.Item(Name)).isGridEmpty
+    End If
+End Function
+
+
+Public Sub updateGridSize(Name As String, numRow As Long, numCol As Long, numRowSub As Long, numColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).initialize numRow, numCol, numRowSub, numColSub
+    End If
+End Sub
+
+
+Public Sub updateGridSizePreserve(Name As String, numRow As Long, numCol As Long, numRowSub As Long, numColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).updateGridSizePreserve numRow, numCol, numRowSub, numColSub
+    End If
+End Sub
+
+Public Function isPositionGridFile(Name As String, ByVal sFile As String, ByVal Row As Integer, _
+ByVal Col As Integer, ByVal RowSub As Integer, ByVal ColSub As Integer) As Boolean
+    If checkGridName(Name) Then
+        isPositionGridFile = Grids(GridNames.Item(Name)).isPositionGridFile(sFile, Row, Col, RowSub, ColSub)
+    End If
+End Function
+
+'''
+'
+'''
+Public Function loadPositionGridFile(Name As String, sFile As String) As Boolean
+    If checkGridName(Name) Then
+        loadPositionGridFile = Grids(GridNames.Item(Name)).loadPositionGridFile(sFile)
+    End If
+End Function
+
+
+Public Function writePositionGridFile(Name As String, sFile As String) As Boolean
+    If checkGridName(Name) Then
+        writePositionGridFile = Grids(GridNames.Item(Name)).writePositionGridFile(sFile)
+    End If
+End Function
+
+
+Public Function isValidGridFile(Name As String, ByVal sFile As String, ByVal Row As Long, _
+ByVal Col As Long, ByVal RowSub As Long, ByVal ColSub As Long) As String
+    If checkGridName(Name) Then
+        isValidGridFile = Grids(GridNames.Item(Name)).isValidGridFile(sFile, Row, Col, RowSub, ColSub)
+    End If
+End Function
+
+'''
+'
+'''
+Public Function loadValidGridFile(Name As String, sFile As String, format As String) As Boolean
+    If checkGridName(Name) Then
+        loadValidGridFile = Grids(GridNames.Item(Name)).loadValidGridFile(sFile, format)
+    End If
+End Function
+
+Public Function setIndeces(Name As String, Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Boolean
+    If checkGridName(Name) Then
+        setIndeces = Grids(GridNames.Item(Name)).setIndeces(Row, Col, RowSub, ColSub)
+    End If
+End Function
+
+Public Function nextGridPt(Name As String) As Boolean
+    If checkGridName(Name) Then
+        nextGridPt = Grids(GridNames.Item(Name)).nextGridPt
+    End If
+End Function
+
+Public Function thisRow(Name As String) As Integer
+    If checkGridName(Name) Then
+        thisRow = Grids(GridNames.Item(Name)).iRow
+    End If
+End Function
+
+
+Public Function thisColumn(Name As String) As Integer
+    If checkGridName(Name) Then
+        thisColumn = Grids(GridNames.Item(Name)).iCol
+    End If
+End Function
+
+Public Function thisSubRow(Name As String) As Integer
+    If checkGridName(Name) Then
+        thisSubRow = Grids(GridNames.Item(Name)).iRowSub
+    End If
+End Function
+
+
+Public Function thisSubColumn(Name As String) As Integer
+    If checkGridName(Name) Then
+        thisSubColumn = Grids(GridNames.Item(Name)).iColSub
+    End If
+End Function
+
+Public Function getThisPt(Name As String, pos As Vector, Valid As Boolean)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).getThisPt pos, Valid
+    End If
+End Function
+
+
+Public Function setThisPt(Name As String, pos As Vector, Valid As Boolean)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setThisPt pos, Valid
+    End If
+End Function
+
+Public Function getNrPts(Name As String) As Long
+    If checkGridName(Name) Then
+        getNrPts = Grids(GridNames.Item(Name)).getNrPts
+    End If
+End Function
+
+
+Public Function getNrValidPts(Name As String) As Long
+    If checkGridName(Name) Then
+        getNrValidPts = Grids(GridNames.Item(Name)).getNrValidPts
+    End If
+End Function
+
+Public Function getPt(Name As String, pos As Vector, Valid As Boolean, _
+Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).getPt pos, Valid, Row, Col, RowSub, ColSub
+    End If
+End Function
+
+Public Function setPt(Name As String, pos As Vector, Valid As Boolean, _
+Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setPt pos, Valid, Row, Col, RowSub, ColSub
+    End If
+End Function
+
+Public Function getThisX(Name As String) As Double
+    If checkGridName(Name) Then
+        getThisX = Grids(GridNames.Item(Name)).getThisX
+    End If
+End Function
+
+Public Sub setThisX(Name As String, Value As Double)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setThisX Value
+    End If
+End Sub
+
+
+Public Function getThisY(Name As String) As Double
+    If checkGridName(Name) Then
+        getThisY = Grids(GridNames.Item(Name)).getThisY
+    End If
+End Function
+
+Public Sub setThisY(Name As String, Value As Double)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setThisY Value
+    End If
+End Sub
+
+Public Function getThisZ(Name As String) As Double
+    If checkGridName(Name) Then
+        getThisZ = Grids(GridNames.Item(Name)).getThisZ
+    End If
+End Function
+
+Public Sub setThisZ(Name As String, Value As Double)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setThisZ Value
+    End If
+End Sub
+
+Public Function getThisValid(Name As String) As Boolean
+    If checkGridName(Name) Then
+        getThisValid = Grids(GridNames.Item(Name)).getThisValid
+    End If
+End Function
+
+Public Sub setThisValid(Name As String, Value As Boolean)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setThisValid Value
+    End If
+End Sub
+
+Public Sub setAllValid(Name As String, Value As Boolean)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setAllValid Value
+    End If
+End Sub
+
+
+
+Public Function getX(Name As String, Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Double
+    If checkGridName(Name) Then
+        getX = Grids(GridNames.Item(Name)).getX(Row, Col, RowSub, ColSub)
+    End If
+End Function
+
+
+Public Sub setX(Name As String, Value As Double, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setX Value, Row, Col, RowSub, ColSub
+    End If
+End Sub
+
+Public Function getY(Name As String, Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Double
+    If checkGridName(Name) Then
+        getY = Grids(GridNames.Item(Name)).getY(Row, Col, RowSub, ColSub)
+    End If
+End Function
+
+Public Sub setY(Name As String, Value As Double, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setY Value, Row, Col, RowSub, ColSub
+    End If
+End Sub
+
+Public Function getZ(Name As String, Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Double
+    If checkGridName(Name) Then
+        getZ = Grids(GridNames.Item(Name)).getZ(Row, Col, RowSub, ColSub)
+    End If
+End Function
+
+Public Sub setZ(Name As String, Value As Double, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setZ Value, Row, Col, RowSub, ColSub
+    End If
+End Sub
+
+Public Function getValid(Name As String, Row As Long, Col As Long, RowSub As Long, ColSub As Long) As Boolean
+    If checkGridName(Name) Then
+        getValid = Grids(GridNames.Item(Name)).getValid(Row, Col, RowSub, ColSub)
+    End If
+End Function
+
+Public Sub setValid(Name As String, Value As Boolean, Row As Long, Col As Long, RowSub As Long, ColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setValid Value, Row, Col, RowSub, ColSub
+    End If
+End Sub
+
+
+Public Function writeValidGridFile(Name As String, sFile As String) As Boolean
+    If checkGridName(Name) Then
+        writeValidGridFile = Grids(GridNames.Item(Name)).writeValidGridFile(sFile)
+    End If
+End Function
+
+
+
+Public Sub makeGridFromOnePt(Name As String, pos As Vector, Row As Long, Col As Long, RowSub As Long, ColSub As Long, dRow As Double, dCol As Double, _
+dRowSub As Double, dColSub As Double, Optional refRow As Integer = 1, Optional refCol As Integer = 1)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).makeGridFromOnePt pos, Row, Col, RowSub, ColSub, dRow, dCol, dRowSub, dColSub, refRow, refCol
+    End If
+End Sub
+
+Public Sub makeGridFromManyPts(Name As String, pos() As Vector, Row As Long, Col As Long, RowSub As Long, ColSub As Long, _
+dRowSub As Double, dColSub As Double)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).makeGridFromManyPts pos, Row, Col, RowSub, ColSub, dRowSub, dColSub
+    End If
+End Sub
+
+
+Public Function thisSuffix(Name As String) As String
+    If checkGridName(Name) Then
+        thisSuffix = Grids(GridNames.Item(Name)).thisSuffix
+    End If
+End Function
+
+Public Function thisSuffixWell(Name As String) As String
+    If checkGridName(Name) Then
+        thisSuffixWell = Grids(GridNames.Item(Name)).thisSuffixWell
+    End If
+End Function
+
+
+Public Function getThisName(Name As String) As String
+    If checkGridName(Name) Then
+        getThisName = Grids(GridNames.Item(Name)).getThisName
+    End If
+End Function
+
+
+Public Sub setThisName(Name As String, Value As String)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setThisName Value
+    End If
+End Sub
+
+Public Function getName(Name As String, numRow As Long, numCol As Long, numRowSub As Long, numColSub As Long) As String
+    If checkGridName(Name) Then
+        getName = Grids(GridNames.Item(Name)).getName(numRow, numCol, numRowSub, numColSub)
+    End If
+End Function
+
+Public Sub setName(Name As String, Value As String, numRow As Long, numCol As Long, numRowSub As Long, numColSub As Long)
+    If checkGridName(Name) Then
+        Grids(GridNames.Item(Name)).setName Value, numRow, numCol, numRowSub, numColSub
+    End If
+End Sub
+
+
+Public Function suffix(Name As String, numRow As Long, numCol As Long, numRowSub As Long, numColSub As Long) As String
+    If checkGridName(Name) Then
+        suffix = Grids(GridNames.Item(Name)).suffix(numRow, numCol, numRowSub, numColSub)
+    End If
+End Function
+
+Public Function numCol(Name As String) As Integer
+    If checkGridName(Name) Then
+        numCol = Grids(GridNames.Item(Name)).numCol
+    End If
+End Function
+
+
+Public Function numRow(Name As String) As Integer
+    If checkGridName(Name) Then
+        numRow = Grids(GridNames.Item(Name)).numCol
+    End If
+End Function
+
+
+Public Function numColSub(Name As String) As Integer
+    If checkGridName(Name) Then
+        numColSub = Grids(GridNames.Item(Name)).numColSub
+    End If
+End Function
+
+
+Public Function numRowSub(Name As String) As Integer
+    If checkGridName(Name) Then
+        numRowSub = Grids(GridNames.Item(Name)).numRowSub
+    End If
+End Function
diff --git a/AutofocusScreen/src/AutofocusScreen/ImagingJobs.cls b/AutofocusScreen/src/AutofocusScreen/ImagingJobs.cls
new file mode 100644
index 0000000..fc9a4c8
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/ImagingJobs.cls
@@ -0,0 +1,564 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "ImagingJobs"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''
+' A Class to manage several AJob: imagingJob with different Settings and Tracks
+'''
+Option Explicit
+
+'''' We can use number or a dictionary to find a Job in Jobs
+Private Jobs() As AJob
+Private JobNames As Dictionary
+Private ZENv As Integer
+Private ZoomPixelSlice(1 To 9, 1 To 3) As Double
+
+Private Sub MsgNoJob(Name As String)
+    MsgBox "ImagingJobs: Job " & Name & " has not been defined"
+End Sub
+
+
+'''
+'   Initialize a series of Jobs with given name
+'''
+Public Sub initialize(Names() As String, Recording As DsRecording, ZEN As Object)
+    Dim i As Integer
+   ' Set Jobs = New AJob
+    For i = 0 To UBound(Names)
+        AddJob CStr(Names(i)), Lsm5.DsRecording, ZEN
+    Next i
+End Sub
+
+Public Function getZENv() As Integer
+    getZENv = ZENv
+End Function
+
+Public Function setZENv(Value As Integer)
+    ZENv = Value
+End Function
+
+Public Sub resetJobs()
+    Erase Jobs
+    Set JobNames = New Dictionary
+End Sub
+
+'''
+' AddJob
+'   Add Job and increase number of Jobs
+'''
+Public Sub AddJob(Name As String, Recording As DsRecording, ZEN As Object)
+    If JobNames Is Nothing Then
+        Set JobNames = New Dictionary
+    End If
+    If Not JobNames.Exists(Name) Then
+        If isArrayEmpty(Jobs) Then
+            ReDim Jobs(0)
+        Else
+            ReDim Preserve Jobs(0 To UBound(Jobs) + 1)
+        End If
+        JobNames.Add Name, UBound(Jobs)
+    End If
+    Dim i As Integer
+    Dim iJob As Integer
+    iJob = JobNames.Item(Name)
+    Set Jobs(iJob) = New AJob
+    Jobs(iJob).Name = Name
+    Jobs(iJob).setJob Lsm5.DsRecording, ZEN
+End Sub
+
+
+'''
+'   Set the job with Name from ZEN using a given recording
+'''
+Public Function setJob(Name As String, Recording As DsRecording, ZEN As Object) As Boolean
+    On Error GoTo ErrorHandle:
+    Dim iJob As Integer
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    If Jobs(JobNames.Item(Name)).setJob(Recording, ZEN) Then
+        setJob = True
+    End If
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in ImagingJobs.setJob " + Name + " " + Err.Description
+End Function
+
+
+Public Function GetRecording(Name As String) As DsRecording
+    If JobNames.Exists(Name) Then
+        Set GetRecording = Jobs(JobNames.Item(Name)).GetRecording
+    Else
+       MsgNoJob Name
+    End If
+End Function
+
+Private Function checkJobName(Name As String) As Boolean
+    If JobNames.Exists(Name) Then
+        checkJobName = True
+    Else
+        MsgNoJob Name
+    End If
+End Function
+
+'''
+'   Put the job with Name from Macro into ZEN
+'''
+Public Function putJob(Name As String, ZEN As Object) As Boolean
+    On Error GoTo ErrorHandle:
+    Dim iJob As Integer
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    If Jobs(JobNames.Item(Name)).putJob(ZEN) Then
+        putJob = True
+    End If
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in ImagingJobs.putJob " + Name + " " + Err.Description
+ End Function
+
+
+''''
+'Roi Handler. This manages vectorElements in ZEN. Every Job can have some Rois associated to
+''''
+Public Sub setRoiMaxNr(Name As String, roiMaxNr As Integer)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).setRoiMaxNr roiMaxNr
+End Sub
+
+Public Sub setRoi(Name As String, ARoi As Roi, roiNr As Integer)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).setRoi ARoi, roiNr
+End Sub
+
+Public Sub setRois(Name As String, Rois() As Roi)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).setRois Rois
+End Sub
+
+Public Function getRoi(Name As String, roiNr As Integer) As Roi
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    Set getRoi = Jobs(JobNames.Item(Name)).getRoi(roiNr)
+End Function
+
+
+'''
+' create ROIs in ZEN
+'''
+Public Sub createRois(Name As String)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).createRois
+End Sub
+
+
+Public Sub clearRois(Name As String)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).clearRois
+End Sub
+
+
+''''''
+Public Function TrackNumber(Name As String) As Integer
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    TrackNumber = Jobs(JobNames.Item(Name)).TrackNumber
+End Function
+
+
+''''''
+'    UpdateJobTimeSeries: if True the Job also has time Series
+''''''
+Public Sub setTimeSeries(Name As String, Value As Boolean)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).Recording.TimeSeries = Value
+End Sub
+
+Public Function getTimeSeries(Name As String) As Boolean
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getTimeSeries = Jobs(JobNames.Item(Name)).Recording.TimeSeries
+End Function
+
+
+'''
+' X-Lines
+'''
+Public Function getSamplesPerLine(Name As String) As Long
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getSamplesPerLine = Jobs(JobNames.Item(Name)).Recording.SamplesPerLine
+End Function
+
+'''
+' Y-Lines
+''''
+Public Function getLinesPerFrame(Name As String) As Long
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getLinesPerFrame = Jobs(JobNames.Item(Name)).Recording.LinesPerFrame
+End Function
+
+
+'''
+' Interval for time series
+'''
+Public Sub setTimeBetweenStacks(Name As String, Value As Double)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).TimeBetweenStacks = Value
+End Sub
+
+Public Function getTimeBetweenStacks(Name As String) As Double
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getTimeBetweenStacks = Jobs(JobNames.Item(Name)).TimeBetweenStacks
+End Function
+
+Public Sub setTrackNumber(Name As String, Value As Integer)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).TrackNumber = Value
+End Sub
+
+
+Public Sub setAcquireTrack(Name As String, iTrack As Integer, Value As Boolean)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).ReDimAcquireTrack (Jobs(JobNames.Item(Name)).TrackNumber - 1)
+    Jobs(JobNames.Item(Name)).setAcquireTrack iTrack, Value
+End Sub
+
+Public Function getAcquireTrack(Name As String, iTrack As Integer) As Boolean
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    If iTrack < Jobs(JobNames.Item(Name)).TrackNumber Then
+        getAcquireTrack = Jobs(JobNames.Item(Name)).getAcquireTrack(iTrack)
+    End If
+End Function
+
+Public Function isAcquiring(Name As String) As Boolean
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    If Jobs(JobNames.Item(Name)).isAcquiring Then
+        isAcquiring = True
+    End If
+End Function
+
+Public Sub setBleachTrack(Name As String, Value As Boolean)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Dim Success As Integer
+    Jobs(JobNames.Item(Name)).Recording.TrackObjectBleach(Success).Acquire = Value
+    Jobs(JobNames.Item(Name)).Recording.TrackObjectBleach(Success).UseBleachParameters = Value
+End Sub
+
+''''
+'   True if track is bleaching
+''''
+Public Function getBleachTrack(Name As String) As Boolean
+    Dim Success As Integer
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getBleachTrack = Jobs(JobNames.Item(Name)).Recording.TrackObjectBleach(Success).Acquire And Jobs(JobNames.Item(Name)).Recording.TrackObjectBleach(Success).UseBleachParameters
+End Function
+
+
+''''
+'   This is the number of Z-stacks
+''''
+Public Sub setFramesPerStack(Name As String, Value As Integer)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).Recording.framesPerStack = Value
+End Sub
+
+Public Function getFramesPerStack(Name As String) As Integer
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getFramesPerStack = Jobs(JobNames.Item(Name)).Recording.framesPerStack
+End Function
+
+''''
+'   This is dZ (in um)
+''''
+Public Sub setFrameSpacing(Name As String, Value As Double)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).Recording.frameSpacing = Value
+End Sub
+
+Public Function getFrameSpacing(Name As String) As Double
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getFrameSpacing = Jobs(JobNames.Item(Name)).Recording.frameSpacing
+End Function
+
+'''
+'   This is dXdY in um
+'''
+Public Function getSampleSpacing(Name As String) As Double
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    'Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing 'this is in meter different specification depending on the variable. What a mess!!!
+    getSampleSpacing = Jobs(JobNames.Item(Name)).Recording.SampleSpacing
+End Function
+
+
+Public Sub setZoom(Name As String, Value As Double)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).Recording.ZoomX = Value
+    Jobs(JobNames.Item(Name)).Recording.ZoomY = Value
+End Sub
+
+Public Function getZoom(Name As String) As Double
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getZoom = Jobs(JobNames.Item(Name)).Recording.ZoomX
+End Function
+
+Public Function getCorrX(Name As String) As Double
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getCorrX = Jobs(JobNames.Item(Name)).CorrX
+End Function
+
+
+Public Function getCorrY(Name As String) As Double
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getCorrY = Jobs(JobNames.Item(Name)).CorrY
+End Function
+
+Public Sub setCorrX(Name As String, Value As Double)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).CorrX = Value
+End Sub
+
+
+Public Sub setCorrY(Name As String, Value As Double)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).CorrY = Value
+End Sub
+
+Public Function getCentralPtPx(Name As String) As Vector
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getCentralPtPx.X = (Jobs(JobNames.Item(Name)).Recording.SamplesPerLine - 1) / 2
+    getCentralPtPx.Y = (Jobs(JobNames.Item(Name)).Recording.LinesPerFrame - 1) / 2
+    If Jobs(JobNames.Item(Name)).isZStack Then
+        getCentralPtPx.Z = (Jobs(JobNames.Item(Name)).Recording.framesPerStack - 1) / 2
+    Else
+        getCentralPtPx.Z = 0
+    End If
+End Function
+
+
+''''
+'   Number of time points
+'''
+Public Sub setStacksPerRecord(Name As String, Value As Integer)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).Recording.StacksPerRecord = Value
+End Sub
+
+
+Public Function getStacksPerRecord(Name As String) As Integer
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getStacksPerRecord = Jobs(JobNames.Item(Name)).Recording.StacksPerRecord
+End Function
+
+
+'''''
+' Sets usage of piezo or no
+'   ZScan: X-Z Scan
+'   Stack: Frame mode with Zstacks
+'   Plane: just one plane
+'   Line: Just a Line
+'''''
+Public Sub SetScanMode(Name As String, Value As String)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).Recording.ScanMode = Value
+End Sub
+
+Public Function GetScanMode(Name As String) As String
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    GetScanMode = Jobs(JobNames.Item(Name)).Recording.ScanMode
+End Function
+
+'true if record is a ZStack
+Public Function isZStack(Name As String) As Boolean
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    isZStack = Jobs(JobNames.Item(Name)).isZStack
+End Function
+
+'''''
+' Sets usage of piezo or no
+'   ZScanner: Piezo
+'   FocusStep: Focuswheel
+'   OnTheFly: Focuswheel that is not syncronized with imaging
+'''''
+Public Sub SetSpecialScanMode(Name As String, Value As String)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).Recording.SpecialScanMode = Value
+End Sub
+
+Public Function GetSpecialScanMode(Name As String) As String
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    GetSpecialScanMode = Jobs(JobNames.Item(Name)).Recording.SpecialScanMode
+End Function
+
+'''''
+' Sets Unidirectional or bidirectional scan
+'    0: Unidirectional
+'    1: bidirectional scan
+'''''
+Public Sub setScanDirection(Name As String, Value As Integer)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).Recording.ScanDirection = Value
+End Sub
+
+Public Function getScanDirection(Name As String) As Integer
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getScanDirection = Jobs(JobNames.Item(Name)).Recording.ScanDirection
+End Function
+
+'''
+' Set and Get the usage of ROIs
+'''
+Public Function setUseRoi(Name As String, Value As Boolean)
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    Jobs(JobNames.Item(Name)).UseRoi = Value
+End Function
+
+Public Function getUseRoi(Name As String) As Boolean
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getUseRoi = Jobs(JobNames.Item(Name)).UseRoi
+End Function
+
+'''
+' Set and Get the pixelDwellTime of Job
+'''
+Public Sub setPixelDwell(Name As String, pixelDwell As Double)
+    If Not checkJobName(Name) Then
+        Exit Sub
+    End If
+    Jobs(JobNames.Item(Name)).pixelDwell = pixelDwell
+End Sub
+
+Public Function getPixelDwell(Name As String) As Double
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    getPixelDwell = Jobs(JobNames.Item(Name)).pixelDwell
+End Function
+
+
+
+''''
+' Create a string with the description of a Job
+''''
+Public Function jobDescriptor(Name As String) As String
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    jobDescriptor = Jobs(JobNames.Item(Name)).jobDescriptor
+End Function
+
+''''
+' Create a string with the description of a Job to be used as settings
+''''
+Public Function jobDescriptorSettings(Name As String) As String
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    jobDescriptorSettings = Jobs(JobNames.Item(Name)).jobDescriptorSettings
+End Function
+
+''''
+' Create a string with the description of a Job
+''''
+Public Function splittedJobDescriptor(Name As String, MaxLines As Integer) As String()
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    splittedJobDescriptor = Jobs(JobNames.Item(Name)).splittedJobDescriptor(MaxLines, jobDescriptor(Name))
+End Function
+
+
+Public Function changeJobFromDescriptor(Name As String, Descriptor As String, Value As Variant)
+    If Not checkJobName(Name) Then
+        Exit Function
+    End If
+    changeJobFromDescriptor = Jobs(JobNames.Item(Name)).changeJobFromDescriptor(Descriptor, Value)
+End Function
+
+
diff --git a/AutofocusScreen/src/AutofocusScreen/ImagingRepetitions.cls b/AutofocusScreen/src/AutofocusScreen/ImagingRepetitions.cls
new file mode 100644
index 0000000..da8dee6
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/ImagingRepetitions.cls
@@ -0,0 +1,162 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "ImagingRepetitions"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+''
+' class to manage several ARepetition
+'''
+Option Explicit
+Private Repetitions As New Collection 'ARepetition to be changed
+Private pZENv As Integer
+Private RepetitionNames As Dictionary
+
+
+Private Sub MsgNoRepetition(Name As String)
+    MsgBox "ImagingRepetitions: Repetition " & Name & " has not been defined"
+End Sub
+
+Public Function checkRepetitionNames(Name As String) As Boolean
+    If RepetitionNames.Exists(Name) Then
+        checkRepetitionNames = True
+    Else
+        MsgNoRepetition Name
+    End If
+End Function
+
+
+'''
+'   Initialize a series of RepetitionJobs with given name
+'''
+Public Sub initialize(Names() As String, RepetitionTimes() As Double, RepetitionNumbers() As Integer, RepetitionIntervals() As Boolean)
+
+    Dim Name As Variant
+    Dim i As Integer
+    Dim MaxNames As Integer
+        
+    If isArrayEmpty(Names) Then
+        MsgBox "initialize ImagingRepetitions class: provide a non-empty array"
+        Exit Sub
+    End If
+    Set Repetitions = New Collection
+    MaxNames = UBound(Names)
+    If UBound(RepetitionTimes) <> MaxNames Or UBound(RepetitionNumbers) <> MaxNames Or _
+        UBound(RepetitionIntervals) <> MaxNames Then
+        MsgBox "initialize ImagingRepetitions class: all arrays should have the same length"
+        Exit Sub
+    End If
+    
+    For i = 0 To MaxNames
+        AddRepetition Names(i), RepetitionTimes(i), RepetitionNumbers(i), RepetitionIntervals(i)
+    Next i
+
+End Sub
+
+
+'''
+'   Initialize a series of RepetitionJobs with given name
+'''
+Public Sub AddRepetition(Name As String, RepetitionTime As Double, RepetitionNumber As Integer, RepetitionInterval As Boolean)
+    Dim Rep As ARepetition
+    Dim i As Integer
+    Set Rep = New ARepetition
+    
+    Rep.initialize Name, RepetitionTime, RepetitionNumber, RepetitionInterval
+    Repetitions.Add Rep, Name
+    
+End Sub
+
+'''
+'  Get current index of repetition
+'''
+Public Function getIndex(Name As String) As Integer
+    getIndex = Repetitions(Name).index
+End Function
+
+'''
+'   Reset everything to new values
+'''
+Public Function reset(Name As String, RepetitionTime As Double, RepetitionNumber As Integer, RepetitionInterval As Boolean)
+    Repetitions(Name).index = 0
+    Repetitions(Name).update RepetitionTime, RepetitionNumber, RepetitionInterval
+End Function
+
+'''
+'   Just reset the index
+'''
+Public Function resetIndex(Name As String)
+    Repetitions(Name).index = 0
+End Function
+
+'''
+'   Update setting of Job
+'''
+Public Function update(Name As String, RepetitionTime As Double, RepetitionNumber As Integer, RepetitionInterval As Boolean)
+    ' this will not upate the index
+    Reps.update Name, RepetitionTime, RepetitionNumber, RepetitionInterval
+End Function
+
+'''
+'   Switch to new Repetition
+'''
+Public Function nextRep(Name As String) As Boolean
+    nextRep = Repetitions(Name).nextRep
+End Function
+
+'''
+'   Compute waiting time
+'''
+Public Function wait(Name As String) As Double
+    wait = Repetitions(Name).wait
+End Function
+
+'''
+'   Check if new timeStart
+'''
+Public Sub updateTimeStart(Name As String)
+    Repetitions(Name).updateTimeStart
+End Sub
+
+Public Sub setInterval(Name As String, Value As Boolean)
+    Repetitions(Name).interval = Value
+End Sub
+
+Public Function thisIndex(Name As String) As Integer
+    thisIndex = Repetitions(Name).index
+End Function
+
+
+'''
+'
+'''
+Public Sub setRepetitionTime(Name As String, Value As Double)
+    Repetitions(Name).Time = Value
+End Sub
+
+'''
+'set the number of repetitions
+'''
+Public Sub setRepetitionNumber(Name As String, Value As Integer)
+    Repetitions(Name).number = Value
+End Sub
+
+'''
+'get the number of repetitions
+'''
+Public Function getRepetitionNumber(Name As String) As Integer
+    getRepetitionNumber = Repetitions(Name).number
+End Function
+
+
+Public Function thisSuffix(Name As String) As String
+    thisSuffix = Repetitions(Name).thisSuffix
+End Function
+
+Public Function suffix(Name As String, Value As Integer) As String
+    suffix = Repetitions(Name).suffix(Value)
+End Function
+
diff --git a/AutofocusScreen/src/AutofocusScreen/ImagingTimers.cls b/AutofocusScreen/src/AutofocusScreen/ImagingTimers.cls
new file mode 100644
index 0000000..546e099
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/ImagingTimers.cls
@@ -0,0 +1,61 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "ImagingTimers"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''
+' Timer class
+'''
+Private Type singleTimer
+    Name As String
+    TimeStart As Double
+End Type
+
+Private Timers() As singleTimer
+Private TimerNames As Dictionary
+
+Private Sub MsgNoTimer(Name As String)
+    MsgBox "Timer: Timer " & Name & " has not been defined"
+End Sub
+
+Public Sub addTimer(Name As String)
+    Dim iTimer As Integer
+    ' only create once the timer with a specific name
+    If TimerNames.Exists(Name) Then
+        Exit Sub
+    End If
+    If isArrayEmpty(Timers) Then
+        ReDim Grids(0)
+    Else
+        ReDim Preserve Timers(0 To UBound(Timers) + 1)
+    End If
+    TimerNames.Add Name, UBound(Timers)
+    iTimer = TimerNames.Item(Name)
+    Timers.Name = Name
+    Timers.startTime = CDbl(GetTickCount) * 0.001
+End Sub
+
+Public Function checkTimerName(Name As String) As Boolean
+    If TimerNames.Exists(Name) Then
+        checkGridName = True
+    Else
+        MsgNoTimer Name
+    End If
+End Function
+
+
+Public Sub updateTimeStart(Name As String)
+    If checkTimerName(Name) Then
+        Timers(TimerNames.Item(Name)).TimeStart = CDbl(GetTickCount) * 0.001
+    End If
+End Sub
+
+Public Function wait(Name As String, Delay As Double) As Double
+    If checkTimerName(Name) Then
+        wait = Timers(TimerNames.Item(Name)).TimeStart + Delay - CDbl(GetTickCount) * 0.001
+    End If
+End Function
diff --git a/AutofocusScreen/src/AutofocusScreen/JobsManager.bas b/AutofocusScreen/src/AutofocusScreen/JobsManager.bas
new file mode 100644
index 0000000..ac06ab9
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/JobsManager.bas
@@ -0,0 +1,1292 @@
+Attribute VB_Name = "JobsManager"
+''''
+' Functions to perform imaging and fcs using the Imging, Fcs, Grid, repetitions classes
+''''
+Option Explicit
+''' The repetition for tasks
+Public Reps As ImagingRepetitions
+'name of the repetitions
+Public RepNames() As String
+
+
+''' A collection of imaging jobs each defining a recording setting
+Public Jobs As ImagingJobs
+'Contains name of the Jonbs
+Public JobNames() As String
+'short name of the jobs (prefix to the file)
+Public JobShortNames As Collection
+'the name of the job that is currently loaded
+Public CurrentJob As String
+
+''' A collection of fcs jobs each defining a specific fcs config (smaller set settings stored for ZENv < 2011)
+Public JobsFcs As FcsJobs
+'Contains name of the Jonbs
+Public JobFcsNames() As String
+'short name of the jobs (prefix to the file)
+Public JobFcsShortNames As Collection
+'the name of the Fcsjob that is currently loaded
+Public CurrentJobFcs As String
+
+
+''' The grid for tasks
+Public Grids As ImagingGrids
+''' Timers initiated when great is created, reinitialized if recquired
+Public TimersGridCreation As Timers
+
+
+''' A vector
+''' ToDo move it to another module
+Public Type Vector
+  X As Double
+  Y As Double
+  Z As Double
+End Type
+
+
+'''
+'   Sets and execute an imaging Job
+'       JobName: The name of the Job to execute
+'       RecordingDoc: the dsRecording where image is stored
+'       RocordingName: The name of the recording (also for the GUI)
+'       position: A vector with stage position where to acquire image X, Y, and Z (cental slice)
+''''
+Public Function AcquireJob(JobName As String, RecordingDoc As DsRecordingDoc, RecordingName As String, position As Vector) As Boolean
+    On Error GoTo ErrorHandle:
+    Dim SuccessRecenter As Boolean
+    Dim Time As Double
+    'stop any running jobs
+    StopAcquisition
+    'Create a NewRecord if required
+    NewRecord RecordingDoc, RecordingName, 0
+    'move stage if required
+    Time = Timer
+    If Round(Lsm5.Hardware.CpStages.PositionX, PrecXY) <> Round(position.X, PrecXY) Or Round(Lsm5.Hardware.CpStages.PositionY, PrecXY) <> Round(position.Y, PrecXY) Then
+        If Not FailSafeMoveStageXY(position.X, position.Y) Then
+            Exit Function
+        End If
+    End If
+    'Debug.Print "Time to move stage " & Round(Timer - Time, 3)
+    
+    
+    Time = Timer
+    'Change settings for new Job if it is different from currentJob (global variable)
+    If JobName <> CurrentJob Then
+        Jobs.putJob JobName, ZEN
+    End If
+    Debug.Print "Time to put Job " & Round(Timer - Time, 3)
+    CurrentJob = JobName
+    'Not sure if this is required
+    Time = Timer
+    If Jobs.GetSpecialScanMode(JobName) = "ZScanner" Then
+        Lsm5.Hardware.CpHrz.Leveling
+    End If
+    'Debug.Print "Time to level Hrz " & Round(Timer - Time, 3)
+    
+    
+    ''' recenter before acquisition
+    Time = Timer
+    If Not Recenter_pre(position.Z, SuccessRecenter, ZENv) Then
+        Exit Function
+    End If
+    'Debug.Print "Time to recenter pre " & Round(Timer - Time, 3)
+
+
+    Time = Timer
+    'checks if any of the track is on
+    If Jobs.isAcquiring(JobName) Then
+        If Not ScanToImage(RecordingDoc) Then
+            Exit Function
+        End If
+    Else
+        GoTo ErrorTrack
+    End If
+    'Debug.Print "Time to scan image " & Round(Timer - Time, 3)
+    
+    'wait that slice recentered after acquisition
+    Time = Timer
+    If Not Recenter_post(position.Z, SuccessRecenter, ZENv) Then
+       Exit Function
+    End If
+    'Debug.Print "Time to recenter post " & Round(Timer - Time, 3)
+    AcquireJob = True
+    Exit Function
+ErrorHandle:
+    MsgBox "Error: AcquireJob for Job " + JobName + " " + Err.Description
+    Exit Function
+ErrorTrack:
+    MsgBox "Error: AcquireJob for job " + JobName + ". Exit now!"
+    Exit Function
+End Function
+
+
+'''
+'   Sets and execute an FCS Job at specified position
+'       JobName: The name of the Job to execute
+'       FcsData: the AimFcsData containing the Fcs
+'       RocordingName: The name of the recording (also for the GUI).Not used yet
+'       position: A vector array with position where to acquire image X, Y (relative to center of image), and Z (absolute).
+''''
+Public Function AcquireFcsJob(JobName As String, RecordingDoc As DsRecordingDoc, FcsData As AimFcsData, FileName As String, positions() As Vector) As Boolean
+    On Error GoTo ErrorHandle:
+    Dim SuccessRecenter As Boolean
+    Dim Time As Double
+    Set FcsControl = Fcs
+   
+    'Stop Fcs acquisition
+    StopAcquisition
+    
+    If Not NewFcsRecord(RecordingDoc, FcsData, FileName, 0) Then
+        GoTo WarningHandle
+    End If
+    
+    'FcsData.name = "Bla"
+    FcsControl.StopAcquisitionAndWait
+    'Create a NewRecord if required
+    NewFcsRecord RecordingDoc, FcsData, FileName
+    
+    '''clear previous positions
+    ClearFcsPositionList
+    '''update positions
+    setFcsPositions positions
+    If JobName <> CurrentJobFcs Then
+        If Not JobsFcs.putJob(JobName, ZEN) Then
+           Exit Function
+        End If
+    End If
+    CurrentJobFcs = JobName
+    If Not ScanToFcs(FcsData) Then
+        Exit Function
+    End If
+    AcquireFcsJob = True
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog "Error: AcquireFcsJob for Job " + JobName + " " + Err.Description
+    Exit Function
+WarningHandle:
+    MsgBox "AcquireFcsJob for job " + JobName + ". Not able to create document!"
+    Exit Function
+End Function
+
+'''''
+' This executes part of the Job save the file compute offline tracking and set the registry
+'''''
+Public Function ExecuteFcsJob(JobName As String, RecordingDoc As DsRecordingDoc, FcsData As AimFcsData, FilePath As String, FileName As String, _
+positions() As Vector, positionsPx() As Vector) As Boolean
+    Dim i As Integer
+    On Error GoTo ErrorHandle:
+    For i = 0 To UBound(positions)
+        positions(i).Z = positions(i).Z + AutofocusForm.Controls(JobName + "ZOffset").Value * 0.000001
+    Next i
+    If Not AcquireFcsJob(JobName, RecordingDoc, FcsData, FileName, positions) Then
+        Exit Function
+    End If
+    'this is a dummy variable used for consistencey except for autofocus the default is saving of all images
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    OiaSettings.initializeDefault
+    
+    If Not SaveFcsMeasurement(FcsData, FilePath & FileName & ".fcs") Then
+         Exit Function
+    End If
+    
+    SaveFcsPositionList FilePath & FileName & ".txt", positionsPx
+    
+    If Not CleanFcsData(RecordingDoc, FcsData) Then
+        Exit Function
+    End If
+    
+    OiaSettings.writeKeyToRegistry "filePath", FilePath & FileName & ".fcs"
+    If ScanStop Then
+        Exit Function
+    End If
+    ExecuteFcsJob = True
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in ExecuteFcsJob for Job " + JobName + " " + Err.Description
+    MsgBox "Error in ExecuteFcsJob for Job " + JobName + " " + Err.Description
+End Function
+
+
+'''''
+' This executes part of the Job save the file compute offline tracking and set the registry
+'''''
+Public Function ExecuteJob(JobName As String, RecordingDoc As DsRecordingDoc, FilePath As String, FileName As String, _
+StgPos As Vector, Optional deltaZ As Integer = -1) As Boolean
+
+    On Error GoTo ErrorHandle:
+    If Not AcquireJob(JobName, RecordingDoc, FileName, StgPos) Then
+        Exit Function
+    End If
+    'this is a dummy variable used for consistencey except for autofocus the default is saving of all images
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    OiaSettings.initializeDefault
+    
+    If AutofocusForm.Controls(JobName & "SaveImage") Then
+        If Not SaveDsRecordingDoc(RecordingDoc, FilePath & FileName & imgFileExtension, imgFileFormat) Then
+            Exit Function
+        End If
+        OiaSettings.writeKeyToRegistry "filePath", FilePath & FileName & imgFileExtension
+    End If
+    
+    If ScanStop Then
+        Exit Function
+    End If
+    ExecuteJob = True
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in ExecuteJob for Job " + JobName + " " + Err.Description
+    MsgBox "Error in ExecuteJob for Job " + JobName + " " + Err.Description
+End Function
+
+'''
+' Compute new positions according to center of mass
+'''''
+Public Function TrackOffLine(JobName As String, RecordingDoc As DsRecordingDoc, currentPosition As Vector) As Vector
+    On Error GoTo ErrorHandle:
+    Dim newPosition() As Vector
+    ReDim newPosition(0)
+    Dim TrackingChannel As String
+    newPosition(0) = currentPosition
+    TrackOffLine = currentPosition
+    If AutofocusForm.Controls(JobName & "CenterOfMass") And (AutofocusForm.Controls(JobName & "TrackZ") Or AutofocusForm.Controls(JobName & "TrackXY")) Then
+        TrackingChannel = AutofocusForm.Controls(JobName & "CenterOfMassChannel").List(AutofocusForm.Controls(JobName & "CenterOfMassChannel").ListIndex)
+        ''compute center of mass in pixel
+        newPosition(0) = MassCenter(RecordingDoc, TrackingChannel)
+        If Not checkForMaximalDisplacementVecPixels(JobName, newPosition) Then
+            GoTo Abort
+        End If
+        'transform it in um
+        newPosition = computeCoordinatesImaging(JobName, currentPosition, newPosition)
+    End If
+    If AutofocusForm.Controls(JobName & "TrackZ") Then
+        TrackOffLine.Z = newPosition(0).Z
+    End If
+    If AutofocusForm.Controls(JobName & "TrackXY") Then
+        TrackOffLine.X = newPosition(0).X
+        TrackOffLine.Y = newPosition(0).Y
+    End If
+    If Not checkForMaximalDisplacement(JobName, TrackOffLine, currentPosition) Then
+        TrackOffLine = currentPosition
+    End If
+    Debug.Print "X = " & currentPosition.X & ", " & newPosition(0).X & ", Y = " & currentPosition.Y & ", " & newPosition(0).Y & ", Z = " & currentPosition.Z & ", " & newPosition(0).Z
+    Exit Function
+Abort:
+    ScanStop = True
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in TrackOffLine " + JobName + " " + Err.Description
+    ErrorLog.UpdateLog "Error in TrackOffLine " + JobName + " " + Err.Description
+    Exit Function
+End Function
+
+
+
+''''
+'   Update positions according to track command
+''''
+Public Function TrackJob(JobName As String, StgPos As Vector, StgPosNew As Vector) As Vector
+    On Error GoTo ErrorHandle:
+    TrackJob = StgPos
+    If AutofocusForm.Controls(JobName & "TrackZ") Then
+        TrackJob.Z = StgPosNew.Z
+    End If
+    If AutofocusForm.Controls(JobName & "TrackXY") Then
+        TrackJob.X = StgPosNew.X
+        TrackJob.Y = StgPosNew.Y
+    End If
+    Exit Function
+ErrorHandle:
+    MsgBox "Error in TrackJob " + JobName + " " + Err.Description
+    ErrorLog.UpdateLog "Error in TrackJob " + JobName + " " + Err.Description
+End Function
+
+'''
+'   Execute a job and perform a tracking. Returns an updated position X, Y, and Z
+'''
+Public Function ExecuteJobAndTrack(GridName As String, JobName As String, RecordingDoc As DsRecordingDoc, parentPath As String, StgPos As Vector, Success As Boolean) As Vector
+    
+    On Error GoTo ErrorHandle:
+    Dim Time As Double
+    Dim ScanMode As String
+    Dim newStgPos As Vector
+    Dim FileName As String
+    Dim FilePath As String
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    
+    Success = False
+    
+
+    If AutofocusForm.Controls(JobName + "Active") Then
+        DisplayProgress "Job " & JobName & ", Row " & Grids.thisRow(GridName) & ", Col " & Grids.thisColumn(GridName) & vbCrLf & _
+        "subRow " & Grids.thisSubRow(GridName) & ", subCol " & Grids.thisSubColumn(GridName) & ", Rep " & Reps.thisIndex(GridName), RGB(&HC0, &HC0, 0)
+
+        ScanMode = Jobs.GetScanMode(JobName)
+        If ScanMode = "ZScan" Or ScanMode = "Line" Then
+            AutofocusForm.Controls(JobName & "TrackXY").Value = False
+        End If
+        FileName = FileNameFromGrid(GridName, JobName)
+        FilePath = parentPath & FilePathSuffix(GridName, JobName) & "\"
+        If JobName <> "Autofocus" Then
+            StgPos.Z = StgPos.Z + AutofocusForm.Controls(JobName + "ZOffset").Value
+        End If
+        
+        If AutofocusForm.Controls(JobName + "OiaActive") And AutofocusForm.Controls(JobName + "OiaSequential") Then
+            OiaSettings.writeKeyToRegistry "codeMic", "wait"
+        End If
+        
+        If Not ExecuteJob(JobName, RecordingDoc, FilePath, FileName, StgPos) Then
+            Exit Function
+        End If
+        'do any recquired computation
+        Time = Timer
+        StgPos = TrackOffLine(JobName, RecordingDoc, StgPos)
+        Debug.Print "Time to TrackOffLine " & Timer - Time
+        If AutofocusForm.Controls(JobName + "OiaActive") And AutofocusForm.Controls(JobName + "OiaSequential") Then
+            OiaSettings.writeKeyToRegistry "codeOia", "newImage"
+            newStgPos = ComputeJobSequential(JobName, GridName, StgPos, FilePath, FileName, RecordingDoc)
+            If Not checkForMaximalDisplacement(JobName, StgPos, newStgPos) Then
+                newStgPos = StgPos
+            End If
+                
+            Debug.Print "X =" & StgPos.X & ", " & newStgPos.X & ", " & StgPos.Y & ", " & newStgPos.Y & ", " & StgPos.Z & ", " & newStgPos.Z
+            StgPos = TrackJob(JobName, StgPos, newStgPos)
+        End If
+        
+        If JobName <> "Autofocus" Then
+            StgPos.Z = StgPos.Z - AutofocusForm.Controls(JobName + "ZOffset").Value
+        End If
+    
+    End If
+    ExecuteJobAndTrack = StgPos
+    Success = True
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in ExecuteJobAndTrack " + GridName + " " + JobName + " " + parentPath + " " + Err.Description
+End Function
+
+
+
+''''''
+'   Performs many things (TODO: write more). Pretty much the whole macro runs through here
+''''''
+Public Function StartJobOnGrid(GridName As String, JobName As String, RecordingDoc As DsRecordingDoc, parentPath As String) As Boolean
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    Dim StgPos As Vector, newStgPos As Vector
+    Dim Time As Double
+    '''The name of jobs run for the global mode
+    Dim JobNamesGlobal(2) As String
+    Dim iJobGlobal As Integer
+    Dim iGuiDocument As Integer
+    JobNamesGlobal(0) = "Autofocus"
+    JobNamesGlobal(1) = "Acquisition"
+    JobNamesGlobal(2) = "AlterAcquisition"
+    
+    Dim FileName As String
+    Dim deltaZ As Integer
+    deltaZ = -1
+    Dim SuccessRecenter As Boolean
+    Dim SuccessExecute As Boolean
+    'Stop all running acquisitions (maybe to strong)
+    StopAcquisition
+    
+    'coordinates
+    Dim previousZ As Double   'remember position of previous position in Z
+    
+    
+    
+    'Coordinates
+    Dim X As Double              ' x value where to move the stage (this is used as reference)
+    Dim Y As Double              ' y value where to move the stage
+    Dim Z As Double              ' z value where to move the stage
+    Dim Xold As Double
+    Dim Yold As Double
+    Dim Zold As Double
+    Dim MaxMovementXY As Double
+    Dim MaxMovementZ As Double
+    
+    'test variables
+    Dim Success As Integer       ' Check if something was sucessfull
+    
+    'Recording stuff
+    Dim FilePath As String   ' full path of file to save (changes through function)
+    
+    OiaSettings.resetRegistry
+    OiaSettings.readFromRegistry
+    
+    FileName = AutofocusForm.TextBoxFileName.Value & Grids.getName(JobName, 1, 1, 1, 1) & Grids.suffix(JobName, 1, 1, 1, 1) & Reps.suffix(JobName, 1)
+    'create a new Gui document if recquired
+    NewRecord RecordingDoc, FileName
+    
+    CurrentJob = ""
+    Running = True  'Now we're starting. This will be set to false if the stop button is pressed or if we reached the total number of repetitions.
+
+     
+    
+    previousZ = Grids.getZ(JobName, 1, 1, 1, 1)
+    Reps.resetIndex (JobName)
+    
+    '''
+    ' Check if there are any valid positions
+    ''''
+    If Grids.getNrValidPts(GridName) = 0 Then
+        DisplayProgress "Job " & JobName & ", on grid " & GridName & " has no valid positions !", RGB(&HC0, &HC0, 0)
+        Sleep (500)
+        Exit Function
+    End If
+    
+    While Reps.nextRep(GridName) ' cycle all repetitions
+        Grids.setIndeces GridName, 1, 1, 1, 1
+        Do ''Cycle all positions defined in grid
+            If Grids.getThisValid(GridName) Then
+               DisplayProgress "Job " & JobName & ", Row " & Grids.thisRow(GridName) & ", Col " & Grids.thisColumn(JobName) & vbCrLf & _
+                "subRow " & Grids.thisSubRow(GridName) & ", subCol " & Grids.thisSubColumn(GridName) & ", Rep " & Reps.thisIndex(GridName), RGB(&HC0, &HC0, 0)
+
+                'Do some positional Job
+                StgPos.X = Grids.getThisX(GridName)
+                StgPos.Y = Grids.getThisY(GridName)
+                StgPos.Z = Grids.getThisZ(GridName)
+                
+                If Reps.getIndex(GridName) = 1 And AutofocusForm.GridScanActive Then
+                    StgPos.Z = previousZ
+                End If
+
+                ' Recenter and move where it should be. Job global is a series of jobs
+                ' TODO move into one single function per task
+                If JobName = "Global" Then
+                    For iJobGlobal = 0 To UBound(JobNamesGlobal)
+                        ' run subJobs for global setting
+                        StgPos = ExecuteJobAndTrack(GridName, JobNamesGlobal(iJobGlobal), RecordingDoc, parentPath, StgPos, SuccessExecute)
+                        If Not SuccessExecute Then
+                            GoTo StopJob
+                        End If
+                    Next iJobGlobal
+                Else
+                    StgPos = ExecuteJobAndTrack(GridName, JobName, RecordingDoc, parentPath, StgPos, SuccessExecute)
+                    If Not SuccessExecute Then
+                        GoTo StopJob
+                    End If
+                End If
+                
+                Grids.setThisX GridName, StgPos.X
+                Grids.setThisY GridName, StgPos.Y
+                Grids.setThisZ GridName, StgPos.Z
+                previousZ = Grids.getThisZ(GridName)
+            End If
+            If ScanPause = True Then
+                If Not AutofocusForm.Pause Then ' Pause is true if Resume
+                    GoTo StopJob
+                    Exit Function
+                End If
+            End If
+        Loop While Grids.nextGridPt(JobName)
+        ''Wait till next repetition
+        Reps.updateTimeStart (JobName)
+        
+        If Reps.wait(JobName) > 0 Then
+            DisplayProgress "Waiting " & CStr(CInt(Reps.wait(JobName))) & " s before scanning repetition  " & Reps.getIndex(JobName) + 1, RGB(&HC0, &HC0, 0)
+            DoEvents
+        End If
+        
+        While ((Reps.wait(JobName) > 0) And (Reps.getIndex(JobName) < Reps.getRepetitionNumber(JobName)))
+            Sleep (100)
+            DoEvents
+            If ScanPause = True Then
+                If Not AutofocusForm.Pause Then ' Pause is true if Resume
+                    GoTo StopJob
+                    Exit Function
+                End If
+            End If
+            If ScanStop Then
+                GoTo StopJob
+            End If
+            DisplayProgress "Waiting " & CStr(CInt(Reps.wait(JobName))) & " s before scanning repetition  " & Reps.getIndex(JobName) + 1, RGB(&HC0, &HC0, 0)
+        Wend
+        Sleep (100)
+        DoEvents
+        If ScanPause = True Then
+            If Not AutofocusForm.Pause Then ' Pause is true is Resume
+                GoTo StopJob
+            End If
+        End If
+        If ScanStop Then
+            GoTo StopJob
+        End If
+    Wend
+    StartJobOnGrid = True
+    Exit Function
+StopJob:
+    ScanStop = True
+    StopAcquisition
+    DisplayProgress "Stopped", RGB(&HC0, 0, 0)
+    Exit Function
+ErrorHandle1:
+    ScanStop = True
+    MsgBox "Error StartJobOnGrid for Job " + JobNamesGlobal(iJobGlobal) + " on Grid " + GridName + " " + Err.Description
+    StopAcquisition
+    Exit Function
+ErrorHandle2:
+    ScanStop = True
+    MsgBox "Error StartJobOnGrid for Job " + JobName + " on Grid " + GridName + " " + Err.Description
+    StopAcquisition
+    Exit Function
+End Function
+
+'''
+' Derive filename from Grid and repetition
+'''
+Private Function FileNameFromGrid(GridName As String, JobName As String) As String
+On Error GoTo ErrorHandle:
+     FileNameFromGrid = AutofocusForm.TextBoxFileName.Value & Grids.getThisName(GridName) & JobShortNames(JobName) & "_" & Grids.thisSuffix(GridName) & Reps.thisSuffix(GridName)
+     Exit Function
+ErrorHandle:
+    MsgBox "Error in FileNameOnGrid " + Err.Description
+End Function
+
+''''
+' check  that newPos is not further away than the size of the image. In fact it should be half the image
+''''
+Public Function checkForMaximalDisplacement(JobName As String, currentPos As Vector, newPos As Vector) As Boolean
+    Dim MaxMovementXY As Double
+    Dim MaxMovementZ As Double
+    
+    MaxMovementXY = Max(Jobs.getSamplesPerLine(JobName), Jobs.getLinesPerFrame(JobName)) * Jobs.getSampleSpacing(JobName)
+    MaxMovementZ = Jobs.getFramesPerStack(JobName) * Jobs.getFrameSpacing(JobName)
+                                
+    If Abs(newPos.X - currentPos.X) > MaxMovementXY Or Abs(newPos.Y - currentPos.Y) > MaxMovementXY Or Abs(newPos.Z - currentPos.Z) > MaxMovementZ Then
+        ErrorLog.UpdateLog "Job " & JobName & " online image analysis returned a too large displacement/focus " & _
+        "dX, dY, dZ = " & Abs(newPos.X - currentPos.X) & ", " & Abs(newPos.Y - currentPos.Y) & ", " & Abs(newPos.Z - currentPos.Z) & vbCrLf & _
+        "accepted dX, dY, dZ = " & MaxMovementXY & ", " & MaxMovementXY & ", " & MaxMovementZ
+        Exit Function
+    End If
+    checkForMaximalDisplacement = True
+End Function
+
+
+''''
+' check  that newPos is not further away than the size of the image. In fact it should be half the image
+''''
+Private Function checkForMaximalDisplacementVec(JobName As String, currentPos As Vector, newPos() As Vector) As Boolean
+    Dim MaxMovementXY As Double
+    Dim MaxMovementZ As Double
+    Dim i As Integer
+    MaxMovementXY = CDbl(Max(Jobs.getSamplesPerLine(JobName), Jobs.getLinesPerFrame(JobName))) * Jobs.getSampleSpacing(JobName)
+    MaxMovementZ = Jobs.getFramesPerStack(JobName) * Jobs.getFrameSpacing(JobName)
+    For i = 0 To UBound(newPos)
+        If Abs(newPos(i).X - currentPos.X) > MaxMovementXY Or Abs(newPos(i).Y - currentPos.Y) > MaxMovementXY Or Abs(newPos(i).Z - currentPos.Z) > MaxMovementZ Then
+            ErrorLog.UpdateLog "Job " & JobName & " online image analysis returned a too large displacement/focus " & _
+            "dX, dY, dZ = " & Abs(newPos(i).X - currentPos.X) & ", " & Abs(newPos(i).Y - currentPos.Y) & ", " & Abs(newPos(i).Z - currentPos.Z) & vbCrLf & _
+            "accepted dX, dY, dZ = " & MaxMovementXY & ", " & MaxMovementXY & ", " & MaxMovementZ
+            Exit Function
+        End If
+    Next i
+    checkForMaximalDisplacementVec = True
+End Function
+
+''''
+' check  that newPos is within possible boundary.
+'   newPos is a vector of coordinates in pixel. It is positive
+''''
+Private Function checkForMaximalDisplacementVecPixels(JobName As String, newPos() As Vector) As Boolean
+    Dim MaxX As Long
+    Dim MaxY As Long
+    Dim MaxZ As Long
+    Dim i As Integer
+    MaxX = Jobs.getSamplesPerLine(JobName) - 1
+    If Jobs.GetScanMode(JobName) = "ZScan" Then
+        MaxY = 0
+    Else
+        MaxY = Jobs.getLinesPerFrame(JobName) - 1
+    End If
+    If Jobs.isZStack(JobName) Then
+        MaxZ = Jobs.getFramesPerStack(JobName) - 1
+    Else
+        MaxZ = 0
+    End If
+    For i = 0 To UBound(newPos)
+        If newPos(i).X < 0 Or newPos(i).Y < 0 Or newPos(i).Z < 0 Then
+            ErrorLog.UpdateLog "Job " & JobName & " online image analysis returned negative pixel values " & _
+            "X, Y, Z = " & newPos(i).X & ", " & newPos(i).Y & ", " & newPos(i).Z & vbCrLf
+            Exit Function
+        End If
+        If newPos(i).X > MaxX Or newPos(i).Y > MaxY Or newPos(i).Z > MaxZ Then
+            ErrorLog.UpdateLog "Job " & JobName & " online image analysis returned a too large displacement/focus " & _
+            "X, Y, Z = " & newPos(i).X & ", " & newPos(i).Y & ", " & newPos(i).Z & vbCrLf & _
+            "accepted range is X = " & 0 & "-" & MaxX & ", Y = " & 0 & "-" & MaxY & ", Z = " & 0 & "-" & MaxZ
+            Exit Function
+        End If
+    Next i
+    checkForMaximalDisplacementVecPixels = True
+End Function
+
+'''
+' Derive filepath Suffix from Grid and repetition
+'''
+Private Function FilePathSuffix(GridName As String, JobName As String) As String
+    FilePathSuffix = AutofocusForm.TextBoxFileName.Value & Grids.getThisName(GridName) & JobShortNames(JobName)
+    If (Grids.numCol(GridName) * Grids.numRow(GridName) = 1 And Grids.numColSub(GridName) * Grids.numRowSub(GridName) = 1) Then
+        FilePathSuffix = FilePathSuffix & "_" & Grids.thisSuffix(GridName)
+        Exit Function
+    End If
+    If (Grids.numCol(GridName) * Grids.numRow(GridName) > 1 And Not Grids.numColSub(GridName) * Grids.numRowSub(GridName) > 1) _
+    Or (Not Grids.numCol(GridName) * Grids.numRow(GridName) > 1 And Grids.numColSub(GridName) * Grids.numRowSub(GridName) > 1) Then
+        FilePathSuffix = FilePathSuffix & "_" & Grids.thisSuffix(GridName)
+    Else
+        FilePathSuffix = FilePathSuffix & "_" & Grids.thisSuffixWell(GridName) & "\" & FilePathSuffix & "_" & Grids.thisSuffix(GridName)
+    End If
+End Function
+
+
+'''
+'   Update the settings of the corresponding Formpage from the Job
+'''
+Public Sub UpdateFormFromJob(Jobs As ImagingJobs, JobName As String)
+    
+    'update form for any new tracks
+    'AutofocusForm.AutoFindTracks
+    Dim i As Integer
+    Dim Record As DsRecording
+    Dim jobDescriptor() As String
+    Set Record = Jobs.GetRecording(JobName)
+    
+    For i = 0 To TrackNumber - 1
+       AutofocusForm.Controls(JobName + "Track" + CStr(i + 1)).Value = Jobs.getAcquireTrack(JobName, i)
+    Next i
+         
+    jobDescriptor = Jobs.splittedJobDescriptor(JobName, 8)
+    AutofocusForm.Controls(JobName + "Label1").Caption = jobDescriptor(0)
+    If UBound(jobDescriptor) > 0 Then
+        AutofocusForm.Controls(JobName + "Label2").Caption = jobDescriptor(1)
+    End If
+    
+    If Jobs.GetScanMode(JobName) = "ZScan" Or Jobs.GetScanMode(JobName) = "Line" Then
+        AutofocusForm.Controls(JobName + "TrackXY").Value = False
+        AutofocusForm.Controls(JobName + "TrackXY").Enabled = False
+    Else
+        AutofocusForm.Controls(JobName + "TrackXY").Enabled = AutofocusForm.Controls(JobName + "Active")
+    End If
+    AutofocusForm.FillTrackingChannelList JobName
+End Sub
+
+'''
+'   Update the settings of the corresponding Formpage from the Job
+'''
+Public Sub UpdateFormFromJobFcs(Jobs As FcsJobs, JobName As String)
+    
+    'update form for any new tracks
+    'AutofocusForm.AutoFindTracks
+    Dim i As Integer
+    Dim jobDescriptor() As String
+     
+         
+    jobDescriptor = JobsFcs.splittedJobDescriptor(JobName, 8)
+    AutofocusForm.Controls(JobName + "Label1").Caption = jobDescriptor(0)
+    If UBound(jobDescriptor) > 0 Then
+        AutofocusForm.Controls(JobName + "Label2").Caption = jobDescriptor(1)
+    End If
+    
+End Sub
+
+'''
+'   Update the settings of Job with JobName from corresponding Formpage
+'''
+Public Sub UpdateJobFromForm(Jobs As ImagingJobs, JobName As String)
+    Dim i As Integer
+    For i = 0 To TrackNumber - 1
+       Jobs.setAcquireTrack JobName, i, AutofocusForm.Controls(JobName + "Track" + CStr(i + 1)).Value
+    Next i
+    AutofocusForm.UpdateRepetitionTimes
+End Sub
+
+'''
+'   Updates the Gui AcquisitionMode from the Job
+'''
+Public Sub UpdateGuiFromJob(Jobs As ImagingJobs, JobName As String, ZEN As Object)
+    If ZEN Is Nothing Then
+        Exit Sub
+    End If
+    Dim iTrack As Integer
+    Dim ScanMode As String
+    If ZEN Is Nothing Then
+        Exit Sub
+    End If
+    ScanMode = Jobs.GetScanMode(JobName)
+    ZEN.gui.Acquisition.AcquisitionMode.FrameSizeX.Value = Jobs.getSamplesPerLine(JobName)
+    ZEN.gui.Acquisition.AcquisitionMode.FrameSizeY.Value = Jobs.getLinesPerFrame(JobName)
+    
+    If ScanMode = "ZScan" Or ScanMode = "Line" Then
+        ZEN.gui.Acquisition.AcquisitionMode.ScanMode.ByName = "Line"
+    End If
+    
+    If ScanMode = "Stack" Or ScanMode = "Plane" Then
+        ZEN.gui.Acquisition.AcquisitionMode.ScanMode.ByName = "Frame"
+    End If
+    
+    If ScanMode = "Point" Then
+        ZEN.gui.Acquisition.AcquisitionMode.ScanMode.ByName = "Point"
+    End If
+    
+    ZEN.gui.Acquisition.AcquisitionMode.ScanArea.Zoom.Value = Jobs.GetRecording(JobName).ZoomX
+    ZEN.SetListEntrySelected "Scan.Mode.DirectionX", Jobs.GetRecording(JobName).ScanDirection
+    
+    ZEN.gui.Acquisition.Bleaching.StartBleachingAfterNumScans.number.Value = Jobs.GetRecording(JobName).TrackObjectBleach(1).BleachScanNumber
+    ZEN.gui.Acquisition.Bleaching.RepeatBleachAfterNumScans.number.Value = Jobs.GetRecording(JobName).TrackObjectBleach(1).BleachRepeat
+    'Debug.Print "BleachLaserPower " & Jobs.GetRecording(JobName).
+    'ZEN.GUI.Acquisition.AcquisitionMode.BitDepth.ByIndex = 1
+    'This unfortunately does not update the GUI
+'    For iTrack = 0 To Jobs.TrackNumber(JobName) - 1
+'        ZEN.gui.Acquisition.Channels.Track.ByIndex = iTrack '(it does not display properly anyway)
+'        ZEN.gui.Acquisition.Channels.Track.Acquire.Value = Jobs.GetAcquireTrack(JobName, iTrack)
+'    Next iTrack
+
+    
+     
+End Sub
+
+
+
+
+
+'''''''
+'   computeShiftedCoordinates(offsetPosition As Vector, currentPosition As Vector) As Vector
+'   given offsetPosition with (0,0,0) center of image central slice (in um)
+'   the function compute absolute stage/focus coordinates from currentPosition
+''''''
+Public Function computeShiftedCoordinates(offsetPosition As Vector, currentPosition As Vector) As Vector
+    Dim Xpre As Integer
+    Dim Ypre As Integer
+    
+    If MirrorX Then
+        Xpre = -1
+    Else
+        Xpre = 1
+    End If
+    
+    If MirrorY Then
+        Ypre = -1
+    Else
+        Ypre = 1
+    End If
+    
+    If ExchangeXY Then ' not sure about this and needs to be properly tested
+        computeShiftedCoordinates.X = currentPosition.X + Xpre * offsetPosition.Y
+        computeShiftedCoordinates.Y = currentPosition.Y + Ypre * offsetPosition.X
+    Else
+        computeShiftedCoordinates.X = currentPosition.X + Xpre * offsetPosition.X
+        computeShiftedCoordinates.Y = currentPosition.Y + Ypre * offsetPosition.Y
+    End If
+      
+    computeShiftedCoordinates.Z = currentPosition.Z + offsetPosition.Z
+    
+    computeShiftedCoordinates.X = Round(computeShiftedCoordinates.X, PrecXY)
+    computeShiftedCoordinates.Y = Round(computeShiftedCoordinates.Y, PrecXY)
+    computeShiftedCoordinates.Z = Round(computeShiftedCoordinates.Z, PrecZ)
+End Function
+
+
+''''
+' compute offset coordinates for imaging from pixel coordinates
+' newPosition() As Vector
+' the values are returned in um!!
+''''
+Public Function computeCoordinatesImaging(JobName As String, currentPosition As Vector, newPosition() As Vector) As Vector()
+    Dim pixelSize As Double
+    Dim frameSpacing As Double
+    Dim MaxX As Integer
+    Dim MaxY As Integer
+    Dim framesPerStack As Integer
+    Dim i As Integer
+    Dim position() As Vector
+    position = newPosition
+    'pixelSize = Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing 'This is in meter!!! be careful . Position for imaging is provided in um
+    pixelSize = Jobs.getSampleSpacing(JobName) ' this is in um
+    'compute difference with respect to center
+    MaxX = Jobs.getSamplesPerLine(JobName)
+    MaxY = Jobs.getLinesPerFrame(JobName)
+    framesPerStack = Jobs.getFramesPerStack(JobName)
+    frameSpacing = Jobs.getFrameSpacing(JobName)
+    For i = 0 To UBound(newPosition)
+        position(i).X = (position(i).X - (MaxX - 1) / 2) * pixelSize
+        position(i).Y = (position(i).Y - (MaxY - 1) / 2) * pixelSize
+        If Jobs.isZStack(JobName) Then
+            position(i).Z = (position(i).Z - (framesPerStack - 1) / 2) * frameSpacing
+        Else
+            position(i).Z = 0
+        End If
+        position(i) = computeShiftedCoordinates(position(i), currentPosition)
+    Next i
+    computeCoordinatesImaging = position
+End Function
+
+
+''''
+'   compute coordinates for fcs from pixel coordinates
+'       JobName: the JobName from the image from which we will do FCS (Fcs can only occur after an image)
+'       currentPosition: current Position of stage and focus in um
+'       newPosition: new position where to perform FCS in pixels (0,0,0) is upper left corner bottom slice
+'   Returns a coordinate vector in meter where  the value should be returned in meter!! (for imaging coordinates are returned in meter)
+''''
+Public Function computeCoordinatesFcs(JobName As String, currentPosition As Vector, newPosition() As Vector) As Vector()
+    Dim pixelSize As Double
+    Dim frameSpacing As Double
+    Dim MaxX As Integer
+    Dim MaxY As Integer
+    Dim framesPerStack As Integer
+    Dim i As Integer
+    Dim position() As Vector
+    position = newPosition
+    'pixelSize = Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing 'This is in meter!!!
+    pixelSize = Jobs.getSampleSpacing(JobName) ' this is in um
+    'compute difference with respect to center
+    MaxX = Jobs.getSamplesPerLine(JobName)
+    MaxY = Jobs.getLinesPerFrame(JobName)
+    framesPerStack = Jobs.getFramesPerStack(JobName)
+    frameSpacing = Jobs.getFrameSpacing(JobName)
+    For i = 0 To UBound(newPosition)
+        'for FCS position is with respect
+        position(i).X = (position(i).X - (MaxX - 1) / 2) * pixelSize * 0.000001
+        position(i).Y = (position(i).Y - (MaxY - 1) / 2) * pixelSize * 0.000001
+        If Jobs.isZStack(JobName) Then
+            position(i).Z = (position(i).Z - (framesPerStack - 1) / 2) * frameSpacing
+        Else
+            position(i).Z = 0
+        End If
+        position(i).Z = (currentPosition.Z + position(i).Z) * 0.000001
+    Next i
+    computeCoordinatesFcs = position
+End Function
+
+
+
+
+''''
+' create and update a subgrid and eventually decide whether to run Job
+''''
+Public Function runSubImagingJob(GridName As String, JobName As String, newPositions() As Vector) As Boolean
+    Dim i As Integer
+    Dim ptNumber As Integer ' number of pts for the grid
+    Dim maxWait As Double   ' maximal time to wait for the grid
+    Dim GridLowBound As Integer
+       
+    If AutofocusForm.Controls(JobName + "OptimalPtNumber").Value <> "" Then
+        ptNumber = CInt(AutofocusForm.Controls(JobName + "OptimalPtNumber").Value)
+    Else
+        ptNumber = 0
+    End If
+    
+    If AutofocusForm.Controls(JobName + "maxWait").Value <> "" Then
+        maxWait = CDbl(AutofocusForm.Controls(JobName + "maxWait").Value)
+    Else
+        maxWait = 0
+    End If
+    
+    ''createnew grid if recquired
+    If Not Grids.checkGridName(GridName) Then
+        Grids.AddGrid (GridName)
+    End If
+
+    '' change size of grid
+    If Grids.isGridEmpty(GridName) Then
+        ''start counter for gridcreation!!!
+        Grids.updateGridSize GridName, 1, 1, 1, UBound(newPositions) + 1
+        GridLowBound = 1
+        If TimersGridCreation Is Nothing Then
+            Set TimersGridCreation = New Timers
+        End If
+        TimersGridCreation.addTimer GridName
+        TimersGridCreation.updateTimeStart GridName
+    Else
+        GridLowBound = Grids.numColSub(GridName) + 1
+        Grids.updateGridSizePreserve GridName, 1, 1, 1, UBound(newPositions) + GridLowBound
+    End If
+    
+    ''' input grid positions
+    For i = 0 To UBound(newPositions)
+            Grids.setPt GridName, newPositions(i), True, 1, 1, 1, i + GridLowBound
+    Next i
+    
+    If ptNumber = 0 Or maxWait = 0 Then
+        runSubImagingJob = True
+        Exit Function
+    End If
+        
+    If AutofocusForm.Controls(JobName + "OptimalPtNumber").Value = "" And AutofocusForm.Controls(JobName + "maxWait").Value = "" Then
+        ' if the value is empty we image whatever has been found
+        runSubImagingJob = True
+        Exit Function
+    End If
+    
+    If AutofocusForm.Controls(JobName + "OptimalPtNumber").Value = "" Then
+        If TimersGridCreation.wait(GridName, CDbl(AutofocusForm.Controls(JobName + "maxWait").Value)) < 0 Then
+            runSubImagingJob = True
+            Exit Function
+        End If
+    End If
+    
+        
+    If AutofocusForm.Controls(JobName + "maxWait").Value = "" Then
+        If Grids.getNrPts(GridName) >= ptNumber Then
+            'trim grid
+            Grids.updateGridSizePreserve GridName, 1, 1, 1, AutofocusForm.Controls(JobName + "OptimalPtNumber").Value
+            runSubImagingJob = True
+            Exit Function
+        End If
+    End If
+    
+    'both are unequal 0. you chose which occurs first
+    If AutofocusForm.Controls(JobName + "OptimalPtNumber").Value <> "" Then
+        If Grids.getNrPts(GridName) >= AutofocusForm.Controls(JobName + "OptimalPtNumber").Value Then
+            'trim grid
+            Grids.updateGridSizePreserve GridName, 1, 1, 1, AutofocusForm.Controls(JobName + "OptimalPtNumber").Value
+            runSubImagingJob = True
+            Exit Function
+        End If
+        
+        If TimersGridCreation.wait(GridName, CDbl(AutofocusForm.Controls(JobName + "maxWait").Value)) < 0 Then
+            runSubImagingJob = True
+            Exit Function
+        End If
+    End If
+    
+    If AutofocusForm.Controls(JobName + "OptimalPtNumber").Value <> "" And AutofocusForm.Controls(JobName + "OptimalPtNumber").Value = "" Then
+        If AutofocusForm.Controls(JobName + "OptimalPtNumber").Value >= Grids.getNrPts(GridName) Then
+            'trim grid
+            Grids.updateGridSizePreserve GridName, 1, 1, 1, AutofocusForm.Controls(JobName + "OptimalPtNumber").Value
+            runSubImagingJob = True
+            Exit Function
+        End If
+    End If
+    
+End Function
+
+'''
+'   Wait for image analysis and perform a specific task.
+'   The exit from here is a hard exit upon error or stop
+''''
+Public Function ComputeJobSequential(parentJob As String, parentGrid As String, parentPosition As Vector, parentPath As String, parentFile As String, RecordingDoc As DsRecordingDoc, Optional deltaZ As Integer = -1) As Vector
+    
+    Dim imageSize As Integer
+    Dim newPositionsPx() As Vector 'from the registru one obtains positions in pixels
+    Dim newPositions() As Vector
+    Dim Rois() As Roi
+    Dim codeMic As String
+    Dim JobName As String 'local convenience variable
+    
+    Dim codeMicToJobName As Dictionary 'use to convert codes of regisrty into Jobnames as used in the code
+    Set codeMicToJobName = New Dictionary
+    codeMicToJobName.Add "trigger1", "Trigger1"
+    codeMicToJobName.Add "trigger2", "Trigger2"
+    codeMicToJobName.Add "fcs1", "Fcs1"
+    
+    Dim OiaSettings As OnlineIASettings
+    Set OiaSettings = New OnlineIASettings
+    codeMic = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="codeMic")
+    
+    
+    Dim TimeWait, TimeStart, MaxTimeWait As Double
+    
+    MaxTimeWait = 100
+    
+    'default return value is currentPosition
+    ComputeJobSequential = parentPosition
+    
+    Select Case codeMic
+        Case "wait":
+            'Wait for image analysis to finish
+            DisplayProgress "Waiting for image analysis...", RGB(0, &HC0, 0)
+            TimeStart = CDbl(GetTickCount) * 0.001
+            Do While ((TimeWait < MaxTimeWait) And (codeMic = "wait"))
+                Sleep (50)
+                TimeWait = CDbl(GetTickCount) * 0.001 - TimeStart
+                codeMic = GetSetting(appname:="OnlineImageAnalysis", section:="macro", _
+                          Key:="codeMic")
+                DoEvents
+                If ScanStop Then
+                    GoTo Abort
+                End If
+            Loop
+
+            If TimeWait > MaxTimeWait Then
+                codeMic = "timeExpired"
+                SaveSetting "OnlineImageAnalysis", "macro", "codeMic", codeMic
+                SaveSetting "OnlineImageAnalysis", "macro", "codeOia", "nothing"
+            End If
+    End Select
+
+    ''Read all settings at once
+    OiaSettings.readFromRegistry
+    
+    ComputeJobSequential = parentPosition
+    'read if it is the correct code
+    If Not OiaSettings.checkKeyItem("codeMic", OiaSettings.getSettings("codeMic")) Then
+        GoTo Abort
+    End If
+    
+
+    Select Case codeMic
+        Case "nothing", "": 'Nothing to do
+        
+        Case "error":
+            OiaSettings.writeKeyToRegistry "codeMic", "nothing"
+            ErrorLog.UpdateLog "codeMic error. Online image analysis for job " + parentJob + " file " + OiaSettings.getSettings("filePath") + " failed"
+            
+        Case "timeExpired":
+            OiaSettings.writeKeyToRegistry "codeMic", "nothing"
+            ErrorLog.UpdateLog "codeMic timeExpired. Online image analysis for job " + parentJob + " file " + OiaSettings.getSettings("filePath") + " took more then " & MaxTimeWait & " sec"
+            
+        Case "focus":
+            OiaSettings.writeKeyToRegistry "codeMic", "nothing"
+            If OiaSettings.getPositions(newPositionsPx, parentPosition) Then
+                If Not checkForMaximalDisplacementVecPixels(parentJob, newPositionsPx) Then
+                    Exit Function
+                End If
+                newPositions = computeCoordinatesImaging(parentJob, parentPosition, newPositionsPx)
+                If UBound(newPositions) > 0 Then
+                    ErrorLog.UpdateLog " ComputeJobSequential: for Job focus pass only one point to X, Y, and Z of regisrty instead of " & UBound(newPositions) + 1 & ". Using the first point!"
+                End If
+                ComputeJobSequential = newPositions(0)
+            Else
+                ErrorLog.UpdateLog "ComputeJobSequential: No position/wrong position for Job focus. " & vbCrLf & _
+                "Specify one position in X, Y, Z of registry (in pixels, (X,Y) = (0,0) upper left corner image, Z = 0 -> central slice of current stack)!"
+                Exit Function
+            End If
+            
+        Case "trigger1", "trigger2": 'store positions for later processing or direct imaging depending on settings
+            OiaSettings.writeKeyToRegistry "codeMic", "nothing"
+            JobName = codeMicToJobName.Item(codeMic)
+            DisplayProgress "Registry codeMic " & codeMic & ": store positions and eventually image job" & JobName & "...", RGB(0, &HC0, 0)
+            If Not AutofocusForm.Controls(JobName + "Active") Then
+                ErrorLog.UpdateLog "ComputeJobSequential: job " & JobName & " is not active"
+                Exit Function
+            End If
+            If OiaSettings.getPositions(newPositionsPx, parentPosition) Then
+                If Not checkForMaximalDisplacementVecPixels(parentJob, newPositionsPx) Then
+                    GoTo Abort
+                End If
+                newPositions = computeCoordinatesImaging(parentJob, parentPosition, newPositionsPx)
+                ' if displacement are above the possible displacement estimated from current image then abort (this is obsolete now)
+                If Not checkForMaximalDisplacementVec(parentJob, parentPosition, newPositions) Then
+                    GoTo Abort
+                End If
+            Else
+                ErrorLog.UpdateLog "ComputeJobSequential: No position for Job " & JobName & " (key = " & codeMic & ") has been specified! Imaging current position"
+                ReDim newPositions(0)
+                newPositions(0) = parentPosition
+            End If
+            
+            If OiaSettings.getRois(Rois) Then
+                Jobs.setUseRoi JobName, True
+                Jobs.setRois JobName, Rois
+            End If
+            ''' if we run a subjob the grid and counter is reset
+            If runSubImagingJob(JobName, JobName, newPositions) Then
+                'remove positions from parent grid to avoid revisiting the position
+                Grids.setThisValid parentGrid, False
+                'start acquisition of Job on grid named JobName
+                If Not StartJobOnGrid(JobName, JobName, RecordingDoc, parentPath & parentFile & "\") Then
+                    GoTo Abort
+                End If
+                'set all run positions to notValid
+                Grids.setAllValid JobName, False
+            End If
+            
+        Case "fcs1":
+            OiaSettings.writeKeyToRegistry "codeMic", "nothing"
+            JobName = codeMicToJobName.Item(codeMic)
+            DisplayProgress "Registry codeMic " & codeMic & " executing " & JobName & "...", RGB(0, &HC0, 0)
+            If Not AutofocusForm.Controls(JobName + "Active") Then
+                ErrorLog.UpdateLog "ComputeJobSequential: job " & JobName & " is not active"
+                Exit Function
+            End If
+            If OiaSettings.getFcsPositions(newPositionsPx, parentPosition) Then
+                If Not checkForMaximalDisplacementVecPixels(parentJob, newPositionsPx) Then
+                    GoTo Abort
+                End If
+                newPositions = computeCoordinatesFcs(parentJob, parentPosition, newPositionsPx)
+                ' if displacement are above the possible displacement estimated from current image then abort
+            Else
+                ReDim newPositionsPx(0)
+                newPositionsPx(0) = Jobs.getCentralPtPx(parentJob)
+                newPositions = computeCoordinatesFcs(parentJob, parentPosition, newPositionsPx)
+                ErrorLog.UpdateLog "ComputeJobSequential: No position for Job " & JobName & " (key = " & codeMic & ") has been specified!"
+            End If
+            ReDim newPositionsPx(0)
+            DisplayProgress "Job " & JobName, RGB(&HC0, &HC0, 0)
+            If Not ExecuteFcsJob(JobName, GlobalFcsRecordingDoc, GlobalFcsData, parentPath, "FCS1_" & parentFile, newPositions, newPositionsPx) Then
+                GoTo Abort
+            End If
+            
+        Case Else
+            MsgBox ("Invalid OnlineImageAnalysis codeMic = " & codeMic)
+            GoTo Abort
+    End Select
+Exit Function
+Abort:
+    ScanStop = True ' global flag to stop everything
+    StopAcquisition
+End Function
+
+
+
+
+Public Function ComputeJobParallel(JobName As String, Recording As DsRecording, FilePath As String, FileName As String, X As Double, _
+Y As Double, Z As Double, Optional deltaZ As Integer = -1) As Double()
+    Dim OiaSettings As Dictionary
+    Dim NewCoord() As Double
+    ReDim NewCoord(3)
+    'Defaults we dont change anything
+    deltaZ = -1
+    NewCoord(0) = X
+    NewCoord(1) = Y
+    NewCoord(2) = Z
+    NewCoord(3) = deltaZ
+    If AutofocusForm.Controls(JobName & "OiaActive") And AutofocusForm.Controls(JobName & "OiaParalle") Then
+        ComputeJobParallel = NewCoord
+    End If
+End Function
+
+'
+'
+'
+'
+'Public Sub GetJob(Jobs As Collection, JobName As String)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).GetJob
+'End Sub
+'
+'Public Sub SetJob(Jobs As Collection, JobName As String)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).SetJob
+'End Sub
+'
+'Public Sub UpdateJobLinesPerFrame(Jobs As Collection, JobName As String, Value As Integer)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).LinesPerFrame Value
+'End Sub
+'
+'Public Sub UpdateJobSamplesPerLine(Jobs As Collection, JobName As String, Value As Integer)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).SamplesPerLine Value
+'End Sub
+'
+'Public Sub UpdateJobSpecialScanMode(Jobs As Collection, JobName As String, Value As String)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).SpecialScanMode Value
+'End Sub
+'
+'Public Sub UpdateJobScanDirection(Jobs As Collection, JobName As String, Value As Integer)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).ScanDirection Value
+'End Sub
+'
+'Public Sub UpdateJobStacksPerRecord(Jobs As Collection, JobName As String, Value As Integer)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).StacksPerRecord Value
+'End Sub
+'
+'Public Sub UpdateJobZoom(Jobs As Collection, JobName As String, Value As Double)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).Zoom Value
+'End Sub
+'
+'Public Sub UpdateJobStacks(Jobs As Collection, JobName As String, ZRange As Double, ZStep As Double)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).FramesPerStack CLng(ZRange / ZStep) + 1
+'    Jobs(iJob).FrameSpacing ZStep
+'End Sub
+'
+'Public Sub UpdateJobFramesPerStack(Jobs As Collection, JobName As String, FramesPerStack As Long)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).FramesPerStack FramesPerStack
+'End Sub
+'
+'Public Sub UpdateJobFrameSpacing(Jobs As Collection, JobName As String, FrameSpacing As Double)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).FrameSpacing FrameSpacing
+'End Sub
+'
+'Public Sub UpdateJobFrameSize(Jobs As Collection, JobName As String, FrameSize As Integer)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).FrameSize FrameSize
+'End Sub
+'
+'''''''
+''    UpdateJobTimeSeries: if True the Job also has time Series
+''''''
+'Public Sub UpdateJobTimeSeries(Jobs As Collection, JobName As String, Value As Boolean)
+'    Dim iJob As Integer
+'    iJob = JobsDic(JobName)
+'    Jobs(iJob).TimeSeries Value
+'End Sub
+'
+'
+'Public Function TestImgJob()
+'    Dim JobNames(1) As String
+'    JobNames(0) = "Laser"
+'    JobNames(1) = "Space"
+'    Dim JobsTest As ImagingJobs
+'    Set JobsTest = New ImagingJobs
+'    JobsTest.Initialize JobNames, Lsm5.DsRecording
+'    JobsTest.SetAcquireTrack "Laser", 1, True
+'    JobsTest.SetAcquireTrack "Laser", 0, False
+'    JobsTest.SetFramesPerStack "Laser", 3
+'    JobsTest.PutJob "Laser"
+'
+'
+''    Dim Name As Variant
+''    For Each Name In JobNames
+''        MsgBox Name
+''    Next Name
+''    Set ZEN = Lsm5.CreateObject("Zeiss.Micro.AIM.ApplicationInterface.ApplicationInterface")
+''    Set Jobs = New Collection
+''    Dim Job1 As ImagingJob
+''    Dim Record As DsRecording
+''    Dim Track As DsTrack
+''    Set Job1 = New ImagingJob
+''    Job1.Name = "Job1"
+''    Job1.GetJob
+''    Job1.TimeBetweenStacks = 5
+''    Set Job2 = New ImagingJob
+''
+''    Job2.Name = "Job2"
+''    Job2.GetJob
+''    Set Record = Job2.Recording
+''    Set Track = Job2.Tracks(0)
+''    Job2.TimeBetweenStacks = 10
+''    Job1.StacksPerRecord 2
+''    Job2.StacksPerRecord 3
+''    'ZEN.gui.Acquisition.TimeSeries.Interval.Value = Job2.TimeBetweenStacks
+''
+''    Job1.SetJob
+''    'ZEN.gui.Acquisition.TimeSeries.Interval.Value = Job2.TimeBetweenStacks
+'    'ZEN.SetDouble "TimeSeries.End.Duration", 18
+'
+'    Job2.SetJob
+'
+'    Job1.SetJob
+''    Dim Job2 As ImagingJob
+''    Set Job2 = New ImagingJob
+''    Job2.Name = "Job2"
+''    Jobs.Add Job1
+''    Jobs.Add Job2
+''    ReDim Jobs(1)
+''    Jobs(0).Name = "Hello"
+''    Jobs(0).GetSettings
+''    Jobs(0).Recording.FramesPerStack = 5
+''    Jobs(0).SetSettings
+' '   MsgBox Jobs.Item(2).Name
+'End Function
diff --git a/AutofocusScreen/src/AutofocusScreen/KeyReport.frm b/AutofocusScreen/src/AutofocusScreen/KeyReport.frm
new file mode 100644
index 0000000..caed6e0
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/KeyReport.frm
@@ -0,0 +1,16 @@
+VERSION 5.00
+Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} KeyReport 
+   Caption         =   "Online Image Analysis Windows Registry Keys"
+   ClientHeight    =   11280
+   ClientLeft      =   45
+   ClientTop       =   375
+   ClientWidth     =   8820
+   OleObjectBlob   =   "KeyReport.frx":0000
+   ShowModal       =   0   'False
+   StartUpPosition =   1  'CenterOwner
+End
+Attribute VB_Name = "KeyReport"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = True
+Attribute VB_Exposed = False
diff --git a/AutofocusScreen/src/AutofocusScreen/KeyReport.frx b/AutofocusScreen/src/AutofocusScreen/KeyReport.frx
new file mode 100644
index 0000000..9ec3eea
Binary files /dev/null and b/AutofocusScreen/src/AutofocusScreen/KeyReport.frx differ
diff --git a/AutofocusScreen/src/AutofocusScreen/MCUCommands.bas b/AutofocusScreen/src/AutofocusScreen/MCUCommands.bas
index d2fc67f..3aa7980 100644
--- a/AutofocusScreen/src/AutofocusScreen/MCUCommands.bas
+++ b/AutofocusScreen/src/AutofocusScreen/MCUCommands.bas
@@ -1,5 +1,9 @@
 Attribute VB_Name = "MCUCommands"
+'''
+' Module with functions to control the stage
+''''
 
+Option Explicit
 Public Abort As Boolean
 Private Interface As Object
 Private Frequency As Double
@@ -10,7 +14,7 @@ Public MirrorX As Boolean
 Public MirrorY As Boolean
   
 
-Public Sub InitializeStageProperties(Optional tmp As Boolean) ' tmp is a hack so that function does not appear in menu
+Public Sub InitializeStageProperties(Optional Tmp As Boolean) ' tmp is a hack so that function does not appear in menu
     Set Interface = Lsm5.ExternalCpObject.pHardwareObjects.pInterfaces
     Set Interface = Interface.pItem("CANN")
     
@@ -167,35 +171,35 @@ Public Function GetMinimumStageSpeed() As Double
 End Function
 
 Private Function StageMoveToPositionX(PositionMetre As Double, CANN As Boolean)
-    Dim Position As String
+    Dim position As String
     
-    Position = Hex(CLng(-PositionMetre / Resolution))
-    While Len(Position) < 6
-        Position = "0" + Position
+    position = Hex(CLng(-PositionMetre / Resolution))
+    While Len(position) < 6
+        position = "0" + position
     Wend
-    If Len(Position) > 6 Then
-        Position = Strings.Right(Position, 6)
+    If Len(position) > 6 Then
+        position = Strings.Right(position, 6)
     End If
     If CANN Then
-        SendStageCommand ("XT" + Position + Strings.Chr(13))
+        SendStageCommand ("XT" + position + Strings.Chr(13))
     Else
-         SendCommand ("NPXT" + Position + Strings.Chr(13))
+         SendCommand ("NPXT" + position + Strings.Chr(13))
     End If
 End Function
 
 Private Function StageMoveToPositionY(PositionMetre As Double, CANN As Boolean)
-    Dim Position As String
-        Position = Hex(CLng(PositionMetre / Resolution))
-    While Len(Position) < 6
-        Position = "0" + Position
+    Dim position As String
+        position = Hex(CLng(PositionMetre / Resolution))
+    While Len(position) < 6
+        position = "0" + position
     Wend
-    If Len(Position) > 6 Then
-        Position = Strings.Right(Position, 6)
+    If Len(position) > 6 Then
+        position = Strings.Right(position, 6)
     End If
     If CANN Then
-        SendStageCommand ("YT" + Position + Strings.Chr(13))
+        SendStageCommand ("YT" + position + Strings.Chr(13))
     Else
-        SendCommand ("NPYT" + Position + Strings.Chr(13))
+        SendCommand ("NPYT" + position + Strings.Chr(13))
     End If
     
 End Function
@@ -271,7 +275,7 @@ End Function
 '''
 ' Function is not used
 '''
-Public Sub NoImageAxisChange(Optional tmp As Boolean) ' tmp is used so that the function does not appear in the menu. Not very clean
+Public Sub NoImageAxisChange(Optional Tmp As Boolean) ' tmp is used so that the function does not appear in the menu. Not very clean
     ExchangeXY = False
     MirrorX = False
     MirrorY = False
@@ -280,15 +284,15 @@ End Sub
 '''
 ' Function is not used
 '''
-Public Sub ImageAxisChange(Optional tmp As Boolean)
+Public Sub ImageAxisChange(Optional Tmp As Boolean)
     Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS 1, ExchangeXY, MirrorX, MirrorY
 End Sub
 
 
 ''''''
 '   AreStageCoordinateExchanged() As Boolean
-'       Check weather X and Y axis are exchanged and return True if yes.
-'       Todo: Could also return weather axis are mirrored. Intrestingly althouh axes are not mirrored we use -X??
+'       Check whether X and Y axis are exchanged and return True if yes.
+'       Todo: Could also return whether axis are mirrored. Intrestingly althouh axes are not mirrored we use -X??
 ''''''
 Public Sub StageSettings(MirrorX As Boolean, MirrorY As Boolean, ExchangeXY As Boolean)
     Dim bLSM As Boolean
diff --git a/AutofocusScreen/src/AutofocusScreen/MicroscopeIO.bas b/AutofocusScreen/src/AutofocusScreen/MicroscopeIO.bas
index b9f3a0d..1308414 100644
--- a/AutofocusScreen/src/AutofocusScreen/MicroscopeIO.bas
+++ b/AutofocusScreen/src/AutofocusScreen/MicroscopeIO.bas
@@ -1,6 +1,10 @@
 Attribute VB_Name = "MicroscopeIO"
-Option Explicit
+''''
+' Module with functions for controlling stage, starts and stop scan
+'''''
 
+Option Explicit
+Option Base 0
 Public SystemVersion As String
 
 Public Declare Function GetInputState Lib "user32" () As Long ' Check if mouse or keyboard has been pushed
@@ -22,304 +26,74 @@ Public Declare Function RegQueryValueEx _
     ByVal lpReserved As Long, lpType As Long, _
     lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
 
-''''''''''
-'''TYPES''
-''''''''''
-Public Type RepetitionType     'Contains Number and Time interval for repetition of acquisition protocol
-    Number As Integer   'Number of repetitions
-    Time As Double      'Interval between repetitions
-    Interval As Boolean ' If Interval is True than one computes interval between first and second image = Time other wise
-End Type
-
-''''Position on grid
-Public Type GridPosType
-    Row As Long
-    Col As Long
-    RowSub As Long
-    ColSub As Long
-End Type
-
-''''''''''''''''''''
-'''''CONSTANTS''''''
-''''''''''''''''''''
-Public Const VK_SPACE = &H20
-Public Const VK_RETURN = &HD
-Public Const VK_CANCEL = &H3
-Public Const VK_UP = &H26
-Public Const VK_DOWN = &H28
-Public Const VK_ESCAPE = &H1B
-Public Const VK_PAUSE = &H13
-Public Const VK_ADD = &H6B
-Public Const VK_SUBTRACT = &H6D
-Public Const HKEY_CLASSES_ROOT = &H80000000
-Public Const SYNCHRONIZE = &H100000
-Public Const READ_CONTROL = &H20000
-Public Const STANDARD_RIGHTS_READ = (READ_CONTROL)
-Public Const KEY_QUERY_VALUE = &H1
-Public Const KEY_ENUMERATE_SUB_KEYS = &H8
-Public Const KEY_NOTIFY = &H10
-Public Const KEY_READ = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
-
-Public Const REG_SZ = 1                         ' Unicode nul terminated string
-Public Const ERROR_SUCCESS = 0&
-
-Public Const vbOKOnly = 0   '  Display OK button only.
-Public Const VbOKCancel = 1 '  Display OK and Cancel buttons.
-Public Const VbAbortRetryIgnore = 2  ' Display Abort, Retry, and Ignore buttons.
-Public Const VbYesNoCancel = 3  '  Display Yes, No, and Cancel buttons.
-Public Const VbYesNo = 4 '  Display Yes and No buttons.
-Public Const VbRetryCancel = 5   ' Display Retry and Cancel buttons.
-Public Const VbCritical = 16 ' Display Critical Message icon.
-Public Const VbQuestion = 32 ' Display Warning Query icon.
-Public Const VbExclamation = 48  ' Display Warning Message icon.
-Public Const VbInformation = 64  ' Display Information Message icon.
-Public Const VbDefaultButton1 = 0    ' First button is default.
-Public Const VbDefaultButton2 = 256  ' Second button is default.
-Public Const VbDefaultButton3 = 512  ' Third button is default.
-Public Const VbDefaultButton4 = 768   'Fourth button is default.
-Public Const VbApplicationModal = 0  ' Application modal; the user must respond to the message box before continuing work in the current application.
-Public Const VbSystemModal = 4096   '  System modal; all applications are suspended until the user responds to the message box.
-'The first group of values (05) describes the number and type of buttons displayed in the dialog box; the second group (16, 32, 48, 64) describes the icon style; the third group (0, 256, 512) determines which button is the default; and the fourth group (0, 4096) determines the modality of the message box. When adding numbers to create a final value for the buttons argument, use only one number from each group.
-
-'Note   These constants are specified by Visual Basic for Applications. As a result, the names can be used anywhere in your code in place of the actual values.
-
-'Return Values
-Public Const vbOK = 1   '  OK
-Public Const vbCancel = 2    ' Cancel
-Public Const vbAbort = 3 ' Abort
-Public Const vbRetry = 4 '  Retry
-Public Const vbIgnore = 5   '  Ignore
-Public Const vbYes = 6  '  Yes
-Public Const vbNo = 7    ' No
+
+
+Public imgFileFormat As enumAimExportFormat
+Public imgFileExtension As String
+
 
 Public Const PrecZ = 2                     'precision of Z passed for stage movements i.e. Z = Round(Z, PrecZ)
 Public Const PrecXY = 2                    'precision of X and Y passed for stage movements
 
 Public ZBacklash  As Double           'ToDo: is it still recquired?.
                                            'Has to do with the movements of the focus wheel that are "better"
-                                           'if they are long enough. For amoment a test did not gave significant differences This is required for ZEN2010
-
-Public ZEN As Integer
-'''''''''''''''''''''
-'''GLOBAL VARIABLE'''
-'''''''''''''''''''''
-Public RowG As Integer
-Public ColG As Integer
-Public RowSubG As Integer
-Public ColSubG As Integer
-Public X11 As Double
-Public X12 As Double
-Public X21 As Double
-Public X22 As Double
-
-Public ScanStop As Boolean
-Public ScanPause As Boolean
-Public Running As Boolean
-Public ExtraBleach As Boolean
-Public AutomaticBleaching As Boolean
-Public BleachTable() As Boolean
-Public BleachStartTable() As Double
-Public BleachStopTable() As Double
-Public RepetitionNumber As Integer ' number of repetition
-Public locationNumber As Long      ' number of location global
-
-Public ZOffset As Double
-Public TrackingChannelString As String
-'Public PositionData As Workbook
-'position variables
-Public ZShift As Double
-Public XShift As Double
-Public YShift As Double
-Public XStart As Double ' Stores starting X position of Acquisition
-Public YStart As Double ' Stores starting Y position of Acquisition
-Public ZStart As Double
-Public HRZBefore As Double
-Public HRZ As Boolean
-
-'Filehandling variables
-Public OverwriteFiles As Boolean
-Public NoReflectionSignal As Boolean
-Public PubSentStageGrid As Boolean
-Public BleachingActivated As Boolean
-Public FocusMapPresent As Boolean
-
-Public flgEvent As Integer
-Public flg As Integer
-Public toContinue As Integer
-
-
-Public GlobalProjectName As String
-Public GlobalProject As String
-Public GlobalHelpName As String
-
-Public GlobalPrvTime As Double
-Public GlobalMacroKey As String
-Public GlobalCorrectionOffset As Double
-
-'newPublic29.06.2010
-Public NoFrames As Long
-
-' Public BlockAutoConfiguration As String
-Public BlockTimeIndex As Long
-' Public BlockAutoConfigurationUse As Boolean
-
-Public TimerName As String
-Public BlockTimeDelay As Double
-Public SelectedTimeButton As Integer
-Public TimerButton1 As Double
-Public TimerButton2 As Double
-Public TimerButton3 As Double
-Public TimerButton4 As Double
-Public TimerButton5 As Double
-Public TimerButton6 As Double
-Public LoopingTimerUnit As Integer
-Public BlockRepetitions As Long
-
-Public TimerKey As String
-
-Public GlobalHighRes As Boolean
-Public GlobalDataBaseName As String
-Public GlobalFileName As String
-Public GlobalImageIndex() As Long
-Public GlobalStripeIndex() As Long
-Public BlockZOffset As Double
-Public BlockZRange As Double
-Public BlockZStep As Double
-Public BlockHighSpeed As Boolean
-Public BlockLowZoom As Boolean
-Public BlockHRZ As Boolean
-Public PubSearchScan As Boolean
-
-Public BlockIsSingle As Boolean
-Public BlockSingleTrack As String
-Public BlockSingleTrackIndex As Long
-Public BlockMultiTrack As String
-Public BlockMultiTrackIndex As Long
+                                            'if they are long enough. For amoment a test did not gave significant differences This is required for ZEN2010
+Public ZENv As Integer            'String variable indicating the version of ZEN used 2010 ir 2011 (2012)
+Public ZEN As Object             'Object containing Zeiss.Micro.AIM.ApplicationInterface.ApplicationInterface (for ZEN > 2011)
 
+''''''''''''''''''''''
+'''GLOBAL VARIABLES'''
+''''''''''''''''''''''
 
-     
-Public Track As DsTrack
-Public TrackNumber As Integer
-Public TrackName As String
-Public Success As Integer
-Public IsAutofocusTrackSelected As Boolean
-Public AutofocusTrack As Integer ' number of AutofocusTrack
-Public IsAcquisitionTrackSelected As Boolean
-Public ActiveChannels() As String
-
-Public LocationName As String
-
-Public DoNotGoOn As Boolean
-Public ChangeFocus As Boolean
-Public FocusChanged As Boolean
-Public Try As Long
-Public SystemName As String
-          
-Public BackupRecording As DsRecording             ' To remove
-          
-Public GlobalBackupRecording As DsRecording       ' A backupRecording from initial setup (this will not be changed after Re_initialize)
-Public GlobalAutoFocusRecording As DsRecording    ' A global variable for AutofocusRecording
-Public GlobalAcquisitionRecording As DsRecording  ' A global variable for AcquisitionRecording
-Public GlobalMicropilotRecording As DsRecording   ' A global variable for Micropilot
-Public GlobalBleachRecording As DsRecording       ' A global variable for Bleaching
-
-Public GlobalAltRecording As DsRecording          ' A global variable for AlternativeTrack
-Public GlobalBackupActiveTracks() As Boolean
-
-
-Public GlobalBackupSampleObservationTime As Double  ' Stores pixelDwell time
-
-Public ImageNumber As Long
-Public Const OFS_MAXPATHNAME = 128
-Public Const OF_EXIST = &H4000
-Public flgBreak As Boolean
-Public Const WM_COMMAND = &H111
-
-Public tools As Lsm5Tools
-Public Stage As CpStages
-
-Public TileX As Integer
-Public TileY As Integer
-Public Overlap As Double
-
-Public AcquisitionController As AimAcquisitionController40.AimScanController  'Debugging 20110131
-Public RecordingDocpub As DsRecordingDoc
-
-
-'Grid positions
-Public posGridX() As Double ' they are initiated during acquisition
-Public posGridY() As Double ' they are initiated during acquisition
-Public posGridZ() As Double ' initiated during acquistion
-Public posGridXY_Valid() As Boolean ' they are initiated during acquisition
-
-Public posGridXsub() As Double ' they are initiated during acquisition
-Public posGridYsub() As Double ' they are initiated during acquisition
-Public posGridZsub() As Double ' initiated during acquistion
-Public posGridXYsub_valid() As Boolean ' they are initiated during acquisition
-
-' Counters for HighresImaging 'TODO remove global variables
-Public HighResExperimentCounter As Integer
-Public HighResCounter As Integer
-Public HighResArrayX() As Double ' this is an array of values why do you need to store values?
-Public HighResArrayY() As Double
-Public HighResArrayZ() As Double
-Public HighResArrayDeltaX() As Double ' width of acquisition in um. Default is as set from the main window 'not implemented yet (better to define ROIs)
-Public HighResArrayDeltaY() As Double ' width of acquisition in um. Default is as set from the main window 'not implemented yet (better to define ROIs)
-Public HighResArrayDeltaZ() As Double ' size of acquisition in um. Default is a set from the main window
-
-Public HelpNamePDF As String
-
-Public GlobalStageControlZValues As Boolean
-
-Public Type OFSTRUCT
-        cBytes As Byte
-        fFixedDisk As Byte
-        nErrCode As Integer
-        Reserved1 As Integer
-        Reserved2 As Integer
-        szPathName(OFS_MAXPATHNAME) As Byte
-End Type
-Public Type OVERLAPPED
-        Internal As Long
-        InternalHigh As Long
-        Offset As Long
-        OffsetHigh As Long
-        hEvent As Long
-End Type
-Public Type SECURITY_ATTRIBUTES
-        nLength As Long
-        lpSecurityDescriptor As Long
-        bInheritHandle As Long
-End Type
-
-
-Public Declare Function OpenFile Lib "kernel32" (ByVal lpFileName As String, lpReOpenBuff As OFSTRUCT, _
-ByVal wStyle As Long) As Long
-
-Public Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
-
-Public Declare Function DeleteFile Lib "kernel32" Alias "DeleteFileA" (ByVal lpFileName As String) As Long
-
-Public Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" _
-(ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, _
-lpNumberOfFreeClusters As Long, lpTotalNumberOfClusters As Long) As Long
+Public ScanStop As Boolean      'if TRUE current recording is stopped
+Public ScanPause As Boolean     'if TRUE current recording is paused
+Public Running As Boolean       'TRUE when system is running (e.g. after start)
+Public GlobalDataBaseName As String   'Name of output folder
+Public TrackNumber As Integer    'number of available tracks
 
-Public Declare Function GetTickCount Lib "kernel32" () As Long
+Public OverwriteFiles As Boolean  'if TRUE we do not overwrite files (not active anymore)
+Public FocusMapPresent As Boolean 'if TRUE we have a focus map (not active anymore)
+Public GlobalCorrectionOffset As Double 'not anymore used
 
+'''
+'RecordingDoc used globally for imaging
+'''
+Public GlobalRecordingDoc As DsRecordingDoc
+
+'''
+'FcsData used globally
+'''
+Public GlobalFcsData As AimFcsData
+'''
+'RecordingDoc used globally for Fcs
+'''
+Public GlobalFcsRecordingDoc As DsRecordingDoc
 
 
+Const PauseGrabbing = 50 'pause for polling the whether scan/fcscontroller are acquiring. A high value makes more errors!
 
-
-Public Sub DisplayProgress(State As String, Color As Long)       'Used to display in the progress bar what the macro is doing
-    If (Color & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Then
-        AutofocusForm.ProgressLabel.ForeColor = 0
-    Else
-        AutofocusForm.ProgressLabel.ForeColor = &HFFFFFF
+
+'''
+' Returns version number (ZEN2010, etc.)
+'''
+Public Function getVersionNr() As Integer
+    Dim VersionNr As Long
+    VersionNr = CLng(Left(Lsm5.Info.VersionIs, 1))
+    Select Case VersionNr
+        Case 6:
+            getVersionNr = 2010
+        Case 7:
+            getVersionNr = 2011
+        Case 8:
+            getVersionNr = 2012
+    End Select
+    
+    If VersionNr > 8 Then
+        MsgBox "Don't understand the version of ZEN used. Set to ZEN2012"
     End If
-    AutofocusForm.ProgressLabel.BackColor = Color
-    AutofocusForm.ProgressLabel.Caption = State
-    DoEvents
-End Sub
+End Function
+
+
 
 
 '''''
@@ -336,26 +110,17 @@ Public Function Range() As Double
     End If
 End Function
 
-
-
 ''''
-' TODO: Why not use Lsm5.StartScan?
+' Stop all running FCS jobs and imaging jobs
 ''''
-Public Sub ScanToImageOld(RecordingDoc As DsRecordingDoc) ' new routine to scan overwrite the same image, even with several z-slices
-   ' Dim AcquisitionController As AimAcquisitionController40.AimScanController 'now public
-    Dim image As AimImage
-    
-    If Not RecordingDoc Is Nothing Then
-        Set image = RecordingDoc.RecordingDocument.image(0, True)
-
-        If Not image Is Nothing Then
-            Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-            AcquisitionController.DestinationImage(0) = image
-            AcquisitionController.DestinationImage(1) = Nothing
-            AcquisitionController.StartGrab eGrabModeSingle
-        End If
+Public Sub StopAcquisition()
+    Lsm5.StopScan
+    If Lsm5.Info.IsFCS Then
+        Dim FcsControl As AimFcsController
+        Set FcsControl = Fcs
+        FcsControl.StopAcquisitionAndWait
     End If
-    
+    DoEvents
 End Sub
 
 '''''
@@ -363,34 +128,338 @@ End Sub
 '   scan overwrite the same image, even with several z-slices
 '''''
 Public Function ScanToImage(RecordingDoc As DsRecordingDoc) As Boolean
-
-    Dim ProgressFifo As IAimProgressFifo ' what is this?
-    Dim gui As Object, treenode As Object
-    'Set gui = Lsm5.ViewerGuiServer
-    If Not RecordingDoc Is Nothing Then
-        Set treenode = RecordingDoc.RecordingDocument.image(0, True)
-        'Set treenode = Lsm5.NewDocument why not this?
-        Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller ' public variable
-        AcquisitionController.DestinationImage(0) = treenode 'EngelImageToHechtImage(GlobalSingleImage).Image(0, True)
-        AcquisitionController.DestinationImage(1) = Nothing
-        Set ProgressFifo = AcquisitionController.DestinationImage(0)
-        Lsm5.tools.CheckLockControllers True
-        AcquisitionController.StartGrab eGrabModeSingle
-        'Set RecordingDoc = Lsm5.StartScan this does not overwrite
-        If Not ProgressFifo Is Nothing Then ProgressFifo.Append AcquisitionController
+    On Error GoTo ErrorHandle:
+    Dim ProgressFifo As IAimProgressFifo ' this shows how far you are with the acquisition image ( the blue bar at the bottom). The usage of it makes the macro quite slow
+    Dim AcquisitionController As AimScanController
+    Dim treenode As Object
+    Dim Time As Double
+    'Dim gui As Object
+    'Set gui = Lsm5.ViewerGuiServer not recquired anymore
+    
+    Time = Timer
+    If RecordingDoc Is Nothing Then
+        Exit Function
     End If
-    Sleep (200)
+    Set treenode = RecordingDoc.RecordingDocument.image(0, True)
+    'Set treenode = Lsm5.NewDocument this will create a new document we want to use the same document
+    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
+    AcquisitionController.DestinationImage(0) = treenode 'EngelImageToHechtImage(GlobalSingleImage).Image(0, True)
+    AcquisitionController.DestinationImage(1) = Nothing
+    Set ProgressFifo = AcquisitionController.DestinationImage(0)
+    Lsm5.tools.CheckLockControllers True
+    AcquisitionController.StartGrab eGrabModeSingle
+    'Set RecordingDoc = Lsm5.StartScan this does not overwrite
+    If Not ProgressFifo Is Nothing Then ProgressFifo.Append AcquisitionController
+    'Debug.Print "ScanToImage part1 " & Round(Timer - Time, 3)
+    Sleep (PauseGrabbing)
+    Time = Timer
     While AcquisitionController.IsGrabbing
-        Sleep (200) ' this sometimes hangs if we use GetInputState. Try now without it and test if it does not hang
+        Sleep (PauseGrabbing) ' the timing makes the different whether we release the system or not often enough. funny enough a small value is better
         DoEvents
         If ScanStop Then
             Exit Function
         End If
     Wend
+    'Debug.Print "ScanToImage properAcq " & Round(Timer - Time, 3)
     ScanToImage = True
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog ("Error in ScanToImage " & Err.Description)
+End Function
+
+''''
+' Start Fcs Measurment
+''''
+Public Function ScanToFcs(FcsData As AimFcsData) As Boolean
+    On Error GoTo ErrorHandle
+    Dim FcsControl As AimFcsController
+    Set FcsControl = Fcs
+    If FcsData Is Nothing Then
+      Exit Function
+    End If
+    FcsControl.StartMeasurement FcsData
+    Sleep (PauseGrabbing)
+    While FcsControl.IsAcquisitionRunning(1)
+        Sleep (PauseGrabbing)
+        If ScanStop Then
+            Exit Function
+        End If
+        DoEvents
+    Wend
+    ScanToFcs = True
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog ("Error in ScanToFcs " & Err.Description)
+End Function
+
+'''''
+'   Set the FCS controller and data stuff
+'''''
+Private Sub Initialize_Controller()
+    Set FcsControl = Fcs 'member of Lsm5VBAProject
+    Set viewerGuiServer = Lsm5.viewerGuiServer
+    Set FcsPositions = FcsControl.SamplePositionParameters
+    viewerGuiServer.FcsSelectLsmImagePositions = True
+End Sub
+
+'''''''''''''''''''''''''''''''''''''''''''
+''''''''' Creates NewRecords'''''''''''''''
+'''''''''''''''''''''''''''''''''''''''''''
+
+'''
+' Creates New DsRecordingDoc and a entry in the experiment Tree (works only with ZENv > 2010)
+'   RecordingDoc [In/Out] - A document. If it exists and ForceCreation = False then only the name will be changed
+'   Name                  - Name of the document (Tab-name)
+'   ForceCreation         - force creation of a new document and entry in the experiment tree
+''''
+Public Function NewRecord(RecordingDoc As DsRecordingDoc, Name As String, Optional ForceCreation As Boolean = False) As Boolean
+    
+    On Error GoTo ErrorHandle:
+    Dim node As AimExperimentTreeNode
+    If RecordingDoc Is Nothing Or ForceCreation Then
+        'for version > 2011 you could also specify containers this is not used here
+        'Set node = Lsm5.CreateObject("AimExperiment.TreeNode")
+        'node.type = eExperimentTeeeNodeTypeLsm
+        'viewerGuiServer.InsertExperimentTreeNode node, True, Container (this last option does not exist for ZEN<2011)
+        Set node = Lsm5.NewDocument
+        node.type = eExperimentTeeeNodeTypeLsm
+        Set RecordingDoc = Lsm5.DsRecordingActiveDocObject
+        While RecordingDoc.IsBusy
+            Sleep (Pause)
+            DoEvents
+        Wend
+    End If
+    RecordingDoc.SetTitle Name
+    NewRecord = True
+    Exit Function
+    
+ErrorHandle:
+    ErrorLog.UpdateLog " Error in NewRecord" + Err.Description
+    
+End Function
+
+
+
+''
+' Check if document exists and if it is loaded in the GUI. Otherwise creates a new one.
+''
+Public Function NewRecordGui(RecordingDoc As DsRecordingDoc, Name As String, ZEN As Object, ZENv As Integer) As Boolean
+
+    If ZENv > 2010 Then
+        NewRecordGui = NewRecordGuiAi(RecordingDoc, Name, ZEN)
+    Else
+        NewRecordGui = NewRecord(RecordingDoc, Name, False) ' no idea how to check the name of documents in ZENv < 2011
+    End If
+    
+End Function
+
+
+''''
+'  Check if Name exists in GUI
+'  recquires ZEN_Micro_AIM_ApplicationInterface
+''''
+Public Function NewRecordGuiAi(RecordingDoc As DsRecordingDoc, Name As String, ZEN As Object) As Boolean
+
+    On Error GoTo ErrorHandle
+    
+    If Not ZEN Is Nothing Then
+        If Not NewRecord(RecordingDoc, Name, False) Then
+            Exit Function
+        End If
+        'leave some time to set the name
+        Sleep (1000)
+        If ZEN.gui.Document.ItemCount > 0 Then
+            ZEN.gui.Document.ByName = Name
+            If ZEN.gui.Document.Name.Value <> Name Then
+                If Not NewRecord(RecordingDoc, Name, True) Then
+                    Exit Function
+                End If
+                ZEN.gui.Document.ByName = Name
+            End If
+        Else
+            If Not NewRecord(RecordingDoc, Name, True) Then
+                Exit Function
+            End If
+        End If
+        NewRecordGuiAi = True
+    Else
+        MsgBox "Error: NewRecordGuiAi. Tried to use ZEN_Micro_AIM_ApplicationInterface but no ZEN objet has been initialized"
+        ErrorLog.UpdateLog "Error: NewRecordGuiAi. Tried to use ZEN_Micro_AIM_ApplicationInterface but no ZEN objet has been initialized"
+    End If
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in NewRecordGuiAi " + Err.Description
+End Function
+
+
+
+''''
+'   Create a new FCSData record
+''''
+Public Function NewFcsRecord(RecordingDoc As DsRecordingDoc, FcsData As AimFcsData, Name As String, Optional ForceCreation As Boolean = False) As Boolean
+    Dim MaxDataSets As Integer
+    Dim i As Integer
+    On Error GoTo ErrorHandle:
+    Dim node As AimExperimentTreeNode
+    If FcsData Is Nothing Or RecordingDoc Is Nothing Or ForceCreation Then
+        'for version > 2011 you could also specify containers this is not used here
+        'Set viewerGuiServer = Lsm5.viewerGuiServer
+        'Set node = Lsm5.CreateObject("AimExperiment.TreeNode")
+        'node.type = eExperimentTeeeNodeTypeConfoCor
+        'viewerGuiServer.InsertExperimentTreeNode node, True, Container (this last option does not exist for ZEN<2011)
+        Set node = Lsm5.NewDocument
+        node.type = eExperimentTeeeNodeTypeConfoCor
+        Set FcsData = node.FcsData
+        FcsData.Name = Name
+        Set RecordingDoc = Lsm5.DsRecordingActiveDocObject
+        While RecordingDoc.IsBusy
+            Sleep (Pause)
+            DoEvents
+        Wend
+    End If
+
+    RecordingDoc.SetTitle Name
+    NewFcsRecord = True
+    Exit Function
+
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in NewFcsRecord " + Err.Description
+End Function
+
+'''
+' Remove all existing Data from FcsData. This is recquired if you want only to save new data
+'''
+Public Function CleanFcsData(RecordingDoc As DsRecordingDoc, FcsData As AimFcsData) As Boolean
+    Dim MaxDataSets As Integer
+    Dim i As Integer
+    If FcsData Is Nothing Or RecordingDoc Is Nothing Then
+        GoTo NoRecord
+    End If
+    MaxDataSets = FcsData.DataSets - 1
+    If MaxDataSets >= 0 Then
+        For i = MaxDataSets To 0 Step -1
+            FcsData.Remove (i)
+        Next i
+    End If
+    CleanFcsData = True
+    Exit Function
+NoRecord:
+    ErrorLog.UpdateLog "CleanFcsRecord: Found no active record for FCS!"
+End Function
+
+
+''
+' Check if document exists and if it is loaded in the GUI. Otherwise creates a new one.
+''
+Public Function NewFcsRecordGui(RecordingDoc As DsRecordingDoc, FcsData As AimFcsData, Name As String, ZEN As Object, ZENv As Integer) As Boolean
+
+    If ZENv > 2010 Then
+        NewFcsRecordGui = NewFcsRecordGuiAi(RecordingDoc, FcsData, Name, ZEN)
+    Else
+        NewFcsRecordGui = NewFcsRecord(RecordingDoc, FcsData, Name, False)  ' no idea how to check the name of documents in ZENv < 2011
+    End If
+    
+End Function
+
+
+''''
+'  Check if Name exists in GUI
+'  recquires ZEN_Micro_AIM_ApplicationInterface
+''''
+Public Function NewFcsRecordGuiAi(RecordingDoc As DsRecordingDoc, FcsData As AimFcsData, Name As String, ZEN As Object) As Boolean
+    
+    On Error GoTo ErrorHandle
+    
+    If Not ZEN Is Nothing Then
+        If Not NewFcsRecord(RecordingDoc, FcsData, Name, False) Then
+            Exit Function
+        End If
+        'leave some time to set the name
+        Sleep (1000)
+        If ZEN.gui.Document.ItemCount > 0 Then
+            ZEN.gui.Document.ByName = Name
+            If ZEN.gui.Document.Name.Value <> Name Then
+                If Not NewFcsRecord(RecordingDoc, FcsData, Name, True) Then
+                    Exit Function
+                End If
+                ZEN.gui.Document.ByName = Name
+            End If
+        Else
+            If Not NewFcsRecord(RecordingDoc, FcsData, Name, True) Then
+                Exit Function
+            End If
+        End If
+        NewFcsRecordGuiAi = True
+    Else
+        MsgBox "Error: NewFcsRecordGuiAi. Tried to use ZEN_Micro_AIM_ApplicationInterface but no ZEN objet has been initialized"
+        ErrorLog.UpdateLog "Error: NewFcsRecordGuiAi. Tried to use ZEN_Micro_AIM_ApplicationInterface but no ZEN objet has been initialized"
+    End If
+    Exit Function
+ErrorHandle:
+    ErrorLog.UpdateLog "Error in NewFcsRecordGuiAi " + Err.Description
+End Function
+
+''''
+' SaveFcsMeasurment to File
+''''
+Public Function SaveFcsMeasurement(FcsData As AimFcsData, FileName As String) As Boolean
+    
+    If FcsData Is Nothing Then
+        MsgBox "No Fcs Recording to Save"
+        Exit Function
+    End If
+    ' Write to file
+    Dim writer As AimFcsFileWrite
+    Set writer = Lsm5.CreateObject("AimFcsFile.Write")
+    writer.FileName = FileName
+    writer.FileWriteType = eFcsFileWriteTypeAll
+    writer.format = eFcsFileFormatConfoCor3WithRawData
+
+    writer.Source = FcsData
+    writer.Run
+    'write twice to be sure
+    If Not writer.DestinationFilesExist(FileName) Then
+        writer.FileName = FileName
+        writer.FileWriteType = eFcsFileWriteTypeAll
+        writer.format = eFcsFileFormatConfoCor3WithRawData
+        writer.Source = FcsData
+        writer.Run
+    Else
+        
+    End If
+    SaveFcsMeasurement = True
 End Function
 
+Public Sub SaveFcsPositionList(sFile As String, positionsPx() As Vector)
+    On Error GoTo ErrorHandle
+    Close
+    Dim iFileNum As Integer
+    Dim i As Long
+    Dim PosX As Double
+    Dim PosY As Double
+    Dim PosZ As Double
+    iFileNum = FreeFile()
+    Open sFile For Output As iFileNum
+    Print #iFileNum, "%X Y Z (um): ZEN Fcs position convention 0, 0  is center of image, Z is absolute coordinate"
+    For i = 0 To GetFcsPositionListLength - 1
+        GetFcsPosition PosX, PosY, PosZ, i
+        Print #iFileNum, Round(PosX * 1000000, PrecXY) & " " & Round(PosY * 1000000, PrecXY) & " " & Round(PosZ * 1000000, PrecXY)
+    Next i
+    On Error GoTo ErrorHandle2:
+    Print #iFileNum, "%X Y Z (px). Imaging convention 0,0,0 is upper left corner bottom slice"
+    For i = 0 To UBound(positionsPx)
+        Print #iFileNum, positionsPx(i).X & " " & positionsPx(i).Y & " " & positionsPx(i).Z
+    Next i
 
+    Close
+    Exit Sub
+ErrorHandle:
+    ErrorLog.UpdateLog "SaveFcsPositionList Can't write " & sFile & " for the FcsPositions"
+    Exit Sub
+ErrorHandle2:
+    Close
+    ErrorLog.UpdateLog "positionsPx not assigned"
+End Sub
 
 '''''
 '   SystemVersionOffset()
@@ -398,15 +467,11 @@ End Function
 '       [GlobalCorrectionOffset] Global Out - Offset added to shift in zStack
 '   TODO: Do we still need it. Only for Axioskop does the Offset change
 '''''
-Public Sub SystemVersionOffset(Optional tmp As Boolean) ' tmp is a hack to hide function from menu
+Public Sub SystemVersionOffset(Optional Tmp As Boolean) ' tmp is a hack to hide function from menu
     SystemVersion = Lsm5.Info.VersionIs
     If StrComp(SystemVersion, "2.8", vbBinaryCompare) >= 0 Then
         If Lsm5.Info.IsAxioskop Then
-            If AutofocusForm.AutofocusMaxSpeed Then
-                GlobalCorrectionOffset = 15
-            Else
-                GlobalCorrectionOffset = 1.2
-            End If
+
         ElseIf Lsm5.Info.IsAxioplan Then
             GlobalCorrectionOffset = 0
         ElseIf Lsm5.Info.IsAxioplan2 Then
@@ -424,11 +489,7 @@ Public Sub SystemVersionOffset(Optional tmp As Boolean) ' tmp is a hack to hide
         End If
     Else
         If Lsm5.Info.IsAxioskop Then
-            If AutofocusForm.AutofocusMaxSpeed Then
-                GlobalCorrectionOffset = 15
-            Else
-                GlobalCorrectionOffset = 1.2
-            End If
+
         ElseIf Lsm5.Info.IsAxioplan Then
             GlobalCorrectionOffset = 0
         ElseIf Lsm5.Info.IsAxioVert Then
@@ -439,120 +500,7 @@ Public Sub SystemVersionOffset(Optional tmp As Boolean) ' tmp is a hack to hide
     End If
 End Sub
 
-'''''''
-' Autofocus_StackShift ( NewPicture As DsRecordingDoc )
-' Performs image scan as in GlobalAutofocusRecording
-'       [NewPicture] In/Out - Contains the image
-'''''''
-Public Function Autofocus_StackShift(NewPicture As DsRecordingDoc) As Boolean
-    Dim pixelDwell As Double
-    Dim BigZStep As Double
-    Dim LogMsg As String
-    Dim Time As Double
-    Dim Cnt As Integer
-
-    
-    
-    DisplayProgress "Autofocus SetupScanWindow", RGB(0, &HC0, 0)
-    If NewPicture Is Nothing Then
-        Set NewPicture = Lsm5.NewScanWindow
-        While NewPicture.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    'Dim FramesPerStack As Double
-    'FramesPerStack = Lsm5.DsRecording.FramesPerStack
-    'Lsm5.DsRecording.FramesPerStack = 1
-    
-    'If Not ScanToImage(NewPicture) Then
-    '    Exit Function
-    'End If
-    
-    'Lsm5.DsRecording.FramesPerStack = FramesPerStack
-    
-    DisplayProgress "Autofocus: CheckZRange", RGB(0, &HC0, 0)
-    'checks again if Zranges are good
-    Time = Timer
-    If Not AutofocusForm.CheckZRanges() Then
-        Autofocus_StackShift = False
-        Exit Function
-    End If
-    LogMsg = "% Autofocus_stackshift: check Z-range " & Round(Timer - Time, 2)
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
- 
-    ''''''''''''''''''
-    '** Autofocus ***'
-    ''''''''''''''''''
-    
-    DisplayProgress "Autofocus reset Z-position", RGB(0, &HC0, 0)
-    If AutofocusForm.AutofocusHRZ Then
-        Lsm5.Hardware.CpHrz.Position = 0                ' center the piezo focus (or bring it down again ?)
-    End If
-    
-    Time = Timer
-    DisplayProgress "Autofocus acquire", RGB(0, &HC0, 0)
-    '''Check a last time that AF stack number and step is correct when in Fast Z-line mode
-    If (Not AutofocusForm.AutofocusHRZ.Value) And AutofocusForm.ScanLineToggle.Value And AutofocusForm.AutofocusFastZline.Value Then
-        If Lsm5.DsRecording.SpecialScanMode = "FocusStep" Then
-             DisplayProgress "Highest Z Step of 1.54 um with no piezo and Fast Z line has been reached. Autofocus uses slower Focus Step", RGB(&HC0, &HC0, 0)
-        End If
-        If AutofocusForm.AutofocusZStep.Value > Round(Lsm5.DsRecording.FrameSpacing, 3) Then
-            DisplayProgress "Autofocus acquire. Highest Z Step with no piezo and Fast Z line " + CStr(Round(Lsm5.DsRecording.FrameSpacing, 3)) + " um. Autofocus uses slower Focus Step", RGB(&HC0, &HC0, 0)
-            Lsm5.DsRecording.SpecialScanMode = "FocusStep"
-            Lsm5.DsRecording.FrameSpacing = AutofocusForm.AutofocusZStep.Value
-        End If
-    End If
-    
-    Time = Timer
-    If Not ScanToImage(NewPicture) Then
-        Exit Function
-    End If
-    
-    LogMsg = "% Autofocus_stackshift: acquire time " & Round(Timer - Time, 2)
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-
-    Autofocus_StackShift = True
 
-End Function
-
-
-'''''''
-'   ComputeShiftedCoordinates(XMass, ....)
-'   Calculates new coordinates after translation
-'       [XMass], [YMass], [ZMass]    In - Translation vector
-'       [x], [y], [z] Out - Shifted coordinates. Depends on stage build up and actual position. Positions are rounded up to PrecXY and PrecZ
-''''''
-Public Function ComputeShiftedCoordinates(ByVal XMass As Double, ByVal YMass As Double, ByVal ZMass As Double, ByRef X As Double, ByRef Y As Double, ByRef Z As Double)
-    Dim Xpre As Integer
-    Dim Ypre As Integer
-    
-    If MirrorX Then
-        Xpre = -1
-    Else
-        Xpre = 1
-    End If
-    
-    If MirrorY Then
-        Ypre = -1
-    Else
-        Ypre = 1
-    End If
-    
-    If ExchangeXY Then ' not sure about this
-        X = X + Xpre * YMass
-        Y = Y + Ypre * XMass
-    Else
-        X = X + Xpre * XMass
-        Y = Y + Ypre * YMass
-    End If
-        
-    Z = Z + ZMass
-    X = Round(X, PrecXY)
-    Y = Round(Y, PrecXY)
-    Z = Round(Z, PrecZ)
-End Function
 
 ''''' ' this should move to function
 '   FailSafeMoveStage(Optional Mark As Integer = 0)
@@ -591,7 +539,7 @@ End Function
 Public Function FailSafeMoveStageZ(Z As Double) As Boolean
     FailSafeMoveStageZ = False
     If ZBacklash <> 0 Then
-        Lsm5.Hardware.CpFocus.Position = Z - ZBacklash ' move at correct position
+        Lsm5.Hardware.CpFocus.position = Z - ZBacklash ' move at correct position
         Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy Or Lsm5.Hardware.CpFocus.IsBusy
             Sleep (20)
             If GetInputState() <> 0 Then
@@ -603,7 +551,7 @@ Public Function FailSafeMoveStageZ(Z As Double) As Boolean
             End If
         Loop
     End If
-    Lsm5.Hardware.CpFocus.Position = Z  ' move at correct position
+    Lsm5.Hardware.CpFocus.position = Z  ' move at correct position
     Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy Or Lsm5.Hardware.CpFocus.IsBusy
         Sleep (20)
         If GetInputState() <> 0 Then
@@ -618,71 +566,6 @@ Public Function FailSafeMoveStageZ(Z As Double) As Boolean
     FailSafeMoveStageZ = True
 End Function
 
-''''''
-'   Autofocus_MoveAcquisition
-'   Move stage and Z. To Z a ZOffset from the Autofocusform is added
-'       [XShift] In
-'       [YShift] In
-'       [ZShift] In
-''''''
-Public Function Autofocus_MoveAcquisition(XShift As Double, YShift As Double, ZShift As Double, ZOffset As Double) As Boolean
-    
-    Dim ZFocus As Double
-    Dim Zbefore As Double
-    Dim X As Double
-    Dim Y As Double
-        
-    '''''''''''''''''''''''''''''''''''''''
-    ' Moving to the correct position in Z
-    ' Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-    ZFocus = Lsm5.Hardware.CpFocus.Position + ZOffset + ZShift
-    ' Why do you need to move downward first ? Todo check if recquired step
-    Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash     'Moves down -50uM (ZBacklash) with the focus wheel
-    Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-        Sleep (20)
-        DoEvents
-    Loop
-    Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-    Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-        Sleep (20)
-        DoEvents
-    Loop
-    
-    ' Todo: one might add a lot of controls here, to wait to be sure the focus wheel can acces the position, and also to wait it is done...
-    Sleep (100)
-    DoEvents
-   
-    'This is moving the x and y position
-    'This we want only to do when xy-focus is set
-    'Moving to the correct position in X and Y
-    If AutofocusForm.ScanFrameToggle Then
-        ' Todo: check whether it moves in the correct direction
-        If AutofocusForm.AutofocusTrackXY Then
-            X = Lsm5.Hardware.CpStages.PositionX - XShift
-            Y = Lsm5.Hardware.CpStages.PositionY - YShift
-            Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(X, Y)
-        End If
-         
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            If ScanStop Then
-                Lsm5.StopScan
-                AutofocusForm.StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Autofocus_MoveAcquisition = False
-                Exit Function
-            End If
-            DoEvents
-            Sleep (5)
-        Loop
-    
-    End If
-    
-    ' center all z-stacks again!
-    Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * Lsm5.DsRecording.FramesPerStack / 2
-    
-    Autofocus_MoveAcquisition = True
-    
-End Function
 
 '''''
 '   MoveToNextLocation(Optional Mark As Integer = 0)
@@ -690,7 +573,7 @@ End Function
 '   Default will cycle through all positions sequentially starting from actual position
 '       [Mark] In - Number of position where to move.
 '''''
-Public Sub MoveToNextLocation(Optional Mark As Integer = 0)
+Public Function MoveToNextLocation(Optional Mark As Integer = 0) As Boolean
         Dim MarkCount As Long
         Dim count As Long
         Dim idx As Long
@@ -707,48 +590,27 @@ Public Sub MoveToNextLocation(Optional Mark As Integer = 0)
             If GetInputState() <> 0 Then
                 DoEvents
                 If ScanStop Then
-                    AutofocusForm.StopAcquisition
-                    Exit Sub
+                    Exit Function
                 End If
             End If
         Loop
-End Sub
+        MoveToNextLocation = True
+End Function
 
 
-Private Sub MovetoCorrectZPosition(ZOffset As Double)
-Const ZBacklash = -50
-Dim ZFocus As Double
-Dim Zbefore As Double
-Dim X As Double
-Dim Y As Double
-     ZFocus = Lsm5.Hardware.CpFocus.Position + ZOffset + ZShift
-       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash    'Moves down -50uM (ZBacklash) with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the AutofocusForm.AutofocusHRZ.Value can acces the position, and also to wait it is done...
-        Sleep (100)
-        DoEvents
-End Sub
 
 
 ''''
 '   WaitForRecentering(Z As Double, Success As Boolean) As Boolean
 '   calls the microscope specific WaitForRecentering
 '''
-Public Function WaitForRecentering(Z As Double, Optional Success As Boolean = False, Optional ZEN As Integer = 2011) As Boolean
-    If ZEN = 2010 Then
+Public Function WaitForRecentering(Z As Double, Optional Success As Boolean = False, Optional ZENv As Integer = 2011) As Boolean
+    If ZENv = 2010 Then
         If Not WaitForRecentering2010(Z, Success) Then
             Exit Function
         End If
     End If
-    If ZEN > 2010 Then
+    If ZENv > 2010 Then
         If Not WaitForRecentering2011(Z, Success) Then
             Exit Function
         End If
@@ -775,7 +637,8 @@ Public Function WaitForRecentering2010(Z As Double, Optional Success As Boolean
     ' this waits for central slice at Z
     Dim pos As Double
     Dim Sample0Z As Double
-    pos = Lsm5.Hardware.CpFocus.Position
+    pos = Lsm5.Hardware.CpFocus.position
+    'in this case stage has bene moved
     If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or Lsm5.DsRecording.SpecialScanMode = "ZScanner" Then
         While Round(pos, 1) <> Round(Z, 1) And Cnt < MaxCnt
             Sleep (400)
@@ -786,7 +649,7 @@ Public Function WaitForRecentering2010(Z As Double, Optional Success As Boolean
             End If
         Wend
         If Cnt = MaxCnt Then
-            Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 + pos - Z
+            Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.frameSpacing * (Lsm5.DsRecording.framesPerStack - 1) / 2 + pos - Z
             If Not FailSafeMoveStageZ(Z) Then
                 Exit Function
             End If
@@ -802,7 +665,7 @@ Public Function WaitForRecentering2010(Z As Double, Optional Success As Boolean
 '            End If
 '        Wend
     Else
-        While Round(Lsm5.DsRecording.Sample0Z, 1) <> Round(Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 + _
+        While Round(Lsm5.DsRecording.Sample0Z, 1) <> Round(Lsm5.DsRecording.frameSpacing * (Lsm5.DsRecording.framesPerStack - 1) / 2 + _
             pos - Z, 1) And Cnt < MaxCnt
             Sleep (400)
             DoEvents
@@ -812,7 +675,7 @@ Public Function WaitForRecentering2010(Z As Double, Optional Success As Boolean
             End If
         Wend
         If Cnt = MaxCnt Then
-            Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 + pos - Z
+            Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.frameSpacing * (Lsm5.DsRecording.framesPerStack - 1) / 2 + pos - Z
             GoTo FailedWaiting
         End If
     End If
@@ -844,7 +707,7 @@ Public Function WaitForRecentering2011(Z As Double, Optional Success As Boolean
     ' this waits for central slice at Z
     Dim pos As Double
     Dim Sample0Z As Double
-    pos = Lsm5.Hardware.CpFocus.Position
+    pos = Lsm5.Hardware.CpFocus.position
     If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or Lsm5.DsRecording.SpecialScanMode = "ZScanner" Then
         While Round(pos, 1) <> Round(Z, 1) And Cnt < MaxCnt
             Sleep (400)
@@ -856,7 +719,7 @@ Public Function WaitForRecentering2011(Z As Double, Optional Success As Boolean
         Wend
         
         If Cnt = MaxCnt Then
-            Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 + pos - Z
+            Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.frameSpacing * (Lsm5.DsRecording.framesPerStack - 1) / 2 + pos - Z
             If Not FailSafeMoveStageZ(Z) Then
                 Exit Function
             End If
@@ -865,7 +728,7 @@ Public Function WaitForRecentering2011(Z As Double, Optional Success As Boolean
         
     Else
     
-        While Round(Lsm5.DsRecording.Sample0Z, 1) <> Round(Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 + _
+        While Round(Lsm5.DsRecording.Sample0Z, 1) <> Round(Lsm5.DsRecording.frameSpacing * (Lsm5.DsRecording.framesPerStack - 1) / 2 + _
             pos - Z, 1) And Cnt < MaxCnt
             Sleep (400)
             DoEvents
@@ -877,7 +740,7 @@ Public Function WaitForRecentering2011(Z As Double, Optional Success As Boolean
         
         If Cnt = MaxCnt Then
             Success = False
-            Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 + pos - Z
+            Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.frameSpacing * (Lsm5.DsRecording.framesPerStack - 1) / 2 + pos - Z
             GoTo FailedWaiting
         End If
     End If
@@ -897,11 +760,11 @@ End Function
 '       [Z]     - Absolute position of central slice
 '   position central slice is Z = Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + Lsm5.Hardware.CpFocus.Position
 ''''
-Public Function Recenter_pre(Z As Double, Optional Success As Boolean = False, Optional ZEN As Integer = 2011) As Boolean
-    If Not Recenter(Z, ZEN) Then
+Public Function Recenter_pre(Z As Double, Optional Success As Boolean = False, Optional ZENv As Integer = 2011) As Boolean
+    If Not Recenter(Z, ZENv) Then
         Exit Function
     End If
-    If Not WaitForRecentering(Z, Success, ZEN) Then
+    If Not WaitForRecentering(Z, Success, ZENv) Then
         Exit Function
     End If
     If Not ScanStop Then
@@ -909,8 +772,8 @@ Public Function Recenter_pre(Z As Double, Optional Success As Boolean = False, O
     End If
 End Function
 
-Public Function Recenter_post(Z As Double, Optional Success As Boolean = False, Optional ZEN As Integer = 2011) As Boolean
-    If Not WaitForRecentering(Z, Success, ZEN) Then
+Public Function Recenter_post(Z As Double, Optional Success As Boolean = False, Optional ZENv As Integer = 2011) As Boolean
+    If Not WaitForRecentering(Z, Success, ZENv) Then
         Exit Function
     End If
     
@@ -919,9 +782,9 @@ Public Function Recenter_post(Z As Double, Optional Success As Boolean = False,
     End If
 End Function
 
-Public Function Recenter(Z As Double, Optional ZEN As Integer = 2011) As Boolean
+Public Function Recenter(Z As Double, Optional ZENv As Integer = 2011) As Boolean
     Dim i As Integer
-    If ZEN = 2010 Then
+    If ZENv = 2010 Then
         For i = 1 To 1
             If Not Recenter2010(Z) Then
                 Exit Function
@@ -929,7 +792,7 @@ Public Function Recenter(Z As Double, Optional ZEN As Integer = 2011) As Boolean
             Sleep (200)
         Next i
     End If
-    If ZEN > 2010 Then
+    If ZENv > 2010 Then
         If Not Recenter2011(Z) Then
             Exit Function
         End If
@@ -941,15 +804,15 @@ Public Function Recenter2010(Z As Double) As Boolean
     Dim MoveStage As Boolean
     Dim pos As Double
     Dim Sample0Z As Double
-    pos = Lsm5.Hardware.CpFocus.Position
+    pos = Lsm5.Hardware.CpFocus.position
     MoveStage = True ' this is the only difference to 2011 version
     
     If Lsm5.DsRecording.SpecialScanMode = "ZScanner" Or (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Then
         MoveStage = True
     End If
-    Dim tmp As Integer
+    Dim Tmp As Integer
     
-    Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 + pos - Z
+    Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.frameSpacing * (Lsm5.DsRecording.framesPerStack - 1) / 2 + pos - Z
     Sleep (100)
     DoEvents
     If MoveStage Then
@@ -965,9 +828,9 @@ End Function
 
 Public Function Recenter2011(Z As Double) As Boolean
     Dim MoveStage As Boolean
-    Dim FramesPerStack As Integer
+    Dim framesPerStack As Integer
     Dim pos As Double
-    pos = Lsm5.Hardware.CpFocus.Position
+    pos = Lsm5.Hardware.CpFocus.position
     MoveStage = False 'only move stage when required
     
     If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or Lsm5.DsRecording.SpecialScanMode = "ZScanner" Then
@@ -975,7 +838,7 @@ Public Function Recenter2011(Z As Double) As Boolean
     End If
         
     'Center slide
-    Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 + pos - Z
+    Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.frameSpacing * (Lsm5.DsRecording.framesPerStack - 1) / 2 + pos - Z
     Sleep (100)
     DoEvents
     If MoveStage Then
@@ -986,283 +849,44 @@ Public Function Recenter2011(Z As Double) As Boolean
         End If
     End If
     DoEvents
+    'this messes around with the slice number. Don't use it
+    'ZEN.gui.Acquisition.ZStack.CenterPositionZ.Value = Z
+
     Recenter2011 = True
 End Function
 
-''''
-'   Autofocus_MoveAcquisition_HRZ(ZOffset As Double)
-'   Allow to use HRZ for Move Z-stage (not used at the moment)
-''''
-Public Sub Autofocus_MoveAcquisition_HRZ(ZOffset As Double)
-    Dim NoZStack As Boolean
-    Const ZBacklash = -50
-    Dim ZFocus As Double
-    Dim Zbefore As Double
-    Dim X As Double
-    Dim Y As Double
-
-    AutofocusForm.RestoreAcquisitionParameters
-    
-    Set GlobalBackupRecording = Nothing
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    
-    NoZStack = True
-    If GlobalAcquisitionRecording.ScanMode = "ZScan" Or GlobalAcquisitionRecording.ScanMode = "Stack" Then  'Looks if a Z-Stack is going to be acquired
-        NoZStack = False
-    End If
 
-    'Moving to the correct position in Z
-    If AutofocusForm.AutofocusHRZ.Value And NoZStack Then                                            'If using HRZ for autofocusing and there is no Zstack for image acquisition
-        Lsm5.Hardware.CpHrz.Stepsize = 0.2
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-        DoEvents
-     '   ZFocus = Lsm5.Hardware.CpHrz.Position + ZShift - ZOffset
-     
-     'Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-  
-        ZFocus = Lsm5.Hardware.CpHrz.Position + ZOffset + ZShift
-       
-        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-        
-        DoEvents
-
-    Else                                        'either there is a Z stack for image acquisition or we're using the focuswheel for autofocussing
-        If AutofocusForm.AutofocusHRZ.Value Then                             ' Now I'm not sure with the signs and... I some point I just tried random combinations...
-            ZFocus = Lsm5.Hardware.CpHrz.Position - ZOffset - ZShift '         'ZBefore corresponds to the position where the focuswheel was before doing anything. Zshift is the calculated shift
-        Else                                    'If the HRZ is not calibrated the Z shift might be wrong
-            ZFocus = Zbefore + ZShift
-        End If
-       
-        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-    End If
 
-    'Moving to the correct position in X and Y
- 
-    If AutofocusForm.ScanFrameToggle Then
-        If AutofocusForm.AutofocusTrackXY Then
-            X = Lsm5.Hardware.CpStages.PositionX - XShift  'the fact that it is "-" in this line and "+" in the next line  probably has to do with where the XY of the origin is set (top right corner and not botom left, I think)
-            Y = Lsm5.Hardware.CpStages.PositionY - YShift
-            Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(X, Y)
-        End If
-         
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            If ScanStop Then
-                Lsm5.StopScan
-                AutofocusForm.StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-            DoEvents
-            Sleep (5)
-        Loop
-    End If
-    
 
-    DisplayProgress "Autofocus 14", RGB(0, &HC0, 0)
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    DisplayProgress "Autofocus 15", RGB(0, &HC0, 0)
-End Sub
 
 
 
-'''''
-'   MakeGrid( posGridX() As Double, posGridY() As Double, posGridXY_valid() )
-'   Create a grid
-'       [posGridX] In/Out - Array where X grid positions are stored
-'       [posGridY] In/Out - Array where Y grid positions are stored
-'       [posGridXY_valid] In/Out - Array that says if position is valid
-'       [locationNumbersMainGrid] In/Out - location number on main grid
-'''''
-Public Sub MakeGrid(posGridX() As Double, posGridY() As Double, posGridZ() As Double, XStart As Double, YStart As Double, ZStart As Double, dX As Double, dY As Double, dXsub As Double, dYsub As Double, refCol As Integer, refRow As Integer)
-        ' A row correspond to Y movement and Column to X shift
-        ' entries are posGridX(row, column)!! this what is
-        'counters
-        'Make main grid
-        Dim iRow As Long
-        Dim iCol As Long
-        Dim iRowSub As Long
-        Dim iColSub As Long
-        'Make grid and subgrid
-        For iRow = 1 To UBound(posGridX, 1)
-            For iCol = 1 To UBound(posGridX, 2)
-                For iRowSub = 1 To UBound(posGridX, 3)
-                    For iColSub = 1 To UBound(posGridX, 4)
-                        posGridX(iRow, iCol, iRowSub, iColSub) = Round(XStart + (1 - refCol) * dX + (iCol - 1) * dX + (iColSub - 1 - (UBound(posGridX, 4) - 1) / 2) * dXsub, PrecXY)
-                        posGridY(iRow, iCol, iRowSub, iColSub) = Round(YStart + (1 - refRow) * dY + (iRow - 1) * dY + (iRowSub - 1 - (UBound(posGridX, 3) - 1) / 2) * dYsub, PrecXY)
-                        posGridZ(iRow, iCol, iRowSub, iColSub) = Round(ZStart, PrecZ)
-                    Next iColSub
-                Next iRowSub
-            Next iCol
-        Next iRow
-End Sub
-
-Public Function isValidGridDefault(ByVal sFile As String) As Boolean
-    Dim CellBase As String
-    Dim Default As String
-    Dim last_entry  As String
-    Dim Active As Boolean
-    Dim GoodMatch As Boolean
-    Dim RegEx As VBScript_RegExp_55.RegExp
-    Set RegEx = CreateObject("vbscript.regexp")
-    Dim Match As MatchCollection
-    'Well--Row--Col--(Row,Col)--TypeofWell
-    CellBase = "(\d+)--(\d+)--(\d+)--(\S+)--(\S+)"
-    'valid Row--Col
-    Default = "(\d+) (\d+)--(\d+)"
-    If FileExist(sFile) Then
-        Close
-        Dim iFileNum As Integer
-        Dim Fields As String
-        Dim FieldEntries() As String
-        iFileNum = FreeFile()
-        Open sFile For Input As iFileNum
-        Do While Not EOF(iFileNum)
-            On Error GoTo ErrorHandle:
-            Line Input #iFileNum, Fields
-            GoodMatch = False
-            RegEx.Pattern = Default
-            If RegEx.test(Fields) Then
-                Set Match = RegEx.Execute(Fields)
-                Active = (Match.Item(0).SubMatches.Item(0) = "1")
-                GoodMatch = True
-            Else
-                RegEx.Pattern = CellBase
-                If RegEx.test(Fields) Then
-                    Set Match = RegEx.Execute(Fields)
-                    Active = (Match.Item(0).SubMatches.Item(4) <> "empty")
-                    GoodMatch = True
-                Else
-                    MsgBox "validGridDefault.txt has not the correct format! " & vbCrLf & "The format should be " & vbCrLf & "(In)active(0 or 1) Row(>=1)--Col(>=1) e.g." & vbCrLf & "0 1--1" & vbCrLf & "1 1--2" & vbCrLf _
-                    & "or CellBase format Well--Row--Col--(Row,Col)--Identifier Identifier = empty=> InactiveWell e.g." & vbCrLf & "1--2--1--(1,1)--empty" & vbCrLf _
-                    & "1--1--2--(1,2)--MyCoolGene"
-                    Exit Function
-                End If
-            End If
-        Loop
-        isValidGridDefault = True
-    Else
-        MsgBox " File validGridDefault.txt needs to be in the output folder"
-    End If
-    Exit Function
-ErrorHandle:
-    MsgBox " Could not load validGridDefault.txt"
-End Function
 
+''''
+' Compute the centerofmass of image stored in RecordingDoc return values according
+'   Use channel with name TrackingChannel
+''''
+Public Function MassCenter(RecordingDoc As DsRecordingDoc, TrackingChannel As String) As Vector
 
-'''''
-'   MakeValidGrid( posGridX() As Double, posGridY() As Double, posGridXY_valid() )
-'   Create a grid
-'       [posGridX] In/Out - Array where X grid positions are stored
-'       [posGridY] In/Out - Array where Y grid positions are stored
-'       [posGridXY_valid] In/Out - Array that says if position is valid
-'       [locationNumbersMainGrid] In/Out - location number on main grid
-'''''
-Public Sub MakeValidGrid(posGridXY_Valid() As Boolean, Optional ByVal sFile As String)
-    ' A row correspond to Y movement and Column to X shift
-    ' entries are posGridX(row, column)!! this what is
-    ' counters
-    ' Make main grid
-    Dim CellBase As String
-    Dim Default As String
-    Dim last_entry  As String
-    Dim Active As Boolean
-    Dim GoodMatch As Boolean
-    'Well--Row--Col--(Row,Col)--TypeofWell
-    CellBase = "(\d+)\-\-(\d+)\-\-(\d+)\-\-(\S+)\-\-(\S+)"
-    'valid Row--Col
-    Default = "(\d+) (\d+)\-\-(\d+)"
-    Dim iRow As Long
-    Dim iCol As Long
-    Dim iRowSub As Long
-    Dim iColSub As Long
+    On Error GoTo ErrorHandle:
     Dim RegEx As VBScript_RegExp_55.RegExp
     Set RegEx = CreateObject("vbscript.regexp")
     Dim Match As MatchCollection
-    Dim Rec As DsRecordingDoc
-    Dim FoundChannel As Boolean
-    FoundChannel = False
     
-    ' All points are true as default
-    'Make grid and subgrid
-    For iRow = 1 To UBound(posGridXY_Valid, 1)
-        For iCol = 1 To UBound(posGridXY_Valid, 2)
-            For iRowSub = 1 To UBound(posGridXY_Valid, 3)
-                For iColSub = 1 To UBound(posGridXY_Valid, 4)
-                    posGridXY_Valid(iRow, iCol, iRowSub, iColSub) = True
-                Next iColSub
-            Next iRowSub
-        Next iCol
-    Next iRow
-    
-    'File is either a Cellbase file or a series of 1 and zeros vertically ordered
-    If sFile <> "" And FileExist(sFile) Then
-        Close
-        On Error GoTo ErrorHandle
-        Dim iFileNum As Integer
-        Dim Fields As String
-        Dim FieldEntries() As String
-        iFileNum = FreeFile()
-        Open sFile For Input As iFileNum
-        ' Go till end of file and fill the grid validity
-        Do While Not EOF(iFileNum)
-            On Error GoTo ErrorHandle:
-            Line Input #iFileNum, Fields
-            GoodMatch = False
-            RegEx.Pattern = Default
-            If RegEx.test(Fields) Then
-                Set Match = RegEx.Execute(Fields)
-                Active = (Match.Item(0).SubMatches.Item(0) = "1")
-                GoodMatch = True
-            Else
-                RegEx.Pattern = CellBase
-                If RegEx.test(Fields) Then
-                    Set Match = RegEx.Execute(Fields)
-                    Active = (Match.Item(0).SubMatches.Item(4) <> "empty")
-                    GoodMatch = True
-                End If
-            End If
-            'if this gridposition exists then update activity
-            If GoodMatch And CInt(Match.Item(0).SubMatches.Item(1)) <= UBound(posGridXY_Valid, 1) And CInt(Match.Item(0).SubMatches.Item(1)) >= LBound(posGridXY_Valid, 1) _
-            And CInt(Match.Item(0).SubMatches.Item(2)) <= UBound(posGridXY_Valid, 2) And CInt(Match.Item(0).SubMatches.Item(2)) >= LBound(posGridXY_Valid, 2) Then
-                For iRowSub = 1 To UBound(posGridXY_Valid, 3)
-                    For iColSub = 1 To UBound(posGridXY_Valid, 4)
-                        posGridXY_Valid(CInt(Match.Item(0).SubMatches.Item(1)), CInt(Match.Item(0).SubMatches.Item(2)), iRowSub, iColSub) = Active
-                    Next iColSub
-                Next iRowSub
-            End If
-        Loop
-    End If
-    Exit Sub
-ErrorHandle:
-    MsgBox "MakeValidGrid error!"
-End Sub
-
-
-Public Sub MassCenter(RecordingDoc As DsRecordingDoc, XMass As Double, YMass As Double, ZMass As Double, Context As String)
     Dim scrline As Variant
     Dim spl As Long
     Dim bpp As Long
     Dim ColMax As Long
     Dim LineMax As Long
-    Dim FrameNumber As Integer
-    Dim PixelSize As Double
-    Dim FrameSpacing As Double
-    Dim Intline() As Long
-    Dim IntCol() As Long
-    Dim IntFrame() As Long
+    Dim FrameMax As Integer
+    Dim pixelSize As Double
+    Dim frameSpacing As Double
+    Dim IntLine() As Variant
+    Dim IntCol() As Variant
+    Dim IntFrame() As Variant
+    
     Dim channel As Integer
-    Dim frame As Long
+    Dim Frame As Long
     Dim Line As Long
     Dim Col As Long
     Dim MinColValue As Single
@@ -1287,245 +911,113 @@ Public Sub MassCenter(RecordingDoc As DsRecordingDoc, XMass As Double, YMass As
     Dim FrameValue As Single
     
    
-    'Lsm5Vba.Application.ThrowEvent eRootReuse, 0                   'Was there in the initial Zeiss macro, but it seems notnecessary
     DoEvents
-    'Gets the dimensions of the image in X (Columns), Y (lines) and Z (Frames)
-    If AutofocusForm.ScanFrameToggle And SystemName = "LIVE" Then ' binning only with LIVE device
-        ColMax = RecordingDoc.Recording.RtRegionWidth '/ Lsm5.DsRecordingActiveDocObject.Recording.RtBinning
-        LineMax = RecordingDoc.Recording.RtRegionHeight
-    Else
-        If SystemName = "LIVE" Then
-            ColMax = RecordingDoc.Recording.RtRegionWidth
-            LineMax = RecordingDoc.Recording.RtRegionHeight
-        ElseIf SystemName = "LSM" Then
-            ColMax = RecordingDoc.Recording.SamplesPerLine
-            LineMax = RecordingDoc.Recording.LinesPerFrame
-        Else
-            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-            Exit Sub
-        End If
-    End If
     
-    If RecordingDoc.Recording.ScanMode = "ZScan" Or RecordingDoc.Recording.ScanMode = "Stack" Then
-        FrameNumber = RecordingDoc.Recording.FramesPerStack
-    Else
-        FrameNumber = 1
-    End If
-    'Gets the pixel size
-    PixelSize = RecordingDoc.Recording.SampleSpacing * 1000000
-    'Gets the distance between frames in Z
-    FrameSpacing = RecordingDoc.Recording.FrameSpacing
     
-    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
-    ReDim Intline(LineMax) As Long
-    ReDim IntCol(ColMax) As Long
-    ReDim IntFrame(FrameNumber) As Long
-
-    'Select the image channel on which to do the calculations
-    If Context = "Autofocus" Then       'Takes the first channel in the context of preacquisition focussing
-        channel = 0
-    ElseIf Context = "Tracking" Then    'Takes the channel selected in the pop-up menu when doing postacquisition tracking
-        Dim RegEx As VBScript_RegExp_55.RegExp
-        Set RegEx = CreateObject("vbscript.regexp")
-        Dim Match As MatchCollection
-        Dim Rec As DsRecordingDoc
-        Dim FoundChannel As Boolean
-        FoundChannel = False
-        RegEx.Pattern = "(\w+\d+)-(\w+)"
-        Dim name_channel As String
-        If RegEx.test(TrackingChannelString) Then
-            Set Match = RegEx.Execute(TrackingChannelString)
-            name_channel = Match.Item(0).SubMatches.Item(0)
+    'Find the channel to track
+    Dim Rec As DsRecordingDoc
+    Dim FoundChannel As Boolean
+    FoundChannel = False
+    RegEx.Pattern = "(\w+) (\w+\d+-\w+\d+)"
+    Dim name_channel As String
+    If RegEx.Test(TrackingChannel) Then
+        Set Match = RegEx.Execute(TrackingChannel)
+        name_channel = Match.Item(0).SubMatches.Item(1)
+    End If
+    Dim name_channelA() As String
+    name_channelA = Split(name_channel, "-")
+    For channel = 0 To RecordingDoc.GetDimensionChannels - 1
+        Debug.Print "Channel Names " & RecordingDoc.ChannelName(channel)
+        If RecordingDoc.ChannelName(channel) = name_channelA(0) & "-" & name_channelA(1) Then ' old Code: Left(TrackingChannel,4)
+            FoundChannel = True
+            Exit For
         End If
-        
-        For channel = 0 To RecordingDoc.GetDimensionChannels - 1
-            If RecordingDoc.ChannelName(channel) = name_channel Then ' old Code: Left(TrackingChannel,4)
+    Next channel
+    
+    If Not FoundChannel Then
+        For channel = 0 To RecordingDoc.GetDimensionChannels - 1 ' this is true when only one track is acquired
+            If RecordingDoc.ChannelName(channel) = name_channelA(0) Then ' old Code: Left(TrackingChannel,4)
                 FoundChannel = True
                 Exit For
             End If
         Next channel
-        
-        If Not FoundChannel Then
-            MsgBox (" Was not able to find channel for tracking!!")
-            Exit Sub
-        End If
     End If
     
-    'Tracking is not the correct word. It just does center of mass on an additional channel
-    'Reads the pixel values and fills the tables with the projected (integrated) pixels values in the three directions
-    For frame = 1 To FrameNumber
-        For Line = 1 To LineMax
-            bpp = 0
-            'channel = 0: This will allow to do the tracking on a different channel
-            scrline = RecordingDoc.ScanLine(channel, 0, frame - 1, Line - 1, spl, bpp) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-            For Col = 2 To ColMax               'Now I'm scanning all the pixels in the line
-                Intline(Line - 1) = Intline(Line - 1) + scrline(Col - 1)
-                IntCol(Col - 1) = IntCol(Col - 1) + scrline(Col - 1)
-                IntFrame(frame - 1) = IntFrame(frame - 1) + scrline(Col - 1)
-            Next Col
-        Next Line
-    Next frame
-    'First it finds the minimum and maximum porjected (integrated) pixel values in the 3 dimensions
-    MinColValue = 4095 * LineMax * FrameNumber          'The maximum values are initially set to the maximum possible value
-    minLineValue = 4095 * ColMax * FrameNumber
-    minFrameValue = 4095 * LineMax * ColMax
-    MaxColValue = 0                                     'The maximun values are initialliy set to 0
-    MaxLineValue = 0
-    MaxframeValue = 0
-    For Line = 1 To LineMax
-        If Intline(Line - 1) < minLineValue Then
-            minLineValue = Intline(Line - 1)
-        End If
-        If Intline(Line - 1) > MaxLineValue Then
-            MaxLineValue = Intline(Line - 1)
-        End If
-    Next Line
-    For Col = 1 To ColMax
-        If IntCol(Col - 1) < MinColValue Then
-            MinColValue = IntCol(Col - 1)
-        End If
-        If IntCol(Col - 1) > MaxColValue Then
-            MaxColValue = IntCol(Col - 1)
-        End If
-    Next Col
-    For frame = 1 To FrameNumber
-        If IntFrame(frame - 1) < minFrameValue Then
-            minFrameValue = IntFrame(frame - 1)
-        End If
-        If IntFrame(frame - 1) > MaxframeValue Then
-            MaxframeValue = IntFrame(frame - 1)
-        End If
-    Next frame
-    ' Why do you need to threshold the image? (this is probably to remove noise
-    'Calculates the threshold values. It is set to an arbitrary value of the minimum projected value plus 20% of the difference between the minimum and the maximum projected value.
-    'Then calculates the center of mass
-    LineSum = 0
-    LineWeight = 0
-    MidLine = (LineMax + 1) / 2
-    Threshold = minLineValue + (MaxLineValue - minLineValue) * 0.8         'Threshold calculation
-    For Line = 1 To LineMax
-        LineValue = Intline(Line - 1) - Threshold                           'Subtracs the threshold
-        PosValue = LineValue + Abs(LineValue)                               'Makes sure that the value is positive or zero. If LineValue is negative, the Posvalue = 0; if Line value is positive, then Posvalue = 2*LineValue
-        LineWeight = LineWeight + (PixelSize * (Line - MidLine)) * PosValue 'Calculates the weight of the Thresholded projected pixel values according to their position relative to the center of the image and sums them up
-        LineSum = LineSum + PosValue                                        'Calculates the sum of the thresholded pixel values
-    Next Line
-    If LineSum = 0 Then
-        YMass = 0
-    Else
-        YMass = Round(LineWeight / LineSum, PrecXY)                                       'Normalizes the weights to get the center of mass
+    If Not FoundChannel Then
+        ErrorLog.Show
+        ErrorLog.UpdateLog " MassCenter Was not able to find channel: " & TrackingChannel & " for tracking"
+        Exit Function
     End If
 
-    ColSum = 0
-    ColWeight = 0
-    MidCol = (ColMax + 1) / 2
-    Threshold = MinColValue + (MaxColValue - MinColValue) * 0.8
-    For Col = 1 To ColMax
-        ColValue = IntCol(Col - 1) - Threshold
-        PosValue = ColValue + Abs(ColValue)
-        ColWeight = ColWeight + (PixelSize * (Col - MidCol)) * PosValue
-        ColSum = ColSum + PosValue
-    Next Col
-    If ColSum = 0 Then
-        XMass = 0
-    Else
-        XMass = Round(ColWeight / ColSum, PrecXY)
-    End If
 
-    FrameSum = 0
-    FrameWeight = 0
-    MidFrame = (FrameNumber + 1) / 2
-    Threshold = minFrameValue + (MaxframeValue - minFrameValue) * 0.8
-    For frame = 1 To FrameNumber
-        FrameValue = IntFrame(frame - 1) - Threshold
-        PosValue = FrameValue + Abs(FrameValue)
-        FrameWeight = FrameWeight + (FrameSpacing * (frame - MidFrame)) * PosValue
-        FrameSum = FrameSum + PosValue
-    Next frame
+    'Gets the dimensions of the image in X (Columns), Y (lines) and Z (Frames)
+    ColMax = RecordingDoc.Recording.SamplesPerLine
+    LineMax = RecordingDoc.Recording.LinesPerFrame
     
-    If FrameSum = 0 Then
-        ZMass = 0
+    If RecordingDoc.Recording.ScanMode = "ZScan" Then
+        LineMax = 1
+    End If
+    If RecordingDoc.Recording.ScanMode = "ZScan" Or RecordingDoc.Recording.ScanMode = "Stack" Then
+        FrameMax = RecordingDoc.Recording.framesPerStack
     Else
-        ZMass = Round(FrameWeight / FrameSum, PrecZ)
+        FrameMax = 1
     End If
+    
+     
+    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
+    ReDim IntLine(LineMax - 1)
+    ReDim IntCol(ColMax - 1)
+    ReDim IntFrame(FrameMax - 1)
         
-End Sub
 
-''''''
-' ComputeNewCoordinatesAfterAF(RecordingDoc As DsRecordingDoc, X As Double, Y As Double, Z As Double, DeltaZ As Double, Context As String) As Boolean
-'   Computes new coordinates X, Y, Z and DeltaZ given a recording and a method
-'   [RecordingDoc] In - A recording
-'   [X] In/Out - The old and new X coordinate (physical size)
-'   [Y] In/Out - The old and new Y coordinate (physical size)
-'   [Z] In/Out - The old and new Z coordinate (physical size)
-'   [DeltaZ] (In)/Out -  Default is < 0 => No changes in Thickness of imaging
-'   [Context] In - Either "Autofocus" or "Tracking"
-'   [method]  In - Either "internal" or "external", i.e. online image analysis
-'''''
-Public Function ComputeNewCoordinatesAfterAF(ByVal RecordingDoc As DsRecordingDoc, X As Double, Y As Double, Z As Double, _
-DeltaZ As Double, ByVal Context As String, Optional ByVal method As String = "internal") As Boolean
-    Dim XMass As Double
-    Dim YMass As Double
-    Dim ZMass As Double
-    Dim GridPos As GridPosType
-    Dim LogMsg As String
-    GridPos.Col = 1
-    GridPos.Row = 1
-    GridPos.ColSub = 1
-    GridPos.RowSub = 1
     
-    Dim XArray() As Double
-    Dim YArray() As Double
-    Dim ZArray() As Double
-    Dim DeltaZArray() As Double
-    Dim Time As Double
-    
-    Time = Timer
-    If method = "internal" Then
-        MassCenter RecordingDoc, XMass, YMass, ZMass, Context
-        ComputeShiftedCoordinates XMass, YMass, ZMass, X, Y, Z
-        DeltaZ = -1
-    ElseIf method = "external" Then
-
-        If Not MicroscopePilot(RecordingDoc, GridPos, X, Y, Z, "", XArray, YArray, ZArray, _
-            DeltaZArray) Then
-            MsgBox "Online Image analysis for Autofocus was not succesfull!  Exit Now!"
-            Exit Function
-        End If
-'       If GetSetting("OnlineImageAnalysis", "macro", "code") = "nothing" Then
-'           GoTo NoResponse
-'       End If
-        If isArrayEmpty(XArray) Or isArrayEmpty(YArray) Or isArrayEmpty(ZArray) Then
-            GoTo NoResponse
-            'MsgBox "Online Image analysis for Autofocus gave back empty arrays!  Exit Now!"
-            'Exit Function
-        Else
-            X = XArray(1)
-            Y = YArray(1)
-            Z = ZArray(1)
-            DeltaZ = DeltaZArray(1)
-        End If
-        LogMsg = "% compute Autofocus (external) " & Round(Timer - Time, 2)
-        LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    Else
-        MsgBox "No Method for analysis of Autofocus has been found! Exit Now!"
-        Exit Function
-    End If
-
-    ComputeNewCoordinatesAfterAF = True
+    'Compute center of mass
+    'Reads the pixel values and fills the tables with the projected (integrated) pixels values in the three directions
+    ' Intline  => Y: is the sum along X and along Z
+    ' IntCol   => X : is the sum along Y and Z
+    ' IntFrame => Z : is the sum along X and Y
+    
+    For Frame = 0 To FrameMax - 1
+        For Line = 0 To LineMax - 1
+            bpp = 0 ' bytes per pixel (this will be changed by ScanLine
+            ' spl samples per line (will be changed by scal line)
+            scrline = RecordingDoc.ScanLine(channel, 0, Frame, Line, spl, bpp)  'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
+            For Col = 0 To ColMax - 1             'Now I'm scanning all the pixels in the line
+                IntLine(Line) = IntLine(Line) + scrline(Col)
+                IntCol(Col) = IntCol(Col) + scrline(Col)
+                IntFrame(Frame) = IntFrame(Frame) + scrline(Col)
+            Next Col
+        Next Line
+    Next Frame
+    
+    'no thresholding for the moment
+    'compute center of mass
+    
+    'First it finds the minimum and maximum projected (integrated) pixel values in the 3 dimensions
+    MassCenter.Y = weightedMean(IntLine)
+    MassCenter.X = weightedMean(IntCol)
+    MassCenter.Z = weightedMean(IntFrame)
+'    Dim Max As Single
+'    Max = MAXA(IntFrame)
+'    For Frame = 0 To FrameMax - 1
+'        If IntFrame(Frame) = Max Then
+'            Exit For
+'        End If
+'    Next Frame
+'    MassCenter.Z = Frame
     Exit Function
-NoResponse:
-    LogMsg = "% compute Autofocus (external) did not respond after " & Round(Timer - Time, 2)
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    DisplayProgress "Autofocus: Compute Autofocus external failed...", RGB(&HC0, 0, 0)
-    'Sleep (100)
-    ComputeNewCoordinatesAfterAF = True
+ErrorHandle:
+    MsgBox ("Error in MicroscopeIO.MassCenter " + TrackingChannel + " " + Err.Description)
+    ScanStop = True
 End Function
 
+
+
 ''''''
 ' SaveDsRecordingDoc(Document As DsRecordingDoc, FileName As String) As Boolean
 ' Copied and adapted from MultiTimeSeries macro
 ''''''
-Public Function SaveDsRecordingDoc(Document As DsRecordingDoc, fileName As String) As Boolean
+Public Function SaveDsRecordingDoc(Document As DsRecordingDoc, FileName As String, FileFormat As enumAimExportFormat) As Boolean
     Dim Export As AimImageExport
     Dim image As AimImageMemory
     Dim Error As AimError
@@ -1543,8 +1035,8 @@ Public Function SaveDsRecordingDoc(Document As DsRecordingDoc, fileName As Strin
     
     Set Export = Lsm5.CreateObject("AimImageImportExport.Export.4.5")
     'Set Export = New AimImageExport
-    Export.fileName = fileName
-    Export.Format = eAimExportFormatLsm5
+    Export.FileName = FileName
+    Export.format = FileFormat
     Export.StartExport image, image
     Set Error = Export
     Error.LastErrorMessage
@@ -1577,9 +1069,8 @@ Public Function SaveDsRecordingDoc(Document As DsRecordingDoc, fileName As Strin
 Done:
     MsgBox "Check Temporary Files Folder! Cannot Save Temporary File(s)!"
     ScanStop = True
-    SaveDsRecordingDoc = False
     Export.FinishExport
-    AutofocusForm.StopAcquisition
+    StopAcquisition
 End Function
 
 
@@ -1637,597 +1128,64 @@ Public Sub UsedDevices40(bLSM As Boolean, bLIVE As Boolean, bCamera As Boolean)
 End Sub
 
 
-''''
-'   Read Rois from registry and create them
-'   ToDo: create several roi!!
-''''
-Public Function CreateRoisFromRegistry() As Boolean
-    DisplayProgress "CreateRoisFromRegistry", RGB(0, &HC0, 0)
-    Dim RoiType As String
-    Dim RoiAim As String
-    Dim XKnot()  As String 'the string containinig the X-positions
-    Dim YKnot()  As String 'the string containinig the Y-positions
-    Dim XKnotD()  As Double 'the double array containinig the X-positions
-    Dim YKnotD()  As Double 'the double array containinig the Y-positions
-    
-    Dim i As Integer
-    RoiType = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="roitype")
-    If RoiType = "" Then
-        Exit Function
-    End If
-    
-    
-    XKnot() = Split(GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="roix"), ",")
-    YKnot() = Split(GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="roiy"), ",")
-    If isArrayEmpty(XKnot) Or isArrayEmpty(YKnot) Then
-        MsgBox "CreateRoisFromRegistry: No coordinates found in registry roix and roiy (in pixel)"
-        Exit Function
-    End If
-    
-    If UBound(XKnot) <> UBound(YKnot) Then 'Z position as not been set
-        MsgBox "CreateRoisFromRegistry: Equal number of coordinates x and y"
-        Exit Function
-    End If
-    
-    RoiType = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="roitype")
-    If RoiType = "" Then
-        MsgBox "CreateRoisFromRegistry: You have to specify the type of roi: circle, rectangle, polyline, or ellipse"
-        Exit Function
-    End If
-
-    RoiAim = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="roiaim")
-    If RoiAim = "" Then
-        MsgBox "CreateRoisFromRegistry: You have to specify the aim of roi: bleach, acquire, or analyse"
-        Exit Function
-    End If
-    
-    
-    ReDim XKnotD(UBound(XKnot))
-    ReDim YKnotD(UBound(YKnot))
-    For i = 0 To UBound(XKnot)
-        XKnotD(i) = CDbl(XKnot(i))
-        YKnotD(i) = CDbl(YKnot(i))
-    Next i
-    
-    If MakeVectorElement(RoiType, XKnotD, YKnotD, RoiAim) Then
-        CreateRoisFromRegistry = True
-        Exit Function
-    Else
-        Exit Function
-    End If
-End Function
-
 
-'''
-'   StorePositioninHighResArray(HighResArrayX() As Double, HighResArrayY() As Double, HighResArrayZ() As Double, HighResCounter As Integer)
-'   TODO: Test stricter way of passing arguments
-''''
-Public Function StorePositioninHighResArray(ByVal Xref As Double, ByVal Yref As Double, ByVal Zref As Double, HighResArrayX() As Double, HighResArrayY() As Double, _
-HighResArrayZ() As Double, HighResArrayDeltaZ() As Double) As Boolean
-    ' store postion from windows registry in array
-    Dim Xoffset()  As String 'the string containinig the X-positions
-    Dim Yoffset()  As String 'the string containinig the Y-positions
-    Dim ZOffset() As String  'the string containinig the Z-positions
-    Dim DeltaZ() As String
-    Dim defaultDeltaZ As Double
-    Dim Xnew As Double
-    Dim Ynew As Double
-    Dim Znew As Double
-    Dim Xtmp As Double
-    Dim pixelSizeXY As Double
-    Dim pixelSizeZ As Double
-    Dim unit As String
-    Dim LowBound As Integer
-    Dim i As Integer
-    unit = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="unit")
-    If unit = "um" Or unit = Chr(181) & "m" Then   'has correct pixelSize of um
-        pixelSizeXY = 1
-        pixelSizeZ = 1
-    Else                                    'Default is pixel even when Key does not exist
-        pixelSizeXY = Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing * 1000000
-        pixelSizeZ = Lsm5.DsRecordingActiveDocObject.Recording.FrameSpacing
-    End If
-     
-    Xoffset() = Split(GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="offsetx"), ",")
-    If isArrayEmpty(Xoffset) Then
-        ReDim Xoffset(0)
-        Xoffset(0) = 0
-    End If
-    
-    Yoffset() = Split(GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="offsety"), ",")
-    If isArrayEmpty(Yoffset) Then
-        ReDim Yoffset(0)
-        Yoffset(0) = 0
-    End If
-    
-    ZOffset() = Split(GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="offsetz"), ",")
-    If isArrayEmpty(ZOffset) Then
-        ReDim ZOffset(UBound(Xoffset))
-        For i = 0 To UBound(Xoffset)
-            ZOffset(i) = 0
-        Next i
-    End If
-        
-    If UBound(ZOffset) <> UBound(Xoffset) Then 'Z position as not been set
-        ReDim Preserve ZOffset(UBound(Xoffset))
-        For i = 0 To UBound(Xoffset)
-            ZOffset(i) = ZOffset(0)
-        Next i
-    End If
-    
-    DeltaZ() = Split(GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="deltaZ"), ",")
-    If isArrayEmpty(DeltaZ) Then
-        ReDim DeltaZ(UBound(Xoffset)) ' this means it is not used
-        For i = 0 To UBound(DeltaZ)
-            DeltaZ(i) = -1
-        Next i
-    End If
-    
-    If UBound(DeltaZ) <> UBound(Xoffset) Then 'Z position as not been set
-        ReDim Preserve DeltaZ(UBound(Xoffset))
-        For i = 0 To UBound(DeltaZ)
-            DeltaZ(i) = DeltaZ(0)
-        Next i
-    End If
 
 
-    
-    If UBound(Xoffset) <> UBound(Yoffset) Then
-        MsgBox ("StorePositioninHighResArray: nr of values in registry offsetx and offsety is not the same!")
-        Exit Function
-    End If
-    'ZOffset() = Split(GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="offsetz"), ",") for a later time point we can also set Z
-    If isArrayEmpty(HighResArrayX) Then
-        LowBound = 1
-        ReDim HighResArrayX(1 To UBound(Xoffset) + 1)
-        ReDim HighResArrayY(1 To UBound(Xoffset) + 1)
-        ReDim HighResArrayZ(1 To UBound(Xoffset) + 1)
-        ReDim HighResArrayDeltaZ(1 To UBound(Xoffset) + 1)
-    Else
-        LowBound = UBound(HighResArrayX) + 1
-        ReDim Preserve HighResArrayX(1 To UBound(HighResArrayX) + UBound(Xoffset) + 1)
-        ReDim Preserve HighResArrayY(1 To UBound(HighResArrayY) + UBound(Yoffset) + 1)
-        ReDim Preserve HighResArrayZ(1 To UBound(HighResArrayZ) + UBound(ZOffset) + 1)
-        ReDim Preserve HighResArrayDeltaZ(1 To UBound(HighResArrayDeltaZ) + UBound(DeltaZ) + 1)
-    End If
-    
-    For i = 0 To UBound(Xoffset)
-        Xnew = Xref
-        Ynew = Yref
-        Znew = Zref
-        Xtmp = CDbl(Xoffset(i))
-        ComputeShiftedCoordinates CDbl(Xoffset(i)) * pixelSizeXY, CDbl(Yoffset(i)) * pixelSizeXY, CDbl(ZOffset(i)) * pixelSizeZ, Xnew, Ynew, Znew
-        HighResArrayX(LowBound + i) = Xnew  ' this needs to be unified with computing internal AF
-        HighResArrayY(LowBound + i) = Ynew  ' needs to be unified with computing internal AF
-        HighResArrayZ(LowBound + i) = Znew
-        HighResArrayDeltaZ(LowBound + i) = CDbl(DeltaZ(i)) * pixelSizeZ
-    Next i
-    DisplayProgress "StorePositioninHighResArray - Position stored", RGB(0, &HC0, 0)
-End Function
-
 
 ''''''
-'   MicroscopePilot(RecordingDoc As DsRecordingDoc, BleachingActivated As Boolean, HighResExperimentCounter As Integer, HighResCounter As Integer _
-'   HighResArrayX() As Double, HighResArrayY() As Double, HighResArrayZ() As Double)
-'   TODO: test stricter way of passing arguments
-'   [code] passed by MacroPilot can be
-'       0, wait, Wait, DoNothing or doNothing: Macro waits, but no image is ready to analyse
-'       1, newImage: Macro waits and there is a new image available
-'       2, "nothing", "Nothing", "DoNothing", "doNothing", "donothing": Do nothing
-'       4, "storePosition", "StorePosition", "storePosition", "StorePosition", "store", "Store": Store positions and exit function
-'       5, "imagePositions", "ImagePositions", "imagePosition", "ImagePosition", "imageposition", "image", "Image": Image all stored positions
-'       6, "setFocus": store just one position for the focus
+''
 ''''''
-Public Function MicroscopePilot(RecordingDoc As DsRecordingDoc, GridPos As GridPosType, Xref As Double, Yref As Double, Zref As Double, _
-FileNameID As String, HighResArrayX() As Double, HighResArrayY() As Double, HighResArrayZ() As Double, HighResArrayDeltaZ() As Double, Optional FcsData As AimFcsData, Optional iRepStart As Integer = 0) As Boolean
-    Dim code As String
-    Dim Repetitions As RepetitionType
-    code = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:="codeIn")
-    Dim TimeWait, TimeStart, MaxTimeWait As Double
-    MaxTimeWait = 100
-    
-    Select Case code
-        Case "wait":
-            'Wait for image analysis to finish
-            DisplayProgress "Waiting for image analysis...", RGB(0, &HC0, 0)
-            TimeStart = CDbl(GetTickCount) * 0.001
-            Do While ((TimeWait < MaxTimeWait) And (code = "1" Or code = "wait" Or code = "Wait" Or code = "0"))
-                Sleep (50)
-                TimeWait = CDbl(GetTickCount) * 0.001 - TimeStart
-                code = GetSetting(appname:="OnlineImageAnalysis", section:="macro", _
-                          Key:="CodeIn")
-                DoEvents
-                If ScanStop Then
-                    Exit Function
-                End If
-            Loop
-            If TimeWait > MaxTimeWait Then
-                code = "nothing"
-                SaveSetting "OnlineImageAnalysis", "macro", "codeIn", code
-            End If
-    End Select
-    
-    Select Case code
-        Case "nothing", "":  'Nothing to do
-        Case "ERROR":
-            'MsgBox "Online image analysis had an Error"
-        Case "4", "storePosition", "StorePosition", "storePosition", "StorePosition", "store", "Store": 'store positions for later processing
-            SaveSetting "OnlineImageAnalysis", "macro", "codeIn", "nothing"
-            DisplayProgress "Registry Code 4 (storePosition): store positions and do nothings ...", RGB(0, &HC0, 0)
-            StorePositioninHighResArray Xref, Yref, Zref, HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ
-            ' if there are MicropilotMaxPositions the imaging start when a minimal number of positions are reached
-            If AutofocusForm.MicropilotMaxPositions.Value <> "" Then
-                If UBound(HighResArrayX) = CInt(AutofocusForm.MicropilotMaxPositions.Value) Then
-                    Repetitions.Number = CInt(AutofocusForm.MicropilotRepetitions.Value)
-                    Repetitions.Time = CDbl(AutofocusForm.MicropilotRepetitionTime.Value)
-                    Repetitions.Interval = True
-                    SubImagingWorkFlow RecordingDoc, GlobalMicropilotRecording, "Micropilot", AutofocusForm.MicropilotAutofocus, AutofocusForm.MicropilotZOffset, Repetitions, _
-                    HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ, GridPos, FileNameID, iRepStart
-                    Erase HighResArrayX
-                    Erase HighResArrayY
-                    Erase HighResArrayZ
-                    Erase HighResArrayDeltaZ
-                End If
-            End If
-
-        Case "image", "Image":
-            SaveSetting "OnlineImageAnalysis", "macro", "codeIn", "nothing"
-            DisplayProgress "Registry Code 5 (imagePositions): store positions and do imaging ...", RGB(0, &HC0, 0)
-            StorePositioninHighResArray Xref, Yref, Zref, HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ
-            ' BatchHighresImagingRoutine
-            ' HERE THE IMAGES ARE ACQUIRED
-            Repetitions.Number = CInt(AutofocusForm.MicropilotRepetitions.Value)
-            Repetitions.Time = CDbl(AutofocusForm.MicropilotRepetitionTime.Value)
-            Repetitions.Interval = True
-            SubImagingWorkFlow RecordingDoc, GlobalMicropilotRecording, "Micropilot", AutofocusForm.MicropilotAutofocus, AutofocusForm.MicropilotZOffset, Repetitions, _
-            HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ, GridPos, FileNameID
-            Erase HighResArrayX
-            Erase HighResArrayY
-            Erase HighResArrayZ
-            Erase HighResArrayDeltaZ
-        
-        Case "focus", "Focus":
-            SaveSetting "OnlineImageAnalysis", "macro", "codeIn", "nothing"
-            Erase HighResArrayX
-            Erase HighResArrayY
-            Erase HighResArrayZ
-            Erase HighResArrayDeltaZ
-            
-            DisplayProgress "Registry Code 6 (focus): focus and number of DeltaZ ...", RGB(0, &HC0, 0)
-            StorePositioninHighResArray Xref, Yref, Zref, HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ
-        
-        Case "fcs", "FCS", "Fcs":
-            Dim i As Integer
-            SaveSetting "OnlineImageAnalysis", "macro", "codeIn", "nothing"
-            DisplayProgress "Registry Code 7 (fcs): peform a fcs measurment ...", RGB(0, &HC0, 0)
-            ' read potitions from
-            Erase HighResArrayX
-            Erase HighResArrayY
-            Erase HighResArrayZ
-            Erase HighResArrayDeltaZ
-            DisplayProgress "Registry Code 7 (fcs): perform FCS measurement ...", RGB(0, &HC0, 0)
-            StorePositioninHighResArray Xref, Yref, Zref, HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ
-            'convert in meter
-            For i = LBound(HighResArrayX) To UBound(HighResArrayX)
-                HighResArrayX(i) = (HighResArrayX(i) - Xref) * 0.000001
-                HighResArrayY(i) = (Yref - HighResArrayY(i)) * 0.000001 'inverted image this needs to be tested again
-                HighResArrayZ(i) = HighResArrayZ(i) * 0.000001
-           Next i
-                
-            DisplayProgress "Registry Code 7 (fcs): perform FCS measurement ...", RGB(0, &HC0, 0)
-            SubImagingWorkFlowFcs FcsData, HighResArrayX, HighResArrayY, HighResArrayZ, GlobalDataBaseName & BackSlash, AutofocusForm.TextBoxFileName.Value & UnderScore & FileNameID, _
-            RecordingDoc.Recording.SampleSpacing, RecordingDoc.Recording.FrameSpacing
-        Case "bleach", "Bleach":
-            SaveSetting "OnlineImageAnalysis", "macro", "codeIn", "nothing"
-            DisplayProgress "Registry Code 8 (bleach): peform a bleach measurment ...", RGB(0, &HC0, 0)
-            ' read potitions from
-            If AutofocusForm.ActiveBleach Then
-                Dim LocHighResArrayX() As Double
-                Dim LocHighResArrayY() As Double
-                Dim LocHighResArrayZ() As Double
-                Dim LocHighResArrayDeltaZ() As Double
-                StorePositioninHighResArray Xref, Yref, Zref, LocHighResArrayX, LocHighResArrayY, LocHighResArrayZ, LocHighResArrayDeltaZ
-                LocHighResArrayZ(1) = LocHighResArrayZ(1) + AutofocusForm.BleachZOffset.Value
-                LocHighResArrayDeltaZ(1) = -1
-                
-                
-                'Cooridinates need to be in px
-                
-                Repetitions.Number = 1
-                Repetitions.Time = 0
-                Repetitions.Interval = True
-                DisplayProgress "Registry Code 8 (bleach): perform Bleaching ...", RGB(0, &HC0, 0)
-                'Delete All ROI's
-                Dim AcquisitionController As AimAcquisitionController40.AimScanController
-                Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-                Dim vo As AimImageVectorOverlay
-                Set vo = AcquisitionController.AcquisitionRegions
-                vo.Cleanup
-                CreateRoisFromRegistry
-                
-                'StorePositioninHighResArray Xref, Yref, Zref, HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ
-                DisplayProgress "Registry Code 8 (bleach): perform Bleaching ...", RGB(0, &HC0, 0)
-                SubImagingWorkFlow RecordingDoc, GlobalBleachRecording, "Bleach", AutofocusForm.MicropilotAutofocus, AutofocusForm.MicropilotZOffset, Repetitions, _
-                LocHighResArrayX, LocHighResArrayY, LocHighResArrayZ, LocHighResArrayDeltaZ, GridPos, FileNameID, iRepStart
-                Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
-                Track.UseBleachParameters = False  'switch off the bleaching
-                vo.Cleanup
-            Else
-                MsgBox "Command for bleach but no Bleach track setted"
-            End If
-        Case Else
-            MsgBox ("Invalid OnlineImageAnalysis Code = " & code)
-            Exit Function
-    End Select
-    MicroscopePilot = True
-    'Reset Code to 0 in Windows Registry
-    'SaveSetting "OnlineImageAnalysis", "Cinput", "Code", 0 ' this should be done by the image analysis software
-    'TODO: create a better procedure to check for cells
-    '    If (CheckBoxGridScan_FindGoodPositions) Then
-    '
-    '        codeArray = Split(code, "_")
-    '
-    '        nGoodCells = CInt(codeArray(1))
-    '        minGoodCellsPerImage = CInt(codeArray(2))
-    '        minGoodCellsPerWell = CInt(codeArray(3))
-    '
-    '        GoTo Mark
-    '
-    '    End If
-    '
-    'Reset Code to 0 in Windows Registry
-    'SaveSetting "OnlineImageAnalysis", "Cinput", "Code",
-            
-End Function
-
-
-
-
-Public Function SubImagingWorkFlow(RecordingDoc As DsRecordingDoc, Recording As DsRecording, RecordingName As String, Autofocus As Boolean, ByVal ZOffset As Double, Repetitions As RepetitionType, HighResArrayX() As Double, _
- HighResArrayY() As Double, HighResArrayZ() As Double, HighResArrayDeltaZ() As Double, GridPos As GridPosType, inFileNameID As String, Optional iRepStart As Integer = 0) As Boolean
- 
-    Select Case RecordingName
-        Case "Micropilot":
-            SubImagingWorkFlow = SubImagingWorkFlowMicropilot(RecordingDoc, Recording, RecordingName, Autofocus, ZOffset, Repetitions, HighResArrayX, _
-            HighResArrayY(), HighResArrayZ, HighResArrayDeltaZ, GridPos, inFileNameID, iRepStart)
-        Case "Bleach":
-            SubImagingWorkFlow = SubImagingWorkFlowMicropilot(RecordingDoc, Recording, RecordingName, Autofocus, ZOffset, Repetitions, HighResArrayX, _
-            HighResArrayY(), HighResArrayZ, HighResArrayDeltaZ, GridPos, inFileNameID, iRepStart)
-        Case Else
-            MsgBox ("SubImagingWorkFlow: Invalid workflow" & RecordingName)
-            Exit Function
-    End Select
-End Function
-
-'''''
+'Public Function SubImagingWorkFlowFcs(FcsData As AimFcsData, HighResArrayX() As Double, _
+' HighResArrayY() As Double, HighResArrayZ() As Double, fileDir As String, FileName As String, Optional pixelSizeXY As Double = 0, Optional pixelSizeZ As Double = 0) As Boolean
 '
-'''''
-Public Function SubImagingWorkFlowFcs(FcsData As AimFcsData, HighResArrayX() As Double, _
- HighResArrayY() As Double, HighResArrayZ() As Double, fileDir As String, fileName As String, Optional pixelSizeXY As Double = 0, Optional pixelSizeZ As Double = 0) As Boolean
-
-
-    Dim i As Long
-    ClearFcsPositionList
-    Dim Recording As DsRecordingDoc
-    For i = 1 To UBound(HighResArrayX)
-        SetFcsPosition HighResArrayX(i), HighResArrayY(i), HighResArrayZ(i), i - 1
-    Next i
-    
-    If Not CheckDir(fileDir) Then
-        Exit Function
-    End If
-
-    NewFcsRecord FcsData, "fcs_" & fileName, 1
-
-    If Not FcsMeasurement(FcsData) Then
-        Exit Function
-    End If
+'
+'    Dim i As Long
+'    ClearFcsPositionList
+'    Dim Recording As DsRecordingDoc
+'    For i = 1 To UBound(HighResArrayX)
+'        SetFcsPosition HighResArrayX(i), HighResArrayY(i), HighResArrayZ(i), i - 1
+'    Next i
+'
+'    If Not CheckDir(fileDir) Then
+'        Exit Function
+'    End If
+'
+'    NewFcsRecord FcsData, "fcs_" & FileName, 1
+'
+'    If Not FcsMeasurement(FcsData) Then
+'        Exit Function
+'    End If
+'
+'    Set Recording = Lsm5.DsRecordingActiveDocObject
+'    Recording.SetTitle "fcs_" & FileName
+'
+'    SaveFcsPositionList fileDir & FileName & "_fcsPos.txt", pixelSizeXY, pixelSizeZ
+'    'save measurement
+'    SaveFcsMeasurement FcsData, fileDir & FileName & ".fcs"
+'
+'End Function
 
-    Set Recording = Lsm5.DsRecordingActiveDocObject
-    Recording.SetTitle "fcs_" & fileName
 
-    SaveFcsPositionList fileDir & fileName & "_fcsPos.txt", pixelSizeXY, pixelSizeZ
-    'save measurement
-    SaveFcsMeasurement FcsData, fileDir & fileName & ".fcs"
-    
-End Function
 
 '''''
-'
+'' TODO: Why not use Lsm5.StartScan?
 '''''
-Public Function SubImagingWorkFlowMicropilot(RecordingDoc As DsRecordingDoc, Recording As DsRecording, RecordingName As String, Autofocus As Boolean, ByVal ZOffset As Double, Repetitions As RepetitionType, HighResArrayX() As Double, _
- HighResArrayY() As Double, HighResArrayZ() As Double, HighResArrayDeltaZ() As Double, GridPos As GridPosType, inFileNameID As String, Optional iRepStart As Integer = 0) As Boolean
-    
-    Dim FcsData As AimFcsData
-    Dim Succes As Integer
-    Dim SuccessRecenter As Boolean
-    Dim LocationLabel As String
-    'Timer and Looping Variables
-    Dim iPos As Integer
-    Dim iRep As Integer
-    Dim StartTime As Double
-    Dim NewTime As Double
-    Dim DiffTime As Double
-    Dim TimeLog As Double  'used in the the log
-    
-    'file name variables
-    Dim FileNameID  As String
-    Dim fullpathname As String
-    Dim LogMsg As String
-    'position variables
-    Dim X As Double
-    Dim Y As Double
-    Dim Z As Double
-    Dim DeltaZ As Double
-    DeltaZ = -1  ' default no changes in Stackheight
-    Dim PosZ As Double 'actual position Z
-
-    ' set up the imaging
-    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-    
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (20)
-            DoEvents
-        Wend
-    End If
-    
-    
-    LocationLabel = AutofocusForm.LocationTextLabel.Caption
-    For iRep = 1 To Repetitions.Number
-        StartTime = CDbl(GetTickCount) * 0.001
-        For iPos = 1 To UBound(HighResArrayX)  ' Postition loop
-                ' Move to Positon in x, y, z for Highresscan
-                DisplayProgress RecordingName & " - Move to Position " & iPos, RGB(0, &HC0, 0)
-                X = HighResArrayX(iPos)
-                Y = HighResArrayY(iPos)
-                Z = HighResArrayZ(iPos)
-                If Not FailSafeMoveStageXY(HighResArrayX(iPos), HighResArrayY(iPos)) Then
-                    Exit Function
-                End If
-                'center acquisition (this should be already at correct position after AF)
-                Recenter_pre Z, SuccessRecenter, ZEN
-                AutofocusForm.LocationTextLabel.Caption = LocationLabel & _
-                RecordingName & " Locations: " & iPos & "/" & UBound(HighResArrayX) & _
-                "; X = " & X & ", Y = " & Y & ", Z = " & Z & vbCrLf & _
-                "Repetition :" & iRep & "/" & Repetitions.Number
-                DoEvents
-                
-                'Autofocus. This does an extra Autofocus also for the HighresImaging with the same parameters as Autofocus
-                If Autofocus Then
-                
-                    If AutofocusForm.AutofocusAlgorithm.Value = "external" Then
-                        SaveSetting "OnlineImageAnalysis", "macro", "code", "wait"     'wait for imageAnalysis
-                        If Not AutofocusForm.SaveAFImage Then
-                            MsgBox "Tick Save AFImage for external image analysis of focus!"
-                            Exit Function
-                        End If
-                    End If
-                    
-                    DisplayProgress RecordingName & " - Autofocus activate track and recenter...", RGB(0, &HC0, 0)
-                    If Not AutofocusForm.ActivateTrack(GlobalAutoFocusRecording, "Autofocus") Then
-                        MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-                        Exit Function
-                    End If
-                    
-                    '''center
-                    TimeLog = Timer
-                    If Not Recenter_pre(Z, SuccessRecenter, ZEN) Then
-                        Exit Function
-                    End If
-                    LogMsg = "% " & RecordingName & " : recenter Z (pre AFImg) " & Z & ", time required " & Round(Timer - TimeLog)
-                    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-                    
-                    ' take a z-stack and finds the brightest plane:
-                    DisplayProgress RecordingName & " - Autofocus acquire ...", RGB(0, &HC0, 0)
-                    If Not MicroscopeIO.Autofocus_StackShift(RecordingDoc) Then
-                       Exit Function
-                    End If
-                    
-                    DisplayProgress " Autofocus compute ...", RGB(0, &HC0, 0)
-                    'Delta Z is not used for the moment but could be used later
-                    If Not ComputeNewCoordinatesAfterAF(RecordingDoc, X, Y, Z, DeltaZ, "Autofocus") Then
-                        Exit Function
-                    End If
-                    'wait for recentering
-                    DisplayProgress RecordingName & " - Wait for recentering after acquisition AF...", RGB(0, &HC0, 0)
-                    TimeLog = Timer
-                    If Not Recenter_post(Z, SuccessRecenter, ZEN) Then
-                        Exit Function
-                    End If
-                
-                    LogMsg = "% " & RecordingName & ": recenter Z (post AFImg) " & Z
-                    
-                    PosZ = Round(Lsm5.Hardware.CpFocus.Position, PrecZ)
-                    If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusForm.AutofocusHRZ Then
-                        LogMsg = LogMsg & ", Obtained Z " & PosZ & "; actual position " & PosZ & ", Time required " & Round(Timer - TimeLog) & ", success within rep. " & SuccessRecenter
-                    Else
-                        LogMsg = LogMsg & ", Obtained Z " & Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + PosZ _
-                        & "; actual position " & PosZ & ", Time required " & Round(Timer - TimeLog) & ", success within rep. " & SuccessRecenter
-                    End If
-                    LogMsg = LogMsg & vbCrLf & "% " & RecordingName & ":  center of mass  " & X - HighResArrayX(iPos) & ", " & Y - HighResArrayY(iPos) & ", " & Z - HighResArrayZ(iPos) & ", computed position " & X & ", " & Y & ", " & Z
-                    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-                        
-                    If AutofocusForm.AutofocusTrackXY.Value And AutofocusForm.ScanFrameToggle.Value Then
-                        DisplayProgress RecordingName & " - Autofocus move XY stage", RGB(0, &HC0, 0)
-                        If Not FailSafeMoveStageXY(X, Y) Then
-                            Exit Function
-                        End If
-                        HighResArrayX(iPos) = X
-                        HighResArrayY(iPos) = Y
-                    End If
-                    If DeltaZ > 0 Then
-                        HighResArrayDeltaZ(iPos) = DeltaZ
-                    End If
-     
-                    HighResArrayZ(iPos) = Z
-                End If
-                
-                DisplayProgress RecordingName & " - activate micropilot acquisition track and recenter ...", RGB(0, &HC0, 0)
-                
-                If Not AutofocusForm.ActivateTrack(Recording, RecordingName, HighResArrayDeltaZ(iPos)) Then
-                    MsgBox " No Track selected for  " & RecordingName & "! Macro stops here"
-                    Exit Function
-                End If
-                
-                ' set central slice before moving
-                If Not Recenter_pre(Z + ZOffset, SuccessRecenter, ZEN) Then
-                    Exit Function
-                End If
-                
-                DisplayProgress RecordingName & " - Acquisition position " & iPos & "/" & UBound(HighResArrayX) & " Repetition " & iRep _
-                & "/" & Repetitions.Number, RGB(&HC0, &HC0, 0)
+'Public Sub ScanToImageOld(RecordingDoc As DsRecordingDoc) ' new routine to scan overwrite the same image, even with several z-slices
+'   ' Dim AcquisitionController As AimAcquisitionController40.AimScanController 'now public
+'    Dim image As AimImage
+'
+'    If Not RecordingDoc Is Nothing Then
+'        Set image = RecordingDoc.RecordingDocument.image(0, True)
+'
+'        If Not image Is Nothing Then
+'            Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
+'            AcquisitionController.DestinationImage(0) = image
+'            AcquisitionController.DestinationImage(1) = Nothing
+'            AcquisitionController.StartGrab eGrabModeSingle
+'        End If
+'    End If
+'
+'End Sub
+
 
-                If Not ScanToImage(RecordingDoc) Then
-                    Exit Function
-                End If
-                
-                fullpathname = AutofocusForm.DatabaseTextbox.Value & BackSlash & "HRExp_" & AutofocusForm.TextBoxFileName.Value & UnderScore & inFileNameID & "\"
-                If Not CheckDir(fullpathname) Then
-                    Exit Function
-                End If
-                
-                
-                If RecordingName = "Bleach" Then
-                    FileNameID = fileName(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub, iRepStart)
-                    fullpathname = fullpathname & AutofocusForm.TextBoxFileName.Value & UnderScore & "HRPos" & ZeroString(3 - Len(CStr(iPos))) & iPos & _
-                 "_" & "Bleach_" & FileNameID & ".lsm"
-                Else
-                    FileNameID = fileName(GridPos.Row, GridPos.Col, GridPos.RowSub, GridPos.ColSub, iRep)
-                    fullpathname = fullpathname & AutofocusForm.TextBoxFileName.Value & UnderScore & "HRPos" & ZeroString(3 - Len(CStr(iPos))) & iPos & _
-                    "_" & FileNameID & ".lsm"
-                End If
-                
-                DisplayProgress RecordingName & " - SaveImage", RGB(0, &HC0, 0)
-                If Not SaveDsRecordingDoc(RecordingDoc, fullpathname) Then
-                    Exit Function
-                End If
-                
-                'listen to online imageanalysis
-                'MicroscopePilot RecordingDoc, GridPos, HighResArrayX(iPos), HighResArrayY(iPos), HighResArrayZ(iPos), inFileNameID, HighResArrayX, HighResArrayY, HighResArrayZ, HighResArrayDeltaZ, FcsData, iRep
-
-          
-        Next iPos ' End of postions loop
-        'TODO Check
-        If Not Repetitions.Interval Then
-            StartTime = CDbl(GetTickCount) * 0.001
-        End If
-        DiffTime = CDbl(GetTickCount) * 0.001 - StartTime
-        While DiffTime <= Repetitions.Time And iRep < Repetitions.Number
-            Sleep (10)
-            If GetInputState() <> 0 Then
-            DoEvents
-                If ScanStop Then
-                    SubImagingWorkFlowMicropilot = False
-                    Exit Function
-                End If
-            End If
-            DiffTime = CDbl(GetTickCount) * 0.001 - StartTime
-            DisplayProgress "Waiting " & CStr(CInt(Repetitions.Time - DiffTime)) + " s before scanning repetition  " & (iRep + 1), RGB(&HC0, &HC0, 0)
-        Wend
-    Next iRep  ' End of time repetition loop
-    
-    SubImagingWorkFlowMicropilot = True
-End Function
 
diff --git a/AutofocusScreen/src/AutofocusScreen/OnlineIASettings.cls b/AutofocusScreen/src/AutofocusScreen/OnlineIASettings.cls
new file mode 100644
index 0000000..343835a
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/OnlineIASettings.cls
@@ -0,0 +1,555 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "OnlineIASettings"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''''
+' OiaSettings: A class for Keeping track of settings that can be read from the Registry or from files
+' the seetings are use for the interaction with an external online image analysis program
+'''''
+
+Option Explicit
+Public Settings As Dictionary
+Private Keys() As String
+Private Keys_HowTo As Dictionary
+''keys used for codeMic
+Private subKey_codeMic_HowTo As Dictionary
+''keys used for codeOia
+Private subKey_codeOia_HowTo As Dictionary
+
+Private subKey_roiAim_HowTo As Dictionary
+Private subKey_roiType_HowTo As Dictionary
+
+'''
+' A set of functions to IN/OUT parameters for Onlineimageanalisys this should be a class!!!
+''''
+
+''''
+' Set Registry to default values and initiate correct dictionary for standard key values
+'''
+Public Sub initializeDefault()
+    On Error GoTo errMsg
+'This variable contains the keys for the OnlineImageanalysis
+    ReDim Keys(0 To 15)
+    Keys(0) = "codeMic"
+    Keys(1) = "codeOia"
+    Keys(2) = "fileAnalyzed"
+    Keys(3) = "filePath"
+    Keys(4) = "X"
+    Keys(5) = "Y"
+    Keys(6) = "Z"
+    Keys(7) = "fcsX"
+    Keys(8) = "fcsY"
+    Keys(9) = "fcsZ"
+    Keys(10) = "deltaZ"
+    Keys(11) = "roiType"
+    Keys(12) = "roiAim"
+    Keys(13) = "roiX"
+    Keys(14) = "roiY"
+    Keys(15) = "OutputFolder"
+  
+    Set subKey_roiAim_HowTo = New Dictionary
+    subKey_roiAim_HowTo.Add "", "(empty char) do nothing with roi"
+    subKey_roiAim_HowTo.Add "nothing", "do nothing with roi"
+    subKey_roiAim_HowTo.Add "bleach", "bleach and analyse roi"
+    subKey_roiAim_HowTo.Add "acquisition", "acquire roi"
+    subKey_roiAim_HowTo.Add "acquisitionBleach", "acquire, bleach, and analyse roi"
+    
+    
+    Set subKey_roiType_HowTo = New Dictionary
+    subKey_roiType_HowTo.Add "", "(empty char) no type"
+    subKey_roiType_HowTo.Add "circle", "Define 2 points (in px) roiX=center_X, point_on_circle_X roiY=center_Y, point_on_circle_Y"
+    subKey_roiType_HowTo.Add "rectangle", "Define 2 points (in px) roiX=upper_left_X, lower_right_X roiY=upper_left_Y, lower_right_Y"
+    subKey_roiType_HowTo.Add "polyline", "Define at least 3 points (in px) roiX=point1_X, point2_X ... roiY=point1_Y, point2_Y..."
+    subKey_roiType_HowTo.Add "ellipse", "Define 3 points (in px) roiX=center_X, axis1_X, axis2_X roiY= center_Y, axis1_Y, axis2_Y"
+    
+    Set Keys_HowTo = New Dictionary
+    Keys_HowTo.Add Keys(0), "task to be executed by the microscope"
+    Keys_HowTo.Add Keys(1), "message for the online image analysis (Oia)"
+    Keys_HowTo.Add Keys(2), "file that has been analyzed by Oia (optional)"
+    Keys_HowTo.Add Keys(3), "filepath of current image"
+    Keys_HowTo.Add Keys(4), "X position stage. Multiple positions: X1; X2; X3; ..."
+    Keys_HowTo.Add Keys(5), "Y position stage. Multiple positions: X1; X2; X3; ..."
+    Keys_HowTo.Add Keys(6), "Z position stage. Empty char: keep current Z-position. Multiple positions: Z1; Z2; Z3; ..."
+    Keys_HowTo.Add Keys(7), "X position for fcs. Multiple positions: X1; X2; X3; ..."
+    Keys_HowTo.Add Keys(8), "Y position for fcs. Multiple positions: Y1; Y2; Y3; ..."
+    Keys_HowTo.Add Keys(9), "Z position for fcs. Empty char: keep current Z-position. Multiple positions: Z1; Y2; Y3; ..."
+    Keys_HowTo.Add Keys(10), "number of Z-slices for current job (not in use)"
+    Keys_HowTo.Add Keys(11), "type of roi. Multiple rois: roiType1; roiTyp2"
+    Keys_HowTo.Add Keys(12), "aim of roi. Multiple rois: roiAim1; roiAim2"
+    Keys_HowTo.Add Keys(13), "X positions for roi. Multiple rois: X1roi1, X2roi1; X1roi1, X2roi2 ..."
+    Keys_HowTo.Add Keys(14), "Y positions for roi. Multiple rois: X1roi1, X2roi1; X1roi1, X2roi2 ..."
+    Keys_HowTo.Add Keys(15), "main directory where images are stored"
+    
+    Set subKey_codeMic_HowTo = New Dictionary
+    subKey_codeMic_HowTo.Add "", "(empty char) wait for image analysis"
+    subKey_codeMic_HowTo.Add "wait", "wait for image analysis"
+    subKey_codeMic_HowTo.Add "error", "error from image analysis"
+    subKey_codeMic_HowTo.Add "timeExpired", "time for image analysis has expired"
+    subKey_codeMic_HowTo.Add "nothing", "Do nothing"
+    subKey_codeMic_HowTo.Add "focus", "read X, Y, and Z  and change focus"
+    subKey_codeMic_HowTo.Add "trigger1", "perform job Trigger1 at position X, Y, and Z"
+    subKey_codeMic_HowTo.Add "trigger2", "perform job Trigger2 at position X, Y, and Z"
+    subKey_codeMic_HowTo.Add "fcs1", "perform job Fcs1 at position fcsX, fcsY, and fcsZ"
+    
+    Set subKey_codeOia_HowTo = New Dictionary
+    subKey_codeOia_HowTo.Add "", "(empty char) online image analysis does nothing"
+    subKey_codeOia_HowTo.Add "nothing", "online image analysis does nothing"
+    subKey_codeOia_HowTo.Add "newImage", "a new image is there"
+    
+    Set Settings = New Dictionary
+    Dim Key As Variant
+    For Each Key In Keys
+        Settings.Add Key, ""
+    Next Key
+    Exit Sub
+errMsg:
+    ErrorLog.UpdateLog "OnlineIASettings.initializeDefault error " + Err.Description
+End Sub
+
+Public Function getSettings(Key As Variant) As Variant
+    Dim LogTxt As String
+    Dim i  As Integer
+    If Settings.Exists(Key) Then
+        getSettings = Settings.Item(Key)
+        Exit Function
+    End If
+    LogTxt = "OnlineIASettings.getSettings: Failed to get " + Key + " from OiaSettings. Possible values are:" & vbCrLf
+    LogTxt = LogTxt & available_subKey(Keys_HowTo)
+    
+    MsgBox LogTxt
+    ErrorLog.UpdateLog (LogTxt)
+End Function
+
+
+Public Function available_subKey(subKey_HowTo As Dictionary) As String
+    Dim TabSp  As String
+    Dim codeKeys() As Variant
+    Dim Key As Variant
+    codeKeys = subKey_HowTo.Keys
+    Dim LogTxt As String
+    For Each Key In codeKeys
+        If Len(CStr(Key)) > 6 Then
+            TabSp = "" & vbTab
+        Else
+            TabSp = "" & vbTab & vbTab
+        End If
+        LogTxt = LogTxt & "   " & Key & " " & TabSp & subKey_HowTo.Item(Key) & vbCrLf
+    Next Key
+    available_subKey = LogTxt
+End Function
+
+Public Function createKeyReport() As String
+    Dim report As String
+    report = "Windows registry keys to interact with Online image analysis" & vbCrLf
+    report = report & "location is: HKCU\SOFTWARE\VB and VBA Program Settings\OnlineImageAnalysis\macro" & vbCrLf
+    report = report & "All coordinates must be in pixels. (X, Y, Z) = (0,0,0) is the upper left corner, first slice." & vbCrLf
+    report = report & "------------------------" & vbCrLf
+    report = report & "Principal Keys and meaning:" & vbCrLf
+    report = report & available_subKey(Keys_HowTo)
+    report = report & "------------------------" & vbCrLf
+    report = report & "codeMic values:" & vbCrLf
+    report = report & available_subKey(subKey_codeMic_HowTo)
+    report = report & "------------------------" & vbCrLf
+    report = report & "codeOia values:" & vbCrLf
+    report = report & available_subKey(subKey_codeOia_HowTo)
+    report = report & "------------------------" & vbCrLf
+    report = report & "roiType values:" & vbCrLf
+    report = report & available_subKey(subKey_roiType_HowTo)
+    report = report & "------------------------" & vbCrLf
+    report = report & "roiAim values:" & vbCrLf
+    report = report & available_subKey(subKey_roiAim_HowTo)
+    
+    createKeyReport = report
+End Function
+
+
+'''
+' Check existence of Key and whether Item is consistent with it
+''
+Public Function checkKeyItem(Key As Variant, Value As Variant)
+    Dim errorMsg As String
+    If Settings.Exists(Key) Then
+        Settings.Item(Key) = Value
+        Select Case Key
+            Case "codeOia"
+                checkKeyItem = checkSubkey(CStr(Key), Value, subKey_codeOia_HowTo)
+                Exit Function
+            Case "codeMic"
+                checkKeyItem = checkSubkey(CStr(Key), Value, subKey_codeMic_HowTo)
+                Exit Function
+            Case "roiAim"
+                checkKeyItem = checkSubkey(CStr(Key), Value, subKey_roiAim_HowTo)
+            Case "roiType"
+                checkKeyItem = checkSubkey(CStr(Key), Value, subKey_roiType_HowTo)
+                Exit Function
+            Case Else
+                checkKeyItem = True
+        End Select
+    Else
+        errorMsg = "OnlineIASettings error: key " & CStr(Key) & " is not a correct key for registry. Values are " & vbCrLf
+        errorMsg = errorMsg & available_subKey(Keys_HowTo)
+        MsgBox errorMsg
+        ErrorLog.UpdateLog errorMsg
+    End If
+End Function
+
+Public Function checkSubkey(KeyName As String, Value As Variant, subKey_HowTo As Dictionary) As Boolean
+    Dim errorMsg As String
+    Dim Key As Variant
+    Dim codeKeys() As Variant
+    codeKeys = subKey_HowTo.Keys
+    For Each Key In codeKeys
+        If Value = Key Then
+            checkSubkey = True
+            Exit Function
+        End If
+    Next Key
+    errorMsg = "OnlineIASettings error: Wrong " & KeyName & " = " & Me.getSettings(KeyName) & " in Registry. Values are " & vbCrLf
+    errorMsg = errorMsg & available_subKey(subKey_HowTo)
+    MsgBox errorMsg
+    ErrorLog.UpdateLog errorMsg
+End Function
+
+
+
+'''
+'   check if Keys has been initialized
+'''
+Private Sub checkExistKeys()
+    If isArrayEmpty(Keys) Then
+        initializeDefault
+    End If
+End Sub
+
+
+'''
+' Default registry values is always empty
+'''
+Public Sub resetRegistry()
+    checkExistKeys
+    Dim i As Integer
+    For i = LBound(Keys) To UBound(Keys)
+        SaveSetting "OnlineImageAnalysis", "macro", Keys(i), ""
+    Next i
+End Sub
+
+''''
+'   ReadOiaSettingsFromRegistry(Settings As Collection, Keys() As String)
+'       Read Registry using the keys stored in Keys and create a new dictionary
+''''
+Public Sub readFromRegistry()
+    checkExistKeys
+    Dim Key As Variant
+    For Each Key In Keys
+        If Settings.Exists(Key) Then
+            Settings.Item(Key) = GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:=Key)
+        Else
+            Settings.Add Key, GetSetting(appname:="OnlineImageAnalysis", section:="macro", Key:=Key)
+        End If
+        checkKeyItem Key, Settings.Item(Key)
+    Next Key
+End Sub
+
+
+
+
+''''
+'   writeToRegistry()
+'       Write settings with keys defined in Keys to Registry
+''''
+
+Public Sub writeToRegistry()
+    checkExistKeys
+    Dim Key As Variant
+    For Each Key In Keys
+        If Settings.Exists(Key) Then
+            SaveSetting "OnlineImageAnalysis", "macro", Key, Settings.Item(Key)
+        End If
+    Next Key
+End Sub
+
+''''
+'   writeKeyToRegistry()
+'       Write a specific value in Key of registry
+''''
+Public Sub writeKeyToRegistry(Key As Variant, Value As Variant)
+    Dim Success As Boolean
+    checkExistKeys
+    
+    If checkKeyItem(Key, Value) Then
+        Settings.Item(Key) = Value
+        SaveSetting "OnlineImageAnalysis", "macro", Key, Value
+    End If
+End Sub
+
+''''
+'   ReadOiaSettingsFromFile(Settings As Dictionary, FileName As String)
+'       Read FileName and store key and paramter into Settings
+''''
+Public Sub readFromFile(FileName As String)
+    checkExistKeys
+    Dim iFileNum As Integer
+    Dim Fields As String
+    Dim FieldEntries() As String
+    Dim Entries() As String
+    Close
+    On Error GoTo ErrorHandle
+    iFileNum = FreeFile()
+    Open FileName For Input As iFileNum
+    Do While Not EOF(iFileNum)
+            Line Input #iFileNum, Fields
+            While Left(Fields, 1) = "%" 'this are comments
+                Line Input #iFileNum, Fields
+            Wend
+            FieldEntries = Split(Fields, " ", 2)
+            Settings.Add FieldEntries(0), FieldEntries(1)
+    Loop
+    Close #iFileNum
+    Exit Sub
+ErrorHandle:
+    MsgBox "Not able to read " & FileName & " for OiaSettings"
+End Sub
+
+''''
+'   WriteOiaSettingsToFile(Settings As Dictionary, FileName As String)
+'   Write Settings to file with FileName
+''''
+Public Sub writeToFile(FileName As String)
+    checkExistKeys
+    Dim i As Integer
+    Dim iFileNum As Integer
+    Dim Key As Variant
+    Close
+    'On Error GoTo ErrorHandle
+    iFileNum = FreeFile()
+    Open FileName For Output As iFileNum
+    
+    For Each Key In Settings.Keys
+        Print #iFileNum, Key & " " & Settings.Item(Key)
+    Next Key
+    Close
+ErrorHandle:
+End Sub
+
+''''
+'   Parse FileName to get name of SettingFile
+'   It is assumed that FileName = something_Txxx.lsm
+'   ToDO: better parsing
+'''
+Public Function settingsFileName(FileName As String) As String
+    settingsFileName = Left(FileName, Len(FileName) - 9) & "_oia.txt"
+End Function
+
+
+''''
+'   Parse rois from settings
+''''
+Public Function getRois(Rois() As Roi) As Boolean
+    checkExistKeys
+    Dim RoiOut() As Roi
+    Dim XRois()  As String 'the string containinig all X-positions of a ROI
+    Dim YRois()  As String 'the string containinig all Y-positions of a ROI
+    Dim X() As String ' string containing X pos of a single ROI
+    Dim Y() As String ' String containing y pos of a single ROI
+    Dim XD()  As Double 'the double array containinig the X-positions
+    Dim YD()  As Double 'the double array containinig the Y-positions
+    Dim i As Integer
+    Dim iRoi As Integer
+    Dim roiType() As String
+    Dim roiAim() As String
+    If Settings.Item("roiType") = "" Then
+        Exit Function
+    End If
+    roiType = Split(Settings.Item("roiType"), ";")
+    If Settings.Item("roiAim") = "" Or Settings.Item("roiX") = "" Or Settings.Item("roiY") = "" Then
+        ErrorLog.UpdateLog "OnlineIASettings.getRois: For each roi you need to define roiType, roiAim, roiX, and roiY! Different rois are separated by semicolumns. " + vbCrLf + "roiType1 ; roiType2; etc." & vbCrLf & _
+        "roiX1_roi1, roiX2_roi1; roiX1_roi2, roiX2_roi2, roiX3_roi2; etc. Coordinates in pixels"
+        Exit Function
+    End If
+    
+    roiAim = Split(Settings.Item("roiAim"), ";")
+    XRois() = Split(Settings.Item("roiX"), ";")
+    YRois() = Split(Settings.Item("roiY"), ";")
+    
+    If UBound(roiType) <> UBound(roiAim) And UBound(roiType) <> UBound(XRois) And UBound(roiType) <> UBound(YRois) Then
+       ErrorLog.UpdateLog "OnlineIASettings.getRois: Number of Rois and coordinates need to correspond. Different rois are separated by semicolumns. " + vbCrLf + "roiType1 ; roiType2; etc." & vbCrLf & _
+        "roiX1_roi1, roiX2_roi1; roiX1_roi2, roiX2_roi2, roiX3_roi2; etc. Coorindates in pixels"
+        Exit Function
+    End If
+    ReDim Rois(0 To UBound(roiType))
+    For iRoi = 0 To UBound(roiType)
+        X() = Split(XRois(iRoi), ",")
+        Y() = Split(YRois(iRoi), ",")
+        If isArrayEmpty(X) Or isArrayEmpty(Y) Then
+            MsgBox "GetRoisFromRegistry: No coordinates found in registry foir roix and roiy (in pixel)"
+            Exit Function
+        End If
+        ReDim XD(UBound(X))
+        ReDim YD(UBound(Y))
+        For i = 0 To UBound(X)
+            XD(i) = CDbl(X(i))
+            YD(i) = CDbl(Y(i))
+        Next i
+        Set Rois(iRoi) = New Roi
+        Rois(iRoi).setRoi roiType(iRoi), roiAim(iRoi), XD, YD
+        If Not Rois(iRoi).roiConsistency Then
+            Exit Function
+        End If
+    Next iRoi
+    getRois = True
+End Function
+
+
+'''
+'   GetPositionsFromSettings(Settings As Dictionary, StgPos() As Vector) As Boolean
+'   Settings contains all settings for OnlineImageanalysis
+'   StgPos containes the coordinates
+'   StgPos.X, StgPos.Y: defined 0,0 at upper left corner
+'   StgPos.Z: defined 0 for the central slice
+'   units are converted afterwards as it depends on the type of Job (default unit is px)
+''''
+Public Function getPositions(StgPos() As Vector, currentPosition As Vector) As Boolean
+    checkExistKeys
+    ' store postion from windows registry in array
+    Dim locX()  As String 'the string containinig the X-positions
+    Dim locY()  As String 'the string containinig the Y-positions
+    Dim locZ() As String  'the string containinig the Z-positions
+    Dim i As Integer
+    
+    If Settings.Exists("X") Then
+        locX() = Split(Settings.Item("X"), ";")
+    End If
+    
+    If isArrayEmpty(locX) Then
+        Exit Function
+    End If
+    
+    If Settings.Exists("Y") Then
+        locY() = Split(Settings.Item("Y"), ";")
+    End If
+    
+    If isArrayEmpty(locY) Then
+        Exit Function
+    End If
+    
+    If UBound(locX) <> UBound(locY) Then
+        ErrorLog.UpdateLog "OnlineIASettings.getPositions: nr of values in registry for X, Y are not the same, separate the values with semicolumn " _
+        & vbCrLf & "X=X1; X2; ..." & vbCrLf & "Y = Y1; Y2; Y3...."
+        Exit Function
+    End If
+    
+    If Settings.Exists("Z") Then
+        locZ() = Split(Settings.Item("Z"), ";")
+    End If
+    
+    If isArrayEmpty(locZ) Then 'Z has not been set. We use the currentvalue as default
+        ReDim locZ(UBound(locX))
+        For i = 0 To UBound(locX)
+            locZ(i) = currentPosition.Z
+        Next i
+    End If
+        
+    If UBound(locZ) <> UBound(locX) Then 'Z has not been set for all positions
+        ErrorLog.UpdateLog "OnlineIASettings.getPositions: nr of values in registry for X, Y, Z are not the same, separate the values with semicolumn " _
+        & vbCrLf & "X=X1; X2; ... " & vbCrLf & "Y = Y1; Y2; Y3.... " & vbCrLf & "Z = Z1; Z2; Z3.... "
+        Exit Function
+    End If
+    
+'    If Settings.Exists("deltaZ") Then
+'        locDeltaZ() = Split(Settings.Item("deltaZ"), ",")
+'    End If
+'
+'    If isArrayEmpty(locDeltaZ) Then
+'        ReDim locDeltaZ(UBound(locX)) 'deltaZ has not been set. We use a default values
+'        For i = 0 To UBound(locDeltaZ)
+'            locDeltaZ(i) = -1
+'        Next i
+'    End If
+'
+'    If UBound(locDeltaZ) <> UBound(locX) Then 'deltaZ has not been set for all positions
+'        MsgBox ("StorePositionsFromRegistry: nr of values in registry for deltaz, z are not the same, separate the values with comma!")
+'        Exit Function
+'    End If
+    
+    ' Convert values to Double
+    ReDim StgPos(0 To UBound(locX))
+    For i = 0 To UBound(locX)
+        StgPos(i).X = CDbl(locX(i))
+        StgPos(i).Y = CDbl(locY(i))
+        StgPos(i).Z = CDbl(locZ(i))
+    Next i
+    getPositions = True
+End Function
+
+'''
+'   GetPositionsFromSettings(Settings As Dictionary, StgPos() As Vector) As Boolean
+'   Settings contains all settings for OnlineImageanalysis
+'   StgPos containes the coordinates
+'   StgPos.X, StgPos.Y: defined 0,0 at upper left corner
+'   StgPos.Z: defined 0 for the central slice
+'   units are converted afterwards as it depends on the type of Job (default unit is px)
+''''
+Public Function getFcsPositions(StgPos() As Vector, currentPosition As Vector) As Boolean
+    checkExistKeys
+    ' store postion from windows registry in array
+    Dim locX()  As String 'the string containinig the X-positions
+    Dim locY()  As String 'the string containinig the Y-positions
+    Dim locZ() As String  'the string containinig the Z-positions
+    Dim i As Integer
+    
+    If Settings.Exists("fcsX") Then
+        locX() = Split(Settings.Item("fcsX"), ";")
+    End If
+    
+    If isArrayEmpty(locX) Then
+        Exit Function
+    End If
+    
+    If Settings.Exists("fcsY") Then
+        locY() = Split(Settings.Item("fcsY"), ";")
+    End If
+    
+    If isArrayEmpty(locY) Then
+        Exit Function
+    End If
+    
+    If UBound(locX) <> UBound(locY) Then
+        ErrorLog.UpdateLog "OnlineIASettings.getFcsPositions: nr of values in registry for fcsX, fcsY are not the same, separate the values with semicolumn " _
+        & vbCrLf & "fcsX=X1; X2; ..." & vbCrLf & "Y = Y1; Y2; Y3...."
+        Exit Function
+    End If
+    
+    If Settings.Exists("fcsZ") Then
+        locZ() = Split(Settings.Item("fcsZ"), ";")
+    End If
+    
+    If isArrayEmpty(locZ) Then 'Z has not been set. We use the currentvalue as default
+        ReDim locZ(UBound(locX))
+        For i = 0 To UBound(locX)
+            locZ(i) = currentPosition.Z
+        Next i
+    End If
+        
+    If UBound(locZ) <> UBound(locX) Then 'Z has not been set for all positions
+        ErrorLog.UpdateLog "OnlineIASettings.getFcsPositions: nr of values in registry for fcsX, fcsY, fcsZ are not the same, separate the values with semicolumn " _
+        & vbCrLf & "fcsX=X1; X2; ... " & vbCrLf & "fcsY = Y1; Y2; Y3.... " & vbCrLf & "fcsZ = Z1; Z2; Z3.... "
+        Exit Function
+    End If
+    
+    ' Convert values to Double
+    ReDim StgPos(0 To UBound(locX))
+    For i = 0 To UBound(locX)
+        StgPos(i).X = CDbl(locX(i))
+        StgPos(i).Y = CDbl(locY(i))
+        StgPos(i).Z = CDbl(locZ(i))
+    Next i
+    getFcsPositions = True
+End Function
+
+
+
diff --git a/AutofocusScreen/src/AutofocusScreen/OnlineImageAnalysisIO.bas b/AutofocusScreen/src/AutofocusScreen/OnlineImageAnalysisIO.bas
new file mode 100644
index 0000000..5c99614
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/OnlineImageAnalysisIO.bas
@@ -0,0 +1,278 @@
+Attribute VB_Name = "OnlineImageAnalysisIO"
+Option Explicit
+
+Public Sub testOiaSettings()
+    Dim Settings As OnlineIASettings
+    Set Settings = New OnlineIASettings
+    
+End Sub
+''''
+'' A set of functions to IN/OUT parameters for Onlineimageanalisys this should be a class!!!
+'''''
+'
+'''''
+'' Set Registry to default values
+''''
+'Public Sub SetRegistryKeyNames(Keys() As String)
+''This variable contains the keys for the OnlineImageanalysis
+'    ReDim Keys(11)
+'    Keys(0) = "code"
+'    Keys(1) = "fileAnalyzed"
+'    Keys(2) = "filePath"
+'    Keys(3) = "X"
+'    Keys(4) = "Y"
+'    Keys(5) = "Z"
+'    Keys(6) = "deltaZ"
+'    Keys(7) = "roiType"
+'    Keys(8) = "roiAim"
+'    Keys(9) = "roiX"
+'    Keys(10) = "roiY"
+'    Keys(11) = "unit"
+'End Sub
+'
+''''
+'' Default registry value is always empty
+''''
+'Public Sub resetRegistry(Keys() As String)
+'    Dim i As Integer
+'    For i = LBound(Keys) To UBound(Keys)
+'        SaveSetting "OnlineImageAnalysis", "macro", Keys(i), ""
+'    Next i
+'End Sub
+'
+'''''
+''   ReadOiaSettingsFromRegistry(Settings As Collection, Keys() As String)
+''       Read Registry using the keys stored in Keys and create a new dictionary
+'''''
+'Public Sub ReadOiaSettingsFromRegistry(Settings As Dictionary, Keys() As String)
+'    Set Settings = New Dictionary
+'    Dim key As Variant
+'    For Each key In Keys
+'        Settings.Add key, GetSetting(appname:="OnlineImageAnalysis", section:="macro", key:=key)
+'    Next key
+'End Sub
+'
+'''''
+''   WriteOiaSettingsToRegistry(Settings As Dictionary, Keys() As String)
+''       Write settings with keys defined in Keys to Registry
+'''''
+'
+'Public Sub writeOiaSettingsToRegistry(Settings As Dictionary, Keys() As String)
+'    Dim key As Variant
+'    For Each key In Keys
+'        If Settings.Exists(key) Then
+'            SaveSetting "OnlineImageAnalysis", "macro", key, Settings.Item(key)
+'        End If
+'    Next key
+'End Sub
+'
+'''''
+''   ReadOiaSettingsFromFile(Settings As Dictionary, FileName As String)
+''       Read FileName and store key and paramter into Settings
+'''''
+'Public Sub ReadOiaSettingsFromFile(Settings As Dictionary, FileName As String)
+'    Set Settings = New Dictionary
+'    Dim iFileNum As Integer
+'    Dim Fields As String
+'    Dim FieldEntries() As String
+'    Dim Entries() As String
+'    Close
+'    On Error GoTo ErrorHandle
+'    iFileNum = FreeFile()
+'    Open FileName For Input As iFileNum
+'    Do While Not EOF(iFileNum)
+'            Line Input #iFileNum, Fields
+'            While Left(Fields, 1) = "%" 'this are comments
+'                Line Input #iFileNum, Fields
+'            Wend
+'            FieldEntries = Split(Fields, " ", 2)
+'            Settings.Add FieldEntries(0), FieldEntries(1)
+'    Loop
+'    Close #iFileNum
+'    Exit Sub
+'ErrorHandle:
+'    MsgBox "Not able to read " & FileName & " for OiaSettings"
+'End Sub
+'
+'''''
+''   WriteOiaSettingsToFile(Settings As Dictionary, FileName As String)
+''   Write Settings to file with FileName
+'''''
+'Public Sub WriteOiaSettingsToFile(Settings As Dictionary, FileName As String)
+'    Dim i As Integer
+'    Dim iFileNum As Integer
+'    Dim key As Variant
+'    Close
+'    'On Error GoTo ErrorHandle
+'    iFileNum = FreeFile()
+'    Open FileName For Output As iFileNum
+'
+'    For Each key In Settings.Keys
+'        Print #iFileNum, key & " " & Settings.Item(key)
+'    Next key
+'    Close
+'ErrorHandle:
+'End Sub
+'
+'''''
+''   Parse FileName to get name of SettingFile
+''   It is assumed that FileName = something_Txxx.lsm
+''   ToDO: better parsing
+''''
+'Public Function OiaSettingsFileName(FileName As String) As String
+'    OiaSettingFileName = Left(FileName, Len(FileName) - 9) & "_oia.txt"
+'End Function
+'
+'
+'''''
+''   Parse rois from settings
+''   This should be put in the Jobdefinition as a Roi is associated to a Job
+'''''
+'Public Function GetRoisFromSettings(OiaSettings As Dictionary) As Roi()
+'    Dim RoiOut() As Roi
+'    Dim XRois()  As String 'the string containinig all X-positions of a ROI
+'    Dim YRois()  As String 'the string containinig all Y-positions of a ROI
+'    Dim X() As String ' string containing X pos of a single ROI
+'    Dim Y() As String ' String containing y pos of a single ROI
+'    Dim XD()  As Double 'the double array containinig the X-positions
+'    Dim YD()  As Double 'the double array containinig the Y-positions
+'    Dim i As Integer
+'    Dim iRoi As Integer
+'    If OiaSettings.Item("roiType") = "" Then
+'        Exit Function
+'    End If
+'
+'    roiType = Split(OiaSettings.Item("roiType"), ";")
+'
+'    If OiaSettings.Item("roiAim") = "" Or OiaSettings.Item("roiX") = "" Or OiaSettings.Item("roiY") = "" Then
+'        MsgBox ("GetRoisFromRegistry: For each roi you need to define roiType, roiAim, roiX, and roiY!" + vbCrLf + "roiType1 ; roiType2; etc." & vbCrLf & _
+'        "roiX1_roi1, roiX2_roi1; roiX1_roi2, roiX2_roi2, roiX3_roi2; etc. Coordinates in pixels")
+'        Exit Function
+'    End If
+'
+'    roiAim = Split(OiaSettings.Item("roiAim"), ";")
+'    XRois() = Split(OiaSettings.Item("roiX"), ";")
+'    YRois() = Split(OiaSettings.Item("roiY"), ";")
+'
+'    If UBound(roiType) <> UBound(roiAim) And UBound(roiType) <> UBound(XRoi) And UBound(roiType) <> UBound(YRoi) Then
+'        MsgBox ("GetRoisFromRegistry: Number of Rois and coordinates need to correspond." + vbCrLf + "roiType1 ; roiType2; etc." & vbCrLf & _
+'        "roiX1_roi1, roiX2_roi1; roiX1_roi2, roiX2_roi2, roiX3_roi2; etc. Coorindates in pixels")
+'        Exit Function
+'    End If
+'    ReDim RoiOut(0 To UBound(roiType))
+'    For iRoi = 0 To UBound(roiType)
+'        X() = Split(XRois(iRoi), ",")
+'        Y() = Split(YRois(iRoi), ",")
+'        If isArrayEmpty(X) Or isArrayEmpty(Y) Then
+'            MsgBox "GetRoisFromRegistry: No coordinates found in registry foir roix and roiy (in pixel)"
+'            Exit Function
+'        End If
+'        ReDim XD(UBound(X))
+'        ReDim YD(UBound(Y))
+'        For i = 0 To UBound(X)
+'            XD(i) = CDbl(X(i))
+'            YD(i) = CDbl(Y(i))
+'        Next i
+'        RoiOut(iRoi).setRoi roiType(iRoi), roiAim(iRoi), CDbl(X), CDbl(YK)
+'        If Not RoiOut(iRoi).roiConsitency Then
+'            Exit Function
+'        End If
+'    Next iRoi
+'    GetRoisFromSettings = RoiOut
+'End Function
+'
+'
+''''
+''   GetPositionsFromSettings(OiaSettings As Dictionary, X() As Double, Y() As Double, Z() As Double, deltaZ() As Integer) As Boolean
+''   OiaSettings contains all settings for OnlineImageanalysis (see OiaKeys)
+''   StgPos containes the coordinates
+''   StgPos.X, StgPos.Y: defined 0,0 at upper left corner
+''   StgPos.Z: defined 0 at central slice
+''   units are converted afterwards as it depends on the type of Job (default unit is px)
+'''''
+'Public Function GetPositionsFromSettings(OiaSettings As Dictionary, StgPos() As Vector) As Boolean
+'
+'    ' store postion from windows registry in array
+'    Dim locX()  As String 'the string containinig the X-positions
+'    Dim locY()  As String 'the string containinig the Y-positions
+'    Dim locZ() As String  'the string containinig the Z-positions
+'    Dim i As Integer
+''    If OiaSettings.Exists("unit") Then
+''        If OiaSettings.Item("unit") = "um" Or OiaSettings.Item("unit") = Chr(181) & "m" Then      'has correct pixelSize of um
+''            pixelSizeXY = 1
+''            pixelSizeZ = 1
+''        ElseIf OiaSettings.Item("unit") = "px" Or OiaSettings.Item("unit") = "" Then
+''            pixelSizeXY = Jobs.GetSampleSpacing(JobName) * 1000000
+''            pixelSizeZ = Jobs.GetFrameSpacing(JobName)
+''        Else
+''            MsgBox "GetPositionsFromSettings: Do not understand unit " & OiaSettings.Item("unit") & ". Possible value for registry entry unit are um or px!"
+''            Exit Function
+''        End If
+''    Else
+''        pixelSizeXY = Jobs.GetSampleSpacing(JobName) * 1000000
+''        pixelSizeZ = Jobs.GetFrameSpacing(JobName)
+''    End If
+'
+'    If OiaSettings.Exists("X") Then
+'        locX() = Split(OiaSettings.Item("X"), ",")
+'    End If
+'
+'    If isArrayEmpty(locX) Then
+'        Exit Function
+'    End If
+'
+'    If OiaSettings.Exists("Y") Then
+'        locY() = Split(OiaSettings.Item("Y"), ",")
+'    End If
+'
+'    If isArrayEmpty(locY) Then
+'        Exit Function
+'    End If
+'
+'    If UBound(locX) <> UBound(locY) Then
+'        MsgBox ("StorePositionsFromRegistry: nr of values in registry for X, Y are not the same, separate the values with comma!")
+'        Exit Function
+'    End If
+'
+'    If OiaSettings.Exists("Z") Then
+'        locZ() = Split(OiaSettings.Item("Z"), ",")
+'    End If
+'
+'    If isArrayEmpty(locZ) Then 'ZOffset has not been set. We use a default values
+'        ReDim locZ(UBound(locX))
+'        For i = 0 To UBound(locX)
+'            locZ(i) = 0
+'        Next i
+'    End If
+'
+'    If UBound(locZ) <> UBound(locX) Then 'Z has not been set for all positions
+'        MsgBox ("StorePositionsFromRegistry: nr of values in registry for offsetX, offsetZ are not the same, separate the values with comma!")
+'        Exit Function
+'    End If
+'
+'    If OiaSettings.Exists("deltaZ") Then
+'        locDeltaZ() = Split(OiaSettings.Item("deltaZ"), ",")
+'    End If
+'
+'    If isArrayEmpty(locDeltaZ) Then
+'        ReDim locDeltaZ(UBound(locX)) 'deltaZ has not been set. We use a default values
+'        For i = 0 To UBound(locDeltaZ)
+'            locDeltaZ(i) = -1
+'        Next i
+'    End If
+'
+'    If UBound(locDeltaZ) <> UBound(locX) Then 'deltaZ has not been set for all positions
+'        MsgBox ("StorePositionsFromRegistry: nr of values in registry for deltaz, z are not the same, separate the values with comma!")
+'        Exit Function
+'    End If
+'
+'    ' Convert values to Double
+'    ReDim StgPos(0 To UBound(locX))
+'    For i = 0 To UBound(locX)
+'        StgPos(i).X = CDbl(locX(i))
+'        StgPos(i).Y = CDbl(locY(i))
+'        StgPos(i).Z = CDbl(locZ(i))
+'    Next i
+'    GetPositionsFromSettings = True
+'End Function
+'
diff --git a/AutofocusScreen/src/AutofocusScreen/Roi.cls b/AutofocusScreen/src/AutofocusScreen/Roi.cls
new file mode 100644
index 0000000..6852349
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/Roi.cls
@@ -0,0 +1,236 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "Roi"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
+'Roi Class
+'Allows to store a Roi check for its consitency and create it
+'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
+Option Explicit
+Public roiType As String   'circle, rectangle, polyline, ellipse
+Public roiAim As String    'acquisition, bleach, analysis
+Private roiX() As Double   'set of X coordinates in pixels
+Private roiY() As Double   'set of Y coordinates in pixels
+Private roiAimDic As Dictionary 'map name to number
+Private roiTypeDic As Dictionary ' map name to number
+
+
+Private Sub populateDic()
+    Set roiAimDic = New Dictionary
+    Set roiTypeDic = New Dictionary
+    roiAimDic.Add "", 0
+    roiAimDic.Add "nothing", 0
+    roiAimDic.Add "bleach", AimVectorOverlay40.eVectorOverlayAcquisitionFlagsBleach Or AimVectorOverlay40.eVectorOverlayAcquisitionFlagsAnalysis
+    roiAimDic.Add "acquisition", AimVectorOverlay40.eVectorOverlayAcquisitionFlagsAcquisition
+    roiAimDic.Add "acquisitionBleach", AimVectorOverlay40.eVectorOverlayAcquisitionFlagsAcquisition Or AimVectorOverlay40.eVectorOverlayAcquisitionFlagsAnalysis _
+            Or AimVectorOverlay40.eVectorOverlayAcquisitionFlagsBleach
+            
+    roiTypeDic.Add "circle", eImageVectorOverlayElementCircle
+    roiTypeDic.Add "rectangle", eImageVectorOverlayElementRectangle
+    roiTypeDic.Add "polyline", eImageVectorOverlayElementClosedPolyLine
+    roiTypeDic.Add "ellipse", eImageVectorOverlayElementEllipse
+    
+End Sub
+
+Private Function createRoiTxt(roiTypeI As Integer, roiAimI As Integer) As Boolean
+    Dim i As Integer
+    Dim Keys() As Variant
+    Dim Items() As Variant
+    
+    If (roiAimDic Is Nothing) Or (roiTypeDic Is Nothing) Then
+        populateDic
+    End If
+    Keys = roiAimDic.Keys
+    Items = roiAimDic.Items
+    Me.roiAim = ""
+    Me.roiType = ""
+    For i = 0 To UBound(Items)
+        If Items(i) = roiAimI Then
+            Me.roiAim = Keys(i)
+            Exit For
+        End If
+    Next i
+    
+    If Me.roiAim = "" Then
+        MsgBox "roi with code roiAim : " & roiAimI & "is not implemented"
+        Exit Function
+    End If
+    
+    Keys = roiTypeDic.Keys
+    Items = roiTypeDic.Items
+    For i = 0 To UBound(Items)
+        If Items(i) = roiTypeI Then
+            Me.roiType = Keys(i)
+            Exit For
+        End If
+    Next i
+    
+    If Me.roiType = "" Then
+        MsgBox "roi with code roiType : " & roiTypeI & "is not implemented"
+        Exit Function
+    End If
+    createRoiTxt = True
+    
+End Function
+
+
+Public Sub setX(X() As Double)
+    roiX = X
+End Sub
+
+
+Public Sub setY(Y() As Double)
+    roiY = Y
+End Sub
+
+
+Public Function getX() As Double()
+    getX = roiX
+End Function
+
+
+Public Function getY() As Double()
+    getY = roiY
+End Function
+
+Public Sub setRoiFomZen(roiNr As Integer)
+    On Error GoTo ErrorHandle
+    Dim vo As AimImageVectorOverlay
+    Dim i As Long
+    Dim X() As Double
+    Dim Y() As Double
+    Set vo = Lsm5.ExternalDsObject.Scancontroller.AcquisitionRegions
+    'Debug.Print "nr Elements "; vo.GetNumberElements
+    If roiNr <= vo.GetNumberElements Then
+        If createRoiTxt(vo.ElementType(roiNr), vo.ElementAcquisitionFlags(roiNr)) Then
+            ReDim X(0 To vo.GetElementNumberKnots(roiNr) - 1)
+            ReDim Y(0 To vo.GetElementNumberKnots(roiNr) - 1)
+            For i = 0 To vo.GetElementNumberKnots(roiNr) - 1
+                vo.GetElementKnot roiNr, i, X(i), Y(i), 0, 0
+            Next i
+            Me.setX X
+            Me.setY Y
+        Else
+             MsgBox "Roi.setRoiFromZen: problems in generating Roi"
+        End If
+    Else
+        MsgBox "Roi.setRoiFromZen no roi nr " & roiNr + 1
+    End If
+Exit Sub
+ErrorHandle:
+   MsgBox "Error in Roi.setRoiFromZen " & Err.Description
+End Sub
+
+Public Sub setRoi(roiType As String, roiAim As String, X() As Double, Y() As Double)
+    Me.roiType = roiType
+    Me.roiAim = roiAim
+    roiX = X
+    roiY = Y
+    If Not roiConsistency Then
+        MsgBox "Wrong dimensions/type/aim for  roi " + roiType + " " + roiAim
+    End If
+End Sub
+
+
+'''''
+' remove all vector elements
+'''''
+Public Function ClearVectorElements() As Boolean
+    Dim vo As AimImageVectorOverlay
+    Set vo = Lsm5.ExternalDsObject.Scancontroller.AcquisitionRegions
+    vo.Cleanup
+End Function
+
+Public Function roiConsistency() As Boolean
+    Dim i As Integer
+    If (roiAimDic Is Nothing) Or (roiTypeDic Is Nothing) Then
+        populateDic
+    End If
+    
+    If roiType <> "" And roiAim <> "" Then
+        If UBound(roiX) <> UBound(roiY) Then
+            MsgBox "For Roi: roiX and roiY coordinates need to be the same"
+            Exit Function
+        End If
+    Else
+        MsgBox "For Roi: a type and aim need to be defined"
+        Exit Function
+    End If
+     
+    If Not roiTypeDic.Exists(roiType) Then
+        MsgBox "Roi.roiConsistency: Does not understand the type of Roi" + roiType + ". Types are circle, rectangle, polyline, ellipse"
+        Exit Function
+    End If
+    
+    Select Case roiType
+        Case "circle":
+            If UBound(roiX) <> 1 Or UBound(roiY) <> 1 Then
+                MsgBox "roiConsistency: For a roiType=" + roiType + "ROI you have to define 2 points (in px)" + vbCrLf _
+                & "roiX=center_X, point_on_circle_X" & vbCrLf & "roiY=center_Y, point_on_circle_Y"
+                Exit Function
+            End If
+        Case "rectangle":
+            If UBound(roiX) <> 1 Or UBound(roiY) <> 1 Then
+                MsgBox "roiConsistency: For a roiType=" + roiType + "ROI you have to define 2 points (in px)" + vbCrLf _
+                & "roiX=upper_left_X, lower_right_X" & vbCrLf & "roiY=upper_left_Y, lower_right_Y"
+                Exit Function
+            End If
+        Case "polyline":
+            If UBound(roiX) <> UBound(roiY) Or UBound(roiY) < 2 Then
+                MsgBox "roiConsistency: For a roiType=" + roiType + "ROI you have to define at least 3 points (in px)" + vbCrLf _
+                & "roiX=point1_X, point2_X ..." & vbCrLf & "roiY=point1_Y, point2_Y..."
+                Exit Function
+            End If
+        Case "ellipse":
+            If UBound(roiX) <> 2 Or UBound(roiX) <> 2 Then
+                MsgBox "roiConsistency: For a roiType=" + roiType + "ROI you have to define 3 points (in px). Center point_on_axis1 point_on_axis2" + vbCrLf _
+                & "roiX=center_X, axis1_X, axis2_X" & vbCrLf & "roiY= center_Y, axis1_Y, axis2_Y"
+                Exit Function
+            End If
+        Case Else:
+            MsgBox "roiConsistency: Does not understand the type of Roi" + roiType + ". Types are circle, rectangle, polyline, ellipse"
+            Exit Function
+    End Select
+    
+    If Not roiAimDic.Exists(Me.roiAim) Then
+        MsgBox "Roi.roiConsistency: Does not understand the aim of Roi, roiAim = " & roiAim & vbCrLf & _
+        ". Aims are acquisition, bleach, bleachAnalysis, acquisitionBleach, acquisitionAnalysis, acquisitionBleachAnalysis"
+        Exit Function
+    End If
+    
+    roiConsistency = True
+End Function
+
+''''
+' Make a Vectorelement (a ROI) to be used for bleaching or imaging
+''''
+Public Function MakeVectorElement() As Boolean
+    If Not roiConsistency Then
+        Exit Function
+    End If
+    
+    If (roiAimDic Is Nothing) Or (roiTypeDic Is Nothing) Then
+        populateDic
+    End If
+    
+    Dim vo As AimImageVectorOverlay
+    Set vo = Lsm5.ExternalDsObject.Scancontroller.AcquisitionRegions
+
+    Dim i As Integer
+    Dim ElementNumber As Long
+    
+    vo.AddElement roiTypeDic.Item(roiType)
+    ElementNumber = vo.GetNumberElements - 1
+    For i = 0 To UBound(roiX)
+        vo.AppendElementKnot ElementNumber, roiX(i), roiY(i), 0, 0
+    Next i
+    Sleep 50 ' this pause is require to finish setting the elements
+    vo.ElementAcquisitionFlags(ElementNumber) = roiAimDic.Item(roiAim)
+    MakeVectorElement = True
+End Function
+
diff --git a/AutofocusScreen/src/AutofocusScreen/RoiControl.bas b/AutofocusScreen/src/AutofocusScreen/RoiControl.bas
index df3db81..1dc0603 100644
--- a/AutofocusScreen/src/AutofocusScreen/RoiControl.bas
+++ b/AutofocusScreen/src/AutofocusScreen/RoiControl.bas
@@ -1,18 +1,35 @@
 Attribute VB_Name = "RoiControl"
+'''
+' Module for Roi control. Due to roi class this module is close to become obsolete
+''''
+
+Option Explicit
 Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
 
+
+
+
+'''''
+' remove all vector elements
+'''''
+Public Function ClearVectorElements() As Boolean
+    Dim vo As AimImageVectorOverlay
+    Set vo = Lsm5.ExternalDsObject.Scancontroller.AcquisitionRegions
+    vo.Cleanup
+End Function
+
 ''''
 ' Make a Vectorelement (a ROI) to be used for bleaching or imaging
 '   TypeVectorOverlay (In) - speifies type of ROI. "circle", "reactangle", "polyline", "ellipse"
 '   X, Y              (In) - X and Y coordinates in pixel!! Upper left corner of image is 0, 0
 '   Aim               (In) - Either "acquisition", "bleaching" (also includes analysis) or "analysis"
 ''''
-Public Function MakeVectorElement(ByVal TypeVectorOverlay As String, X() As Double, Y() As Double, ByVal Aim As String) As Boolean
-    Dim AcquisitionController As AimAcquisitionController40.AimScanController
-    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
+Public Function MakeVectorElement(ByVal TypeVectorOverlay As String, X() As Double, Y() As Double, ByVal aim As String) As Boolean
+'    Dim AcquisitionParameter As AimAcquisitionController40.AimAcquisitionParameters
+'    Set AcquisitionParameter = Lsm5.ExternalDsObject.Scancontroller
     ' Get the Acquisition/Bleach ROIs
     Dim vo As AimImageVectorOverlay
-    Set vo = AcquisitionController.AcquisitionRegions
+    Set vo = Lsm5.ExternalDsObject.Scancontroller.AcquisitionRegions
 
     Dim i As Integer
     Dim ElementNumber As Long
@@ -52,7 +69,7 @@ Public Function MakeVectorElement(ByVal TypeVectorOverlay As String, X() As Doub
         vo.AppendElementKnot ElementNumber, X(i), Y(i), 0, 0
     Next i
     Sleep 50 ' this pause is require to finish setting the elements
-    Select Case Aim
+    Select Case aim
         Case "Acquisition", "acquisition":
             vo.ElementAcquisitionFlags(ElementNumber) = AimVectorOverlay40.eVectorOverlayAcquisitionFlagsAcquisition
             vo.ElementColor(ElementNumber) = "&H0000C000" 'this is green
@@ -67,7 +84,7 @@ Public Function MakeVectorElement(ByVal TypeVectorOverlay As String, X() As Doub
     
 End Function
 
-Sub TestMakeVectorElement(Optional test As Integer)
+Private Sub TestMakeVectorElement()
     Dim AcquisitionController As AimAcquisitionController40.AimScanController
     Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
     Dim X() As Double
@@ -103,52 +120,4 @@ Sub TestMakeVectorElement(Optional test As Integer)
     MakeVectorElement "polyline", X, Y, "acquisition"
 End Sub
 
-''''
-'   ComputeCenter of mass of vector element. Not used
-'''''
-Sub GetCenterVectorElements(Rois As AimImageVectorOverlay, Element As Long, XCenter As Double, YCenter As Double)
-    Dim Knot As Long
-    Dim T As Double
-    Dim Z As Double
-    Dim X As Double
-    Dim Y As Double
-    XCenter = 0
-    YCenter = 0
-    If Element < Rois.GetNumberElements And Element > -1 Then
-        Select Case Rois.ElementType(Element)
-            Case eImageVectorOverlayElementRectangle
-                For Knot = 0 To Rois.ElementKnotSize(Element) - 2
-                   Rois.GetElementKnot Element, Knot, X, Y, Z, T
-                   XCenter = XCenter + X
-                   YCenter = YCenter + Y
-                Next Knot
-                XCenter = XCenter / (Rois.ElementKnotSize(Element) - 1)
-                YCenter = YCenter / (Rois.ElementKnotSize(Element) - 1)
-            Case eImageVectorOverlayElementCircle
-                Rois.GetElementKnot Element, 0, XCenter, YCenter, Z, T
-            Case eImageVectorOverlayElementClosedPolyLine
-                For Knot = 0 To Rois.ElementKnotSize(Element) - 2
-                   Rois.GetElementKnot Element, Knot, X, Y, Z, T
-                   XCenter = XCenter + X
-                   YCenter = YCenter + Y
-                Next Knot
-                XCenter = XCenter / (Rois.ElementKnotSize(Element) - 1)
-                YCenter = YCenter / (Rois.ElementKnotSize(Element) - 1)
-        End Select
-    End If
-End Sub
-
-
-'Sub TranslateVectorElements(Rois As AimImageVectorOverlay, X As Double, Y As Double, Z As Double)
-'    Dim i As Long
-'    Rois.Copy Rois, 1, 0, 0, 0, X, 0, 1, 0, 0, Y, 0, 0, 1, 0, Z, 0, 0, 0, 0, 0
-'End Sub
-
-
-
 
-'Sub GetVectorElements(Rois As AimImageVectorOverlay)
-'    Dim AcquisitionController As AimAcquisitionController40.AimScanController
-'    Set AcquisitionController = Lsm5.ExternalDsObject.ScanController
-'    Set Rois = AcquisitionController.AcquisitionRegions
-'End Sub
diff --git a/AutofocusScreen/src/AutofocusScreen/Stage_Grid.bas b/AutofocusScreen/src/AutofocusScreen/Stage_Grid.bas
deleted file mode 100644
index 71afbf4..0000000
--- a/AutofocusScreen/src/AutofocusScreen/Stage_Grid.bas
+++ /dev/null
@@ -1,187 +0,0 @@
-Attribute VB_Name = "Stage_Grid"
-Public GlobalPositionsStage As Long 'is used
-Public GlobalXpos() As Double ' not really used check this is now posMultiLocationX
-Public GlobalYpos() As Double ' not really used check posMultiLocationY
-Public GlobalZpos() As Double ' not really used check posMultiLocationZ
-Public GlobalLocationsName() As String  ' not really used check
-Public GlobalLocationsNameOld() As String ' not really used check
-Public GlobalZposOld() As Double ' not really used check
-Public GlobalXposOld() As Double ' not really used check
-Public GlobalYposOld() As Double ' not really used check
-Public dsDoc As DsRecordingDoc
-Public Stage As CpStages ' has been defined twice
-Public GettingZmap As Boolean ' not really used
-Public idpos As Long
-
-Public X As Long ' does it make sense to have it as global variable?
-Public Y As Long ' does it make sense to have it as global variable?
-    
-
-
-
-Public GlobalDeActivatedLocations() As Boolean
-Public GlobalLocationsOrder() As Long
-Public GlobalLocationsOrderOld() As Long
-
-
-
-Public Const ZBacklash = 0 'ToDo: is it still recquired?. Has to do with the movements of the focus wheel that are "better" if they are long enough.
-
-
-Public Sub MakeBlankImage(DestImage As DsRecordingDoc, _
-BitsPerSample As Long, bpp As Long, Visible As Boolean, _
-ImgName As String, TimeSeries As Boolean, NumberScans As Long, XPixels As Long, YPixels As Long, Channels As Long)
-Dim i As Long
-
-Dim Success As Integer
-Dim DataChannel As DsDataChannel
-Dim DataChannelIndex As Long
-Dim Track As DsTrack
-Dim TrackIndex As Long
-Dim lpReOpenBuff As OFSTRUCT
-Dim lpRootPathName As String
-Dim lpSectorsPerCluster As Long
-Dim lpBytesPerSector As Long
-Dim lpNumberOfFreeClusters As Long
-Dim lpTotalNumberOfClusters As Long
-Dim lSpace As Long
-Dim lFreeSpace As Double
-Dim fSize As Double
-Dim hFile As Long
-Dim zIndex As Long
-Dim TimeIndex As Long
-Dim channel As Long
-Dim SourceChannel As Long
-Dim NumberChannels As Long
-Dim DestStackNumber As Long
-Dim TimeStampIndex As Long
-Dim indxArr() As Long
-Dim NumberOfSelected As Long
-Dim NumberOfStacks As Long
-
-'Dim Channels() As String
-Dim ReturnValue As Boolean
-Dim OK As Boolean
-Dim scnline As Variant
-Dim spl As Long
-Dim Tnum As Long
-Dim newTime As Double
-Dim myDate As Date
-Dim myDate1 As Date
-Dim newTime1 As Double
-Dim myTime As Date
-Dim OldImage As Object
-Dim ImageType As Long   'ImageType=1 Non Lambda Stack, ImageType=2 Lambda Stack
-                
-    If TimeSeries Then
-        Set DestImage = Lsm5.MakeNewImageDocument(XPixels, _
-        YPixels, 1, NumberScans, _
-        Channels, bpp, Visible)
-    Else
-        Set DestImage = Lsm5.MakeNewImageDocument(XPixels, _
-        YPixels, 1, 1, _
-        Channels, bpp, Visible)
-    End If
-    If (DestImage Is Nothing) Then
-        MsgBox "Cannot Create New Window!", VbExclamation
-        Exit Sub
-    End If
-    If TimeSeries Then
-        DestImage.Recording.TimeSeries = True
-    Else
-        DestImage.Recording.TimeSeries = False
-    End If
-
-    DestImage.SetTitle ImgName
-            
-    
-Finish:
-
-End Sub
-
-
-Public Sub ReadLoc(X As Double, Y As Double)
-    Dim Cnt As Long
-    
-    Cnt = 0
-    On Error GoTo retry
-retry:
-    If Cnt > 1000 Then GoTo Finish
-    Cnt = Cnt + 1
-    X = Lsm5.Hardware.CpStages.PositionX
-    Y = Lsm5.Hardware.CpStages.PositionY
-Finish:
-End Sub
-
-Public Sub CoordinateConversion(bExchangeXY As Boolean, bMirrorX As Boolean, bMirrorY As Boolean)
-    Dim bLSM As Boolean
-    Dim bLIVE As Boolean
-    Dim bCamera As Boolean
-    Dim lsystem As Long
-'    If GlobalSystemVersion = 32 Then
-'        Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisState bExchangeXY, bMirrorX, bMirrorY
-'    ElseIf GlobalSystemVersion > 32 Then
-        UsedDevices40 bLSM, bLIVE, bCamera
-        If bLSM Then
-            lsystem = 0
-        ElseIf bLIVE Then
-            lsystem = 1
-        ElseIf bCamera Then
-            lsystem = 3
-        End If
-'    End If
-    Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS lsystem, bExchangeXY, bMirrorX, bMirrorY
-
-End Sub
-
-'''''
-'   UsedDevices40(bLSM As Boolean, bLIVE As Boolean, bCamera As Boolean)
-'   Ask which system is the macro runnning on
-'       [bLSM]  In/Out - True if LSM system
-'       [bLive] In/Out - True for LIVE system
-'       [bCamera] In/Out - True if Camera is used
-''''
-Public Sub UsedDevices40(bLSM As Boolean, bLIVE As Boolean, bCamera As Boolean)
-    Dim Scancontroller As AimScanController
-    Dim TrackParameters As AimTrackParameters
-    Dim Size As Long
-    Dim lTrack As Long
-    Dim eDeviceMode As Long
-    
-    bLSM = False
-    bLIVE = False
-    bCamera = False
-    Set Scancontroller = Lsm5.ExternalDsObject.Scancontroller
-    Set TrackParameters = Scancontroller.TrackParameters
-    If TrackParameters Is Nothing Then Exit Sub
-    Size = TrackParameters.GetTrackArraySize
-    For lTrack = 0 To Size - 1
-            eDeviceMode = TrackParameters.TrackDeviceMode(lTrack)
-            Select Case eDeviceMode
-                Case eAimDeviceModeLSM
-                    bLSM = True
-                   
-                Case eAimDeviceModeLSM_ChannelMode
-                    bLSM = True
-                   
-                Case eAimDeviceModeLSM_NDD
-                    bLSM = True
-                    
-                Case eAimDeviceModeLSM_DD
-                    bLSM = True
-                   
-                Case eAimDeviceModeSpectralImager
-                    bLSM = True
-                    Exit Sub
-                
-                Case eAimDeviceModeRtScanner
-                    bLIVE = True
-                    Exit Sub
-                
-                Case eAimDeviceModeCamera1
-                    bCamera = True
-                    Exit Sub
-                
-            End Select
-    Next lTrack
-End Sub
diff --git a/AutofocusScreen/src/AutofocusScreen/TestCode.bas b/AutofocusScreen/src/AutofocusScreen/TestCode.bas
index c1871dc..d67fcc9 100644
--- a/AutofocusScreen/src/AutofocusScreen/TestCode.bas
+++ b/AutofocusScreen/src/AutofocusScreen/TestCode.bas
@@ -1,4 +1,26 @@
 Attribute VB_Name = "TestCode"
+Option Explicit
+
+Private Sub test1()
+    Debug.Print Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing
+    Debug.Print Lsm5.DsRecording.SampleSpacing
+    'ScanToImage Lsm5.DsRecordingActiveDocObject
+    'Set Lsm5.DsRecordingActiveDocObject = Lsm5.StartScan
+'    Set viewerGuiServer = Lsm5.viewerGuiServer
+End Sub
+
+Private Sub Test()
+  
+    Dim vo As AimImageVectorOverlay
+    Set vo = Lsm5.ExternalDsObject.Scancontroller.AcquisitionRegions
+    
+    Debug.Print vo.GetNumberElements
+    Debug.Print vo.ElementAcquisitionFlags(0)
+    Debug.Print "number of Knots " & vo.GetElementNumberKnots(0)
+    '' use Ctrl+G to display immediate window
+    'Debug.Print "A Line"
+    'WScript.StdOut
+End Sub
 'Sub ExportVBAFiles()
 '  Dim pVBAProject As Lsm5.L
 '  Dim vbComp As VBComponent  'VBA module, form, etc...
@@ -48,7 +70,8 @@ Attribute VB_Name = "TestCode"
 '   DisplayAmplifierDescriptions()
 '''''
 Private Sub DisplayAmplifierDescriptions()
-    
+    Dim Track As DsTrack
+    Dim Success As Integer
   '  Dim amp As CpAmplifiers
  '   Set amp = Lsm5.Hardware.CpAmplifiers
     
@@ -62,9 +85,9 @@ Private Sub DisplayAmplifierDescriptions()
     Set channel = Track.DetectionChannelObjectByIndex(0, Success)
 
     channel.DetectorGain = 300
-    MsgBox "Detector 0: " + CStr(channel.name) + " " + CStr(channel.DetectorGain)
+    MsgBox "Detector 0: " + CStr(channel.Name) + " " + CStr(channel.DetectorGain)
     channel.DetectorGain = 500
-    MsgBox "Detector 0: " + CStr(channel.name) + " " + CStr(channel.DetectorGain)
+    MsgBox "Detector 0: " + CStr(channel.Name) + " " + CStr(channel.DetectorGain)
                         
     
     'If Track.Acquire Then 'if track is activated for acquisition
diff --git a/AutofocusScreen/src/AutofocusScreen/TestFcs.bas b/AutofocusScreen/src/AutofocusScreen/TestFcs.bas
new file mode 100644
index 0000000..f99bd91
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/TestFcs.bas
@@ -0,0 +1,77 @@
+Attribute VB_Name = "TestFcs"
+Public FcsJob As AFcsJob
+Public Type FcsJobType
+    Name As String
+    LaserActive() As Boolean
+    BleachActive() As Boolean
+    LaserTransmission() As Double
+    BleachTransmission() As Double
+End Type
+
+
+Private Sub TestFcsClass()
+    Set ZEN = Lsm5.CreateObject("Zeiss.Micro.AIM.ApplicationInterface.ApplicationInterface")
+    Dim FcsControl As AimFcsController
+    Set FcsControl = Fcs
+    Debug.Print "Channels " & FcsControl.AcquisitionParameters.Channels '.ChannelDetectorA(0)
+    Debug.Print "Active " & FcsControl.AcquisitionParameters.ChannelEnabled(16) '.ChannelDetectorA(0)
+    Debug.Print "Category " & FcsControl.AcquisitionParameters.ChannelDetectorA(4)
+    If FcsJob Is Nothing Then
+        Set FcsJob = New AFcsJob
+        FcsJob.setJobNoAi "current"
+    End If
+    FcsJob.setJobNoAi "current"
+    If Not FcsJob.putJobNoAi Then
+        FcsJob.setJobNoAi "current"
+    End If
+    Debug.Print FcsJob.jobDescriptor
+    'FcsJob.setLightPath
+    
+End Sub
+Private Sub loadAFcsJob()
+
+'ZEN2011 or up
+    Dim FcsData As AimFcsData
+    Dim ZEN As Zeiss_Micro_AIM_ApplicationInterface.ApplicationInterface
+    Set ZEN = Application.ApplicationInterface
+    ZEN.gui.Fcs.LightPath.Lasers.ByIndex = 1 'set 458
+    ZEN.gui.Fcs.LightPath.Lasers.On.Value = True
+    'ZEN.gui.Fcs.LightPath.BleachLasers.IsEnabled = True
+    'ZEN.gui.Fcs.SaveMethod.Save.Execute
+    NewFcsRecord GlobalFcsRecordingDoc, FcsData, "Test"
+    Debug.Print ZEN.gui.Fcs.LightPath.Config.CurrentItem
+    'ZEN.CommandExecute "Fcs.BeamPath.Save"
+    'ZEN.CommandExecute "SimpleInput.Ok"
+    Dim FcsControl As AimFcsController
+    Set FcsControl = Fcs
+    FcsControl.BeamPathParameters.AttenuatorOn(1) = False
+    FcsData.DataSet(0).AcquisitionParameters.Copy FcsControl.AcquisitionParameters
+    FcsData.DataSet(0).AcquisitionParameters.MeasurementTime = 10
+    'FcsControl.AcquisitionParameters.MeasurementTime = 2
+    Dim AqPar As AimFcsAcquisitionParameters
+    
+    AqPar.MeasurementTime = 0.1
+    
+    
+    'ZEN.gui.Fcs.method.Load "fcs1"
+    'ZEN.gui.Fcs.BeamPath.Save
+    
+'    starts with 1 this is the acquisition power
+'    Power = FcsControl.BeamPathParameters.AttenuatorPower(2)
+'    Power = FcsControl.BeamPathParameters.BleachAttenuatorPower(1)
+'    FcsControl.BeamPathParameters.AttenuatorOn(1) = False
+'    Dim FcsControl As AimFcsController
+'    Set FcsControl = Fcs
+'    ZEN.GUI.Fcs.LightPath.BleachLasers.ByIndex = 1
+'    ZEN.GUI.Fcs.LightPath.BleachLasers.Transmission.Value = 0.1
+
+End Sub
+'    starts with 1 this is the acquisition power
+'    Power = FcsControl.BeamPathParameters.AttenuatorPower(2)
+'    Power = FcsControl.BeamPathParameters.BleachAttenuatorPower(1)
+'    FcsControl.BeamPathParameters.AttenuatorOn(1) = False
+'    Dim FcsControl As AimFcsController
+'    Set FcsControl = Fcs
+'    ZEN.GUI.Fcs.LightPath.BleachLasers.ByIndex = 1
+'    ZEN.GUI.Fcs.LightPath.BleachLasers.Transmission.Value = 0.1
+
diff --git a/AutofocusScreen/src/AutofocusScreen/TestFocus.bas b/AutofocusScreen/src/AutofocusScreen/TestFocus.bas
new file mode 100644
index 0000000..711a56f
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/TestFocus.bas
@@ -0,0 +1,720 @@
+Attribute VB_Name = "TestFocus"
+Option Explicit
+
+''''''
+'' AFTest1_Click()
+'' Perform repeatealy Autofocus with FastZline and acquisition with stage only.
+'' Uses No Z-track and Z-track
+'''''
+'Private Sub AFTest1_Click()
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    AFTest1Run
+'    StopAcquisition
+'End Sub
+'
+'Private Function AFTest1Run() As Boolean
+'    Running = True
+'    Dim RecordingDoc As DsRecordingDoc
+'    Dim FilePath As String
+'    Dim MaxTestRepeats As Integer
+'    Dim TestNr As Integer
+'    Dim pixelDwell As Double
+'    Dim i As Integer
+'    Log = True
+'    Dim Zold As Double
+'    Zold = posTempZ
+'    If GlobalDataBaseName = "" Then
+'        MsgBox ("No outputfolder selected ! Cannot start tests.")
+'        Exit Function
+'    End If
+'
+'    'Setup a single recording doc
+'    If RecordingDoc Is Nothing Then
+'        Set RecordingDoc = Lsm5.NewScanWindow
+'        While RecordingDoc.IsBusy
+'            Sleep (100)
+'            DoEvents
+'        Wend
+'    End If
+'
+'    If Not CheckDir(GlobalDataBaseName) Then
+'        Exit Function
+'    End If
+'
+'    AcquisitionTrack1.Value = AutofocusTrack1.Value
+'    AcquisitionTrack2.Value = AutofocusTrack2.Value
+'    AcquisitionTrack3.Value = AutofocusTrack3.Value
+'    AcquisitionTrack4.Value = AutofocusTrack4.Value
+'
+'
+'
+'    '''''''
+'    ' No Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = False
+'    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
+'    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
+'    GlobalBackupRecording.SpecialScanMode = "FocusStep"
+'    If Not RunTestAutofocusButton(RecordingDoc, True, AFTest_Repetitions.Value, "AFTest1_FastZLine_Stage_NoTrackZ") Then
+'        Exit Function
+'    End If
+'
+'    '''''''
+'    ' Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = True
+'    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
+'    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
+'    GlobalBackupRecording.SpecialScanMode = "FocusStep"
+'    If Not RunTestAutofocusButton(RecordingDoc, False, AFTest_Repetitions.Value, "AFTest1_FastZLine_Stage_TrackZ") Then
+'        Exit Function
+'    End If
+'
+'    AFTest1Run = True
+'End Function
+'
+'
+''''''
+'' AFTest2_Click()
+'' Perform repeatealy Autofocus with piezo and acquisition with piezo
+'' Uses No Z-track and Z-track
+'''''
+'Private Sub AFTest2_Click()
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    AFTest2Run
+'    StopAcquisition
+'End Sub
+'
+'Private Function AFTest2Run() As Boolean
+'    Running = True
+'    Dim RecordingDoc As DsRecordingDoc
+'    Log = True
+'    If Not Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.Name) Then
+'        MsgBox ("No piezo availabe! Cannot start tests.")
+'        Exit Function
+'    End If
+'    If GlobalDataBaseName = "" Then
+'        MsgBox ("No outputfolder selected ! Cannot start tests.")
+'        Exit Function
+'    End If
+'
+'    'Setup a single recording doc
+'    If RecordingDoc Is Nothing Then
+'        Set RecordingDoc = Lsm5.NewScanWindow
+'        While RecordingDoc.IsBusy
+'            Sleep (100)
+'            DoEvents
+'        Wend
+'    End If
+'
+'    If Not CheckDir(GlobalDataBaseName) Then
+'        Exit Function
+'    End If
+'
+'    AcquisitionTrack1.Value = AutofocusTrack1.Value
+'    AcquisitionTrack2.Value = AutofocusTrack2.Value
+'    AcquisitionTrack3.Value = AutofocusTrack3.Value
+'    AcquisitionTrack4.Value = AutofocusTrack4.Value
+'    AutofocusMaxSpeed.Value = True
+'    AutofocusFastZline = False
+'    AutofocusHRZ.Value = True
+'
+'    '''''''
+'    ' No Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = False
+'    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
+'    GlobalAcquisitionRecording.SpecialScanMode = "ZScanner"
+'    GlobalBackupRecording.SpecialScanMode = "ZScanner"
+'
+'    If Not RunTestAutofocusButton(RecordingDoc, True, AFTest_Repetitions.Value, "AFTest2_Piezo_Piezo_NoTrackZ") Then
+'        Exit Function
+'    End If
+'
+'    '''''''
+'    ' Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = True
+'    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
+'    GlobalAcquisitionRecording.SpecialScanMode = "ZScanner"
+'    GlobalBackupRecording.SpecialScanMode = "ZScanner"
+'
+'    If Not RunTestAutofocusButton(RecordingDoc, False, AFTest_Repetitions.Value, "AFTest2_Piezo_Piezo_TrackZ") Then
+'        Exit Function
+'    End If
+'    AFTest2Run = True
+'End Function
+'
+'
+''''''
+'' AFTest3_Click()
+'' Perform repeatealy Autofocus with stage and acquisition with stage
+'' Uses No Z-track and Z-track
+'''''
+'Private Sub AFTest3_Click()
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    AFTest3Run
+'    StopAcquisition
+'End Sub
+'
+'Private Function AFTest3Run() As Boolean
+'    Running = True
+'    Dim RecordingDoc As DsRecordingDoc
+'    Log = True
+'    If GlobalDataBaseName = "" Then
+'        MsgBox ("No outputfolder selected ! Cannot start tests.")
+'        Exit Function
+'    End If
+'
+'    'Setup a single recording doc
+'    If RecordingDoc Is Nothing Then
+'        Set RecordingDoc = Lsm5.NewScanWindow
+'        While RecordingDoc.IsBusy
+'            Sleep (100)
+'            DoEvents
+'        Wend
+'    End If
+'
+'    If Not CheckDir(GlobalDataBaseName) Then
+'        Exit Function
+'    End If
+'
+'    AcquisitionTrack1.Value = AutofocusTrack1.Value
+'    AcquisitionTrack2.Value = AutofocusTrack2.Value
+'    AcquisitionTrack3.Value = AutofocusTrack3.Value
+'    AcquisitionTrack4.Value = AutofocusTrack4.Value
+'    AutofocusMaxSpeed.Value = True
+'    AutofocusFastZline = False
+'    AutofocusHRZ.Value = False
+'
+'    '''''''
+'    ' No Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = False
+'    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
+'    GlobalBackupRecording.SpecialScanMode = "FocusStep"
+'    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
+'    If Not RunTestAutofocusButton(RecordingDoc, True, AFTest_Repetitions.Value, "AFTest3_Stage_Stage_NoTrackZ") Then
+'        Exit Function
+'    End If
+'
+'    '''''''
+'    ' Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = True
+'    GlobalBackupRecording.SpecialScanMode = "FocusStep"
+'    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
+'    If Not RunTestAutofocusButton(RecordingDoc, False, AFTest_Repetitions.Value, "AFTest3_Stage_Stage_TrackZ") Then
+'        Exit Function
+'    End If
+'    AFTest3Run = True
+'End Function
+'
+''''''
+'' AFTest4_Click()
+'' Perform repeatealy Autofocus with piezo and acquisition with stage
+'' Uses No Z-track and Z-track
+'''''
+'Private Sub AFTest4_Click()
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    AFTest4Run
+'    StopAcquisition
+'End Sub
+'
+'Private Function AFTest4Run() As Boolean
+'    Running = True
+'    Dim RecordingDoc As DsRecordingDoc
+'    Log = True
+'    If Not Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.Name) Then
+'        MsgBox ("No piezo availabe! Cannot start tests.")
+'        Exit Function
+'    End If
+'    If GlobalDataBaseName = "" Then
+'        MsgBox ("No outputfolder selected ! Cannot start tests.")
+'        Exit Function
+'    End If
+'
+'    'Setup a single recording doc
+'    If RecordingDoc Is Nothing Then
+'        Set RecordingDoc = Lsm5.NewScanWindow
+'        While RecordingDoc.IsBusy
+'            Sleep (100)
+'            DoEvents
+'        Wend
+'    End If
+'
+'    If Not CheckDir(GlobalDataBaseName) Then
+'        Exit Function
+'    End If
+'
+'    AcquisitionTrack1.Value = AutofocusTrack1.Value
+'    AcquisitionTrack2.Value = AutofocusTrack2.Value
+'    AcquisitionTrack3.Value = AutofocusTrack3.Value
+'    AcquisitionTrack4.Value = AutofocusTrack4.Value
+'    AutofocusMaxSpeed.Value = True
+'    AutofocusFastZline = False
+'    AutofocusHRZ.Value = True
+'
+'    '''''''
+'    ' No Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = False
+'    ActivateTrack GlobalAcquisitionRecording, "Autofocus"
+'    GlobalBackupRecording.SpecialScanMode = "FocusStep"
+'    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
+'
+'    If Not RunTestAutofocusButton(RecordingDoc, True, AFTest_Repetitions.Value, "AFTest4_Piezo_Stage_NoTrackZ") Then
+'        Exit Function
+'    End If
+'
+'    '''''''
+'    ' Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = True
+'    GlobalBackupRecording.SpecialScanMode = "FocusStep"
+'    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
+'    If Not RunTestAutofocusButton(RecordingDoc, False, AFTest_Repetitions.Value, "AFTest4_Piezo_Stage_TrackZ") Then
+'        Exit Function
+'    End If
+'    AFTest4Run = True
+'End Function
+'
+'
+''''''
+'' AFTest5_Click()
+'' Acquire reeatedly images with Fast-Z-Line
+'''''
+'Private Sub AFTest5_Click()
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    AFTest5Run
+'    StopAcquisition
+'End Sub
+'
+'Private Function AFTest5Run() As Boolean
+'    Running = True
+'    Dim RecordingDoc As DsRecordingDoc
+'
+'    If GlobalDataBaseName = "" Then
+'        MsgBox ("No outputfolder selected ! Cannot start tests.")
+'        Exit Function
+'    End If
+'
+'    'Setup a single recording doc
+'    If RecordingDoc Is Nothing Then
+'        Set RecordingDoc = Lsm5.NewScanWindow
+'        While RecordingDoc.IsBusy
+'            Sleep (100)
+'            DoEvents
+'        Wend
+'    End If
+'
+'    If Not CheckDir(GlobalDataBaseName) Then
+'        Exit Function
+'    End If
+'
+'    AutofocusTrackZ.Value = False
+'    AcquisitionTrack1.Value = False
+'    AcquisitionTrack2.Value = False
+'    AcquisitionTrack3.Value = False
+'    AcquisitionTrack4.Value = False
+'    AutofocusMaxSpeed.Value = True
+'    AutofocusHRZ.Value = False
+'    AutofocusFastZline.Value = True
+'    AutofocusLineSize.Value = 256
+'    If Not RunTestFastZline(RecordingDoc, 1, AFTest_Repetitions.Value, 1, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'    AutofocusLineSize.Value = 128
+'    If Not RunTestFastZline(RecordingDoc, 2, AFTest_Repetitions.Value, 1, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'    AutofocusLineSize.Value = 64
+'    If Not RunTestFastZline(RecordingDoc, 3, AFTest_Repetitions.Value, 1, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'    AutofocusLineSize.Value = 256
+'    If Not RunTestFastZline(RecordingDoc, 4, AFTest_Repetitions.Value, 2, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'
+'
+'    AutofocusLineSize.Value = 128
+'    If Not RunTestFastZline(RecordingDoc, 5, AFTest_Repetitions.Value, 2, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'    AutofocusLineSize.Value = 256
+'    If Not RunTestFastZline(RecordingDoc, 6, AFTest_Repetitions.Value, 3, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'
+'
+'    AutofocusLineSize.Value = 128
+'    If Not RunTestFastZline(RecordingDoc, 7, AFTest_Repetitions.Value, 3, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'
+'    AutofocusLineSize.Value = 256
+'    If Not RunTestFastZline(RecordingDoc, 8, AFTest_Repetitions.Value, 4, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'
+'    AutofocusLineSize.Value = 128
+'    If Not RunTestFastZline(RecordingDoc, 9, AFTest_Repetitions.Value, 4, "AFTest5_FastZlineTest", 5000) Then
+'        Exit Function
+'    End If
+'    AFTest5Run = True
+'End Function
+'
+'
+'
+''''''
+'' AFTest6_Click()
+'' Perform repeatealy Autofocus with piezo and frame acquisition with piezo at multiposition
+'' Uses No Z-track and Z-track
+'''''
+'Private Sub AFTest6_Click()
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    AFTest6Run
+'    StopAcquisition
+'End Sub
+'
+'Private Function AFTest6Run() As Boolean
+'    Running = True
+'    Dim RecordingDoc As DsRecordingDoc
+'    Log = True
+'    If Not Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.Name) Then
+'        MsgBox ("No piezo availabe! Cannot start tests.")
+'        Exit Function
+'    End If
+'    If GlobalDataBaseName = "" Then
+'        MsgBox ("No outputfolder selected ! Cannot start tests.")
+'        Exit Function
+'    End If
+'
+'    'Setup a single recording doc
+'    If RecordingDoc Is Nothing Then
+'        Set RecordingDoc = Lsm5.NewScanWindow
+'        While RecordingDoc.IsBusy
+'            Sleep (100)
+'            DoEvents
+'        Wend
+'    End If
+'
+'    If Not CheckDir(GlobalDataBaseName) Then
+'        Exit Function
+'    End If
+'
+'    AcquisitionTrack1.Value = AutofocusTrack1.Value
+'    AcquisitionTrack2.Value = AutofocusTrack2.Value
+'    AcquisitionTrack3.Value = AutofocusTrack3.Value
+'    AcquisitionTrack4.Value = AutofocusTrack4.Value
+'    AutofocusMaxSpeed.Value = True
+'    AutofocusFastZline = False
+'    AutofocusHRZ.Value = True
+'
+'
+'    '''''''
+'    ' Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = True
+'
+'    MultipleLocationToggle.Value = True
+'    GlobalRepetitionNumber = AFTest_Repetitions.Value
+'    GlobalRepetitionTime.Value = 0
+'    If Not StartSetting() Then
+'        Exit Function
+'    End If
+'    GlobalAcquisitionRecording.SpecialScanMode = "ZScanner"
+'
+'    GlobalAcquisitionRecording.ScanMode = "Stack"                       'This is defining to acquire a Z stack of Z-Y images
+'    GlobalAcquisitionRecording.SamplesPerLine = 32  'If doing frame autofocussing it uses the userdefined frame size
+'    GlobalAcquisitionRecording.LinesPerFrame = 32
+'    If AutofocusZStep.Value > 0 Then
+'        GlobalAcquisitionRecording.FramesPerStack = Round(10 / AutofocusZStep.Value)
+'        GlobalAcquisitionRecording.FrameSpacing = AutofocusZStep.Value
+'    Else
+'        GlobalAcquisitionRecording.FramesPerStack = 10
+'        GlobalAcquisitionRecording.FrameSpacing = 10
+'    End If
+'    TextBoxFileName.Value = "Piezo"
+'    'Set counters back to 1
+'    RepetitionNumber = 1 ' first time point
+'    StartAcquisition BleachingActivated 'This is the main function of the macro
+'    AFTest6Run = True
+'End Function
+'
+'
+''''''
+'' AFTest6_Click()
+'' Perform repeatealy Autofocus with piezo and frame acquisition with piezo at multiposition
+'' Uses No Z-track and Z-track
+'''''
+'Private Sub AFTest7_Click()
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    AFTest7Run
+'    StopAcquisition
+'End Sub
+'
+'Private Function AFTest7Run() As Boolean
+'    Running = True
+'    Dim RecordingDoc As DsRecordingDoc
+'    Log = True
+'    If Not Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.Name) Then
+'        MsgBox ("No piezo availabe! Cannot start tests.")
+'        Exit Function
+'    End If
+'    If GlobalDataBaseName = "" Then
+'        MsgBox ("No outputfolder selected ! Cannot start tests.")
+'        Exit Function
+'    End If
+'
+'    'Setup a single recording doc
+'    If RecordingDoc Is Nothing Then
+'        Set RecordingDoc = Lsm5.NewScanWindow
+'        While RecordingDoc.IsBusy
+'            Sleep (100)
+'            DoEvents
+'        Wend
+'    End If
+'
+'    If Not CheckDir(GlobalDataBaseName) Then
+'        Exit Function
+'    End If
+'
+'    AcquisitionTrack1.Value = AutofocusTrack1.Value
+'    AcquisitionTrack2.Value = AutofocusTrack2.Value
+'    AcquisitionTrack3.Value = AutofocusTrack3.Value
+'    AcquisitionTrack4.Value = AutofocusTrack4.Value
+'    AutofocusMaxSpeed.Value = True
+'    AutofocusFastZline = True
+'    AutofocusHRZ.Value = False
+'
+'
+'    '''''''
+'    ' Z-Tracking, Acquistion after Autofocus
+'    '''''''
+'    AutofocusTrackZ.Value = True
+'
+'    MultipleLocationToggle.Value = True
+'    GlobalRepetitionNumber = AFTest_Repetitions.Value
+'    GlobalRepetitionTime.Value = 0
+'    If Not StartSetting() Then
+'        Exit Function
+'    End If
+'    GlobalAcquisitionRecording.SpecialScanMode = "FocusStep"
+'
+'    GlobalAcquisitionRecording.ScanMode = "Stack"                       'This is defining to acquire a Z stack of Z-Y images
+'    GlobalAcquisitionRecording.SamplesPerLine = 8  'If doing frame autofocussing it uses the userdefined frame size
+'    GlobalAcquisitionRecording.LinesPerFrame = 8
+'    If AutofocusZStep.Value > 0 Then
+'        GlobalAcquisitionRecording.FramesPerStack = Round(20 / AutofocusZStep.Value)
+'        GlobalAcquisitionRecording.FrameSpacing = AutofocusZStep.Value
+'    Else
+'        GlobalAcquisitionRecording.FramesPerStack = 10
+'        GlobalAcquisitionRecording.FrameSpacing = 10
+'    End If
+'    TextBoxFileName.Value = "FastZline"
+'    'Set counters back to 1
+'    RepetitionNumber = 1 ' first time point
+'    StartAcquisition BleachingActivated 'This is the main function of the macro
+'    AFTest7Run = True
+'End Function
+'
+'
+'Private Sub AFTestAll_Click()
+'    posTempZ = Lsm5.Hardware.CpFocus.Position
+'    Running = True
+'    If Not AFTest1Run Then
+'        GoTo ScanStop
+'    End If
+'    If Not AFTest3Run Then
+'        GoTo ScanStop
+'    End If
+'
+'    If Not AFTest5Run Then
+'        GoTo ScanStop
+'    End If
+'
+'    If Lsm5.Hardware.CpHrz.Exist(Lsm5.Hardware.CpHrz.Name) Then
+'        If Not AFTest2Run Then
+'            GoTo ScanStop
+'        End If
+'        If Not AFTest4Run Then
+'            GoTo ScanStop
+'        End If
+'        If Not AFTest6Run Then
+'            GoTo ScanStop
+'        End If
+'        If Not AFTest7Run Then
+'            GoTo ScanStop
+'        End If
+'    End If
+'ScanStop:
+'    ScanStop = True
+'    StopAcquisition
+'End Sub
+'
+'
+'''''
+''   RunTestAutofocusButton(RecordingDoc As DsRecordingDoc, TestNr As Integer, MaxTestRepeats As Integer) As Boolean
+''   Using the actual setting for autofocusing function runs AutofocusButton. Save images and logfile on the GlobalDataBaseName directory
+''       [RecordingDoc] - A recording where images are overwritten
+''       [TestNr]       - Number of the test, this sets the name of the image files and logfiles.
+''       [MaxTestRepeats] - Maximal number of tests for each repeat
+'''''
+'Private Function RunTestAutofocusButton(RecordingDoc As DsRecordingDoc, ResetPos As Boolean, MaxTestRepeats As Integer, Optional FileName As String = "AutofocusTest", Optional Pause As Integer = 1000) As Boolean
+'
+'    Dim FilePath As String
+'    Dim TestRepeats As Integer
+'    Dim Zold As Double
+'    Dim pos As Double
+'    TestRepeats = 1
+'    LogFileName = GlobalDataBaseName & "\" & FileName & "_Log" & ".txt"
+'
+'    If Log Then
+'        SafeOpenTextFile LogFileName, LogFile, FileSystem
+'        LogFile.WriteLine "% Autofocus Test. Repeated AutofocusButton executions. "
+'        LogFile.WriteLine "% MaxSpeed " & AutofocusMaxSpeed.Value & ", Zoom " & AutofocusZoom.Value & ", Piezo " & AutofocusHRZ.Value & ", AFTrackZ " & AutofocusTrackZ.Value & _
+'        ", AFTrackXY " & AutofocusTrackXY.Value & ", FastZLine" & AutofocusFastZline.Value
+'    End If
+'    Zold = posTempZ
+'    While TestRepeats < MaxTestRepeats + 1
+'        DisplayProgress "Running Test " & FileName & ". Repeat " & TestRepeats & "/" & MaxTestRepeats & ".......", RGB(0, &HC0, 0)
+'
+'        FilePath = GlobalDataBaseName & "\" & FileName & "_" & TestRepeats
+'        If Log Then
+'            SafeOpenTextFile LogFileName, LogFile, FileSystem
+'            LogFile.WriteLine " "
+'
+'            LogFile.WriteLine "% Save image in file " & FilePath & ".lsm"
+'            LogFile.Close
+'        End If
+'        DoEvents
+'        Sleep (Pause)
+'        DoEvents
+'
+'        If ResetPos Then
+'            posTempZ = Round(Zold + (1 - 2 * Rnd) * 10, PrecZ)
+'        End If
+'        Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
+'
+'        DisplayProgress "Autofocus SetupScanWindow", RGB(0, &HC0, 0)
+'        If RecordingDoc Is Nothing Then
+'            Set RecordingDoc = Lsm5.NewScanWindow
+'            While RecordingDoc.IsBusy
+'                Sleep (100)
+'                DoEvents
+'            Wend
+'        End If
+'        If Not AutofocusButtonRun(RecordingDoc, GlobalDataBaseName & "\AFimg_" & FileName & "_" & TestRepeats & ".lsm") Then
+'            Exit Function
+'        End If
+'        'save file
+'        If ActivateTrack(GlobalAcquisitionRecording, "Acquisition") Then
+'            SaveDsRecordingDoc RecordingDoc, FilePath & ".lsm"
+'        End If
+'        TestRepeats = TestRepeats + 1
+'        If ScanStop Then
+'            Exit Function
+'        End If
+'    Wend
+'    If Log Then
+'        LogFile.Close
+'    End If
+'    RunTestAutofocusButton = True
+'End Function
+'
+'''''
+''   RunTestFastZline(RecordingDoc As DsRecordingDoc, TestNr As Integer, MaxTestRepeats As Integer, pixelDwell As Double, FrameSize As Integer, pause As Integer) As Boolean
+''   Using the actual setting for autofocusing function runs AutofocusButton. Save images and logfile on the GlobalDataBaseName directory
+''       [RecordingDoc] - A recording where images are overwritten
+''       [TestNr]       - Number of the test, this sets the name of the image files and logfiles.
+''       [MaxTestRepeats] - Maximal number of tests for each repeat
+'''''
+'Private Function RunTestFastZline(RecordingDoc As DsRecordingDoc, TestNr As Integer, MaxTestRepeats As Integer, Optional pixelDwellfactor As Double = 1, Optional FileName As String = "AutofocusTest", Optional Pause As Integer = 5000) As Boolean
+'
+'    Dim FilePath As String
+'    Dim TestRepeats As Integer
+'    Dim SuccessRecenter As Boolean
+'    Dim time As Double
+'    Dim pos As Double ' position temp variable
+'    TestRepeats = 1
+'    LogFileName = GlobalDataBaseName & "\" & FileName & TestNr & ".txt"
+'
+'    If Log Then
+'        SafeOpenTextFile LogFileName, LogFile, FileSystem
+'        LogFile.WriteLine "% FastZlineTest " & TestNr & ". Repeated fast Zline executions. PixelDwellfactor: " & pixelDwellfactor & ", LineSize: " & AutofocusLineSize.Value & ", pause: " & Pause
+'        LogFile.WriteLine "% MaxSpeed " & AutofocusMaxSpeed.Value & ", Zoom " & AutofocusZoom.Value & ", Piezo " & AutofocusHRZ.Value & ", AFTrackZ " & AutofocusTrackZ.Value & _
+'        ", AFTrackXY " & AutofocusTrackXY.Value
+'    End If
+'
+'    While TestRepeats < MaxTestRepeats + 1
+'        DisplayProgress "Running Test " & TestNr & ". Repeat " & TestRepeats & "/" & MaxTestRepeats & ".......", RGB(0, &HC0, 0)
+'        FilePath = GlobalDataBaseName & "\" & FileName & TestNr & "_" & TestRepeats
+'        If Log Then
+'            SafeOpenTextFile LogFileName, LogFile, FileSystem
+'            LogFile.WriteLine " "
+'            LogFile.WriteLine "% Save image in file " & FilePath & ".lsm"
+'            LogFile.Close
+'        End If
+'        DoEvents
+'        Sleep (Pause)
+'        DoEvents
+'        If Not AutofocusForm.ActivateTrack(GlobalAutoFocusRecording, "Autofocus") Then
+'            MsgBox "No track selected for Autofocus! Cannot Autofocus!"
+'            Exit Function
+'        End If
+'        time = Timer
+'        Recenter_pre posTempZ, SuccessRecenter, ZENv
+'
+'        Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, 1).SampleObservationTime * pixelDwellfactor
+'
+'        Sleep (Pause)
+'        DoEvents
+'        If Log Then
+'            SafeOpenTextFile LogFileName, LogFile, FileSystem
+'            time = Timer - time
+'            'pos = Lsm5.Hardware.CpFocus.Position
+'            LogFile.WriteLine ("% AutofocusButton: center and wait 1st  Z = " & posTempZ & ", Time required " & time & ", success Recenter " & SuccessRecenter)
+''            Sleep (100)
+''            If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
+''                LogFile.WriteLine ("% AutofocusButton: Target Central slide AQ  " & posTempZ & "; obtained Central slide " & pos & "; position " & pos)
+''            Else
+''                LogFile.WriteLine ("% AutofocusButton: Target Central slide AQ  " & posTempZ & "; obtained Central slide " & _
+''                Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + pos & "; position " & pos)
+''            End If
+'            LogFile.Close
+'        End If
+'
+'        If Not ScanToImage(RecordingDoc) Then
+'            Exit Function
+'        End If
+'        time = Timer
+'        Recenter_post posTempZ, SuccessRecenter, ZENv
+'        DoEvents
+'        If Log Then
+'            SafeOpenTextFile LogFileName, LogFile, FileSystem
+'            time = Timer - time
+'            pos = Lsm5.Hardware.CpFocus.Position
+'            LogFile.WriteLine ("% AutofocusButton: recenter 1st  Z = " & posTempZ & ", Time required " & time & ", waiting repeats (max 9) " & Round(time / 0.4))
+'            If (Lsm5.DsRecording.ScanMode <> "Stack" And Lsm5.DsRecording.ScanMode <> "ZScan") Or AutofocusHRZ Then
+'                LogFile.WriteLine ("% AutofocusButton: Target Central slide AQ (after img) " & posTempZ & "; obtained Central slide " & Lsm5.Hardware.CpFocus.Position & "; position " & Lsm5.Hardware.CpFocus.Position)
+'            Else
+'                LogFile.WriteLine ("% AutofocusButton: Target Central slide AQ (after img) " & posTempZ & "; obtained Central slide " & _
+'                Lsm5.DsRecording.FrameSpacing * (Lsm5.DsRecording.FramesPerStack - 1) / 2 - Lsm5.DsRecording.Sample0Z + Lsm5.Hardware.CpFocus.Position & "; position " & Lsm5.Hardware.CpFocus.Position)
+'            End If
+'            LogFile.Close
+'        End If
+'        SaveDsRecordingDoc RecordingDoc, FilePath & ".lsm"
+'        TestRepeats = TestRepeats + 1
+'        If ScanStop Then
+'            Exit Function
+'        End If
+'    Wend
+'    If Log Then
+'        LogFile.Close
+'    End If
+'    RunTestFastZline = True
+'End Function
+'
+'
diff --git a/AutofocusScreen/src/AutofocusScreen/TileScan.bas b/AutofocusScreen/src/AutofocusScreen/TileScan.bas
deleted file mode 100644
index 13181a1..0000000
--- a/AutofocusScreen/src/AutofocusScreen/TileScan.bas
+++ /dev/null
@@ -1,51 +0,0 @@
-Attribute VB_Name = "TileScan"
-
-Dim TileX As Integer
-Dim TileY As Integer
-Dim GlobalPositionsStageOld As Integer
-Dim FrameWidth As Double
-Dim FrameHeight As Double
-Dim RelFrameHeight As Double
-Dim RelFrameWidth As Double
-Dim Overlap As Double
-Dim Xnew As Double
-Dim Ynew As Double
-
-
-
-
-Public Sub CalculateTileLocs()
-    CopyPositionArrays
-End Sub
-
-
-Public Sub CopyPositionArrays()
-GlobalXposOld() = GlobalXpos()
-GlobalYposOld() = GlobalYpos()
-GlobalZposOld() = GlobalZpos()
-GlobalLocationsNameOld() = GlobalLocationsName()
-GlobalPositionsStageOld = GlobalPositionsStage
-GlobalPositionsStage = GlobalPositionsStage * TileX * TileY
-ReDim GlobalXpos(GlobalPositionsStage)
-ReDim GlobalYpos(GlobalPositionsStage)
-ReDim GlobalZpos(GlobalPositionsStage)
-ReDim GlobalLocationsName(GlobalPositionsStage)
-Dim n As Integer
-Dim TX As Integer
-Dim TY As Integer
-
-For n = 0 To GlobalPositionsStageOld - 1
-Xnew = GlobalXposOld(n + 1) - ((TileX - 1) / 2) * RelFrameWidth
-Ynew = GlobalYposOld(n + 1) - ((TileY - 1) / 2) * RelFrameHeight
-    For TY = 0 To TileY - 1
-        For TX = 0 To TileX - 1
-            GlobalXpos(n * TileX * TileY + (TY * TileX) + TX + 1) = Xnew + TX * RelFrameWidth
-            GlobalYpos(n * TileX * TileY + (TY * TileX) + TX + 1) = Ynew + TY * RelFrameHeight
-            GlobalZpos(n * TileX * TileY + (TY * TileX) + TX + 1) = GlobalZposOld(n + 1)
-            If Grid Then
-            GlobalLocationsName(n * TileX * TileY + (TY * TileX) + TX + 1) = GlobalLocationsNameOld(n + 1)
-            End If
-         Next TX
-     Next TY
-Next n
-End Sub
diff --git a/AutofocusScreen/src/AutofocusScreen/Timers.cls b/AutofocusScreen/src/AutofocusScreen/Timers.cls
new file mode 100644
index 0000000..bb01978
--- /dev/null
+++ b/AutofocusScreen/src/AutofocusScreen/Timers.cls
@@ -0,0 +1,68 @@
+VERSION 1.0 CLASS
+BEGIN
+  MultiUse = -1  'True
+END
+Attribute VB_Name = "Timers"
+Attribute VB_GlobalNameSpace = False
+Attribute VB_Creatable = False
+Attribute VB_PredeclaredId = False
+Attribute VB_Exposed = False
+'''
+' Timer class
+' A very simple timer that just keeps track of its creation, updateTime and when wait called it display whether a certain time is elapsed or not
+'''
+Option Explicit
+Private Type singleTimer
+    Name As String
+    TimeStart As Double
+End Type
+
+Private Timers() As singleTimer
+Private TimerNames As Dictionary
+
+Private Sub MsgNoTimer(Name As String)
+    MsgBox "Timer: Timer " & Name & " has not been defined"
+End Sub
+
+Public Sub addTimer(Name As String)
+    Dim iTimer As Integer
+    ' only create once the timer with a specific name
+    If TimerNames Is Nothing Then
+        Set TimerNames = New Dictionary
+    End If
+    If TimerNames.Exists(Name) Then
+        Exit Sub
+    End If
+    
+    If TimerNames.count = 0 Then
+        ReDim Timers(0)
+    Else
+        ReDim Preserve Timers(0 To UBound(Timers) + 1)
+    End If
+    
+    TimerNames.Add Name, UBound(Timers)
+    iTimer = TimerNames.Item(Name)
+    Timers(iTimer).Name = Name
+    Timers(iTimer).TimeStart = CDbl(GetTickCount) * 0.001
+End Sub
+
+Public Function checkTimerName(Name As String) As Boolean
+    If TimerNames.Exists(Name) Then
+       checkTimerName = True
+    Else
+        MsgNoTimer Name
+    End If
+End Function
+
+
+Public Sub updateTimeStart(Name As String)
+    If checkTimerName(Name) Then
+        Timers(TimerNames.Item(Name)).TimeStart = CDbl(GetTickCount) * 0.001
+    End If
+End Sub
+
+Public Function wait(Name As String, Delay As Double) As Double
+    If checkTimerName(Name) Then
+        wait = Timers(TimerNames.Item(Name)).TimeStart + Delay - CDbl(GetTickCount) * 0.001
+    End If
+End Function
diff --git a/AutofocusScreen/src/AutofocusScreen/ZValues.frm b/AutofocusScreen/src/AutofocusScreen/ZValues.frm
deleted file mode 100644
index 68222d8..0000000
--- a/AutofocusScreen/src/AutofocusScreen/ZValues.frm
+++ /dev/null
@@ -1,25 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} ZValues 
-   Caption         =   "ZValues"
-   ClientHeight    =   2175
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   4365
-   OleObjectBlob   =   "ZValues.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "ZValues"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-Private Sub CommandButton1_Click()
-GlobalStageControlZValues = True
-ZValues.Hide
-End Sub
-
-Private Sub CommandButton2_Click()
-GlobalStageControlZValues = False
-ZValues.Hide
-End Sub
diff --git a/AutofocusScreen/src/AutofocusScreen/ZValues.frx b/AutofocusScreen/src/AutofocusScreen/ZValues.frx
deleted file mode 100644
index 1df92c2..0000000
Binary files a/AutofocusScreen/src/AutofocusScreen/ZValues.frx and /dev/null differ
diff --git a/AutofocusScreen/src/AutofocusScreen/newMacros.bas b/AutofocusScreen/src/AutofocusScreen/newMacros.bas
deleted file mode 100644
index 27aa1eb..0000000
--- a/AutofocusScreen/src/AutofocusScreen/newMacros.bas
+++ /dev/null
@@ -1,800 +0,0 @@
-Attribute VB_Name = "newMacros"
-Option Explicit
-Public SystemVersion As String
-
-Public Declare Function GetInputState Lib "user32" () As Long ' Check if mouse or keyboard has been pushed
-
-Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
-Public Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
-Declare Function RegOpenKeyEx _
-    Lib "advapi32.dll" Alias "RegOpenKeyExA" _
-    (ByVal hKey As Long, ByVal lpSubKey As String, _
-    ByVal ulOptions As Long, ByVal samDesired As Long, _
-    phkResult As Long) As Long
-
-Public Declare Function RegCloseKey _
-    Lib "advapi32.dll" (ByVal hKey As Long) As Long
-
-Public Declare Function RegQueryValueEx _
-    Lib "advapi32.dll" Alias "RegQueryValueExA" _
-    (ByVal hKey As Long, ByVal lpValueName As String, _
-    ByVal lpReserved As Long, lpType As Long, _
-    lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
-
-''''''''''''''''''''''''
-'Debug and LogVariables'
-''''''''''''''''''''''''
-Public LogFile As TextStream 'This is the file where a log of the procedure is saved
-Public LogFileName As String
-Public LogFileNameBase As String
-Public FileSystem As FileSystemObject
-Public Log     As Boolean          'If true we log data during the macro
-
-
-
-''''''''''''''''''''
-'''''CONSTANTS''''''
-''''''''''''''''''''
-Public Const VK_SPACE = &H20
-Public Const VK_RETURN = &HD
-Public Const VK_CANCEL = &H3
-Public Const VK_UP = &H26
-Public Const VK_DOWN = &H28
-Public Const VK_ESCAPE = &H1B
-Public Const VK_PAUSE = &H13
-Public Const VK_ADD = &H6B
-Public Const VK_SUBTRACT = &H6D
-Public Const HKEY_CLASSES_ROOT = &H80000000
-Public Const SYNCHRONIZE = &H100000
-Public Const READ_CONTROL = &H20000
-Public Const STANDARD_RIGHTS_READ = (READ_CONTROL)
-Public Const KEY_QUERY_VALUE = &H1
-Public Const KEY_ENUMERATE_SUB_KEYS = &H8
-Public Const KEY_NOTIFY = &H10
-Public Const KEY_READ = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
-
-Public Const REG_SZ = 1                         ' Unicode nul terminated string
-Public Const ERROR_SUCCESS = 0&
-
-Public Const vbOKOnly = 0   '  Display OK button only.
-Public Const VbOKCancel = 1 '  Display OK and Cancel buttons.
-Public Const VbAbortRetryIgnore = 2  ' Display Abort, Retry, and Ignore buttons.
-Public Const VbYesNoCancel = 3  '  Display Yes, No, and Cancel buttons.
-Public Const VbYesNo = 4 '  Display Yes and No buttons.
-Public Const VbRetryCancel = 5   ' Display Retry and Cancel buttons.
-Public Const VbCritical = 16 ' Display Critical Message icon.
-Public Const VbQuestion = 32 ' Display Warning Query icon.
-Public Const VbExclamation = 48  ' Display Warning Message icon.
-Public Const VbInformation = 64  ' Display Information Message icon.
-Public Const VbDefaultButton1 = 0    ' First button is default.
-Public Const VbDefaultButton2 = 256  ' Second button is default.
-Public Const VbDefaultButton3 = 512  ' Third button is default.
-Public Const VbDefaultButton4 = 768   'Fourth button is default.
-Public Const VbApplicationModal = 0  ' Application modal; the user must respond to the message box before continuing work in the current application.
-Public Const VbSystemModal = 4096   '  System modal; all applications are suspended until the user responds to the message box.
-'The first group of values (05) describes the number and type of buttons displayed in the dialog box; the second group (16, 32, 48, 64) describes the icon style; the third group (0, 256, 512) determines which button is the default; and the fourth group (0, 4096) determines the modality of the message box. When adding numbers to create a final value for the buttons argument, use only one number from each group.
-
-'Note   These constants are specified by Visual Basic for Applications. As a result, the names can be used anywhere in your code in place of the actual values.
-
-'Return Values
-Public Const vbOK = 1   '  OK
-Public Const vbCancel = 2    ' Cancel
-Public Const vbAbort = 3 ' Abort
-Public Const vbRetry = 4 '  Retry
-Public Const vbIgnore = 5   '  Ignore
-Public Const vbYes = 6  '  Yes
-Public Const vbNo = 7    ' No
-
-Public Const PrecZ = 2                     'precision of Z passed for stage movements i.e. Z = Round(Z, PrecZ)
-Public Const PrecXY = 2                    'precision of X and Y passed for stage movements
-
-Public ZBacklash  As Double           'ToDo: is it still recquired?.
-                                           'Has to do with the movements of the focus wheel that are "better"
-                                           'if they are long enough. For amoment a test did not gave significant differences This is required for ZEN2010
-
-
-'''''''''''''''''''''
-'''GLOBAL VARIABLE'''
-'''''''''''''''''''''
-
-
-
-Public X11 As Double
-Public X12 As Double
-Public X21 As Double
-Public X22 As Double
-
-Public ScanStop As Boolean
-Public ScanPause As Boolean
-Public Running As Boolean
-Public ExtraBleach As Boolean
-Public AutomaticBleaching As Boolean
-Public BleachTable() As Boolean
-Public BleachStartTable() As Double
-Public BleachStopTable() As Double
-Public RepetitionNumber As Integer ' number of repetition
-Public locationNumber As Long      ' number of location global
-
-Public ZOffset As Double
-Public TrackingChannelString As String
-'Public PositionData As Workbook
-'position variables
-Public XMass As Double
-Public YMass As Double
-Public ZMass As Double
-Public ZShift As Double
-Public XShift As Double
-Public YShift As Double
-Public XStart As Double ' Stores starting X position of Acquisition
-Public YStart As Double ' Stores starting Y position of Acquisition
-Public ZStart As Double
-Public HRZBefore As Double
-Public HRZ As Boolean
-
-'Filehandling variables
-Public OverwriteFiles As Boolean
-Public NoReflectionSignal As Boolean
-Public PubSentStageGrid As Boolean
-Public BleachingActivated As Boolean
-Public FocusMapPresent As Boolean
-
-Public flgEvent As Integer
-Public flg As Integer
-Public toContinue As Integer
-
-
-Public GlobalProjectName As String
-Public GlobalProject As String
-Public GlobalHelpName As String
-
-Public GlobalPrvTime As Double
-Public GlobalMacroKey As String
-Public GlobalCorrectionOffset As Double
-
-'newPublic29.06.2010
-Public NoFrames As Long
-
-' Public BlockAutoConfiguration As String
-Public BlockTimeIndex As Long
-' Public BlockAutoConfigurationUse As Boolean
-
-Public TimerName As String
-Public BlockTimeDelay As Double
-Public SelectedTimeButton As Integer
-Public TimerButton1 As Double
-Public TimerButton2 As Double
-Public TimerButton3 As Double
-Public TimerButton4 As Double
-Public TimerButton5 As Double
-Public TimerButton6 As Double
-Public TimerUnit As Integer
-Public BlockRepetitions As Long
-
-Public TimerKey As String
-
-Public GlobalHighRes As Boolean
-Public GlobalDataBaseName As String
-Public GlobalFileName As String
-Public GlobalImageIndex() As Long
-Public GlobalStripeIndex() As Long
-Public BlockZOffset As Double
-Public BlockZRange As Double
-Public BlockZStep As Double
-Public BlockHighSpeed As Boolean
-Public BlockLowZoom As Boolean
-Public BlockHRZ As Boolean
-Public PubSearchScan As Boolean
-
-Public BlockIsSingle As Boolean
-Public BlockSingleTrack As String
-Public BlockSingleTrackIndex As Long
-Public BlockMultiTrack As String
-Public BlockMultiTrackIndex As Long
-
-
-     
-Public Track As DsTrack
-Public TrackNumber As Integer
-Public TrackName As String
-Public Success As Integer
-Public IsAutofocusTrackSelected As Boolean
-Public AutofocusTrack As Integer ' number of AutofocusTrack
-Public IsAcquisitionTrackSelected As Boolean
-Public ActiveChannels() As String
-
-Public LocationName As String
-
-Public DoNotGoOn As Boolean
-Public ChangeFocus As Boolean
-Public FocusChanged As Boolean
-Public Try As Long
-Public SystemName As String
-          
-Public BackupRecording As DsRecording             ' To remove
-          
-Public GlobalBackupRecording As DsRecording       ' A backupRecording from initial setup (this will not be changed after Re_initialize)
-Public GlobalAutoFocusRecording As DsRecording    ' A global variable for AutofocusRecording
-Public GlobalAcquisitionRecording As DsRecording  ' A global variable for AcquisitionRecording
-Public GlobalZoomRecording As DsRecording         ' A global variable for Micropilot
-Public GlobalAltRecording As DsRecording          ' A global variable for AlternativeTrack
-Public GlobalBackupActiveTracks() As Boolean
-
-
-Public GlobalBackupSampleObservationTime As Double  ' Stores pixelDwell time
-
-Public ImageNumber As Long
-Public Const OFS_MAXPATHNAME = 128
-Public Const OF_EXIST = &H4000
-Public flgBreak As Boolean
-Public Const WM_COMMAND = &H111
-
-Public tools As Lsm5Tools
-Public Stage As CpStages
-
-Public TileX As Integer
-Public TileY As Integer
-Public Overlap As Double
-
-Public AcquisitionController As AimAcquisitionController40.AimScanController  'Debugging 20110131
-Public RecordingDocpub As DsRecordingDoc
-
-
-'Grid positions
-Public posGridX() As Double ' they are initiated during acquisition
-Public posGridY() As Double ' they are initiated during acquisition
-Public posGridZ() As Double ' initiated during acquistion
-Public posGridXY_Valid() As Boolean ' they are initiated during acquisition
-
-Public posGridXsub() As Double ' they are initiated during acquisition
-Public posGridYsub() As Double ' they are initiated during acquisition
-Public posGridZsub() As Double ' initiated during acquistion
-Public posGridXYsub_valid() As Boolean ' they are initiated during acquisition
-
-' Counters for HighresImaging 'TODO remove global variables
-Public HighResExperimentCounter As Integer
-Public HighResCounter As Integer
-Public HighResArrayX() As Double ' this is an array of values why do you need to store values?
-Public HighResArrayY() As Double
-Public HighResArrayZ() As Double
-Public HelpNamePDF As String
-
-Public GlobalStageControlZValues As Boolean
-
-Public Type OFSTRUCT
-        cBytes As Byte
-        fFixedDisk As Byte
-        nErrCode As Integer
-        Reserved1 As Integer
-        Reserved2 As Integer
-        szPathName(OFS_MAXPATHNAME) As Byte
-End Type
-Public Type OVERLAPPED
-        Internal As Long
-        InternalHigh As Long
-        Offset As Long
-        OffsetHigh As Long
-        hEvent As Long
-End Type
-Public Type SECURITY_ATTRIBUTES
-        nLength As Long
-        lpSecurityDescriptor As Long
-        bInheritHandle As Long
-End Type
-
-
-Public Declare Function OpenFile Lib "kernel32" (ByVal lpFileName As String, lpReOpenBuff As OFSTRUCT, _
-ByVal wStyle As Long) As Long
-
-Public Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
-
-Public Declare Function DeleteFile Lib "kernel32" Alias "DeleteFileA" (ByVal lpFileName As String) As Long
-
-Public Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" _
-(ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, _
-lpNumberOfFreeClusters As Long, lpTotalNumberOfClusters As Long) As Long
-
-Public Declare Function GetTickCount Lib "kernel32" () As Long
-
-
-Public Sub Autofocus_Setup()
-        AutofocusForm.Show
-End Sub
-
-
-Public Sub DisplayProgress(State As String, Color As Long)       'Used to display in the progress bar what the macro is doing
-    If (Color & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Then
-        AutofocusForm.ProgressLabel.ForeColor = 0
-    Else
-        AutofocusForm.ProgressLabel.ForeColor = &HFFFFFF
-    End If
-    AutofocusForm.ProgressLabel.BackColor = Color
-    AutofocusForm.ProgressLabel.Caption = State
-    DoEvents
-End Sub
-
-
-''''
-' TODO: Why not use Lsm5.StartScan?
-''''
-Public Sub ScanToImage(RecordingDoc As DsRecordingDoc) ' new routine to scan overwrite the same image, even with several z-slices
-   ' Dim AcquisitionController As AimAcquisitionController40.AimScanController 'now public
-    Dim image As AimImage
-    
-    If Not RecordingDoc Is Nothing Then
-        Set image = RecordingDoc.RecordingDocument.image(0, True)
-
-        If Not image Is Nothing Then
-            Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-            AcquisitionController.DestinationImage(0) = image
-            AcquisitionController.DestinationImage(1) = Nothing
-            AcquisitionController.StartGrab eGrabModeSingle
-        End If
-    End If
-    
-End Sub
-
-'''''
-'   ScanToImageNew ( RecordingDoc As DsRecordingDoc) As Boolean
-'   scan overwrite the same image, even with several z-slices
-'''''
-Public Function ScanToImageNew(RecordingDoc As DsRecordingDoc) As Boolean
-
-    Dim ProgressFifo As IAimProgressFifo ' what is this?
-    Dim gui As Object, treenode As Object
-    'Set gui = Lsm5.ViewerGuiServer
-    ScanToImageNew = False
-    If Not RecordingDoc Is Nothing Then
-        Set treenode = RecordingDoc.RecordingDocument.image(0, True)
-        'Set treenode = Lsm5.NewDocument why not this?
-        Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller ' public variable
-        AcquisitionController.DestinationImage(0) = treenode 'EngelImageToHechtImage(GlobalSingleImage).Image(0, True)
-        AcquisitionController.DestinationImage(1) = Nothing
-        Set ProgressFifo = AcquisitionController.DestinationImage(0)
-        Lsm5.tools.CheckLockControllers True
-        AcquisitionController.StartGrab eGrabModeSingle
-        'Set RecordingDoc = Lsm5.StartScan this does not overwrite
-        If Not ProgressFifo Is Nothing Then ProgressFifo.Append AcquisitionController
-    End If
-    Sleep (200)
-    While AcquisitionController.IsGrabbing
-        Sleep (200) ' this sometimes hangs if we use GetInputState. Try now without it and test if it does not hang
-        DoEvents
-        If ScanStop Then
-            Exit Function
-        End If
-    Wend
-    ScanToImageNew = True
-End Function
-
-
-
-'''''
-'   SystemVersionOffset()
-'   Calculate an offset added to z-stack changes
-'       [GlobalCorrectionOffset] Global Out - Offset added to shift in zStack
-'   TODO: Do we still need it. Only for Axioskop does the Offset change
-'''''
-Public Sub SystemVersionOffset(Optional tmp As Boolean) ' tmp is a hack to hide function from menu
-    SystemVersion = Lsm5.Info.VersionIs
-    If StrComp(SystemVersion, "2.8", vbBinaryCompare) >= 0 Then
-        If Lsm5.Info.IsAxioskop Then
-            If AutofocusForm.CheckBoxHighSpeed Then
-                GlobalCorrectionOffset = 15
-            Else
-                GlobalCorrectionOffset = 1.2
-            End If
-        ElseIf Lsm5.Info.IsAxioplan Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioplan2 Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioplan2i Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioVert Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxiovert100M Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxiovert200M Then
-            GlobalCorrectionOffset = 0
-        Else
-            GlobalCorrectionOffset = 0
-        End If
-    Else
-        If Lsm5.Info.IsAxioskop Then
-            If AutofocusForm.CheckBoxHighSpeed Then
-                GlobalCorrectionOffset = 15
-            Else
-                GlobalCorrectionOffset = 1.2
-            End If
-        ElseIf Lsm5.Info.IsAxioplan Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioVert Then
-            GlobalCorrectionOffset = 0
-        Else
-            GlobalCorrectionOffset = 0
-        End If
-    End If
-End Sub
-
-'''''''
-' Autofocus_StackShift ( NewPicture As DsRecordingDoc )
-' Performs image scan as in GlobalAutofocusRecording, calculation of signal centroid (mass)
-' global variables [ZMass] and [XMass], [YMasss] (FrameScan).
-'                  GlobalAutofocusRecording is set in function
-' This function does not change the focus just computes it
-'       [NewPicture] In/Out - Contains the image
-'''''''
-Public Function Autofocus_StackShift(NewPicture As DsRecordingDoc) As Boolean
-    Dim pixelDwell As Double
-    Dim BigZStep As Double
-    Dim LogMsg As String
-    Dim Time As Double
-    Dim Cnt As Integer
-
-    
-    
-    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-    DisplayProgress "Autofocus SetupScanWindow", RGB(0, &HC0, 0)
-    If NewPicture Is Nothing Then
-        Set NewPicture = Lsm5.NewScanWindow
-        While NewPicture.IsBusy
-            Sleep (100)
-            DoEvents
-        Wend
-    End If
-    
-    'Dim FramesPerStack As Double
-    'FramesPerStack = Lsm5.DsRecording.FramesPerStack
-    'Lsm5.DsRecording.FramesPerStack = 1
-    
-    'If Not ScanToImageNew(NewPicture) Then
-    '    Exit Function
-    'End If
-    
-    'Lsm5.DsRecording.FramesPerStack = FramesPerStack
-    
-    DisplayProgress "Autofocus: CheckZRange", RGB(0, &HC0, 0)
-    'checks again if Zranges are good
-    If Not AutofocusForm.CheckZRanges() Then
-        Autofocus_StackShift = False
-        Exit Function
-    End If
-    
-    SystemVersionOffset         ' extra offset depending on macroscope
-
-    ''''''''''''''''''
-    '** Autofocus ***'
-    ''''''''''''''''''
-    
-    DisplayProgress "Autofocus reset Z-position", RGB(0, &HC0, 0)
-    If AutofocusForm.CheckBoxHRZ Then
-        Lsm5.Hardware.CpHrz.Position = 0                ' center the piezo focus (or bring it down again ?)
-    End If
-    
-    Time = Timer
-    DisplayProgress "Autofocus acquire", RGB(0, &HC0, 0)
-    '''Check a last time that AF stack number and step is correct when in Fast Z-line mode
-    If (Not AutofocusForm.CheckBoxHRZ.Value) And AutofocusForm.ScanLineToggle.Value And AutofocusForm.CheckBoxFastZline.Value Then
-        If Lsm5.DsRecording.SpecialScanMode = "FocusStep" Then
-             DisplayProgress "Highest Z Step of 1.54 um with no piezo and Fast Z line has been reached. Autofocus uses slower Focus Step", RGB(&HC0, &HC0, 0)
-        End If
-        If AutofocusForm.BSliderZStep.Value > Round(Lsm5.DsRecording.FrameSpacing, 3) Then
-            DisplayProgress "Autofocus acquire. Highest Z Step with no piezo and Fast Z line " + CStr(Round(Lsm5.DsRecording.FrameSpacing, 3)) + " um. Autofocus uses slower Focus Step", RGB(&HC0, &HC0, 0)
-            Lsm5.DsRecording.SpecialScanMode = "FocusStep"
-            Lsm5.DsRecording.FrameSpacing = AutofocusForm.BSliderZStep.Value
-        End If
-    End If
-
-    If Not ScanToImageNew(NewPicture) Then
-        Exit Function
-    End If
-    
-    LogMsg = "% Autofocus_stackshift: acquire time " & Round(Timer - Time, 2)
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-    
-    Time = Timer
-    DisplayProgress "Autofocus compute", RGB(0, &HC0, 0)
-    
-    ' Computes XMass, YMass and ZMass
-    AutofocusForm.MassCenter ("Autofocus")
-    
-    LogMsg = "% Autofocus_stackshift: compute time " & Round(Timer - Time, 2)
-    LogMessage LogMsg, Log, LogFileName, LogFile, FileSystem
-
-    If Not ScanStop Then
-        Autofocus_StackShift = True
-    End If
-End Function
-
-
-'''''''
-'   ComputeShiftedCoordinates(XMass, ....)
-'   Calculates new coordinates after translation
-'       [XMass], [YMass], [ZMass]    In - Translation vector
-'       [x], [y], [z] Out - Shifted coordinates. Depends on stage build up and actual position. Positions are rounded up to PrecXY and PrecZ
-''''''
-Public Function ComputeShiftedCoordinates(ByVal XMass As Double, ByVal YMass As Double, ByVal ZMass As Double, ByRef x As Double, ByRef Y As Double, ByRef Z As Double)
-
-    If AreStageCoordinateExchanged Then
-        x = x - YMass
-        Y = Y - XMass
-    Else
-        x = x + XMass
-        Y = Y - YMass
-    End If
-        
-    Z = Z + ZMass
-    x = Round(x, PrecXY)
-    Y = Round(Y, PrecXY)
-    Z = Round(Z, PrecZ)
-End Function
-
-''''' ' this should move to function
-'   FailSafeMoveStage(Optional Mark As Integer = 0)
-'   Moves stage and wait till it is finished
-'       [x] In - x-position
-'       [y] In - y-position
-'''''
-Public Function FailSafeMoveStageXY(x As Double, Y As Double) As Boolean
-    
-    FailSafeMoveStageXY = False
-
-
-    Lsm5.Hardware.CpStages.SetXYPosition x, Y
-    'TODO Check this
-    Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-        Sleep (200)
-        If GetInputState() <> 0 Then
-            DoEvents
-            If ScanStop Then
-                ScanStop = True
-                Exit Function
-            End If
-        End If
-    Loop
-    
-    FailSafeMoveStageXY = True
-    
-End Function
-
-
-'''''
-'   FailSafeMoveStageZ(z As Double)
-'   Moves focus and wait till it is finished
-'       [z] In - z-position )
-'''''
-Public Function FailSafeMoveStageZ(Z As Double) As Boolean
-    FailSafeMoveStageZ = False
-    If ZBacklash <> 0 Then
-        Lsm5.Hardware.CpFocus.Position = Z - ZBacklash ' move at correct position
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy Or Lsm5.Hardware.CpFocus.IsBusy
-            Sleep (20)
-            If GetInputState() <> 0 Then
-                DoEvents
-                If ScanStop Then
-                    FailSafeMoveStageZ = False
-                    Exit Function
-                End If
-            End If
-        Loop
-    End If
-    Lsm5.Hardware.CpFocus.Position = Z  ' move at correct position
-    Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy Or Lsm5.Hardware.CpFocus.IsBusy
-        Sleep (20)
-        If GetInputState() <> 0 Then
-            DoEvents
-            If ScanStop Then
-                FailSafeMoveStageZ = False
-                Exit Function
-            End If
-        End If
-    Loop
-
-    FailSafeMoveStageZ = True
-End Function
-
-''''''
-'   Autofocus_MoveAcquisition
-'   Move stage and Z. To Z a ZOffset from the Autofocusform is added
-'       [XShift] In
-'       [YShift] In
-'       [ZShift] In
-''''''
-Public Function Autofocus_MoveAcquisition(XShift As Double, YShift As Double, ZShift As Double, ZOffset As Double) As Boolean
-    
-    Dim ZFocus As Double
-    Dim Zbefore As Double
-    Dim x As Double
-    Dim Y As Double
-        
-    '''''''''''''''''''''''''''''''''''''''
-    ' Moving to the correct position in Z
-    ' Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-    ZFocus = Lsm5.Hardware.CpFocus.Position + ZOffset + ZShift
-    ' Why do you need to move downward first ? Todo check if recquired step
-    Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash     'Moves down -50uM (ZBacklash) with the focus wheel
-    Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-        Sleep (20)
-        DoEvents
-    Loop
-    Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-    Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-        Sleep (20)
-        DoEvents
-    Loop
-    
-    ' Todo: one might add a lot of controls here, to wait to be sure the focus wheel can acces the position, and also to wait it is done...
-    Sleep (100)
-    DoEvents
-   
-    'This is moving the x and y position
-    'This we want only to do when xy-focus is set
-    'Moving to the correct position in X and Y
-    If AutofocusForm.ScanFrameToggle Then
-        ' Todo: check whether it moves in the correct direction
-        If AutofocusForm.CheckBoxAutofocusTrackXY Then
-            x = Lsm5.Hardware.CpStages.PositionX - XShift
-            Y = Lsm5.Hardware.CpStages.PositionY - YShift
-            Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, Y)
-        End If
-         
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            If ScanStop Then
-                Lsm5.StopScan
-                AutofocusForm.StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Autofocus_MoveAcquisition = False
-                Exit Function
-            End If
-            DoEvents
-            Sleep (5)
-        Loop
-    
-    End If
-    
-    ' center all z-stacks again!
-    Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * Lsm5.DsRecording.FramesPerStack / 2
-    
-    Autofocus_MoveAcquisition = True
-    
-End Function
-
-'''''
-'   MoveToNextLocation(Optional Mark As Integer = 0)
-'   Moves to next location as set in the stage (mark)
-'   Default will cycle through all positions sequentially starting from actual position
-'       [Mark] In - Number of position where to move.
-'''''
-Public Sub MoveToNextLocation(Optional Mark As Integer = 0)
-        Dim Markcount As Long
-        Dim count As Long
-        Dim idx As Long
-        Dim dX As Double
-        Dim dY As Double
-        Dim dZ As Double
-        Dim i As Integer
-        Lsm5.Hardware.CpStages.MarkMoveToZ (Mark)
-        'Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToMarkZ (0)  'old code Moves to the first location marked in the stage control. How to move to next point?
-        ' the points were deleted and readded at the end of list in the Acquisition function
-        'TODO: Check code
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-            Sleep (100)
-            If GetInputState() <> 0 Then
-                DoEvents
-                If ScanStop Then
-                    AutofocusForm.StopAcquisition
-                    Exit Sub
-                End If
-            End If
-        Loop
-End Sub
-
-
-Private Sub MovetoCorrectZPosition(ZOffset As Double)
-Const ZBacklash = -50
-Dim ZFocus As Double
-Dim Zbefore As Double
-Dim x As Double
-Dim Y As Double
-     ZFocus = Lsm5.Hardware.CpFocus.Position + ZOffset + ZShift
-       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash    'Moves down -50uM (ZBacklash) with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the AutofocusForm.CheckBoxHRZ.Value can acces the position, and also to wait it is done...
-        Sleep (100)
-        DoEvents
-End Sub
-
-''''
-'   Autofocus_MoveAcquisition_HRZ(ZOffset As Double)
-'   Allow to use HRZ for Move Z-stage (not used at the moment)
-''''
-Public Sub Autofocus_MoveAcquisition_HRZ(ZOffset As Double)
-    Dim NoZStack As Boolean
-    Const ZBacklash = -50
-    Dim ZFocus As Double
-    Dim Zbefore As Double
-    Dim x As Double
-    Dim Y As Double
-
-    AutofocusForm.RestoreAcquisitionParameters
-    
-    Set GlobalBackupRecording = Nothing
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    
-    NoZStack = True
-    If GlobalAcquisitionRecording.ScanMode = "ZScan" Or GlobalAcquisitionRecording.ScanMode = "Stack" Then  'Looks if a Z-Stack is going to be acquired
-        NoZStack = False
-    End If
-
-    'Moving to the correct position in Z
-    If AutofocusForm.CheckBoxHRZ.Value And NoZStack Then                                            'If using HRZ for autofocusing and there is no Zstack for image acquisition
-        Lsm5.Hardware.CpHrz.Stepsize = 0.2
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-        DoEvents
-     '   ZFocus = Lsm5.Hardware.CpHrz.Position + ZShift - ZOffset
-     
-     'Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-  
-        ZFocus = Lsm5.Hardware.CpHrz.Position + ZOffset + ZShift
-       
-        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-        
-        DoEvents
-
-    Else                                        'either there is a Z stack for image acquisition or we're using the focuswheel for autofocussing
-        If AutofocusForm.CheckBoxHRZ.Value Then                             ' Now I'm not sure with the signs and... I some point I just tried random combinations...
-            ZFocus = Lsm5.Hardware.CpHrz.Position - ZOffset - ZShift '         'ZBefore corresponds to the position where the focuswheel was before doing anything. Zshift is the calculated shift
-        Else                                    'If the HRZ is not calibrated the Z shift might be wrong
-            ZFocus = Zbefore + ZShift
-        End If
-       
-        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-    End If
-
-    'Moving to the correct position in X and Y
- 
-    If AutofocusForm.ScanFrameToggle Then
-        If AutofocusForm.CheckBoxAutofocusTrackXY Then
-            x = Lsm5.Hardware.CpStages.PositionX - XShift  'the fact that it is "-" in this line and "+" in the next line  probably has to do with where the XY of the origin is set (top right corner and not botom left, I think)
-            Y = Lsm5.Hardware.CpStages.PositionY - YShift
-            Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, Y)
-        End If
-         
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            If ScanStop Then
-                Lsm5.StopScan
-                AutofocusForm.StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-            DoEvents
-            Sleep (5)
-        Loop
-    End If
-    
-
-    DisplayProgress "Autofocus 14", RGB(0, &HC0, 0)
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    DisplayProgress "Autofocus 15", RGB(0, &HC0, 0)
-End Sub
-
-
-
diff --git a/AutofocusScreen/src/concat/A_Main_ModifySeries.bas b/AutofocusScreen/src/concat/A_Main_ModifySeries.bas
index b87f931..1f33c09 100644
--- a/AutofocusScreen/src/concat/A_Main_ModifySeries.bas
+++ b/AutofocusScreen/src/concat/A_Main_ModifySeries.bas
@@ -82,8 +82,7 @@ End Sub
 Public Sub ReadRegistryModify(key As String, myKey As String)
     GlobalNumberOfStacks = Lsm5.tools.RegLongValue(myKey, "GlobalNumberOfStacks")
     GlobalTimeIntv = Lsm5.tools.RegDoubleValue(myKey, "GlobalTimeIntv")
-    GlobalDirName = ""
-    'Lsm5.tools.RegStringValue(myKey, "Directory")
+    GlobalDirName = Lsm5.tools.RegStringValue(myKey, "Directory")
     GlobalFileSource = Lsm5.tools.RegLongValue(myKey, "GlobalFileSource")
        
 End Sub
diff --git a/AutofocusScreen/src/concat/DatabaseDialog.frm b/AutofocusScreen/src/concat/DatabaseDialog.frm
index 6af8eb1..c332c82 100644
--- a/AutofocusScreen/src/concat/DatabaseDialog.frm
+++ b/AutofocusScreen/src/concat/DatabaseDialog.frm
@@ -20,7 +20,7 @@ Attribute VB_Exposed = False
 ' Concat v2.0.2
 '''''''''''''''''''''End: Version Description'''''''''''''''''''''''''''''''''''''''''''''''''''''
 '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-Private Const Version = " v2.0.4"
+Private Const Version = " v2.0.3"
 Option Explicit 'force to declare all variables
 Private Pattern() As String
 
@@ -28,7 +28,6 @@ Dim DatabaseDialogLoaded As Boolean
 
 
 
-
 Private Sub StopButton_Click()
     flgBreak = True
 End Sub
@@ -473,11 +472,11 @@ On Error GoTo NoImage
         End If
         If GlobalFileSource = 0 Then
             If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-                'Set Thumbnail = SourceImageDocument.Thumbnail(0, 200, 200, SourceImage.ImageMemory.GetDimensionZ() / 2, SourceImage.ImageMemory.GetDimensionT() / 2, Nothing)
+'                Set Thumbnail = SourceImageDocument.Thumbnail(0, 200, 200, SourceImage.ImageMemory.GetDimensionZ() / 2, SourceImage.ImageMemory.GetDimensionT() / 2, Nothing)
                 Set Thumbnail = SourceImageDocument.Thumbnail
                 If Not Thumbnail Is Nothing Then
-                    'Image1.Picture = TransferPicture(Thumbnail).Picture
-                    'Image1.Visible = True
+                    Image1.Picture = TransferPicture(Thumbnail).Picture
+                    Image1.Visible = True
                     DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
                 Else
                     Image1.Visible = False
@@ -489,11 +488,11 @@ On Error GoTo NoImage
             End If
         Else
             Import.filename = GlobalFiles(ImagesListBox.ListIndex + 1)
-            'Import.ReadFullSizeFileInformation SourceImage
-            'Import.ReadThumbnail Thumbnail, Import.FileInfoSize(eAimImportExportCoordinateT) / 2, _
-            'Import.FileInfoSize(eAimImportExportCoordinateZ) / 2, 128, 128
-            'Image1.Visible = True
-            'Image1.Picture = TransferPicture(Thumbnail).Picture
+            Import.ReadFullSizeFileInformation SourceImage
+            Import.ReadThumbnail Thumbnail, Import.FileInfoSize(eAimImportExportCoordinateT) / 2, _
+            Import.FileInfoSize(eAimImportExportCoordinateZ) / 2, 128, 128
+            Image1.Visible = True
+            Image1.Picture = TransferPicture(Thumbnail).Picture
             User_flg = True
             Exit Sub
         
diff --git a/AutofocusScreen/src/concat/DatabaseDialog.frx b/AutofocusScreen/src/concat/DatabaseDialog.frx
index 2472a3c..eff6c45 100644
Binary files a/AutofocusScreen/src/concat/DatabaseDialog.frx and b/AutofocusScreen/src/concat/DatabaseDialog.frx differ
diff --git a/AutofocusScreen_LSM5_v1.7/._AutofocusScreen1_7.lvb b/AutofocusScreen_LSM5_v1.7/._AutofocusScreen1_7.lvb
deleted file mode 100644
index 59f3257..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/._AutofocusScreen1_7.lvb and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/._AutofocusScreen_help.pdf b/AutofocusScreen_LSM5_v1.7/._AutofocusScreen_help.pdf
deleted file mode 100644
index 59f3257..0000000
diff --git a/AutofocusScreen_LSM5_v1.7/._Concatenate1_10 LSM_40.lvb b/AutofocusScreen_LSM5_v1.7/._Concatenate1_10 LSM_40.lvb
deleted file mode 100644
index 59f3257..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/._Concatenate1_10 LSM_40.lvb and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/AutofocusScreen1_7.lvb b/AutofocusScreen_LSM5_v1.7/AutofocusScreen1_7.lvb
deleted file mode 100644
index ab34982..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/AutofocusScreen1_7.lvb and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/AutofocusScreen_help.pdf b/AutofocusScreen_LSM5_v1.7/AutofocusScreen_help.pdf
deleted file mode 100644
index 293bfb6..0000000
--- a/AutofocusScreen_LSM5_v1.7/AutofocusScreen_help.pdf
+++ /dev/null
@@ -1,213 +0,0 @@
- This macro works on our LSM 5 LIVE configuration at EMBL. Although it is
- designed to work on LSM 510 Classic and LSM510 Meta models, we cannot
- guarantee that it will work on other LSM configurations and we do not take any
- responsibility for damage occurring during or after its use.
-
-
-
-AutofocusScreen for LSM
-Features:
-- Screening experiments with user-defined grid formats
-- Multilocation time series
-- Reflection based or cell based autofocus
-- Tracking of cells
-- Tile function
-
-The Macro is designed for LSM 5 LIVE, LSM 510 Meta and LSM 510 Classic.
-When you start the Macro, it will be automatically adapted to the used device.
-
-For Multilocation experiments a motorized stage is needed. The autofocus can
-be done with an objective piezo, stage piezo or with the focus wheel. A piezo
-driven focus is not necessary.
-
-
-Use Help:
-The Macro can be use in three different experiment modes.
-
-   1. Experiments at a single location
-   2. Experiment with multiple locations chosen manually
-   3. Experiments with a grid array (e.g. 96 well plates, spotted labteks)
-
-
-
-
-You choose the location mode that you want to use in the top bar by pressing the
-corresponding button.
-
-The Macro will be adapted then to the experiment type.
-In this help file, you find for each of these modes an overview sheet that provides
-you all the information for the experiment type.
-                                             The Single Location Mode: Experiments with a single location
-     Experiment Set-Up Step by Step:                                                        Settings Overview:
-                                                               2
-1    Before you start the macro, select the tracks
-     you want to use for autofocus and imaging in                                                             Click Scan Line for hardware-based autofocus (choose
-                                                                                                              imaging settings that acquire the reflected laser light).
-     the LSM configuration control window.                              3                                      Click Scan Frame, if you want to use the cell-based autofocus
-     After starting the macro, the selected tracks                                                             (choose track that aquires the emitted light of your sample).
-
-     will appear in the Autofocus and Acquisiton                                        5                                                          With the Z-Step slider you can
-     modules.                                                                                                                    5 m
-                                                                                                                                                   change the distance of the
-                                                                                                                                        3 m       slices of the autofocus Z stack.
-2    Choose the location mode (e.g. single location) you                                7
-                                                                                              Z
-                                                                                                                                            1 m
-                                                                                                                                                   ScanSpeed-Slider: Adjust
-     want to use.                                                                                                                                  Scanspeed in lines per second.
-3    Choose the track you want to use for autofocus by
-     checking the corresponding box.                                                          Check             if you use high zoom values in the acquisition track. The Autofocus will
-                                                                                                                        X
-                                                                                              be taken then with Zoom Factor 1 to avoid that local dirt causes a wrong focus value.
-4    Acquire an image in the desired focus plane                            6                Check            if you want to use piezo stage or piezo objective for
-     with the LSM Scan Control dialogue.                                            9        autofocus rather than focus wheel.
-                                                                                             If you check                 the autofocus is repeated with a larger range, if a reflection
-5    Click Get current position offset: the Z offset will be                                 line is not found. This control mode is recommended for the acquisition of the Z profile.
-     updated automatically.
-6    Choose the tracks you want to acquire.
-7    Click Autofocus, to check if the desired plane in
-     your sample is found by the autofocus.
-8    Define database, where the images of the
-     timeseries should be stored.
-9    Press Start: Acquisition will begin.
-10   Select the appropriate delay time between two
-     rounds of acquisition. The delay time and number
-     of acquisitions can still be modified once the
-     acquisition has been started.                                                           Post Aquisition Tracking
-                                                                                             If you want to track single cells in x and y press Track Locations button.
-
-                                                                   10
-     For concatenation of the images use the macro                                           Choose the track you want to use for tracking in the dropdown menu. You can
-     Concatenate_v1.10-LSM40.                                                                track only in z if the selected track contains more than one z slice (the autofocus
-                                                                                             will then be deactivated).
-
-
-                                                                            8
-                                                                                            If you define tracks after starting the macro, press the
-                                                                                            Reinitialize button to update the tracklist in the macro.
-
-
-
-
-                                                                                            The infobox provides you information about the status of the macro.
-                        The Multiple Locations Mode: Experiments with multiple locations chosen manually
-     Experiment Set-Up Step by Step:                                                      Settings Overview:
-                                                                                 2
-1    Before you start the macro, select the tracks
-     you want to use for autofocus and imaging in                                                            Click Scan Line for hardware-based autofocus (choose
-                                                                    3                                        imaging settings that acquire the reflected laser light).
-     the LSM configuration control window.                                                                    Click Scan Frame, if you want to use the cell-based autofocus
-     After starting the macro, the selected tracks                                                            (choose track that aquires the emitted light of your sample).
-     will appear in the Autofocus and Acquisiton                                     5
-                                                                                                                                                   With the Z-Step slider you can
-     modules.                                                                         7                                                            change the distance of the
-                                                                                                                                 5 m
-2    Choose the location mode (e.g. multiple location)                                                                                  3 m       slices of the autofocus Z stack.
-                                                                                             Z
-                                                                                                                                            1 m
-     you want to use.                                                                                                                              ScanSpeed-Slider: Adjust
-                                                                                                                                                   Scanspeed in lines per second.
-3    Choose the track you want to use for autofocus by
-     checking the corresponding box.
-                                                                                              Check             if you use high zoom values in the acquisition track. The Autofocus will
-4    Acquire an image in the desired focus plane                        6                                               X
-                                                                                              be taken then with Zoom Factor 1 to avoid that local dirt causes a wrong focus value.
-     with the LSM Scan Control dialogue.                                             11      Check            if you want to use piezo stage or piezo objective for
-                                                                                             autofocus rather than focus wheel.
-     Click Get current position offset: the Z offset will be                                 If you check                 the autofocus is repeated with a larger range, if a reflection
-5
-                                                                                             line is not found. This control mode is recommended for the acquisition of the Z profile.
-     updated automatically.
-6    Choose the tracks you want to acquire.                                                 Locations Settings
-7    Click Autofocus to check if the desired plane in                                        Tile Locations: Acquire a larger area at each
-                                                                                             location by imaging serveral frames arranged
-     your sample is found by the autofocus.                                                  side by side. Enter the numer of tiles you want         Tile X: 1   Tile X: 2   Tile X: 2
-                                                                                             to acquire and click           .                        Tile Y: 1   Tile Y: 1   Tile Y: 2
-8    Mark the locations you want to acquire with
-                                                                                             Zmap: Measurement of z Values at the locations you want to acquire before you start the
-     the Stage and Focus Control dialogue of the                             9               experiment. If          is checked, a reference autofocus is taken only at the frist location
-     LSM software.                                                                           during the experiment. Values of other locations will be corrected by the same offset value.
-                                                                                             With this mode you can acquire more locations in the same time period, but the sample
-9    Click Start Zmap to get an automated                                                    has to be fixed by the object holder very tightly.
-     Z-profile of your sample (optional step to
-     increase number of locations imaged in a                                                Post Aquisition Tracking
-     time period).                                                                           If you want to track single cells in x and y press Track Locations button.
-10   Define database, where the images of the                  12
-     timeseries should be stored.                                                            Choose the track you want to use for tracking in the dropdown menu. You can
-                                                                                             track only in z if the selected track contains more than one z slice (the autofocus
-11   Click Start: Acquisition will begin.                                                    will then be deactivated).
-
-12   Select the appropriate delay time between two                      10
-                                                                                           If you define tracks after starting the macro, press the
-     rounds of acquisition. The delay time and number                                      Reinitialize button to update the tracklist in the macro.
-     of acquisitions can still be modified once the
-     acquisition has been started.
-     For concatenation of the images use the macro
-     Concatenate_v1.10-LSM40.                                                             The infobox provides you with information about the status of the macro.
-                                            The Grid Mode: Experiments with locations arranged in a grid
-      Experiment Set-Up Step by Step:                                                               Settings Overview:
-                                                                                      2
-1     Before you start the macro, select the tracks
-      you want to use for the autofocus and imaging
-                                                                        3                                                Click Scan Line for hardware-based autofocus (choose
-      in the LSM configuration control window.                                                                           imaging settings that acquire the reflected laser light).
-     After starting the macro, the selected tracks will                                                                   Click Scan Frame, if you want to use the cell-based autofocus
-     appear in the Autofocus and Acquisiton modules.                                            5
-                                                                                                                          (choose track that aquires the emitted light of your sample).
-
-2    Choose the location mode (e.g. Grid) you want to use.                                      7                                                            With the Z-Step slider you can
-                                                                                                                                                             change the distance of the
-3    Choose the track you want to use for autofocus by                                                                                     5 m
-                                                                                                                                                             slices of the autofocus Z stack.
-                                                                                                       Z                                          3 m
-     checking the corresponding box.                                                                                                                  1 m
-                                                                                                                                                             ScanSpeed-Slider: Adjust
-4    Acquire an image in the desired focus plane                                                                                                             Scanspeed in lines per second.
-     with the LSM Scan Control dialogue.
-5    Click Get current position offset: the Z offset will be                6                           Check             if you use high zoom values in the acquisition track. The Autofocus will
-                                                                                                                                  X
-                                                                                                        be taken then with Zoom Factor 1 to avoid that local dirt causes a wrong focus value.
-     automatilly updated.                                                                      14
-                                                                                                       Check            if you want to use piezo stage or piezo objective for
-6    Choose the tracks you want to acquire.                                                            autofocus rather than focus wheel.
-                                                                                                       If you check                 the autofocus is repeated with a larger range, if a reflection
-7    Press Autofocus, to check if the desired plane in                                                 line is not found. This control mode is recommended for the acquisition of the Z profile.
-                                                                    8
-     your sample is found by the autofocus.
-                                                                                                     Locations Settings
-                                                                                          10
-8    Enter the settings of your grid.                                                                      Step X (um)                                                     You can store and reload grids.
-                                                                                                                                                                           To open the corresponding
-9    Select the numbers of tiles to be imaged at each                        9                                                                                             window press Store/Apply.
-                                                                                                           Step Y (um)
-     location.
-                                                                                      11                                     unidirectional         bidirectional
-10   Click Show Grid: A window appears displaying the grid.                                                                  scanning               scanning
-                                                                                 12
-     Select and deselect locations with the mouse left                                                 Tile Locations: Acquire a larger area at each
-     button. Move the stage to a reference point in your                                               location by imaging serveral frames arranged
-                                                                                                       side by side.                                           Tile X: 1     Tile X: 2   Tile X: 2
-     sample. Mark this location in the visualized grid with                                                                                                    Tile Y: 1     Tile Y: 1   Tile Y: 2
-     mouse right button click.
-                                                                                                      Zmap: Measurement of z- Values at the locations you want to acquire before you start the
-11   Click Update Stage: The selected locations will                                                  experiment. If          is checked, a reference autofocus is taken only at the frist location
-     appear in the Stage and Focus Control Window of                                                  during the experiment. Values of other locations will be corrected by the same offset value.
-                                                                                                      With this mode you can aquire more locations in the same time period, but the sample
-     the LSM software.                                         15                                     has to be fixed by the object holder very tightly.
-12   Click Start Zmap to get an automated
-     Z-profile of your sample.                                                                      If you define tracks after starting the macro, press the
-                                                                                                    Reinitialize button to update the tracklist in the macro.
-13   Define database, where the images of the
-                                                                            13
-     timeseries should be stored.                                                                      Post Aquisition Tracking
-14   Click Start: Acquisition starts.                                                                  If you want to track single cells in x and y press Track Locations button.
-15   Select the appropriate delay time between two
-     rounds of aquisition. The delay time and number                                                   Choose the track you want to use for tracking in the dropdown menu. You can
-                                                                                                       track only in z if the selected track contains more than one z slice (the autofocus
-     of acquisitions can still be modified once the                                                    will then be deactivated).
-     acquisition has been started.
-                                                                                                    The infobox provides you with information about the status of the macro.
-                                                                                                    Move with the mouse pointer above the current displayed grid: column, row and
-     For concatenation of the images use the macro                                                  mark number will appear.
-     Concatenate_v1.10-LSM40.
-
\ No newline at end of file
diff --git a/AutofocusScreen_LSM5_v1.7/Concatenate1_10 LSM_40.lvb b/AutofocusScreen_LSM5_v1.7/Concatenate1_10 LSM_40.lvb
deleted file mode 100644
index 1aabf0a..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/Concatenate1_10 LSM_40.lvb and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/src/AutofocusForm.frm b/AutofocusScreen_LSM5_v1.7/src/AutofocusForm.frm
deleted file mode 100644
index 9601072..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/AutofocusForm.frm
+++ /dev/null
@@ -1,3212 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} AutofocusForm 
-   Caption         =   "AutofocusScreen"
-   ClientHeight    =   13065
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   6600
-   OleObjectBlob   =   "AutofocusForm.frx":0000
-   ShowModal       =   0   'False
-   StartUpPosition =   3  'Windows Default
-End
-Attribute VB_Name = "AutofocusForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-
-
-
-
-
-
-
-
-
-
-
-
-Private Sub CheckBoxInnactivateAutofocus_Click()    ' changes look of inactivated buttom if checked and verfies that the posacquisition Z tracking is not activated if autofocusing is reactivated
-                                                    
-    If CheckBoxInnactivateAutofocus.Value = False Then
-              CheckBoxInnactivateAutofocus.BackColor = &HFFFFFF
-     
-    Else
-        CheckBoxInnactivateAutofocus.BackColor = 33023
-    End If
-End Sub
-
-
-
-Private Sub CheckBoxLowZoom_Click()
-'There is nothing to do when clicking on this
-End Sub
-
-
-
-
-
-
-
-
-Private Sub CommandButton1_Click()
-
-    Dim dblTask As Double
-    Dim MacroPath As String
-    Dim Mypath As String
-    Dim MyPathPDF As String
-    
-    Dim bslash As String
-    Dim success As Integer
-    Dim pos As Integer
-    Dim Start As Integer
-    Dim Count As Long
-    Dim ProjName As String
-    Dim indx As Integer
-    Dim AcrobatObject As Object
-    Dim AcrobatViewer As Object
-    Dim OK As Boolean
-    Dim StrPath As String
-    Dim ExecName As String
-    
-       
-    
-    Count = ProjectCount()
-    For indx = 0 To Count - 1
-        MacroPath = ProjectPath(indx, success)
-        ProjName = ProjectTitle(indx, success)
-        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, MacroPath, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            Mypath = Strings.Left(MacroPath, Start - 1)
-            MyPathPDF = Mypath + HelpNamePDF
-
-            OK = False
-            On Error GoTo RTFhelp
-            OK = FServerFromDescription("AcroExch.Document", StrPath, ExecName)
-            dblTask = Shell(ExecName + " " + MyPathPDF, vbNormalFocus)
-            
-RTFhelp:
-            If Not OK Then
-                MsgBox "Install Acrobat Viewer!"
-            End If
-            Exit For
-        End If
-    Next indx
-End Sub
-
-Private Sub CommandButtonStoreApply_Click()
- StoreApplyForm.Show 0
- End Sub
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Private Sub ScanLineToggle_Click()
-    ScanFrameToggle.Value = Not ScanLineToggle.Value 'if ScanFrame is true ScanLine is false (you can only chose one of them)
-    FrameAutofocussing = ScanFrameToggle.Value 'if ScanFrame is true than FrameAutofocusing (boolean variable) will be set true as well
-    FrameSizeLabel.Visible = ScanFrameToggle.Value 'FrameSize Label is only displayed if ScanFrame is activated
-    BSliderFrameSize.Visible = ScanFrameToggle.Value 'FrameSize Slider is only displayed if ScanFrame is activated
-    BSliderScanSpeed.Visible = ScanLineToggle.Value
-    ScanSpeedLabel.Visible = ScanLineToggle.Value
-End Sub
-
-Private Sub ScanFrameToggle_Click()
-    ScanLineToggle.Value = Not ScanFrameToggle.Value 'if ScanLine is chosen, ScanFrame will be unchecked
-    FrameAutofocussing = ScanFrameToggle.Value 'if ScanFrame is true than FrameAutofocusing (boolean variable) will be set true
-    FrameSizeLabel.Visible = ScanFrameToggle.Value
-    
-    BSliderScanSpeed.Visible = ScanLineToggle.Value
-    ScanSpeedLabel.Visible = ScanLineToggle.Value
-
-'         If SystemName = "LSM" Then
-'
-'            BSliderFrameSize.ValueEditable = True
-'             BSliderFrameSize.Min = 16
-'            BSliderFrameSize.Max = 1024
-'            BSliderFrameSize.Step = 128
-'            BSliderFrameSize.StepSmall = 4
-'           BSliderFrameSize.ValueDisplay = True
-'
-'        ElseIf SystemName = "LIVE" Then
-'
-'
-'            BSliderFrameSize.ValueEditable = False
-'            BSliderFrameSize.Min = 128
-'            BSliderFrameSize.Max = 1024
-'            BSliderFrameSize.Step = 128
-'            BSliderFrameSize.StepSmall = 128
-'            BSliderFrameSize.Value = 128
-'
-'        End If
-   
-  BSliderFrameSize.Visible = ScanFrameToggle.Value
-  
-End Sub
-
-Private Sub SetFocusButton_Click()
-    AutofocusForm.GetBlockValues                                             'Updates the parameters value for BlockZRange, BlockZStep....
-    SetFocus BlockZRange, BlockZStep, BlockLowZoom, BlockHighSpeed, BlockZOffset  ' Performs the scan in Z (line or Frame, to find the offset value
-End Sub
-
-
-
-Private Sub AutofocusButton_Click()
-    Dim AutofocusDoc As DsRecordingDoc
-    Try = 1
-    AutofocusForm.GetBlockValues 'Updates the parameters value for BlockZRange, BlockZStep..
-    DisplayProgress "Autofocus 0", RGB(0, &HC0, 0)
-    Lsm5.StopScan
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    StoreAquisitionParameters
-    Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-    If ScanStop = True Then
-        GoTo Abort
-    End If
-    'check if Z shift makes sense
-    CheckRefControl BlockZRange
-    If CheckBoxMoveHRZ.Value = True Then
-    Autofocus_MoveAquisition_HRZ BlockLowZoom, BlockZOffset
-    Else
-    Autofocus_MoveAquisition BlockLowZoom, BlockZOffset
-    End If
-    If ScanStop = True Then
-        GoTo Abort
-    End If
-    'DoAutofocus BlockZOffset, BlockZRange, BlockZStep, BlockHRZ, BlockLowZoom, BlockHighSpeed  ' Performs the scan in Z (line or Frame, to find the offset value
-
-    ActivateAcquisitionTrack
-    If IsAcquisitionTrackSelected And IsAutofocusTrackSelected Then
-        Sleep (20)
-        Set AutofocusDoc = Lsm5.StartScan
-    Do While AutofocusDoc.IsBusy                                  ' Waiting untill the image acquisition is done
-        If ScanStop Then
-            Lsm5.StopScan
-            GoTo Abort
-        End If
-        DoEvents
-        Sleep (10)
-    Loop
-        Lsm5.tools.WaitForScanEnd False, 20       'Wait untill the scan is finnished, the waiting time is 20s. This could be too short in some instances
-    Else
-     GoTo Abort
-    End If
-Abort:
-If Not (GlobalBackupRecording Is Nothing) Then
-    RestoreAquisitionParameters
-    Set GlobalBackupRecording = Nothing
-   Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents                                'Finnish everything which had started
-    'ActivateAcquisitionTrack                'Activates the tracks for image acquisition
-End If
-    If ScanStop = True Then
-        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-        ScanStop = False
-    Else
-        DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    End If
-End Sub
-
-Private Sub StartBleachButton_Click()
-    Dim success As Integer
-    AutomaticBleaching = False
-    If LocationTracking And TrackingChannelString = "" Then
-        MsgBox ("Select a channel for tracking, or uncheck the tracking button")
-        Exit Sub
-    End If
-    If MultipleLocation And Lsm5.Hardware.CpStages.MarkCount < 1 Then
-        MsgBox ("Select at least one location in the stage control window, or uncheck the multiple location button")
-        Exit Sub
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No Database selected ! Cannot start acquisition.")
-        Exit Sub
-    End If
-    Set Track = Lsm5.DsRecording.TrackObjectBleach(success)
-    If success Then
-        If Track.BleachPositionZ <> 0 Then
-            MsgBox ("This macro does not enable to bleach at a different Z position. Please uncheck the corresponding box in the Bleach Control Window")
-            Exit Sub
-        End If
-        If Lsm5.IsValidBleachRoi Then
-            If (Track.BleachScanNumber + 1) > BlockRepetitions Then
-                MsgBox ("Not enough repetitions to bleach")
-                Exit Sub
-            End If
-            FillBleachTable
-            AutomaticBleaching = True
-            Track.UseBleachParameters = True
-        Else
-            MsgBox ("A bleaching ROI needs to be defined to start the macro in the bleaching mode")
-            Exit Sub
-        End If
-    Else
-        MsgBox ("A bleach track needs to be defined to start the macro in the bleaching mode")
-        Exit Sub
-    End If
-    StartAcquisition
-End Sub
-
-Private Sub FillBleachTable()                              'Fils a table for the macro to know when the bleaches have to occur. This works for FRAPs (and FLIPS if working with LSM 3.2)
-    Set Track = Lsm5.DsRecording.TrackObjectBleach(success)
-    If success Then
-        ReDim BleachTable(BlockRepetitions)               'The bleach table contains as many timepoints as blockrepetitions
-    'When working with the Lsm 2.8, remove all this test, except the one indicated line
-        If Track.EnableBleachRepeat Then
-            For i = Track.BleachScanNumber + 1 To BlockRepetitions Step Track.BleachRepeat
-                BleachTable(i) = True
-            Next
-        Else
-            BleachTable(Track.BleachScanNumber + 1) = True  'This is the only line to be kept when working with the Lsm 2.8
-        End If
-    End If
-End Sub
-
-Private Sub StartButton_Click()
-    Try = 1
-    AutomaticBleaching = False                                  'We do not do FRAps or FLIPS in this case. Bleaches can still be done with the "ExtraBleach" button.
-    If LocationTracking And TrackingChannelString = "" Then
-        MsgBox ("Select a channel for tracking, or uncheck the tracking button")
-        Exit Sub
-    End If
-    If MultipleLocation And Lsm5.Hardware.CpStages.MarkCount < 1 Then
-        MsgBox ("Select at least one location in the stage control window, or uncheck the multiple location button")
-        Exit Sub
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No Database selected ! Cannot start acquisition.")
-        Exit Sub
-    End If
-    
-    StartAcquisition 'This is the main function of the macro
-    
-End Sub
-
-Private Sub StartAcquisition()
-     Dim rettime, difftime As Double
-    Dim GlobalPrvTime As Double
-    Dim Location As Integer
-    Dim LocationNumber As Integer
-    Dim LocationName As String
-    Dim name As String
-    Dim tilename As String
-    Dim x As Double
-    Dim XCor As Double
-    Dim y As Double
-    Dim YCor As Double
-    Dim z As Double
-    Dim ZCor As Double
-    Dim ZBacklash As Double                 'I forgot to initialize this to -50
-    Dim success As Integer
-    Dim RelativeLocation As Integer
-    Dim StitchImage As RecordingDocument
-    Dim ScanImage As RecordingDocument
-    Dim ImageCopy As New AimImageCopy
-    Dim Progress As AimProgress
-    Dim Scancontroller As AimScanController
-    Dim TileDatabaseName As String
-    Dim NameLength As Integer
-    Dim Myname As String
-    Dim Mypath As String
-    Dim TileXOld As Integer
-    Dim r As Integer
-    
-    
-    
-            '''''''''''''''''''''''''create stiching database''''''''''''''''''''
-TileX = AutofocusForm.TextBoxTileX.Value
-TileY = AutofocusForm.TextBoxTileY.Value
-
-If TileX > 1 Or TileY > 1 Then
-            
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, GlobalDataBaseName, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            Mypath = Strings.Left(GlobalDataBaseName, Start - 1)
-            NameLength = Len(GlobalDataBaseName)
-            Myname = Strings.Right(GlobalDataBaseName, NameLength - Start + 1)
-            NameLength = Len(Myname)
-            Myname = Strings.Left(Myname, NameLength - 4)
-            TileDatabaseName = Mypath & Myname & "_tile.mdb"
-            Lsm5.NewDatabase (TileDatabaseName)
-            TileDatabaseName = TileDatabaseName & "\" & Myname & "_tile.mdb"
-End If
-''''''''''''''''''''end create stiching database
-    
-    
-    InitializeStageProperties
-    SetStageSpeed 9, True
-    
-    GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-    If MultipleLocation Or Grid Then
-    PutStagePositionsInArray
-    End If
-    
-    
-            
-    RepetitionNumber = 1
-    Running = True                              'Now we're starting. This will be set to false if the sopt button is pressed or if we reached the total number of repetitions.
-    StartButton.Enabled = False
-    StartBleachButton.Enabled = False
-    CloseButton.Enabled = False
-    ReinitializeButton.Enabled = False
-   'SetFocusButton.Enabled = False
-   'AutofocusButton.Enabled = False
-   If TileX > 1 Or TileY > 1 Then
-    Set Scancontroller = Lsm5.ExternalDsObject.Scancontroller
-   End If
-    
-    If MultipleLocation Or Grid Then                    'Defines the Location Number parameter
-        LocationNumber = Lsm5.Hardware.CpStages.MarkCount       'Counts the locations stored in the Stage control window from the LSM
-    Else
-        LocationNumber = 1                                      'If using the single location you do not have to mark it in the stage control window.
-    End If
-    If LocationTracking Or FrameAutofocussing Then
-'        Excel.Application.Visible = True                               'The Excel stuff is to store the XYZ position of the cells at each time point
-'        Set PositionData = Excel.Workbooks.Add
-'        For Location = 1 To LocationNumber
-'            PositionData.Sheets.Add
-'            PositionData.ActiveSheet.name = "Location " & Location
-'            PositionData.ActiveSheet.Columns("A:A").Select
-'            Selection.NumberFormat = "m/d/yyyy h:mm:ss"
-'            PositionData.ActiveSheet.Cells(1, 1) = "Time"
-'            PositionData.ActiveSheet.Cells(1, 2) = "X (m)"
-'            PositionData.ActiveSheet.Cells(1, 3) = "Y (m)"
-'            PositionData.ActiveSheet.Cells(1, 4) = "Z (m)"
-'            PositionData.ActiveSheet.Cells(1, 6) = "Time delay"
-'            PositionData.ActiveSheet.Columns("F:F").Select
-'            Selection.NumberFormat = "[h]:mm:ss"
-'            PositionData.ActiveSheet.Cells(1, 7) = "Total Distance (m)"
-'        Next Location
-    End If
-    
-    
-    Do While Running                                    'As long as the macro is running we're in this loop
-    If CheckBoxZMap.Value Then
-        Location = 1
-        Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToMarkZ (0)  'Moves to the first location marked in the stage control
-                Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-                    If ScanStop Then        'now when we're waiting for things to happen we allow the user to stop the macro
-                        Lsm5.StopScan
-                        StopAcquisition
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        Exit Sub
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-   
-        AutofocusForm.GetBlockValues                                'Updates the parameters value for BlockZRange, BlockZStep..
-        Lsm5.StopScan
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-        DoEvents
-        StoreAquisitionParameters
-        Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-        'check if Z shift makes sense
-        CheckRefControl BlockZRange
-        'Caluclate new z Position, Store Z in Array
-'        If Grid Or MultipleLocation Then
-'        Lsm5.Hardware.CpStages.MarkClearAll
-'        For idpos = 1 To GlobalPositionsStage
-'            GlobalZpos(idpos) = GlobalZpos(idpos) + ZShift
-'            Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-'        Next idpos
-'        Else
-'        GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-'            For idpos = 1 To GlobalPositionsStage
-'            success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).GetMarkZ(0, x, y, z)
-'           success = Lsm5.Hardware.CpStages.MarkClear(0)
-'            z = z + ZShift
-'            Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ x, y, z
-'        Next idpos
-'        End If
-        Sleep (100)
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-                 DoEvents
-         Sleep (100)
-                  
-        RestoreAquisitionParameters
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-                 DoEvents
-    End If
-    
-    If Not (LocationTracking Or FrameAutofocussing) Then
-        If Grid Or MultipleLocation Then
-            Lsm5.Hardware.CpStages.MarkClearAll
-            For idpos = 1 To GlobalPositionsStage
-                GlobalZpos(idpos) = GlobalZpos(idpos) - ZShift
-                Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-            Next idpos
-            Else
-            GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-                For idpos = 1 To GlobalPositionsStage
-                success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).GetMarkZ(0, x, y, z)
-               success = Lsm5.Hardware.CpStages.MarkClear(0)
-                z = z + ZShift
-                Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ x, y, z
-            Next idpos
-            End If
-    End If
-    
-    
-        For Location = 1 To LocationNumber              'This loops all the locations (only one if Single location is selected
-            If MultipleLocation Or Grid Then
-                Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToMarkZ (0)  'Moves to the first location marked in the stage control
-                Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-                    If ScanStop Then        'now when we're waiting for things to happen we allow the user to stop the macro
-                        Lsm5.StopScan
-                        StopAcquisition
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        Exit Sub
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-            End If
-    
-            If CheckBoxInnactivateAutofocus Then  ' Looking if needs to perform an autofocus
-                ZShift = 0
-            Else
-                
-                If CheckBoxZMap.Value Then GoTo AfterAutofocus
-                  
-                'MsgBox ("doing AF")
-                 AutofocusForm.GetBlockValues
-                 DisplayProgress "Autofocus 0", RGB(0, &HC0, 0)
-                 Lsm5.StopScan
-                 Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-                 DoEvents
-                 StoreAquisitionParameters
-                 Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                 CheckRefControl BlockZRange
-                 
-                 Autofocus_MoveAquisition BlockLowZoom, BlockZOffset
-                ' DoAutofocus BlockZOffset, BlockZRange, BlockZStep, BlockHRZ, BlockLowZoom, BlockHighSpeed
-            End If
-          
-    
-AfterAutofocus:
-           AutofocusForm.ActivateAcquisitionTrack
-           Sleep (100) 'laser hast to swtich from standby to on
-            If Not IsAcquisitionTrackSelected Then      'An additional control....
-                StopAcquisition
-                MsgBox "No track selected for Acquisition! Cannot Acquire!"
-                DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-                Exit Sub
-            End If
-    
-            If BleachTable(RepetitionNumber) = True Then                                            'Check if we're performing a bleach before image acquisition
-                Set Track = Lsm5.DsRecording.TrackObjectBleach(success)
-                If success Then
-                    DisplayProgress "Bleaching", &HFF00FF
-                    DoEvents
-                    Track.UseBleachParameters = True            'Bleach parameters are lasers lines, bleach iterations... stored in the bleach control window
-'                    BleachStartTable(RepetitionNumber) = Lsm5.ExternalCpObject.pHardwareObjects.pScanController.GetDspTime
-                    BleachStartTable(RepetitionNumber) = GetTickCount       'Get the time right before bleach to store this in the image metadata
-                    Lsm5.Bleach 0
-                    Lsm5.tools.WaitForScanEnd False, 1                      'Waits for the end of the bleach during one second, I think this is not long enough
-                    BleachStopTable(RepetitionNumber) = GetTickCount       'Get the time right after bleach to store this in the image metadata
-'                    BleachStopTable(RepetitionNumber) = Lsm5.ExternalCpObject.pHardwareObjects.pScanController.GetDspTime
-                    Track.UseBleachParameters = False  'switch off the bleaching
-                Else
-                    MsgBox ("Could not set bleach track. Did not bleach.")
-                End If
-                If Location = LocationNumber Then   'Alowas again to do an extrableach at the en
-                    ExtraBleachButton.Caption = "Bleach"
-                    ExtraBleachButton.BackColor = &H8000000F
-                End If
-            End If
-    
-            DisplayProgress "Acquiring location " & Location & ", repetition " & RepetitionNumber, RGB(&HC0, &HC0, 0)  'Now we're going to do the acquisition
-            Lsm5.DsRecording.TimeSeries = True              'This is for the concatenation I think: we're doing a timeseries with one timepoint. I'm not sure why is the reason for this
-            Lsm5.DsRecording.StacksPerRecord = 1
-            
-  
-            Sleep (100)
-            'Set Track = Lsm5.DsRecording.TrackObjectByIndex(3, Success)
-            
-            
-         If TileX > 1 Or TileY > 1 Then
-            
-            If Lsm5.DsRecording.ScanMode = "Stack" Then
-                Set ScanImage = Lsm5.ExternalDsObject.MakeNewImageDocument(Lsm5.DsRecording.RtRegionWidth, _
-                                                               Lsm5.DsRecording.RtRegionWidth, _
-                                                               Lsm5.DsRecording.FramesPerStack, _
-                                                               Lsm5.DsRecording.StacksPerRecord, _
-                                                               Lsm5.DsRecording.NumberOfChannels, _
-                                                               Bytesperpixel, _
-                                                               0)
-            Else
-                Set ScanImage = Lsm5.ExternalDsObject.MakeNewImageDocument(Lsm5.DsRecording.RtRegionWidth, _
-                                                               Lsm5.DsRecording.RtRegionWidth, _
-                                                               1, _
-                                                               Lsm5.DsRecording.StacksPerRecord, _
-                                                               Lsm5.DsRecording.NumberOfChannels, _
-                                                               Bytesperpixel, _
-                                                               0)
-            End If
-        
-                   
-            If ScanImage Is Nothing Then Exit Sub
-                
-            ScanImage.NeverAgainScanToTheImage
-            
-            'MsgBox "taking the tile imgae"
-            Scancontroller.DestinationImage(0) = ScanImage.Image(0, True)
-            Scancontroller.InitializeDestinationImages eGrabModeSingle
-            Scancontroller.StartGrab eGrabModeSingle
-            While Scancontroller.IsGrabbing
-                DoEvents
-                Sleep (10)
-                If ScanStop Then
-                   Lsm5.StopScan
-                   StopAcquisition
-                   DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                   Exit Sub
-                End If
-            Wend
-            
-        Else ' NO TILING
-            
-            ' HERE THE TILING IMAGE IS TAKEN!!!!
-            Set RecordingDoc = Lsm5.StartScan()         'Start image acquisition
-          
-              End If
-          
-          
-            If RepetitionNumber = 1 Then
-                StartTime = GetTickCount            'Get the time when the acquisition was started
-            End If
-            If MultipleLocation Or Grid Then                'Sets the name of the image to store in the database
-                LocationName = "_L" & Location
-            Else
-                LocationName = ""
-            End If
-            If Grid Then
-                LocationName = "_" & GlobalLocationsName(Location) & LocationName
-            End If
-            
-            If TileX > 1 Or TileY > 1 Then
-                name = GlobalFileName & LocationName & "_R" & RepetitionNumber
-                ScanImage.SetTitle name
-'            Do While ScanImage.IsBusy                        'Wait the end of the scan
-'               If ScanStop Then
-'                    Lsm5.StopScan
-'                    StopAcquisition
-'                    DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-'                    Exit Sub
-'               End If
-'               DoEvents
-'               Sleep (5)
-'            Loop
-            Else
-                name = GlobalFileName & LocationName & "_R" & RepetitionNumber
-                RecordingDoc.SetTitle name
-                Do While RecordingDoc.IsBusy                        'Wait the end of the scan
-                   If ScanStop Then
-                        Lsm5.StopScan
-                        StopAcquisition
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        Exit Sub
-                   End If
-                   DoEvents
-                   Sleep (5)
-                Loop
-            End If
-            Lsm5.tools.WaitForScanEnd False, 10
-            
-'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''stitching
-        If TileX > 1 Or TileY > 1 Then    'step into stitching routine if you have more than 1 frame at each location
-            RelativeLocation = Location Mod (TileX * TileY)
-            If RelativeLocation = 0 Then RelativeLocation = (TileX * TileY)
-            
-            If Lsm5.DsRecording.TrackObjectByIndex(0, success).DataChannelObjectByIndex(0, success).BitsPerSample > 8 Then
-                Bytesperpixel = 2
-            Else
-                Bytesperpixel = 1
-            End If
-         
-        
-                If RelativeLocation = 1 Then 'at each first frame of a new tile group define a new image
-            If AreStageCoordinateExchanged Then
-                If Lsm5.DsRecording.ScanMode = "Stack" Then
-                    Set StitchImage = Lsm5.ExternalDsObject.MakeNewImageDocument(CLng(Lsm5.DsRecording.RtRegionWidth * TileY), _
-                                                                     CLng(Lsm5.DsRecording.RtRegionHeight * TileX), _
-                                                                     Lsm5.DsRecording.FramesPerStack, _
-                                                                     1, _
-                                                                     Lsm5.DsRecording.NumberOfChannels, _
-                                                                     Bytesperpixel, _
-                                                                     1)
-                  Else
-                    Set StitchImage = Lsm5.ExternalDsObject.MakeNewImageDocument(CLng(Lsm5.DsRecording.RtRegionWidth * TileY), _
-                                                                     CLng(Lsm5.DsRecording.RtRegionHeight * TileX), _
-                                                                     1, _
-                                                                     1, _
-                                                                     Lsm5.DsRecording.NumberOfChannels, _
-                                                                     Bytesperpixel, _
-                                                                     1)
-                    End If
-        Else
-                 If Lsm5.DsRecording.ScanMode = "Stack" Then
-                    Set StitchImage = Lsm5.ExternalDsObject.MakeNewImageDocument(CLng(Lsm5.DsRecording.RtRegionWidth * TileX), _
-                                                                     CLng(Lsm5.DsRecording.RtRegionHeight * TileY), _
-                                                                     Lsm5.DsRecording.FramesPerStack, _
-                                                                     1, _
-                                                                     Lsm5.DsRecording.NumberOfChannels, _
-                                                                     Bytesperpixel, _
-                                                                     1)
-                  Else
-                    Set StitchImage = Lsm5.ExternalDsObject.MakeNewImageDocument(CLng(Lsm5.DsRecording.RtRegionWidth * TileX), _
-                                                                     CLng(Lsm5.DsRecording.RtRegionHeight * TileY), _
-                                                                     1, _
-                                                                     1, _
-                                                                     Lsm5.DsRecording.NumberOfChannels, _
-                                                                     Bytesperpixel, _
-                                                                     1)
-                    End If
-            End If
-                                                                     '''''overlap is still missing
-                                                                     
-                    If StitchImage Is Nothing Then Exit Sub
-                    
-                
-                End If
-              
-                StitchImage.NeverAgainScanToTheImage
-            
-       ' ImageCopy.SourceImage = RecordingDoc.Image(0, False)
-  
-        ImageCopy.SourceImage = ScanImage.Image(0, False)
-        ImageCopy.DestinationImage = StitchImage.Image(0, False)
-        
-'        If RelativeLocation Mod TileY = 0 Then
-'        ImageCopy.DestinationY = 0
-'        Else
-If AreStageCoordinateExchanged Then
-If RelativeLocation = 1 Then r = 1
- ImageCopy.DestinationX = (TileY - r) * Lsm5.DsRecording.RtRegionWidth
- If RelativeLocation Mod TileX = 0 Then r = r + 1
-'If RelativeLocation Mod TileX = 0 Then
-'            ImageCopy.DestinationX = 0
-'        Else
-'
-' ImageCopy.DestinationX = CLng(Abs(1 - Int((RelativeLocation - 1) / TileX)) * Lsm5.DsRecording.RtRegionWidth)
-'
-'      End If
-       If RelativeLocation Mod TileX = 0 Then
-            ImageCopy.DestinationY = 0
-        Else
-            ImageCopy.DestinationY = CLng((TileX - (RelativeLocation Mod TileX)) * Lsm5.DsRecording.RtRegionWidth)
-        End If
-Else
-        ImageCopy.DestinationY = CLng(Int((RelativeLocation - 1) / TileX) * Lsm5.DsRecording.RtRegionWidth)
-        
-'        End If
-       If RelativeLocation Mod TileX = 0 Then
-            ImageCopy.DestinationX = 0
-        Else
-            ImageCopy.DestinationX = CLng(Abs((RelativeLocation Mod TileX) - TileX) * Lsm5.DsRecording.RtRegionWidth)
-        End If
- End If
-        
-        If RelativeLocation = 1 Then
-            ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-            StitchImage.SetVoxelSizeX CLng(Lsm5.DsRecording.RtRegionWidth * TileX)
-            StitchImage.SetVoxelSizeY CLng(Lsm5.DsRecording.RtRegionHeight * TileY)
-            
-        Else
-            ImageCopy.ImageParameterCopyFlags = 0
-        End If
-            
-        ImageCopy.Start
-        Set Progress = ImageCopy
-        
-        While Not Progress.Ready
-           DoEvents
-           Sleep (10)
-           If ScanStop Then Exit Sub
-        Wend
-            
-            
-     If RelativeLocation = TileX * TileY Then
-     
-        tilename = "Tile_" & GlobalLocationsName(Location) & "_L" & (Location / RelativeLocation) & "_R" & RepetitionNumber
-        StitchImage.SetTitle tilename
-        
-        
-       
-         GlobalImageIndex(RepetitionNumber) = StitchImage.SaveToDatabase(TileDatabaseName, tilename)
-         StitchImage.CloseAllWindows
-    End If
-    End If
-''''''''''''''''''''''''''''''''''''''''''''''''end stitching
-            
-            
-            
-            If BleachStartTable(RepetitionNumber) > 0 Then          'If a bleach was performed we add the information to the image metadata
-                Lsm5.DsRecordingActiveDocObject.AddEvent (BleachStartTable(RepetitionNumber) - StartTime) / 1000, eEventTypeBleachStart, "Bleach Start"
-                Lsm5.DsRecordingActiveDocObject.AddEvent (BleachStopTable(RepetitionNumber) - StartTime) / 1000, eEventTypeBleachStop, "Bleach End"
-            End If
-            'Now we save the image
-            
-            If TileX > 1 Or TileY > 1 Then
-                GlobalImageIndex(RepetitionNumber) = ScanImage.SaveToDatabase(GlobalDataBaseName, name)
-            Else
-                GlobalImageIndex(RepetitionNumber) = RecordingDoc.SaveToDatabase(GlobalDataBaseName, name)      'This is a strange way to call the function to save images, but it works
-            End If
-            If ScanStop Then
-                Lsm5.StopScan
-                StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-            
-            If LocationTracking Or FrameAutofocussing Then
-'                PositionData.Sheets("Location " & Location).Select
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 1) = CDate(Lsm5.DsRecordingActiveDocObject.Recording.Sample0Time)
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 2) = Lsm5.Hardware.CpStages.PositionX
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 3) = Lsm5.Hardware.CpStages.PositionY
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 4) = Lsm5.Hardware.CpFocus.Position
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 6) = PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 1) - PositionData.ActiveSheet.Cells(2, 1)
-'                If RepetitionNumber > 1 Then
-'                    PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 7) = PositionData.ActiveSheet.Cells(RepetitionNumber, 7) + Sqr((PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 2) - PositionData.ActiveSheet.Cells(RepetitionNumber, 2)) ^ 2 + (PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 3) - PositionData.ActiveSheet.Cells(RepetitionNumber, 3)) ^ 2)
-'                Else
-'                    PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 7) = 0
-'                End If
-            End If
-            
-            'This is if we're doing some postacquisition tracking
-            If LocationTracking Then
-                DisplayProgress "Analysing the new position of location " & Location, &H80FF&
-                DoEvents
-                MassCenter ("Tracking")
-                XCor = XMass
-                YCor = -YMass
-                If TrackZ Then
-                    ZCor = ZMass
-                Else
-                    If BlockHRZ Then
-                        ZCor = 0
-'                        Success = Lsm5.Hardware.CpHrz.Leveling
-                    Else
-                        ZCor = 0
-                    End If
-                End If
-                '''''changed
-            If AreStageCoordinateExchanged Then
-            XCor = YMass
-            YCor = XMass
-            End If
-            '''changed
-            Else
-                XCor = 0
-                YCor = 0
-                If BlockHRZ Then
-                    ZCor = 0
-                    success = Lsm5.Hardware.CpHrz.Leveling   'This I think puts the HRZ to its resting position, and moves the focuswheel correspondingly
-                Else
-                    ZCor = 0
-                End If
-            End If
-            
-            x = Lsm5.Hardware.CpStages.PositionX - XCor                     'Records the current X,Y,Z positions
-            y = Lsm5.Hardware.CpStages.PositionY - YCor
-            z = Lsm5.Hardware.CpFocus.Position + ZCor
-            
-            If MultipleLocation Or Grid Then
-                success = Lsm5.Hardware.CpStages.MarkClear(0)                   'Deletes the first mark location in the stage control (the current one)
-                                                                                'This deletion and new addition of the location was necessary to change the X, Y and Z properties of that location. I did not know how to do it otherwise
-                Lsm5.Hardware.CpStages.MinMarkDistance = 0.1                    'Put a very small mark distance to make it possible to have two cells coming close together. This parameter can be cahnged with the macro but is not accessible from the main software !
-                While Lsm5.Hardware.CpStages.MarkGetIndex(x, y) <> -1
-                    x = x + 0.1
-                    y = y + 0.1
-                Wend
-                success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ(x, y, z) 'Adds the location again,at the end of the list
-                
-                Lsm5.Hardware.CpStages.MinMarkDistance = 10                     'Put back the minimal marking distance to its default value
-                'test if this is working
-                Do While Lsm5.Info.IsAnyHardwareBusy
-                    Sleep (20)
-                    DoEvents
-                Loop
-
-                If Location < LocationNumber Then   'Close the image window if other images will be taken at other locations
-                    If TileX > 1 Or TileY > 1 Then
-                        If ScanImage.IsValid Then
-                            ScanImage.CloseAllWindows
-                        End If
-                    Else
-                        If RecordingDoc.IsValid Then
-                            RecordingDoc.CloseAllWindows
-                        End If
-                    End If
-                End If
-            Else                                                        'In the single location case with postacquisition tracking one still has to move to the new focus before next acquisition
-                Lsm5.Hardware.CpFocus.Position = z + ZBacklash          'Note that ZBacklash was not initialized to -50
-                Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                    Sleep (20)
-                    DoEvents
-                Loop
-                Lsm5.Hardware.CpFocus.Position = z
-                Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                    Sleep (20)
-                    DoEvents
-                Loop
-                If LocationTracking Then                                'In the single location case one also neess to correct for the XY movements if location tracking is activated
-                    success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-                    Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                        If ScanStop Then
-                            Lsm5.StopScan
-                            StopAcquisition
-                            DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                            Exit Sub
-                        End If
-                        DoEvents
-                        Sleep (5)
-                    Loop
-                End If
-            End If
-        Next Location           'Now all the locations have been visited
-
-        If AutomaticBleaching Then FillBleachTable     ' Updating the bleaching table before the next acquisitions, just in case there were changes n the bleaching window
-        
-        If (RepetitionNumber < BlockRepetitions) Then
-            GlobalPrvTime = CDbl(GetTickCount) * 0.001      'Parameters for the waiting. This I took over from the initial Zeiss Macro
-            rettime = GlobalPrvTime
-            difftime = rettime - GlobalPrvTime
-            Do While (difftime <= BlockTimeDelay) And Not (BleachTable(RepetitionNumber + 1) = True)        'This loops define the waiting delay before going back to the first location
-                If ExtraBleach Then                                 'Modifies the bleaching table to do an Extrableach for al locatins at the next repetition
-                    ExtraBleach = False
-                    BleachTable(RepetitionNumber + 1) = True
-                End If
-                If ScanPause = True Then
-                    Pause
-                End If
-                If ScanStop Then
-                    StopAcquisition
-                    DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                    Exit Sub
-                End If
-                DisplayProgress "Waiting " & CStr(CInt(BlockTimeDelay - difftime)) + " s before scanning repetition  " & (RepetitionNumber + 1), RGB(&HC0, &HC0, 0)
-                DoEvents
-                Sleep (10)
-                rettime = CDbl(GetTickCount) * 0.001
-                difftime = rettime - GlobalPrvTime
-            Loop
-            GlobalPrvTime = rettime
-            
-            If TileX > 1 Or TileY > 1 Then
-                
-                If ScanImage.IsValid Then
-                    ScanImage.CloseAllWindows
-                End If
-                
-                
-            Else
-                If RecordingDoc.IsValid Then
-                    RecordingDoc.CloseAllWindows
-                End If
-            End If
-        Else
-            Running = False
-        End If
-        RepetitionNumber = RepetitionNumber + 1
-'        TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    Loop
-    StopAcquisition
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-End Sub
-
-Public Sub MassCenter(Context As String)
-     Dim scrline As Variant
-    Dim spl As Long
-    Dim bpp As Long
-    Dim ColMax As Long
-    Dim LineMax As Long
-Lsm5Vba.Application.ThrowEvent eRootReuse, 0                   'Was there in the initial Zeiss macro, but it seems notnecessary
-    DoEvents
-    'Gets the dimensions of the image in X (Columns), Y (lines) and Z (Frames)
-   If FrameAutofocussing And SystemName = "LIVE" Then ' binning only with LIVE device
-   ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth '/ Lsm5.DsRecordingActiveDocObject.Recording.RtBinning
-    LineMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionHeight
-   Else
-   If SystemName = "LIVE" Then
-    ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth
-    LineMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionHeight
-    ElseIf SystemName = "LSM" Then
-             ColMax = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
-             LineMax = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-            Else
-                MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-                Exit Sub
-            End If
-    
-    
-    
-     End If
-    If Lsm5.DsRecordingActiveDocObject.Recording.ScanMode = "ZScan" Or Lsm5.DsRecordingActiveDocObject.Recording.ScanMode = "Stack" Then
-    
-        FrameNumber = Lsm5.DsRecordingActiveDocObject.Recording.FramesPerStack
-    Debug.Print Lsm5.DsRecordingActiveDocObject.Recording.ScanMode
-    Else
-    Debug.Print Lsm5.DsRecordingActiveDocObject.Recording.ScanMode
-        FrameNumber = 1
-    End If
-    'Gets the pixel size
-    PixelSize = Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing * 1000000
-    'Gets the distance between frames in Z
-    FrameSpacing = Lsm5.DsRecordingActiveDocObject.Recording.FrameSpacing
-    
-    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
-    ReDim Intline(LineMax) As Long
-    ReDim IntCol(ColMax) As Long
-    ReDim IntFrame(FrameNumber) As Long
-
-    'Select the image channel on which to do the calculations
-    If Context = "Autofocus" Then       'Takes the first channel in the context of preacquisition focussing
-        Channel = 0
-    ElseIf Context = "Tracking" Then    'Takes the channle selected in the pop-up menue when doing postacquisition tracking
-        For Channel = 0 To Lsm5.DsRecordingActiveDocObject.GetDimensionChannels - 1
-            If Lsm5.DsRecordingActiveDocObject.ChannelName(Channel) = Left(TrackingChannelString, 3) Then
-                Exit For
-            ElseIf Lsm5.DsRecordingActiveDocObject.ChannelName(Channel) = TrackingChannelString Then
-             Exit For
-            Else
-            End If
-        Next Channel
-    End If
-    
-   'lineMax = 1
-
-    'Reads the pixel values and fills the tables with the projected (integrated) pixels values in the three directions
-    For Frame = 1 To FrameNumber
-        For line = 1 To LineMax
-            bpp = 0
-           
-            scrline = Lsm5.DsRecordingActiveDocObject.ScanLine(Channel, 0, Frame - 1, line - 1, spl, bpp) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-            For Col = 1 To ColMax               'Now I'm scanning all the pixels in the line
-                Intline(line - 1) = Intline(line - 1) + scrline(Col - 1)
-                IntCol(Col - 1) = IntCol(Col - 1) + scrline(Col - 1)
-                IntFrame(Frame - 1) = IntFrame(Frame - 1) + scrline(Col - 1)
-            Next Col
-        Next line
-    Next Frame
-    
-    'First it finds the minimum and maximum porjected (integrated) pixel values in the 3 dimensions
-    MinColValue = 4095 * LineMax * FrameNumber           'The maximum values are initially set to the maximum possible value
-    minLineValue = 4095 * ColMax * FrameNumber
-    minFrameValue = 4095 * LineMax * ColMax
-    MaxColValue = 0                                     'The maximun values are initialliy set to 0
-    MaxLineValue = 0
-    MaxframeValue = 0
-    For line = 1 To LineMax
-        If Intline(line - 1) < minLineValue Then
-            minLineValue = Intline(line - 1)
-        End If
-        If Intline(line - 1) > MaxLineValue Then
-            MaxLineValue = Intline(line - 1)
-        End If
-    Next line
-    For Col = 1 To ColMax
-        If IntCol(Col - 1) < MinColValue Then
-            MinColValue = IntCol(Col - 1)
-        End If
-        If IntCol(Col - 1) > MaxColValue Then
-            MaxColValue = IntCol(Col - 1)
-        End If
-    Next Col
-    For Frame = 1 To FrameNumber
-        If IntFrame(Frame - 1) < minFrameValue Then
-            minFrameValue = IntFrame(Frame - 1)
-        End If
-        If IntFrame(Frame - 1) > MaxframeValue Then
-            MaxframeValue = IntFrame(Frame - 1)
-        End If
-    Next Frame
-
-    'Calculates the threshold values. It is set to an arbitrary value of the minimum projected value plus 20% of the difference between the minimum and the maximum projected value.
-    'Then calculates the center of mass
-    LineSum = 0
-    LineWeight = 0
-    MidLine = (LineMax + 1) / 2
-    If CheckBoxRefControl.Value = True Then
-        If (MaxframeValue - minFrameValue) < minFrameValue * 0.5 Or MaxframeValue = 0 Then NoReflectionSignal = True
-    End If
-    Threshold = minLineValue + (MaxLineValue - minLineValue) * 0.8         'Threshold calculation
-    For line = 1 To LineMax
-        LineValue = Intline(line - 1) - Threshold                           'Subtracs the threshold
-        PosValue = LineValue + Abs(LineValue)                               'Makes sure that the value is positive or zero. If LineValue is negative, the Posvalue = 0; if Line value is positive, then Posvalue = 2*LineValue
-        LineWeight = LineWeight + (PixelSize * (line - MidLine)) * PosValue 'Calculates the weight of the Thresholded projected pixel values according to their position relative to the center of the image and sums them up
-        LineSum = LineSum + PosValue                                        'Calculates the sum of the thresholded pixel values
-    Next line
-    If LineSum = 0 Then
-        YMass = 0
-    Else
-        YMass = LineWeight / LineSum                                       'Normalizes the weights to get the center of mass
-    End If
-
-    ColSum = 0
-    ColWeight = 0
-    MidCol = (ColMax + 1) / 2
-    Threshold = MinColValue + (MaxColValue - MinColValue) * 0.8
-    For Col = 1 To ColMax
-        ColValue = IntCol(Col - 1) - Threshold
-        PosValue = ColValue + Abs(ColValue)
-        ColWeight = ColWeight + (PixelSize * (Col - MidCol)) * PosValue
-        ColSum = ColSum + PosValue
-    Next Col
-    If ColSum = 0 Then
-        XMass = 0
-    Else
-        XMass = ColWeight / ColSum
-    End If
-
-    FrameSum = 0
-    FrameWeight = 0
-    MidFrame = (FrameNumber + 1) / 2
-    Threshold = minFrameValue + (MaxframeValue - minFrameValue) * 0.8
-    For Frame = 1 To FrameNumber
-        FrameValue = IntFrame(Frame - 1) - Threshold
-        PosValue = FrameValue + Abs(FrameValue)
-        FrameWeight = FrameWeight + (FrameSpacing * (Frame - MidFrame)) * PosValue
-        FrameSum = FrameSum + PosValue
-    Next Frame
-    If FrameSum = 0 Then
-        ZMass = 0
-    Else
-        ZMass = FrameWeight / FrameSum
-        End If
-        
-End Sub
-
-
-Private Sub StopButton_Click()
-   
-        ScanStop = True
-        DisplayProgress "Restore Settings", RGB(&HC0, 0, 0)
-   
-End Sub
-
-Public Sub StopAcquisition()
-    Dim FileName As String
-    Running = False
-    ScanStop = False
-    RepetitionNumber = 1
-    ScanPause = False
-    PauseButton.Caption = "Pause"
-    PauseButton.BackColor = &H8000000F
-    ExtraBleach = False
-    ExtraBleachButton.Caption = "Bleach"
-    ExtraBleachButton.BackColor = &H8000000F
-    ReDim BleachTable(BlockRepetitions)
-    ReDim BleachStartTable(BlockRepetitions)
-    ReDim BleachStopTable(BlockRepetitions)
-    CloseButton.Enabled = True
-    ReinitializeButton.Enabled = True
-    StartButton.Enabled = True
-    StartBleachButton.Enabled = True
-    If LocationTracking Or FrameAutofocussing Then
-'        For i = 1 To PositionData.Sheets.count
-'            PositionData.Sheets.Item(i).Select
-'            Cells.Select
-'            Selection.Columns.AutoFit
-'        Next i
-'        FileName = Left(DataBaseLabel, Len(DataBaseLabel) - 4) & ".xls"
-'        PositionData.SaveAs FileName:=FileName, FileFormat:=xlNormal, Password:="", WriteResPassword:="", ReadOnlyRecommended:=False, CreateBackup:=False
-'        PositionData.Close
-'        Excel.Application.Quit
-    End If
-End Sub
-
-
-
-Private Sub PauseButton_Click()
-    If Running Then
-        If ScanPause = False Then
-            ScanPause = True
-            PauseButton.Caption = "Resume"
-            PauseButton.BackColor = 12648447
-        Else
-            ScanPause = False
-            PauseButton.Caption = "Pause"
-            PauseButton.BackColor = &H8000000F
-        End If
-    Else
-        MsgBox "The acquisition has not started yet or is already finished. Cannot pause."
-    End If
-End Sub
-
-Public Sub Pause()
-    Dim rettime As Double
-    Dim GlobalPrvTime As Double
-    SetFocusButton.Enabled = True
-    AutofocusButton.Enabled = True
-    GlobalPrvTime = CDbl(GetTickCount) * 0.001
-    rettime = GlobalPrvTime
-    difftime = rettime - GlobalPrvTime
-    Do While True
-        DisplayProgress "Pause " & CStr(CInt(difftime)) & " s", RGB(&HC0, &HC0, 0)
-        If ScanStop Then
-            Exit Sub
-        End If
-        If ScanPause = False Then
-            SetFocusButton.Enabled = False
-            AutofocusButton.Enabled = False
-            Exit Sub
-        End If
-        DoEvents
-        Sleep (20)
-        rettime = CDbl(GetTickCount) * 0.001
-        difftime = rettime - GlobalPrvTime
-    Loop
-End Sub
-
-
-Private Sub ExtraBleachButton_Click()
-    If Running Then
-        ExtraBleach = True
-        ExtraBleachButton.Caption = "Will Bleach"
-        ExtraBleachButton.BackColor = 12648447
-    Else
-        MsgBox "The acquisition has not started yet or is already finished. Cannot bleach."
-    End If
-End Sub
-
-Private Sub StripeScanToggle_Click()
- If MultipleLocationToggle.Value = True Then MultipleLocationToggle.Value = Not StripeScanToggle.Value
-    If SingleLocationToggle.Value = True Then SingleLocationToggle.Value = Not StripeScanToggle.Value
-    If GridToggle.Value = True Then GridToggle.Value = Not StripeScanToggle.Value
-    GridObjectsandVarialbles True
-    CheckBoxMeander.Visible = False
-    CheckBoxScannAll.Visible = True
-End Sub
-
-Private Sub GridToggle_Click()
-    GridToggle.Value = True
-    If MultipleLocationToggle.Value = True Then MultipleLocationToggle.Value = Not GridToggle.Value
-    If SingleLocationToggle.Value = True Then SingleLocationToggle.Value = Not GridToggle.Value
-    If StripeScanToggle.Value = True Then StripeScanToggle.Value = Not GridToggle.Value
-    GridObjectsandVarialbles True
-    CheckBoxScannAll.Visible = False
-    StartBleachButton.Visible = False
-    ExtraBleachButton.Visible = False
-End Sub
-
-Private Sub SingleLocationToggle_Click()
-    SingleLocationToggle.Value = True
-   If MultipleLocationToggle.Value = True Then MultipleLocationToggle.Value = Not SingleLocationToggle.Value
-    If StripeScanToggle.Value = True Then StripeScanToggle.Value = Not SingleLocationToggle.Value
-    If GridToggle.Value = True Then GridToggle.Value = Not SingleLocationToggle.Value
-    GridObjectsandVarialbles False
-    CheckBoxScannAll.Visible = False
-    Label15.Caption = "Define Locations Using Stage and Focus Corntrol Dialog!"
-  '  StartBleachButton.Visible = True
- '   ExtraBleachButton.Visible = True
-    Frame15.Visible = False
-End Sub
-
-Private Sub MultipleLocationToggle_Click()
-    MultipleLocationToggle.Value = True
-    If SingleLocationToggle.Value = True Then SingleLocationToggle.Value = Not MultipleLocationToggle.Value
-    If GridToggle.Value = True Then GridToggle.Value = Not MultipleLocationToggle.Value
-    If StripeScanToggle.Value = True Then StripeScanToggle.Value = Not MultipleLocationToggle.Value
-    GridObjectsandVarialbles False
-    Label15.Caption = "Define Locations Using Stage and Focus Corntrol Dialog!"
-    CheckBoxScannAll.Visible = False
-   ' ZMapButton.Left = 12
-   ' ZMapButton.Top = 258
-    ZMapButton.Visible = True
-   ' CheckBoxZMap.Left = 80
-   ' CheckBoxZMap.Top = 258
-    CheckBoxZMap.Visible = True
-    StartBleachButton.Visible = False
-  '  ExtraBleachButton.Visible = True
-    Frame15.Visible = True
-    TextBoxTileX.Visible = True
-    TextBoxTileY.Visible = True
-    Tileframe.Visible = True
-    Label17.Visible = True
-    Label18.Visible = True
-    Label20.Visible = True
-    CreateLocationsButton.Visible = True
-    TextBoxOverlap.Visible = True
-End Sub
-Private Sub GridObjectsandVarialbles(Activate As Boolean)
-   ' ZMapButton.Left = 198.05
-   ' ZMapButton.Top = 306
-    ZMapButton.Visible = Activate
-    CreateLocationsButton.Visible = Activate
-    CommandButtonRemove.Visible = Activate
-    CommandButtonGrid.Visible = Activate
-    CommandButtonStoreApply.Visible = Activate
-    TextBoxYGrid.Visible = Activate
-    TextBoxXGrid.Visible = Activate
-    TextBoxYStep.Visible = Activate
-    TextBoxXStep.Visible = Activate
-    Tileframe.Visible = Activate
-    Frame16.Visible = Activate
-    Frame15.Visible = Activate
-    Label1.Visible = Activate
-    Label2.Visible = Activate
-    Label3.Visible = Activate
-    Label4.Visible = Activate
-    Label5.Visible = Activate
-   ' Label16.Visible = Activate
-    Label7.Visible = Activate
-    Label17.Visible = Activate
-    Label18.Visible = Activate
-    Label20.Visible = Activate
-    TextBoxOverlap.Visible = Activate
-    TextBoxTileX.Visible = Activate
-    TextBoxTileY.Visible = Activate
-   ' CheckBoxKeepSteps.Visible = Activate
-    CheckBoxMeander.Visible = Activate
-  '  CheckBoxZMap.Left = 132
-   ' CheckBoxZMap.Top = 288
-    CheckBoxZMap.Visible = Activate
-    'LabelGrid.Visible = Activate
-    Label15.Visible = Not Activate
-    Grid = GridToggle.Value
-    MultipleLocation = MultipleLocationToggle.Value ' Sets the MultipleLocation Boolean to False
-   
-End Sub
-
-
-
-Public Sub AutoFindTracks()
-    Dim i, j As Integer
-    Dim ChannelOK As Boolean
-    Dim DataChannel As DsDataChannel
-    Dim Color As Long
-    Dim ConfiguredTracks As Integer
-
-    
-    OptionButtonTrack1.Visible = False
-    OptionButtonTrack1.Enabled = False
-    OptionButtonTrack1.Value = False
-    CheckBoxTrack1.Visible = False
-    CheckBoxTrack1.Enabled = False
-    CheckBoxTrack1.Value = False
-    
-    OptionButtonTrack2.Visible = False
-    OptionButtonTrack2.Enabled = False
-    OptionButtonTrack2.Value = False
-    CheckBoxTrack2.Visible = False
-    CheckBoxTrack2.Enabled = False
-    CheckBoxTrack2.Value = False
-    
-    OptionButtonTrack3.Visible = False
-    OptionButtonTrack3.Enabled = False
-    OptionButtonTrack3.Value = False
-    CheckBoxTrack3.Visible = False
-    CheckBoxTrack3.Enabled = False
-    CheckBoxTrack3.Value = False
-    
-    OptionButtonTrack4.Visible = False
-    OptionButtonTrack4.Enabled = False
-    OptionButtonTrack4.Value = False
-    CheckBoxTrack4.Visible = False
-    CheckBoxTrack4.Enabled = False
-    CheckBoxTrack4.Value = False
-    
-    ConfiguredTracks = Lsm5.DsRecording.TrackCount
-    ChannelOK = False
-    GoodTracks = 0
-    
-'The next line and the following "if" should be removed when working with the LSM 2.8 software (where the lambda mode is not defined)
-    Set Track = Lsm5.DsRecording.TrackObjectLambda(success)
-    If success Then
-        If Track.Acquire Then
-            MsgBox ("This macro does not work in the Lambda Mode. Please switch to the Channel Mode and reinitialize the Macro.")
-            Exit Sub
-        End If
-    End If
-            
-    For i = 1 To ConfiguredTracks
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, success)
-        TrackName = Track.name
-        j = 0
-'In the next line remove "Or Track.IslambdaTrack" when working with the LSM 2.8 software
-        If Not (Track.IsBleachTrack Or Track.IsLambdaTrack) Then
-            Do While (Not ChannelOK) And (j < Track.DataChannelCount)
-                Set DataChannel = Track.DataChannelObjectByIndex(j, success)
-                If DataChannel.Acquire = True Then ChannelOK = True
-                Color = DataChannel.ColorRef
-                j = j + 1
-            Loop
-            If ChannelOK Then
-                If Not Track.IsRatioTrack Then
-                    GoodTracks = GoodTracks + 1
-                    If GoodTracks = 5 Then
-                        MsgBox ("This Macro only accepts 4 different tracks")
-                    End If
-                    If GoodTracks = 1 Then
-                        OptionButtonTrack1.Visible = True
-                        OptionButtonTrack1.Caption = TrackName
-                        OptionButtonTrack1.Enabled = True
-                        OptionButtonTrack1.BackColor = Color
-                        CheckBoxTrack1.Visible = True
-                        CheckBoxTrack1.Caption = TrackName
-                        CheckBoxTrack1.Enabled = True
-                        CheckBoxTrack1.BackColor = Color
-                    End If
-                    If GoodTracks = 2 Then
-                        OptionButtonTrack2.Visible = True
-                        OptionButtonTrack2.Caption = TrackName
-                        OptionButtonTrack2.Enabled = True
-                        OptionButtonTrack2.BackColor = Color
-                        CheckBoxTrack2.Visible = True
-                        CheckBoxTrack2.Caption = TrackName
-                        CheckBoxTrack2.Enabled = True
-                        CheckBoxTrack2.BackColor = Color
-                    End If
-                    If GoodTracks = 3 Then
-                        OptionButtonTrack3.Visible = True
-                        OptionButtonTrack3.Caption = TrackName
-                        OptionButtonTrack3.Enabled = True
-                        OptionButtonTrack3.BackColor = Color
-                        CheckBoxTrack3.Visible = True
-                        CheckBoxTrack3.Caption = TrackName
-                        CheckBoxTrack3.Enabled = True
-                        CheckBoxTrack3.BackColor = Color
-                    End If
-                    If GoodTracks = 4 Then
-                        OptionButtonTrack4.Visible = True
-                        OptionButtonTrack4.Caption = TrackName
-                        OptionButtonTrack4.Enabled = True
-                        OptionButtonTrack4.BackColor = Color
-                        CheckBoxTrack4.Visible = True
-                        CheckBoxTrack4.Caption = TrackName
-                        CheckBoxTrack4.Enabled = True
-                        CheckBoxTrack4.BackColor = Color
-                    End If
-                Else
-                    MsgBox ("This macro does not allow to use a Ratio Channel. The Ratio Channel will thus be disabled.")
-                    For j = 0 To Track.DataChannelCount - 1
-                        Set DataChannel = Track.DataChannelObjectByIndex(j, success)
-                        DataChannel.Acquire = False
-                    Next
-                End If
-                ChannelOK = False
-            End If
-        End If
-    Next
-    If GoodTracks < 4 Then
-        TrackNumber = GoodTracks
-    Else
-        TrackNumber = 4
-    End If
-End Sub
-
-
-
-Private Sub BSliderZoffset_Change()
-    'Tests whether chosen Offset is less or equal to half of the working distance of the objective but why can't it be bigger??
-    Dim Position As Long 'gets the postion of the actual objective revolver by number
-    Dim Range As Double 'contains value of working distance in um
-    If flgUserChange Then '??? What is the sense of flgUserChange
-        Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-        If Position >= 0 Then ' ??? is it possible that Revolver Position has another value
-            Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000# ' ??? why is there a # behind that number if range is already defined as double
-                                                                                            ' in which unit is working distance read out and why multiplication with 1000
-        Else
-            Range = 0#
-        End If
-        If Abs(BSliderZOffset.Value) > Range * 0.9 Then
-            BSliderZOffset.Value = 0
-            MsgBox "Zoffset has to be less than the working distance of the objective: " + CStr(Range) + " um"
-        End If
-    End If
-End Sub
-
-
-
-
-Private Sub BSliderZRange_Change()    ' It should be possible to change the limit of the range to bigger values than half of the working distance
-    Dim Position As Long
-    Dim Range As Double
-    If flgUserChange Then
-        Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-        If Position >= 0 Then
-            Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-        Else
-            Range = 0#
-        End If
-        If BSliderZRange.Value > Range * 0.9 Then
-            BSliderZRange.Value = Range * 0.9
-            MsgBox "ZRange has to be less or equal to the working distance of the objective: " + CStr(Range) + " um"
-        End If
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-
-Private Sub CloseButton_Click()
-    AutoStore
-'    Excel.Application.DisplayAlerts = False
-'    Excel.Application.Quit
-    End
-End Sub
-
-
-Private Sub ReInitializeButton_Click()
-    Re_Initialize
-End Sub
-
-
-Private Sub CommandButtonStore_Click()
-    StoreApply.Show
-End Sub
-
-
-
-
-
-
-Private Sub UserForm_Initialize()           ' This contained some initialization  that have then been deleted or moved to Re_Start
-    Re_Start
-End Sub
-
-
-Private Sub Re_Start()                      'Initializations that need to be performed only at the first start of the Macro
-    Dim delay As Single
-    Dim standType As String
-    Dim Count As Long
-    Dim ImageDatabase As DsGuidedModeDatabase
-    Dim i As Long
-    Dim MruList As DsMruList
-    Dim cnt As Long
-    Dim lpReOpenBuff As OFSTRUCT
-    Dim wStyle As Long
-    Dim lpRootPathName As String
-    Dim lpSectorsPerCluster As Long
-    Dim lpBytesPerSector As Long
-    Dim lpNumberOfFreeClusters As Long
-    Dim lpTotalNumberOfClusters As Long
-    Dim lSpace As Long
-    Dim lFreeSpace As Double
-    Dim fSize As Double
-    Dim hFile As Long
-   
-    
-    Set tools = Lsm5.tools
-    GlobalMacroKey = "Autofocus"
-   
-'    bRunning = False
- '   LbStatus = "inactive"
-    flgUserChange = True
-    delay = 1
-    flgEvent = 7
-    flg = 0
-    Lsm5.StopScan
-    Wait (delay)
-    TimerUnit = 1
-    CommandTimeSec.BackColor = &HFF8080
-    BlockRepetitions = 1
-    ReDim Preserve GlobalImageIndex(BlockRepetitions)
-    ScanLineToggle.Value = True
-    SingleLocationToggle.Value = True
-    Label15.Caption = "Define Locations Using Stage and Focus Corntrol Dialog!!"
-    GlobalProject = "AutofocusScreen1.7"
-    GlobalProjectName = GlobalProject + ".lvb"
-    HelpNamePDF = "AutofocusScreen_help.pdf"
-    Re_Initialize ' Continues the initialization process
-  
-     
-    
-End Sub
-
-
-Public Sub Re_Initialize()                  'Initializations that need to be performed only when clicling the "initialize" button
-    Dim delay As Single
-    Dim standType As String
-    Dim Count As Long
-     Dim bLSM As Boolean
-    Dim bLIVE As Boolean
-    Dim bCamera As Boolean
-    
-'    StopAcquisition
-'    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    AutoFindTracks
-  
-     BSliderZOffset.Value = 0
-    BSliderZRange.Value = 80
-    BSliderZStep.Value = 0.1
-    TextBoxXGrid.Value = 3
-    TextBoxYGrid.Value = 2
-    TextBoxXStep.Value = -1125
-    TextBoxYStep.Value = 1125
-    BSliderScanSpeed = 1000
-    BSliderRepetitions = 300
-    BSliderTime = 1
-    
-    CheckBoxLowZoom = False
-    CheckBoxInnactivateAutofocus = False
-    PubSearchScan = False
-    NoReflectionSignal = False
-    PubSentStageGrid = False
-    GlobalZmapAquired = False
-    
-    
-    If Lsm5.Hardware.CpHrz.Exist("HRZ") = True Then     'Check if an HRZ is available. If not the "HRZ checkbox is not available.
-        CheckBoxHRZ.Visible = True
-        CheckBoxHRZ.Value = True
-    Else
-'   I take this out, because at the LMS we have an HRZ but the LSM Software does not give the right signal for that, but now you can can use the HRZ
-'   CheckBoxHRZ.Visible = False
-'   CheckBoxHRZ.Value = False
-    End If
-    
-    ScanLineToggle.Value = True
-    SingleLocationToggle.Value = True
-    UsedDevices40 bLSM, bLIVE, bCamera
-    If bLSM Then
-            SystemName = "LSM"
-            CheckBoxHighSpeed.Value = True
-            CheckBoxHighSpeed.Visible = True
-            CheckBoxHighSpeed.Top = 48
-            CheckBoxLowZoom.Top = 71.35
-            CheckBoxHRZ.Top = 90.95
-            CheckBoxRefControl.Top = 110.6
-     
-             BSliderFrameSize.Min = 16
-            BSliderFrameSize.Max = 1024
-            BSliderFrameSize.Step = 8
-            BSliderFrameSize.StepSmall = 4
-          
-           
-            Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-        ElseIf bLIVE Then
-            SystemName = "LIVE"
-            CheckBoxHighSpeed.Value = False
-            CheckBoxHighSpeed.Visible = False
-            CheckBoxHRZ.Top = 85
-            CheckBoxRefControl.Top = 108
-            CheckBoxLowZoom.Top = 60
-'            BSliderFrameSize.ValueEditable = False
-            BSliderFrameSize.Min = 128
-            BSliderFrameSize.Max = 1024
-            BSliderFrameSize.Step = 128
-            BSliderFrameSize.StepSmall = 128
-          
-            Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-            
-          
-            
-        ElseIf bCamera Then
-            SystemName = "Camera"
-        End If
-    AutofocusForm.Caption = GlobalProject + " for " + SystemName
-      
-End Sub
-
-Private Sub CreditButton_Click()
-    CreditForm.Show
-End Sub
-
-Private Sub TrackingToggle_Click()                                          ' Sets the parameters for postacquisition tracking
-    LocationTracking = TrackingToggle.Value
-    ComboBoxTrackingChannel.Visible = TrackingToggle.Value
-    FillTrackingChannelList
-    CheckBoxTrackZ.Visible = TrackingToggle.Value
-    If Lsm5.DsRecording.ScanMode = "Stack" Then
-        CheckBoxTrackZ.Enabled = True
-    Else
-        CheckBoxTrackZ.Enabled = False
-        CheckBoxTrackZ.Value = False
-    End If
-End Sub
-
-
-'fills popup menu for chosing a track for post-acquisition tracking in ScanLine mode
-Private Sub FillTrackingChannelList()
-    Dim t As Integer
-    Dim c As Integer
-    Dim ca As Integer
-    Dim Channel As DsDetectionChannel
-
-    ActivateAcquisitionTrack 'will set IsAcquisitionTrack selected true if a valid track is selected for acquisition, and "marks the track in the Zeiss config window
-    
-    ReDim ActiveChannels(Lsm5.Constants.MaxActiveChannels)  'ActiveChannels is a dynamic array (variable size), ReDim defines array size required next
-                                                            'Array size is (MaxActiveChannels gets) the total max number of active channels in all tracks
-    ComboBoxTrackingChannel.Clear 'Content of popup menu for chosing track for post-acquisition tracking is deleted
-    ca = 0
-    
-    If IsAcquisitionTrackSelected Then 'IsAcquisitionTrackSelected is True if one channel is activated in tracks 1-4
-        For t = 1 To TrackNumber 'This loop goes through all tracks and will collect all activated channels to display them in popup menu
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(t - 1, success) 'goes through all defined tracks
-            If Track.Acquire Then 'if track is activated for acquisition
-                For c = 1 To Track.DetectionChannelCount 'for every detection channel of track
-                    Set Channel = Track.DetectionChannelObjectByIndex(c - 1, success)
-                    If Channel.Acquire Then 'if channel is activated
-                        ca = ca + 1 'counter for active channels will increase by one
-                        ComboBoxTrackingChannel.AddItem Track.name & " " & Channel.name 'entry is added to combo box to chose track for post-acquisition tracking
-                        ActiveChannels(ca) = Channel.name & "-T" & Track.MultiplexOrder + 1  'adds entry to ActiveChannel Array with name of channel + name of track
-                    End If
-                Next c
-            End If
-        Next t
-        
-        ComboBoxTrackingChannel.Value = ComboBoxTrackingChannel.List(0) 'initially displayed text in popup menu is a blank line (first channel is 1).
-    End If
-End Sub
-Private Sub ComboBoxTrackingChannel_Change()        'Sets the name of the channel for PostAcquisition tracking.
-    TrackingChannelString = ActiveChannels(ComboBoxTrackingChannel.ListIndex + 1)
-End Sub
-Private Sub CheckBoxTrackZ_Click()
-    TrackZ = CheckBoxTrackZ.Value
-    If CheckBoxTrackZ.Value = True Then
-        CheckBoxInnactivateAutofocus.Value = True                  'If posacquisition Z-tracking is activated, it is necessary to deactivate autofocussing
-        CheckBoxInnactivateAutofocus.BackColor = 33023
-        CheckBoxTrackZ.BackColor = 33023
-    Else
-        CheckBoxTrackZ.BackColor = &H8000000F
-    End If
-End Sub
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Private Sub CommandTimeMin_Click()
-    TimerUnit = 60
-    BSliderTime.Max = 60                        'When workings with minutes the maximum delay that can be set with the slider is 1 hour
-    BSliderTime.Value = BlockTimeDelay / 60
-    CommandTimeMin.BackColor = &HFF8080
-    CommandTimeSec.BackColor = &H8000000F
-End Sub
-
-Private Sub CommandTimeSec_Click()
-    TimerUnit = 1
-    BSliderTime.Max = 180                       'When workings with seconds the maximum delay that can be set with the slider is 3 minutes
-    BSliderTime.Value = BlockTimeDelay
-    CommandTimeSec.BackColor = &HFF8080
-    CommandTimeMin.BackColor = &H8000000F
-End Sub
-
-
-
-
-
-
-
-
-
-Private Sub BSliderTime_Click()
-   
-
-    BlockTimeDelay = BSliderTime.Value * TimerUnit                      'BlockTimedelay gets the value of the slider in seconds
-    
-End Sub
-
-
-
-
-
-Private Sub BSliderRepetitions_Change()
-    If Not Running Then
-        BlockRepetitions = BSliderRepetitions.Value
-    ElseIf Not (BSliderRepetitions.Value <= (RepetitionNumber + 1)) Then
-        BlockRepetitions = BSliderRepetitions.Value
-    Else
-        BSliderRepetitions.Value = RepetitionNumber + 1
-        BlockRepetitions = BSliderRepetitions.Value
-    End If
-    
-    ReDim Preserve GlobalImageIndex(BlockRepetitions)           'The global image index I'm not sure how this is working.
-    ReDim Preserve BleachTable(BlockRepetitions)                'BleachTable defines when bleaching will have to occur
-    If AutomaticBleaching Then FillBleachTable                  'Reads the parameters defined in the Bleach control window of the main software
-    ReDim Preserve BleachStartTable(BlockRepetitions)           'This is to store the timepoints when the bleaches started. Preserve is to keep the timepoints if the slider is moved during an experiment
-    ReDim Preserve BleachStopTable(BlockRepetitions)            'This is to store the timepoints when the bleaches stopped. Preserve is to keep the timepoints if the slider is moved during an experiment
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-
-
-
-Private Sub TextBoxFileName_Change()
-    GlobalFileName = TextBoxFileName.Value
-End Sub
-
-Private Sub CommandButtonSelectDataBase_Click()
-    Dim lpReOpenBuff As OFSTRUCT
-    Dim wStyle As Long
-    Dim hFile As Long
-    Dim flgUserChangeSaved As Boolean
-    flgUserChangeSaved = flgUserChange
-    
-    flgUserChange = False
-
-'Common Dialog is used to open folders and files in windows
-    CommonDialog.FileName = GlobalDataBaseName                      'remembers which was the latest Database that was opened
-    CommonDialog.Filter = "Database files ( *.mdb ) |*.mdb"         'filter to only display database files
-    CommonDialog.ShowOpen
-    hFile = OpenFile(CommonDialog.FileName, lpReOpenBuff, wStyle)
-    If hFile <> -1 Then
-        GlobalDataBaseName = CommonDialog.FileName                  'Store the path of the database in the GlobalDatabaseName variable
-        DataBaseLabel.Caption = CommonDialog.FileName
-    Else
-        MsgBox "Selected file does not exist"
-    End If
-    flgUserChange = flgUserChangeSaved
-End Sub
-
-Private Sub CommandButtonNewDataBase_Click()   'Creates a new database
-    Lsm5.NewDatabase (NewDatabase)              'Directly opens the LSM window to create a new database
-    Lsm5.CloseAllDatabaseWindows                'Strange that this is there and not before the previous line...
-    GlobalDataBaseName = Lsm5.MruDatabases.name(0)      'Write the name of the database in a varialbe (used afterwards for saving to the right database)
-    DataBaseLabel.Caption = Lsm5.MruDatabases.name(0)   'Indicates the name of the databse for the user to check
-End Sub
- 
-
-
-
-Public Sub ActivateAutofocusTrack(HighSpeed As Boolean)
-    Dim i As Integer
-
-    IsAutofocusTrackSelected = False
-    For i = 1 To TrackNumber
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, success)
-        If i = 1 Then
-            If OptionButtonTrack1.Value = True Then
-                Track.Acquire = 1
-                IsAutofocusTrackSelected = True
-                AutofocusTrack = i - 1
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 2 Then
-            If OptionButtonTrack2.Value = True Then
-                Track.Acquire = 1
-                IsAutofocusTrackSelected = True
-                AutofocusTrack = i - 1
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 3 Then
-            If OptionButtonTrack3.Value = True Then
-                Track.Acquire = 1
-                IsAutofocusTrackSelected = True
-                AutofocusTrack = i - 1
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 4 Then
-            If OptionButtonTrack4.Value = True Then
-                Track.Acquire = 1
-                IsAutofocusTrackSelected = True
-                AutofocusTrack = i - 1
-           Else
-                Track.Acquire = 0
-            End If
-        End If
-    Next i
-    If HighSpeed Then
-        Track.SamplingNumber = 1
-    End If
-End Sub
-
-
-Public Sub ActivateAcquisitionTrack()
-    Dim i As Integer
-
-    'this loop goes through all tracks; it will check for actual track in loop whether corresponding checkbox is activated
-    'if checkbox of one of tracks is selected IsAcquisitionTrack will be set true
-    'is this so complicated to be sure that if one track is chosen this track is a track that is defined in track list ???
-    IsAcquisitionTrackSelected = False
-    For i = 1 To TrackNumber 'TrackNumber is maximum 4 or less (see definition with GoodTracks)
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, success) 'choses track corresponding to track number
-        If i = 1 Then
-            If CheckBoxTrack1.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 2 Then
-            If CheckBoxTrack2.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 3 Then
-            If CheckBoxTrack3.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 4 Then
-            If CheckBoxTrack4.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-    Next i
-End Sub
-
-
-' I could delete this procedure if I do not add any help button
-'Private Sub HelpButton_Click()
-'    Dim dblTask As Double
-'    Dim MacroPath As String
-'    Dim MyPath As String
-'    Dim bslash As String
-'    Dim Success As Integer
-'    Dim pos As Integer
-'    Dim Start As Integer
-'    Dim count As Long
-'    Dim ProjName As String
-'    Dim indx As Integer
-'
-'    count = ProjectCount()
-'    For indx = 0 To count - 1
-'        MacroPath = ProjectPath(indx, Success)
-'        ProjName = ProjectTitle(indx, Success)
-'        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
-'            Start = 1
-'            bslash = "\"
-'            pos = Start
-'            Do While pos > 0
-'                pos = InStr(Start, MacroPath, bslash)
-'                If pos > 0 Then
-'                    Start = pos + 1
-'                End If
-'            Loop
-'            MyPath = Left(MacroPath, Start - 1)
-'            MyPath = MyPath + GlobalHelpName
-'            dblTask = Shell("C:\Program Files\Windows NT\Accessories\wordpad.exe " + MyPath, vbNormalFocus)
-'            Exit For
-'        End If
-'    Next indx
-'End Sub
-
-Sub Wait(PauseTime As Single)
-    Dim Start As Single
-    Start = Timer   ' Set start time.
-    Do While Timer < Start + PauseTime
-       DoEvents    ' Yield to other processes.
-       'Lsm5.DsRecording.StartScanTriggerIn
-    Loop
-End Sub
-
-
-
-Public Sub SetFocus(ZRange As Double, ZStep As Double, LowZoom As Boolean, HighSpeed As Boolean, Zoffset As Double)
-    Dim SpeedCopy As Double
-    Dim ZoomXCopy As Double
-    Dim ZoomYCopy As Double
-    Dim SamplesPerLineCopy As Long
-    Dim LinesPerFrameCopy As Long
-    Dim ScanModeCopy As String
-    Dim SpecialScanModeCopy As String
-
-    Dim Range As Double
-    Dim Position As Long
-  
-    Dim MyRecording As DsRecording
-
-    Dim Tnum As Long
-    Dim i As Long
-    Dim success As Integer
-    Dim NewPicture As DsRecordingDoc
-    Dim Pixel As Long
-    Dim scrline As Variant
-    Dim PxlArray() As Long
-    Dim spl As Long
-    Dim bpp As Long
-    Dim IntensityStr As String
-    Dim ChNumber As Long
-    Dim Channel As Long
-    Dim LongRange As Long
-    Dim PxlMax As Long
-    Dim PxlTot As Long
-    Dim LineMax As Long
-    Dim StackSize As Double
-    Dim SavedSampling As Long
-    Dim key As String
-    Dim line As Long
-    Dim lT As Long
-    Dim NoFrames As Long
-    Dim SystemVersion As String
-    Dim Speed As Long
-    Dim MaxSpeed As Long
-    
-    
-  Zbefore = Lsm5.Hardware.CpFocus.Position
-    DisplayProgress "Get Offset Value", RGB(0, &HC0, 0)             'Gives information to the user
-    Lsm5.StopScan                                                   'Just in case some scanning wa working
-   Lsm5Vba.Application.ThrowEvent eRootReuse, 0                   'Was there in the initial Zeiss macro, but it seems notnecessary
-    DoEvents
-    
-    ZAuto = 0                                                       'I do not know why is this Z Auto there. I believe it is obsolete
-   ' ZBacklash = -50 'Has to do with the movements of the focus wheel that are "better" if they are long enough.
-    
-    StoreAquisitionParameters
-    
-    
-    ActivateAutofocusTrack HighSpeed                                'Sets the track for autofocussing (i.e. "selects" the track in the Zeiss config window )
-    If Not IsAutofocusTrackSelected Then                                'The variable IsAutofocusTrackSelected has been updated in the ActivateAutofocausTrack function
-        MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-        Exit Sub
-    End If
-  
-    Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition       'Verifies that the working distnce is OK. Comes from the initial Zeiss autofocussing macro
-    If Position >= 0 Then
-        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-    Else
-        Range = 0#
-    End If
-    If Range = 0 Then
-        MsgBox "Objective's working distance not defined! Cannot Autofocus!"
-        Exit Sub
-    End If
-    If ZRange > Range * 0.9 Then
-        ZRange = Range * 0.9
-    End If
-    If Abs(Zoffset) > Range * 0.9 Then                   'The offset has to be within half of the working distance. May want to change this when working with large samples in Z
-        Zoffset = 0
-    End If
-
-    SystemVersionOffset
-    
-     AutofocusForm.AutofocusSetting HRZ, BlockHighSpeed
-     Lsm5.DsRecording.FrameSpacing = ZStep
-    NoFrames = CLng(ZRange / ZStep) + 1                     'Calculates the number of frames per stack. Clng converts it to a long and rounds up the fraction
-    Lsm5.DsRecording.FramesPerStack = NoFrames
-    If NoFrames > 2048 Then                                 'overwrites the userdefined value if too many frames have been defined by the user
-        NoFrames = 2048
-    End If
-    If Not HRZ Then
-    Lsm5.DsRecording.Sample0Z = ZStep * NoFrames / 2
-    End If                                                    'Distance of the actual focus to the first Z position of the image (or line) to acquire in the stack.
-                                                            'I think this is only valid for the focus wheel and not the HRZ
-    
-    If Zoffset <= Range * 0.9 Then
-       Lsm5.Hardware.CpFocus.Position = Zbefore + Zoffset + GlobalCorrectionOffset + ZBacklash 'Move down 50um (=ZBacklash) below the position of the offset
-      Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-            Sleep (20)  '20ms
-           DoEvents
-       Loop
-       Lsm5.Hardware.CpFocus.Position = Zbefore + Zoffset + GlobalCorrectionOffset            'Moves up to the position of the offset
-       Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-           Sleep (20)
-           DoEvents
-        Loop
-   End If
-If Not FrameAutofocussing Then
- Lsm5.DsRecording.ScanMode = "ZScan"
- If Not HRZ Then
- Lsm5.DsRecording.SpecialScanMode = "FocusStep"
- End If
- End If
-    Set NewPicture = Lsm5.StartScan                             'Starts the image acquisition for autofocussing
-    Do While NewPicture.IsBusy                                  ' Waiting untill the image acquisition is done
-        If ScanStop Then
-            Lsm5.StopScan
-            GoTo Abort
-        End If
-        DoEvents
-        Sleep (10)
-    Loop
-    Lsm5.tools.WaitForScanEnd False, 40                        'This looks redoundant with the previous, but I had trried to remove it and had problems. It's better to have 2 contols than none !
- 
-    AutofocusForm.MassCenter ("Autofocus")                                    'Calculates the mass center in 3 dimensions
-    XShift = XMass
-    YShift = -YMass
-    ZShift = ZMass
-    
-        'check if Z shift makes sense
-        CheckRefControl BlockZRange
-        
- If Zoffset <= Range * 0.9 Then
-       Lsm5.Hardware.CpFocus.Position = Zbefore + GlobalCorrectionOffset + ZBacklash  'Move down 50um (=ZBacklash) below the position of the offset
-      Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-            Sleep (20)  '20ms
-           DoEvents
-       Loop
-       Lsm5.Hardware.CpFocus.Position = Zbefore + GlobalCorrectionOffset             'Moves up to the position of the offset
-       Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-           Sleep (20)
-           DoEvents
-        Loop
-   End If
-
-    If HRZ Then                             'The HRZ and the focus wheel are acquiring Z stacks in opposite directions
-        Zoffset = -ZShift + Zoffset
-    Else
-        Zoffset = ZShift + Zoffset
-    End If
-    BSliderZOffset.Value = Zoffset          'Writes the calculated value in the offset value
-Abort:
-   RestoreAquisitionParameters
-    Set GlobalBackupRecording = Nothing
-   Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents                                'Finnish everything which had started
-    'ActivateAcquisitionTrack                'Activates the tracks for image acquisition
-    
-    If ScanStop = True Then
-        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-        ScanStop = False
-    Else
-        DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    End If
-End Sub
-
-
-Public Sub SetBlockValues()
-    Dim Position As Long
-    Dim Range As Double
- 
-    CheckBoxHighSpeed.Value = BlockHighSpeed
-    CheckBoxLowZoom.Value = BlockLowZoom
-    CheckBoxHRZ.Value = BlockHRZ
-    Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-    If Position >= 0 Then
-        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-    Else
-        Range = 0#
-    End If
-    If BlockZRange > Range * 0.9 Then
-        BlockZRange = Range * 0.9
-    End If
-    If Abs(BlockZOffset) > Range * 0.9 Then
-        BlockZOffset = 0
-    End If
-    BSliderZOffset.Value = BlockZOffset
-    BSliderZRange.Value = BlockZRange
-    BSliderZStep.Value = BlockZStep
-
-End Sub
-
-
-Public Sub GetBlockValues()
-   
-    BlockHighSpeed = CheckBoxHighSpeed.Value
-    BlockLowZoom = CheckBoxLowZoom.Value
-    HRZ = CheckBoxHRZ.Value
-    BlockZOffset = BSliderZOffset.Value
-    BlockZRange = BSliderZRange.Value
-    BlockZStep = BSliderZStep.Value
-End Sub
-
-
-
-Private Function TimeDisplay(Value As Double) As String         'Calculates the String to display in a "user frindly format". Value is in seconds
-    Dim Hour, Min As Integer
-    Dim Sec As Double
-
-    Hour = Int(Value / 3600)                                        'calculates number of full hours                           '
-    Min = Int(Value / 60) - (60 * Hour)                             'calculates number of left minutes
-    Sec = (Fix((Value - (60 * Min) - (3600 * Hour)) * 100)) / 100   'calculates the number of left seconds
-    If (Hour = 0) And (Min = 0) Then                                'Defines a "user friendly" string to display the time
-        TimeDisplay = Sec & " sec"
-    ElseIf (Hour = 0) And (Sec = 0) Then
-        TimeDisplay = Min & " min"
-    ElseIf (Hour = 0) Then
-        TimeDisplay = Min & " min " & Sec
-    Else
-        TimeDisplay = Hour & " h " & Min
-    End If
-End Function
-
-
-Public Function AcquisitionTime() As Double
-    Dim Track1Speed, Track2Speed, Track3Speed, Track4Speed As Double
-    Dim Pixels As Long
-    Dim FrameNumber As Integer
-    Dim ScanDirection As Integer
-    Dim i As Integer
-   
-    Track1Speed = 0
-    Track2Speed = 0
-    Track3Speed = 0
-    Track4Speed = 0
-    If CheckBoxTrack1.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, success)
-        Track1Speed = Track.SampleObservationTime
-    End If
-    If CheckBoxTrack2.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, success)
-        Track2Speed = Track.SampleObservationTime
-    End If
-    If CheckBoxTrack3.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(2, success)
-        Track3Speed = Track.SampleObservationTime
-    End If
-    If CheckBoxTrack4.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(3, success)
-        Track4Speed = Track.SampleObservationTime
-    End If
-    Pixels = Lsm5.DsRecording.LinesPerFrame * Lsm5.DsRecording.SamplesPerLine
-    FrameNumber = Lsm5.DsRecording.FramesPerStack
-    If Lsm5.DsRecording.ScanDirection = 0 Then
-        ScanDirection = 1
-    Else
-        ScanDirection = 2
-    End If
-    AcquisitionTime = (Track1Speed + Track2Speed + Track3Speed + Track4Speed) * Pixels * FrameNumber / ScanDirection * 3.3485
-End Function
-
-
-
-Private Sub CheckBoxTrack1_Change()
-'    AcquisitionTimeFrame.Caption = TimeDisplay(AcquisitionTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    FillTrackingChannelList
-End Sub
-
-Private Sub CheckBoxTrack2_Change()
-'    AcquisitionTimeFrame.Caption = TimeDisplay(AcquisitionTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    FillTrackingChannelList
-End Sub
-
-Private Sub CheckBoxTrack3_Change()
-'    AcquisitionTimeFrame.Caption = TimeDisplay(AcquisitionTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    FillTrackingChannelList
-End Sub
-
-Private Sub CheckBoxTrack4_Change()
-'    AcquisitionTimeFrame.Caption = TimeDisplay(AcquisitionTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    FillTrackingChannelList
-End Sub
-
-
-
-Public Function AutofocusTime() As Double
-    Dim Speed As Double
-    Dim Pixels As Long
-    Dim FrameNumber As Integer
-    Dim ScanDirection As Integer
-    Dim i As Integer
-
-    Speed = 0
-    If CheckBoxHighSpeed.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, success)
-        Speed = 1.76 * 10 ^ -6
-    Else
-        If OptionButtonTrack1.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, success)
-            Speed = Track.SampleObservationTime
-        End If
-        If OptionButtonTrack2.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, success)
-            Speed = Track.SampleObservationTime
-        End If
-        If OptionButtonTrack3.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, success)
-            Speed = Track.SampleObservationTime
-        End If
-        If OptionButtonTrack4.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, success)
-            Speed = Track.SampleObservationTime
-        End If
-    End If
-    Pixels = 512
-    AutofocusForm.GetBlockValues
-    FrameNumber = CLng(BlockZRange / BlockZStep) + 1
-    If Lsm5.DsRecording.ScanDirection = 0 Then
-        ScanDirection = 1
-    Else
-        ScanDirection = 2
-    End If
-    If CheckBoxHRZ.Value = True Then
-        AutofocusTime = Speed * Pixels * FrameNumber * 3.3485 + 4.9
-    Else
-        AutofocusTime = Speed * Pixels * FrameNumber / ScanDirection * 3.3485 + 4.9
-    End If
-End Function
-
-
-
-Public Sub CheckBoxHRZ_Change() 'I was trying to display the time needed for autofocus, single image acquisition and total time of the experiments, but I gave and and commented out those functions
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Public Sub CheckBoxHighSpeed_Change()  'I was trying to display the time needed for autofocus, single image acquisition and total time of the experiments, but I gave and and commented out those functions
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub BSliderZStep_Change()  'I was trying to display the time needed for autofocus, single image acquisition and total time of the experiments, but I gave and and commented out those functions
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub OptionButtonTrack1_Click()
-    If OptionButtonTrack1.Value Then 'if track 1 checked others are not autofocus track but false
-        OptionButtonTrack2.Value = Not OptionButtonTrack1.Value
-        OptionButtonTrack3.Value = Not OptionButtonTrack1.Value
-        OptionButtonTrack4.Value = Not OptionButtonTrack1.Value
-        CheckAutofocusTrack (1) 'sets SelectedTrack to 1, see below
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub OptionButtonTrack2_Click()
-    If OptionButtonTrack2.Value Then
-        OptionButtonTrack1.Value = Not OptionButtonTrack2.Value
-        OptionButtonTrack3.Value = Not OptionButtonTrack2.Value
-        OptionButtonTrack4.Value = Not OptionButtonTrack2.Value
-        CheckAutofocusTrack (2)
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub OptionButtonTrack3_Click()
-    If OptionButtonTrack3.Value Then
-        OptionButtonTrack1.Value = Not OptionButtonTrack3.Value
-        OptionButtonTrack2.Value = Not OptionButtonTrack3.Value
-        OptionButtonTrack4.Value = Not OptionButtonTrack3.Value
-        CheckAutofocusTrack (3)
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub OptionButtonTrack4_Click()
-    If OptionButtonTrack4.Value Then
-        OptionButtonTrack1.Value = Not OptionButtonTrack4.Value
-        OptionButtonTrack2.Value = Not OptionButtonTrack4.Value
-        OptionButtonTrack3.Value = Not OptionButtonTrack4.Value
-        CheckAutofocusTrack (4)
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-
-'this Function checks whether the track that was selected for autofocusing only contains a single channel (alternetivly defines one of the checked channels)
-'and finds the name of the autofocusing channel
-Private Sub CheckAutofocusTrack(SelectedTrack)
-    Dim Track As DsTrack 'a new track is defined
-    Dim DataChannel As DsDataChannel    'a new interface to a data channel is defined
-                                        'contains channel dependend parameters of the
-                                        'scan memory/display/calculation of scan data during scan operation
-    Dim ActiveChannelNumber As Integer
-    Dim AutofocusChannel As String
-    
-    Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(SelectedTrack - 1, success)
-        'gets the track object by multiplexorder which starts with 0
-        'since selected track starts with 1 (see CheckAutofocusTrack (n)), 1 has to be substracted
-        
-    'the following loop will count the number of activated channels in the track chosen for autofocusing
-    ActiveChannelNumber = 0
-    
-    For j = 0 To Track.DataChannelCount - 1 'gets number of channels that are potentially activatable in track
-        Set DataChannel = Track.DataChannelObjectByIndex(j, success) 'data channel corresponding to loop index is analysed
-        If DataChannel.Acquire = True Then  'checks whether the data channel corresponding to loop index is activated
-            ActiveChannelNumber = ActiveChannelNumber + 1 'counts the number of activated channels
-            If ActiveChannelNumber = 1 Then AutofocusChannel = DataChannel.name 'Gets the name of the first activated channel
-        End If
-    Next
-    
-    If ActiveChannelNumber > 1 Then 'if more than one channel is activated...
-        MsgBox ("The track you selected has more than one active Channel. " & AutofocusChannel & " will be used to calculate autofocus parameters.")
-    End If
-End Sub
-
-
-
-Public Function TotalTimeLeft() As Double
-    Dim Speed As Double
-    Dim Pixels As Long
-    Dim FrameNumber As Integer
-    Dim ScanDirection As Integer
-    Dim i As Integer
-    TotalTimeLeft = (AcquisitionTime + AutofocusTime + BlockTimeDelay) * (BlockRepetitions - RepetitionNumber + 1) - BlockTimeDelay
-End Function
-
-
-
-
-
-Public Sub AutofocusSetting(HRZ As Boolean, HighSpeed As Boolean)
-If LowZoom Then                                         'Changes the zoom if necessary
-        Lsm5.DsRecording.ZoomX = 1
-        Lsm5.DsRecording.ZoomY = 1
-    End If
-        
-    Lsm5.DsRecording.TimeSeries = False                     'Disable the timeseries, because autofocussing is juste one image at one timepoint.
-    
-    If FrameAutofocussing Then                              'Setting the way the Stage is going to move in Z, plus speed and number of pixels
-        Lsm5.DsRecording.ScanMode = "Stack"                 'This is defining to acquire a Z stack of Z-Y images
-        If HRZ Then
-            Lsm5.DsRecording.SpecialScanMode = "ZScanner"
-        Else
-' !!!!!!!!!!!! potential error source  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-' improvement
-    If SystemName = "LSM" Then
-    Lsm5.DsRecording.SpecialScanMode = "FocusStep"
-
-'Lsm5.DsRecording.FrameSpacing = ZStep
-'    NoFrames = CLng(ZRange / ZStep) + 1
-'    Lsm5.DsRecording.FramesPerStack = NoFrames
-'    If NoFrames > 2048 Then
-'        NoFrames = 2048
-'    End If
-    Lsm5.DsRecording.Sample0Z = ZStep * NoFrames / 2
-    Else
-            Lsm5.DsRecording.SpecialScanMode = "OnTheFly"
-             Lsm5.DsRecording.FramesPerStack = 1201
-            Lsm5.DsRecording.Sample0Z = Range / 2
-            Lsm5.DsRecording.FrameSpacing = Range / 1200
-            Sleep (100)
-        End If
-        End If
-        If HighSpeed Then
-            Lsm5.DsRecording.ScanDirection = 1                  'If Highspeed is selected it uses the bidirectionnal scanning
-        End If
-        If SystemName = "LIVE" Then
-            Lsm5.DsRecording.RtRegionWidth = BSliderFrameSize.Value 'If doing frame autofocussing it uses the userdefined frame size
-            Lsm5.DsRecording.RtBinning = 512 / BSliderFrameSize.Value
-            Lsm5.DsRecording.RtRegionHeight = BSliderFrameSize.Value
-        ElseIf SystemName = "LSM" Then
-            Lsm5.DsRecording.SamplesPerLine = BSliderFrameSize.Value  'If doing frame autofocussing it uses the userdefined frame size
-            'Lsm5.DsRecording.RtBinning = 4
-            Lsm5.DsRecording.LinesPerFrame = BSliderFrameSize.Value
-        Else
-            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-        Exit Sub
-        End If
-    Else
-        Lsm5.DsRecording.ScanMode = "ZScan"                     'This is defining to acquire a single X-Z image, like what is done with the "Range" button in the LSM ScanControl window
-        If HRZ Then
-            Lsm5.DsRecording.SpecialScanMode = "ZScanner"
-           If SystemName = "LIVE" Then
-                Lsm5.DsRecording.RtLinePeriod = 1 / BSliderScanSpeed.Value
-                Lsm5.DsRecording.RtRegionWidth = 512
-                Lsm5.DsRecording.RtRegionHeight = 1
-            ElseIf SystemName = "LSM" Then
-                Lsm5.DsRecording.SamplesPerLine = 256
-                Lsm5.DsRecording.LinesPerFrame = 1
-            Else
-                MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-                Exit Sub
-            End If
-           
-        Else
-'
-            Lsm5.DsRecording.SpecialScanMode = "FocusStep"
-            'Lsm5.DsRecording.SpecialScanMode = "OnTheFly" ' I this does not work om old LSM, use "FocusStep"
-            
-            
-       
-        End If
-         If SystemName = "LIVE" Then
-            Lsm5.DsRecording.RtLinePeriod = 1 / BSliderScanSpeed.Value
-            Lsm5.DsRecording.RtRegionWidth = 512
-            Lsm5.DsRecording.RtRegionHeight = 1
-            
-       
-         ElseIf SystemName = "LSM" Then
-                Lsm5.DsRecording.SamplesPerLine = 256
-                Lsm5.DsRecording.LinesPerFrame = 1
-        Else
-                MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-                Exit Sub
-        End If
-        End If
-     Sleep (100)
-    
-End Sub
-
-''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-''''''''''''''''''''''''''''''''''Grid Definition'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-Private Sub TextBoxXgrid_Change()
-            If IsNumeric(TextBoxXGrid.Value) Then
-            GlobalXGrid = TextBoxXGrid.Value
-        Else
-             MsgBox "Please enter the number of columns!"
-        End If
-        
-        ReDim GlobalDeActivatedLocations(GlobalMaximumPositions, GlobalXGrid * GlobalYGrid)
-        ReDim GlobalLocationsOrder(GlobalMaximumPositions, GlobalXGrid * GlobalYGrid)
-        GlobalOrderChanged = True
-    End Sub
-
-Private Sub TextBoxYGrid_Change()
-         If IsNumeric(TextBoxYGrid.Value) Then
-            GlobalYGrid = TextBoxYGrid.Value
-        Else
-             MsgBox "Please enter the number of rows!"
-        End If
-        
-        
-        ReDim GlobalDeActivatedLocations(GlobalMaximumPositions, GlobalXGrid * GlobalYGrid)
-        ReDim GlobalLocationsOrder(GlobalMaximumPositions, GlobalXGrid * GlobalYGrid)
-        GlobalOrderChanged = True
-
-End Sub
-    
-
-Private Sub TextBoxXStep_Change()
-If IsNumeric(TextBoxXStep.Value) Then
-            GlobalXStep = TextBoxXStep.Value
-        Else
-             MsgBox "Please enter the horizontal distance between two neighbouring locations!"
-        End If
-    
-End Sub
-
-
-Private Sub TextBoxYStep_Change()
-
-If IsNumeric(TextBoxYStep.Value) Then
-            GlobalYStep = TextBoxYStep.Value
-        Else
-             MsgBox "Please enter the vertical distance between two neighbouring locations!"
-        End If
-
-   
-End Sub
-Private Sub CommandButtonGrid_Click()
-    ShowGrid
-End Sub
-
-
-Public Sub ShowGrid()
-Dim BitsPerSample As Long
-Dim bpp As Long
-Dim ImgName As String
-Dim LsmMath As New LsmVectorMath
-Dim SpareArray() As Single
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim iX As Long
-Dim iY As Long
-Dim PlaneSize As Long
-    If Not GlobalGridImage Is Nothing Then
-        If Not GlobalGridImage.IsValid Then
-            Set GlobalGridImage = Nothing
-        Else
-             GlobalGridImage.CloseAllWindows
-             Set GlobalGridImage = Nothing
-            
-        End If
-    End If
-    If GlobalGridImage Is Nothing Then
-        BitsPerSample = 12
-        bpp = 2
-        XPixels = 1024
-        YPixels = 1024
-        XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-        YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-        If XGroup <= YGroup Then
-            YGroup = XGroup
-        Else
-            XGroup = YGroup
-        End If
-        XPixels = XGroup * (3 * GlobalXGrid + 1)
-        YPixels = YGroup * (3 * GlobalYGrid + 1)
-        MakeBlankImage GlobalGridImage, BitsPerSample, bpp, True, ImgName, False, 1, XPixels, YPixels, 3
-        GlobalGridImage.SetTitle "Location Grid"
-        GlobalGridImage.NeverAgainScanToTheImage
-        RedrawGrid GlobalGridImage
-        GlobalGridImage.VectorOverlay.LineWidth = 1
-        GlobalGridImage.VectorOverlay.Color = RGB(0, 255, 0)
-        GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-        If GlobalReferencePoints = 2 Then
-            DrawCrossGrid GlobalGridX1, GlobalGridY1
-            DrawCrossGrid GlobalGridX2, GlobalGridY2
-        ElseIf GlobalReferencePoints = 1 Then
-            DrawCrossGrid GlobalGridX1, GlobalGridY1
-        End If
-        
-        GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowNoButtonMouseMoveEvent, 1
-        GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLButtonMouseMoveEvent, 1
-        GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonDownEvent, 1
-        GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonUpEvent, 1
-        GlobalGridImage.EnableImageWindowEvent ds.eImageWindowRightButtonUpEvent, 1
-        
-        DoEvents
-    End If
-End Sub
-
-Private Sub CommandButtonRemove_Click()
-Dim Msg, Style, Title, Help, Ctxt, Response, MyString
-    Msg = "Do You Want to Remove Selected Reference Points?"
-    Style = VbYesNo + VbQuestion + VbDefaultButton2   ' Define buttons.
-    Title = "Remove Reference Points"  ' Define title.
-    Response = MsgBox(Msg, Style, Title)
-    If Response = vbYes Then    ' User chose Yes.
-        GlobalReferencePoints = 0
-        If Not GlobalGridImage Is Nothing Then
-            If GlobalGridImage.IsValid Then
-                GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-            End If
-        End If
-    End If
-End Sub
-
-Private Sub CreateLocationsButton_Click()
-Dim XPos As Double
-    Dim YPos As Double
-    Dim ZPos As Double
-    
-    Dim idx As Long
-    Dim idy As Long
-    Dim idt As Long
-    Dim x As Double
-    Dim y As Double
-    Dim det As Double
-    Dim A11 As Double
-    Dim A12 As Double
-    Dim A21 As Double
-    Dim A22 As Double
-    Dim x1 As Double
-    Dim Y1 As Double
-    
-    Dim result As Long
-    Dim ProgressString As String
-    Dim Color As Long
-    Dim ZeroChanged As Boolean
-    Dim SetZeroMarked As Boolean
-    Dim idpos As Long
-    Dim idold As Long
-    Dim OverWriteZ As Boolean
-    
-    
-    
-  If GridToggle Then
-    
-      OverWriteZ = PubFuncOverWriteZ
-   
-    
-    ProgressString = "Please Wait..."
-    Color = RGB(&HC0, 0, 0)
-    DisplayProgress ProgressString, Color
-    DoEvents
-
-    If TextBoxYGrid.Value * TextBoxXGrid.Value <= GlobalMaximumPositions Then
-        flgUserChange = False
-        GlobalXGrid = TextBoxXGrid.Value
-        GlobalYGrid = TextBoxYGrid.Value
-        GlobalXStep = TextBoxXStep.Value
-        GlobalYStep = TextBoxYStep.Value
-        
-        
-'        Stage.MarkClearAll
-        ZPos = GlobalGridStageZ1
-        If GlobalReferencePoints >= 1 Then
-            XPos = GlobalGridStageX1 - (GlobalGridX1 - 1) * GlobalXStep
-            YPos = GlobalGridStageY1 - (GlobalGridY1 - 1) * GlobalYStep
-'        Else does not wordk properly
-'            x = GetStagePositionX
-'            y = GetStagePositionY
-'            ConvertToStagePositionXY x, y, XPos, YPos
-        End If
-        GlobalPositionsRecalled = GlobalPositionsStage
-        GlobalPositionsStage = GlobalXGrid * GlobalYGrid
-        ReDim GlobalLocationsName(GlobalPositionsStage)
-        GlobalCurrentPosition = 1
-        If GlobalPositionsStage <= 1 Then
-            GlobalPositionsStage = 1
-            GlobalCurrentPosition = 1
-            StartStopForm.ComboBoxLocation.AddItem "Present"
-        Else
-            det = -1 * 1 - 0 * 0
-          '  det = X11 * X22 - X21 * X12
-            If det = 0 Then
-                GlobalPositionsStage = 1
-                GlobalCurrentPosition = 1
-               ' StartStopForm.ComboBoxLocation.AddItem "Present"
-            
-            Else
-                SetZeroMarked = True
-                GetGlobalZZero SetZeroMarked, ZeroChanged
-                x1 = XPos
-                Y1 = YPos
-                ReDim GlobalXpos(GlobalXGrid * GlobalYGrid)
-                ReDim GlobalYpos(GlobalXGrid * GlobalYGrid)
-                If OverWriteZ Then ReDim GlobalZpos(GlobalXGrid * GlobalYGrid)
-            
-                
-                If GlobalMeander Then
-                    idpos = 0
-                    For idy = 1 To GlobalYGrid Step 2
-                        For idx = 1 To GlobalXGrid
-                            idt = (idy - 1) * GlobalXGrid + idx
-                            If Not GlobalDeActivatedLocations(idx, idy) Then
-                                idpos = idpos + 1
-                                
-                                GlobalLocationsOrder(idx, idy) = idpos
-                                GlobalLocationsName(idpos) = "Column" & idx & "_Row" & idy
-                                GlobalXpos(idpos) = x1 + (idx - 1) * GlobalXStep
-                                GlobalYpos(idpos) = Y1 + (idy - 1) * GlobalYStep
-                                If OverWriteZ Then
-                                    GlobalZpos(idpos) = ZPos
-                                Else
-                                    idold = GlobalLocationsOrderOld(idx, idy)
-                                    If idold = -1 Then
-                                        GlobalZpos(idpos) = ZPos
-                                    Else
-                                        GlobalZpos(idpos) = GlobalZposOld(idold)
-                                    End If
-                                End If
-                            Else
-                                GlobalLocationsOrder(idx, idy) = -1
-                            End If
-                        Next idx
-                        If idt >= GlobalXGrid * GlobalYGrid Then Exit For
-                        For idx = 1 To GlobalXGrid
-                            idt = idy * GlobalXGrid + GlobalXGrid - idx + 1
-                            If Not GlobalDeActivatedLocations(GlobalXGrid - idx + 1, idy + 1) Then
-                                idpos = idpos + 1
-                                
-                                GlobalLocationsOrder(GlobalXGrid - idx + 1, idy + 1) = idpos
-                                GlobalLocationsName(idpos) = "Column" & GlobalXGrid - idx + 1 & "_Row" & idy + 1
-                                GlobalXpos(idpos) = x1 + (GlobalXGrid - idx) * GlobalXStep
-                                GlobalYpos(idpos) = Y1 + idy * GlobalYStep
-                                If OverWriteZ Then
-                                    GlobalZpos(idpos) = ZPos
-                                Else
-                                idold = GlobalLocationsOrderOld(GlobalXGrid - idx + 1, idy + 1)
-                                    If idold = -1 Then
-                                        GlobalZpos(idpos) = ZPos
-                                    Else
-                                        GlobalZpos(idpos) = GlobalZposOld(idold)
-                                    End If
-                                End If
-                            Else
-                                GlobalLocationsOrder(GlobalXGrid - idx + 1, idy + 1) = -1
-                            End If
-                        Next idx
-                    Next idy
-                Else
-                    idpos = 0
-                    For idy = 1 To GlobalYGrid
-                        For idx = 1 To GlobalXGrid
-                            idt = (idy - 1) * GlobalXGrid + idx
-                            If Not GlobalDeActivatedLocations(idx, idy) Then
-                                idpos = idpos + 1
-                                GlobalLocationsName(idpos) = "Column" & idx & "_Row" & idy
-                                GlobalLocationsOrder(idx, idy) = idpos
-                                GlobalXpos(idpos) = x1 + (idx - 1) * GlobalXStep
-                                GlobalYpos(idpos) = Y1 + (idy - 1) * GlobalYStep
-                                If OverWriteZ Then
-                                    GlobalZpos(idpos) = ZPos
-                                Else
-                                    idold = GlobalLocationsOrderOld(idx, idy)
-                                    If idold = -1 Then
-                                        GlobalZpos(idpos) = ZPos
-                                    Else
-                                        GlobalZpos(idpos) = GlobalZposOld(idold)
-                                    End If
-                                End If
-                            Else
-                                GlobalLocationsOrder(idx, idy) = -1
-                            End If
-                        Next idx
-                    Next idy
-                End If
-            End If
-        End If
-        GlobalOrderChanged = False
-        GlobalPositionsStage = idpos
-        GLobalPositions = GlobalPositionsStage
-        flgUserChange = False
-        flgUserChange = True
-        GlobalIsTile = False
-    Else
-        MsgBox "Number of locations in the grid cannot exceed " + CStr(GlobalMaximumPositions)
-    End If
-    Tile
-    DisplayProgress GlobalProgressString, GlobalColor
-    DoEvents
-     AutofocusForm.SetMarkedLocations GlobalPositionsStage
-     PubSentStageGrid = True
-     
-     ElseIf MultipleLocationToggle = True Then
-  
-    GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-     PutStagePositionsInArray
-     Tile
-     AutofocusForm.SetMarkedLocations GlobalPositionsStage
-     End If
-End Sub
-
-Public Sub DisplayGridSelection(x As Long, y As Long, xIndx As Long, yIndx As Long)
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim Start As Long
-Dim iX As Long
-Dim iY As Long
-Dim Xmin As Long
-Dim Xmax As Long
-Dim Ymin As Long
-Dim Ymax As Long
-Dim xImage As Long
-Dim StartX As Long
-Dim yImage As Long
-Dim StartY As Long
-Dim Found As Boolean
-Dim EndX As Long
-Dim EndY As Long
-Dim XPosition As Long
-Dim YPosition As Long
-Dim xMod As Long
-Dim yMod As Long
-Dim xString As String
-Dim yString As String
-Dim MyString As String
-
-    If GlobalGridImage Is Nothing And GlobalZGridImage Is Nothing Then Exit Sub
-    
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    XPosition = Int(x / XGroup) + 1
-    YPosition = Int(y / YGroup) + 1
-    xMod = XPosition Mod 3
-    yMod = YPosition Mod 3
-    xIndx = XPosition / 3
-    yIndx = YPosition / 3
-TileX = AutofocusForm.TextBoxTileX.Value
-TileY = AutofocusForm.TextBoxTileY.Value
-    If xMod = 1 Or yMod = 1 Then
-        xString = ""
-        yString = ""
-    Else
-        xString = CStr(xIndx)
-        yString = CStr(yIndx)
-    End If
-  '  LabelGrid.ForeColor = RGB(0, 0, 0)
-    MyString = "Column= " + xString + vbCrLf + "Row= " + yString
-    If Not GlobalOrderChanged Then
-        If GlobalLocationsOrder(xIndx, yIndx) > 0 Then
-            MyString = MyString + vbCrLf + "Mark= " + CStr((GlobalLocationsOrder(xIndx, yIndx) - 1) * TileX * TileY + 1) + " to " + CStr((GlobalLocationsOrder(xIndx, yIndx)) * TileX * TileY)
-        End If
-    End If
-    If GlobalZmapAquired Then
-         If GlobalLocationsOrder(xIndx, yIndx) > -1 Then
-            idpos = GlobalLocationsOrder(xIndx, yIndx)
-            MyString = MyString + vbCrLf + "z-Value= " + CStr(Round(GlobalZpos(idpos), 3))
-            End If
-         End If
-    DisplayProgress MyString, RGB(0, &HC0, 0)
-End Sub
-
-Public Sub DrawCrossGrid(xIndx As Long, yIndx As Long)
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim iX As Long
-Dim iY As Long
-Dim x1 As Long
-Dim Y1 As Long
-Dim X2 As Long
-Dim Y2 As Long
-
-    If (GlobalGridImage Is Nothing) Then Exit Sub
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    x1 = XGroup + 3 * XGroup * (xIndx - 1)
-    Y1 = YGroup + 3 * YGroup * (yIndx - 1)
-    X2 = 3 * XGroup + 3 * XGroup * (xIndx - 1)
-    Y2 = 3 * YGroup + 3 * YGroup * (yIndx - 1)
-      
-    GlobalGridImage.VectorOverlay.Color = RGB(255, 255, 0)
-    GlobalGridImage.VectorOverlay.LineWidth = 1
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeLine, x1, Y1, X2, Y2
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeLine, x1, Y2, X2, Y1
-'    dsDoc.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeCircle, xCross, yCross, xCross, yCross + 30
-    GlobalGridImage.RedrawImage
-    
-End Sub
-
-Public Sub DrawRectangleGrid(x1 As Long, Y1 As Long, X2 As Long, Y2 As Long)
-
-    If (GlobalGridImage Is Nothing) Then Exit Sub
-      
-    GlobalGridImage.VectorOverlay.Color = RGB(0, 255, 0)
-    GlobalGridImage.VectorOverlay.LineWidth = 1
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeRectangle, x1, Y1, X2, Y2
-    GlobalGridImage.RedrawImage
-    
-End Sub
-
-
-Public Sub SetMarkedLocations(Positions As Long)
-    Dim idx As Long
-    Dim ZeroChanged As Boolean
-    Dim SetZeroMarked As Boolean
-    SetZeroMarked = False
- '   If GlobalIsStage And GlobalMultiLocation Then
-        If Positions > 1 Then
-            GetGlobalZZero SetZeroMarked, ZeroChanged
-'            If ZeroChanged Then
-'                FillLocationList
-'            End If
-            Lsm5.Hardware.CpStages.MarkClearAll
-            For idx = 1 To Positions
-                Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idx), GlobalYpos(idx), GlobalZpos(idx)
-            Next idx
-        End If
- '   End If
-End Sub
-
-
-Private Sub CheckBoxMeander_Click()
- If flgUserChange Then
-        GlobalMeander = CheckBoxMeander.Value
-    End If
-
-End Sub
-
-'Private Sub CheckBoxKeepSteps_Click()
-' If flgUserChange Then
-'        GlobalKeepSteps = CheckBoxKeepSteps.Value
-'    End If
-'End Sub
-
-
-Private Sub ZMapButton_Click()
-Dim text As String
-Dim x As Double
-Dim y As Double
-Dim z As Double
-Dim Zbefore As Double
-Dim BitsPerSample As Long
-Dim bpp As Long
-Dim ImgName As String
-Dim SpareArray() As Single
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim iX As Long
-Dim iY As Long
-Dim PlaneSize As Long
-Dim idold As Long
-
-ZValues.Show
-InitializeStageProperties
-SetStageSpeed 8, True
-
-If PubSentStageGrid = False And (Grid Or StripeScanToggle.Value) Then
-    MsgBox "Please send the grid information to stage first!", VbExclamation
-    Exit Sub
-End If
-
-AutofocusForm.GetBlockValues 'Updates the parameters value for BlockZRange, BlockZStep..
-'DisplayProgress "Aquiring Reference", RGB(0, &HC0, 0)
-Lsm5.StopScan
-Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-DoEvents
-StoreAquisitionParameters
-
-'got to Refcor1
-
-
-'Lsm5.Hardware.CpStages.PositionX = GlobalGridStageX1
-'Lsm5.Hardware.CpStages.PositionY = GlobalGridStageY1
-'While Lsm5.Hardware.CpStages.IsBusy
-'    DoEvents
-'Wend
-'Lsm5.Hardware.CpFocus.Position = GlobalGridStageZ1
-'While Lsm5.Hardware.CpFocus.IsBusy
-'    DoEvents
-'Wend
-'Sleep (20)
-''Aquire Z-Stack,Caluclate shift
-'
-'
-' Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-' If PubAbort Then GoTo Abort
-''Caluclate new z Position, Store Z in Array
-'GlobalGridStageZ1 = GlobalGridStageZ1 + ZShift
- GettingZmap = True
-GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-    If MultipleLocation Then
-    PutStagePositionsInArray
-    End If
-    
-
-If Grid Then
-    If GlobalMeander Then
-         For idpos = 1 To GlobalPositionsStage
-            If ScanStop Then
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                GoTo Abort
-             End If
-           
-          
-        If GlobalStageControlZValues = False Then
-           If idpos = 1 Then
-               Lsm5.Hardware.CpFocus.Position = GlobalGridStageZ1
-               Zbefore = GlobalGridStageZ1
-               While Lsm5.Hardware.CpFocus.IsBusy
-                  DoEvents
-               Wend
-           Else
-               Zbefore = GlobalZpos(idpos - 1)
-               Lsm5.Hardware.CpFocus.Position = GlobalZpos(idpos - 1)
-               While Lsm5.Hardware.CpFocus.IsBusy
-                  DoEvents
-               Wend
-           End If
-          
-        Else
-            Lsm5.Hardware.CpFocus.Position = GlobalZpos(idpos)
-            While Lsm5.Hardware.CpFocus.IsBusy
-                  DoEvents
-               Wend
-        End If
-         Lsm5.Hardware.CpStages.PositionX = GlobalXpos(idpos)
-        Lsm5.Hardware.CpStages.PositionY = GlobalYpos(idpos)
-           Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-           DisplayProgress "Aquiring idpos " & idpos & ", z= " & GlobalZpos(idpos), RGB(0, &HC0, 0)
-            Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-             'check if Z shift makes sense
-          CheckRefControl BlockZRange
-           'Calculate new Z and Store in Array
-           GlobalZpos(idpos) = Lsm5.Hardware.CpFocus.Position + BlockZOffset + ZShift
-           
-           Next idpos
-    Else
-       For Row = 1 To GlobalYGrid
-           For column = 1 To GlobalXGrid
-              If Not GlobalDeActivatedLocations(column, Row) Then
-                  idpos = GlobalLocationsOrder(column, Row)
-                  Lsm5.Hardware.CpStages.PositionX = GlobalXpos(idpos)
-                  Lsm5.Hardware.CpStages.PositionY = GlobalYpos(idpos)
-                  If Row = 1 And column = 1 Then
-                      Lsm5.Hardware.CpFocus.Position = GlobalGridStageZ1
-                      Zbefore = GlobalGridStageZ1
-                  ElseIf Row <> 1 And column = 1 Then
-                  idold = GlobalLocationsOrder(column, Row - 1)
-                    If idold = -1 Then
-                        Zbefore = GlobalZpos(idpos - 1)
-                    Else
-                            Zbefore = GlobalZpos(idold)
-                    End If
-                      Lsm5.Hardware.CpFocus.Position = Zbefore
-                Else
-                      Zbefore = GlobalZpos(idpos - 1)
-                      Lsm5.Hardware.CpFocus.Position = GlobalZpos(idpos - 1)
-                  End If
-                Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-                  DisplayProgress "Aquiring idpos " & idpos & ", z= " & GlobalZpos(idpos), RGB(0, &HC0, 0)
-                  'Aquire Z-Stack,Caluclate shift
-                   Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-             'check if Z shift makes sense
-          CheckRefControl BlockZRange
-           'Calculate new Z and Store in Array
-                  GlobalZpos(idpos) = Lsm5.Hardware.CpFocus.Position + BlockZOffset + ZShift
-               End If
-          Next column
-       Next Row
-    End If
-    Lsm5.Hardware.CpStages.MarkClearAll
-        For idpos = 1 To GlobalPositionsStage
-     '    GlobalZpos(idpos) = GlobalZpos(idpos)  + ZShift '?????? suchmarke
-           Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-        Next idpos
-Else ' Zmap in multilocation modus
-GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-    For idpos = 1 To GlobalPositionsStage
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                       GoTo Abort
-                    End If
-                    Lsm5.Hardware.CpStages.PositionX = GlobalXpos(idpos)
-                  Lsm5.Hardware.CpStages.PositionY = GlobalYpos(idpos)
-                  Lsm5.Hardware.CpFocus.Position = GlobalZpos(idpos)
- '                 Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-'            Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToMarkZ (0) 'Moves to the first location marked in the stage control
-              Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-                    If ScanStop Then
-                       DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                      GoTo Abort
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-              DisplayProgress "Aquiring idpos " & idpos, RGB(0, &HC0, 0)
-            Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-             'check if Z shift makes sense
-          CheckRefControl BlockZRange
-           'Calculate new Z and Store in Array
-           GlobalZpos(idpos) = Lsm5.Hardware.CpFocus.Position + BlockZOffset + ZShift
-           
-        
-'           success = Lsm5.Hardware.CpStages.MarkGet(0, x, y)
- '          success = Lsm5.Hardware.CpStages.MarkClear(0)
-'
-'            Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ x, y, z
-          Next idpos
-          Lsm5.Hardware.CpStages.MarkClearAll
-          For idpos = 1 To GlobalPositionsStage
-          Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-          Next idpos
-End If
-'Lsm5.Hardware.CpStages.MarkClearAll
-'        For idpos = 1 To GlobalPositionsStage
-'         GlobalZpos(idpos) = GlobalZpos(idpos) + ZShift
-'           Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-'        Next idpos
-GlobalZmapAquired = True
-DisplayProgress "Zmap ready", RGB(0, &HC0, 0)
-If Grid Then
-    If Not GlobalZGridImage Is Nothing Then
-            If Not GlobalZGridImage.IsValid Then
-                Set GlobalZGridImage = Nothing
-            Else
-                 GlobalZGridImage.CloseAllWindows
-                 Set GlobalZGridImage = Nothing
-                
-            End If
-        End If
-        If GlobalZGridImage Is Nothing Then
-            BitsPerSample = 12
-            bpp = 2
-            XPixels = 1024
-            YPixels = 1024
-            XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-            YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-            If XGroup <= YGroup Then
-                YGroup = XGroup
-            Else
-                XGroup = YGroup
-            End If
-            XPixels = XGroup * (3 * GlobalXGrid + 1)
-            YPixels = YGroup * (3 * GlobalYGrid + 1)
-            MakeBlankImage GlobalZGridImage, BitsPerSample, bpp, True, ImgName, False, 1, XPixels, YPixels, 3
-            GlobalZGridImage.SetTitle "Z Values"
-            GlobalZGridImage.NeverAgainScanToTheImage
-            
-            GlobalZGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowNoButtonMouseMoveEvent, 1
-            GlobalZGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLButtonMouseMoveEvent, 1
-            GlobalZGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonDownEvent, 1
-            GlobalZGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonUpEvent, 1
-            GlobalZGridImage.EnableImageWindowEvent ds.eImageWindowRightButtonUpEvent, 1
-        End If
-    RedrawZGrid GlobalZGridImage
-End If
-'RestoreAquisitionParameters
-'GettingZmap = False
-CheckBoxZMap.Value = True
-Abort:
-RestoreAquisitionParameters
-GettingZmap = False
-PubAbort = False
-If ScanStop = True Then
-        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-        ScanStop = False
-End If
-End Sub
diff --git a/AutofocusScreen_LSM5_v1.7/src/AutofocusForm.frx b/AutofocusScreen_LSM5_v1.7/src/AutofocusForm.frx
deleted file mode 100644
index 8aa323d..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/src/AutofocusForm.frx and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/src/CorrectFocusForm.frm b/AutofocusScreen_LSM5_v1.7/src/CorrectFocusForm.frm
deleted file mode 100644
index b5c28e1..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/CorrectFocusForm.frm
+++ /dev/null
@@ -1,63 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} CorrectFocusForm 
-   Caption         =   "Correct Focus"
-   ClientHeight    =   2130
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   4410
-   OleObjectBlob   =   "CorrectFocusForm.frx":0000
-   ShowModal       =   0   'False
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "CorrectFocusForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-Option Explicit
-
-
-
-
-Private Sub ChangeFocusButton_Click()
-ChangeFocus = True
-FocusChanged = True
-RestoreAquisitionParameters
-Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-DoEvents
-AutofocusForm.ActivateAcquisitionTrack
- While ChangeFocus = True
-                       DoEvents
-                        Sleep (100)
-Wend
-
-End Sub
-
-Private Sub GoOnButton_Click()
-ChangeFocus = False
-Unload CorrectFocusForm
-DoNotGoOn = False
-End Sub
-
-
-
-Private Sub UserForm_Activate()
-Dim i As Long
-Dim j As Long
-i = 5
-ChangeFocus = False
-FocusChanged = False
-While i >= 1
-    
-    Label1.Caption = "The focus couldnot be found. Do You want to change the Position of the FocusWheel manually?" _
-                     + " If you donot press the Change Button, then prgramme will go on automatically in " _
-                     + CStr(i) + " sec."
-    Sleep (1000)
-    DoEvents
-    If ChangeFocus Then Exit Sub
-    i = i - 1
-Wend
-
-If i = 0 Then Unload CorrectFocusForm
-DoNotGoOn = False
-End Sub
diff --git a/AutofocusScreen_LSM5_v1.7/src/CorrectFocusForm.frx b/AutofocusScreen_LSM5_v1.7/src/CorrectFocusForm.frx
deleted file mode 100644
index 7dcfc93..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/src/CorrectFocusForm.frx and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/src/CreditForm.frm b/AutofocusScreen_LSM5_v1.7/src/CreditForm.frm
deleted file mode 100644
index 8d62970..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/CreditForm.frm
+++ /dev/null
@@ -1,20 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} CreditForm 
-   Caption         =   "Credit"
-   ClientHeight    =   3180
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   3585
-   OleObjectBlob   =   "CreditForm.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "CreditForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-Private Sub CloseButton_Click()
-    CreditForm.Hide
-End Sub
-
diff --git a/AutofocusScreen_LSM5_v1.7/src/CreditForm.frx b/AutofocusScreen_LSM5_v1.7/src/CreditForm.frx
deleted file mode 100644
index 6bda6f4..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/src/CreditForm.frx and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/src/Functions.bas b/AutofocusScreen_LSM5_v1.7/src/Functions.bas
deleted file mode 100644
index df494b6..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/Functions.bas
+++ /dev/null
@@ -1,123 +0,0 @@
-Attribute VB_Name = "Functions"
-Public Function GetGlobalZZero(SetZeroMarked As Boolean, ZeroChanged As Boolean)
-    Dim Count As Integer
-    Dim idx As Long
-    
-    Dim XPos As Double
-    Dim YPos As Double
-    Dim ZPos As Double
-    Dim x1 As Double
-    Dim Y1 As Double
-    Dim res1 As Integer
-
-    Dim success As Boolean
-    Dim result As Long
-    Dim Positions As Long
-    ZeroChanged = False
-    If GlobalIsStage Then
-        Positions = Lsm5.Hardware.CpStages.MarkCount
-        ZPos = CpFocus.Position
-        result = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ(0, 0, 0)
-        If result <> (Positions + 1) Then
-            result = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ(10, 10, 0)
-        End If
-        result = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).GetMarkZ(Positions, GlobalXZero, GlobalYZero, GlobalZZero)
-        res1 = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).ClearMark(Positions)
-        
-        Positions = GlobalPositionsStage
-        If SetZeroMarked Then
-            GlobalZZeroMarked = GlobalZZero
-        Else
-            If Positions <= 1 Then
-                Positions = 1
-                If GlobalZZeroMarked <> GlobalZZero Then
-                    GlobalZZeroMarked = GlobalZZero
-                    ZeroChanged = True
-                End If
-                
-            Else
-                If GlobalZZeroMarked <> GlobalZZero Then
-                    For idx = 1 To Positions
-                        GlobalZpos(idx) = GlobalZpos(idx) + GlobalZZeroMarked - GlobalZZero
-                    Next idx
-                    GlobalZZeroMarked = GlobalZZero
-                    ZeroChanged = True
-    
-                End If
-            End If
-        End If
-    Else
-        GlobalZZero = 0
-        Positions = 0
-    End If
-End Function
-Function FServerFromDescription(strName As String, StrPath As String, ExecName As String) As Boolean
-    Dim lngResult As Long
-    Dim strTmp As String
-    Dim hKeyServer As Long
-    Dim strBuffer As String
-    Dim cb As Long
-    Dim i As Integer
-    
-    FServerFromDescription = False
-    
-    strTmp = VBA.Space(255)
-    strTmp = strName + "\CLSID"
-    lngResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strTmp, 0&, KEY_READ, hKeyServer)
-    
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    strBuffer = VBA.Space(255)
-    cb = Len(strBuffer)
-    
-    lngResult = RegQueryValueEx(hKeyServer, "", 0&, REG_SZ, ByVal strBuffer, cb)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    
-    lngResult = RegCloseKey(hKeyServer)
-    strTmp = VBA.Space(255)
-    strTmp = "CLSID\" + Strings.Left(strBuffer, cb - 1) + "\LocalServer32"
-    strBuffer = VBA.Space(255)
-    cb = Len(strBuffer)
-    lngResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strTmp, 0&, KEY_READ, hKeyServer)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-        
-    lngResult = RegQueryValueEx(hKeyServer, "", 0&, REG_SZ, ByVal strBuffer, cb)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    StrPath = Strings.Left(strBuffer, cb - 1)
-    ExecName = StrPath
-    lngResult = RegCloseKey(hKeyServer)
-    
-    i = Len(StrPath)
-    
-    Do Until (i = 0)
-        If (VBA.Mid(StrPath, i, 1) = "\") Then
-            StrPath = Strings.Left(StrPath, i - 1)
-            FServerFromDescription = True
-            Exit Do
-        End If
-        i = i - 1
-    Loop
-
-error_exit:
-    If (Not hKeyServer = 0) Then lngResult = RegCloseKey(hKeyServer)
-
-End Function
-
-Public Function PubFuncOverWriteZ() As Boolean
-Dim Msg, Style, Title, Help, Ctxt, Response, MyString
-If GlobalZmapAquired = True Then
-    Msg = "Do You Want to overwrite Z-Values?"
-    Style = VbYesNo + VbQuestion + VbDefaultButton2   ' Define buttons.
-    Title = "ZValues"  ' Define title.
-    Response = MsgBox(Msg, Style, Title)
-    If Response = vbYes Then ' User chose Yes.
-        PubFuncOverWriteZ = True
-    Else
-        PubFuncOverWriteZ = False
-        GlobalZposOld() = GlobalZpos()
-       GlobalLocationsOrderOld() = GlobalLocationsOrder()
-    End If
- Else
-    PubFuncOverWriteZ = True
-End If
-
-End Function
diff --git a/AutofocusScreen_LSM5_v1.7/src/MCUCommands.bas b/AutofocusScreen_LSM5_v1.7/src/MCUCommands.bas
deleted file mode 100644
index 1330db0..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/MCUCommands.bas
+++ /dev/null
@@ -1,309 +0,0 @@
-Attribute VB_Name = "MCUCommands"
-Option Explicit
-Public Abort As Boolean
-Private Interface As Object
-Private Frequency As Double
-Private Resolution As Double
-
-Public ExchangeXY As Boolean
-Public MirrorX As Boolean
-Public MirrorY As Boolean
-  
-
-Public Sub InitializeStageProperties()
-    Set Interface = Lsm5.ExternalCpObject.pHardwareObjects.pInterfaces
-    Set Interface = Interface.pItem("CANN")
-    
-    Resolution = 0.00000025
-    Frequency = 2000000
-  
-End Sub
-
-Public Function GetStagePositionX(CANN As Boolean) As Double
-  
-   
-  
-    On Error GoTo nostage
-   
-    
-    If ExchangeXY Then
-        GetStagePositionX = StageGetPositionY(CANN) * 1000000#
-    Else
-        GetStagePositionX = StageGetPositionX(CANN) * 1000000#
-    End If
-    If MirrorX Then
-        GetStagePositionX = -GetStagePositionX
-    End If
-nostage:
-End Function
-
-Public Function GetStagePositionY(CANN As Boolean) As Double
-    
-
-    On Error GoTo nostage
-    
-    If ExchangeXY Then
-        GetStagePositionY = StageGetPositionX(CANN) * 1000000#
-    Else
-        GetStagePositionY = StageGetPositionY(CANN) * 1000000#
-    End If
-    If MirrorY Then
-    Else
-        GetStagePositionY = -GetStagePositionY
-    End If
-nostage:
-End Function
-
-Public Function SetStagePositionX(PositionMicrons As Double, CANN As Boolean)
-
-    Dim PositionMetre As Double
-    
-    PositionMetre = PositionMicrons * 0.000001
-    
-  
-    If MirrorX Then
-        PositionMetre = -PositionMetre
-    Else
-    End If
-    If ExchangeXY Then
-        StageMoveToPositionY PositionMetre, CANN
-        Exit Function
-    End If
-    On Error GoTo nostage
-    StageMoveToPositionX PositionMetre, CANN
-nostage:
-End Function
-
-Public Function SetStagePositionY(PositionMicrons As Double, CANN As Boolean)
-   
-    Dim PositionMetre As Double
-    
-    PositionMetre = PositionMicrons * 0.000001
-
-    If MirrorY Then
-    Else
-        PositionMetre = -PositionMetre
-    End If
-    If ExchangeXY Then
-        StageMoveToPositionX PositionMetre, CANN
-        Exit Function
-    End If
-    On Error GoTo nostage
-    StageMoveToPositionY PositionMetre, CANN
-nostage:
-End Function
-
-Public Function SetStageSpeed(StageSpeed As Double, CANN As Boolean) As Boolean
-
-    Dim SampleTimer As Double
-    Dim SamplingTime As Double
-    Dim v As Long
-    
-    SampleTimer = SendStageCommandWaitForAnswer("Xn" + Chr(13))
-    SamplingTime = 16 * (SampleTimer + 1) * (1 / Frequency)
-
-    v = CLng(StageSpeed * SamplingTime / Resolution)
-    If v = 0 Then
-        SetStageSpeed = False
-        Exit Function
-    End If
-    
-    If CANN Then
-        SendStageCommand "XV" + CStr(v) + Chr(13)
-        SendStageCommand "YV" + CStr(v) + Chr(13)
-        SetStageSpeed = True
-    Else
-        SendCommand "NPXV" + CStr(v) + Chr(13)
-        SendCommand "NPYV" + CStr(v) + Chr(13)
-    End If
-End Function
-    
-'-----------------------------------------------------------------------------
-'-----------------------------------------------------------------------------
-    
-Public Sub SetStageAcceleration(Accelearation As Double, CANN As Boolean)
-    If CANN Then
-        SendStageCommand "XA" + CStr(CLng(Accelearation)) + Chr(13)
-        SendStageCommand "YA" + CStr(CLng(Accelearation)) + Chr(13)
-    Else
-        SendCommand "NPXA" + CStr(CLng(Accelearation)) + Chr(13)
-        SendCommand "NPYA" + CStr(CLng(Accelearation)) + Chr(13)
-    End If
-End Sub
-
-Public Function GetStageAcceleration(CANN As Boolean) As Long
-    If CANN Then
-        GetStageAcceleration = SendStageCommandWaitForAnswer("Xa" + Chr(13))
-    Else
-        GetStageAcceleration = SendCommandWaitForAnswer("NPXa" + Chr(13))
-    End If
-End Function
-
-Public Function GetStageSpeed(CANN As Boolean) As Double
-    Dim SampleTimer As Double
-    Dim SamplingTime As Double
-
-    SampleTimer = SendStageCommandWaitForAnswer("Xn" + Chr(13))
-    SamplingTime = 16 * (SampleTimer + 1) * (1 / Frequency)
-    
-    If CANN Then
-        GetStageSpeed = SendStageCommandWaitForAnswer("Xv" + Chr(13)) * Resolution / SamplingTime
-    Else
-        GetStageSpeed = SendCommandWaitForAnswer("NPXv" + Chr(13)) * Resolution / SamplingTime
-    End If
-End Function
-
-Public Function IsStageBusy(CANN As Boolean) As Boolean
-    If CANN Then
-        IsStageBusy = (SendStageCommandWaitForAnswer("Xt" + Chr(13)) <> 0) _
-                   Or (SendStageCommandWaitForAnswer("Yt" + Chr(13)) <> 0)
-    Else
-        IsStageBusy = (SendCommandWaitForAnswer("NPXt" + Chr(13)) <> 0) _
-                   Or (SendCommandWaitForAnswer("NPYt" + Chr(13)) <> 0)
-    End If
-End Function
-
-Public Function GetMaximumStageSpeed() As Double
-    GetMaximumStageSpeed = 0.02703786166
-End Function
-
-Public Function GetMinimumStageSpeed() As Double
-    GetMinimumStageSpeed = 0.0003004206851
-End Function
-
-Private Function StageMoveToPositionX(PositionMetre As Double, CANN As Boolean)
-    Dim Position As String
-    
-    Position = Hex(CLng(-PositionMetre / Resolution))
-    While Len(Position) < 6
-        Position = "0" + Position
-    Wend
-    If Len(Position) > 6 Then
-        Position = Strings.Right(Position, 6)
-    End If
-    If CANN Then
-        SendStageCommand ("XT" + Position + Chr(13))
-    Else
-         SendCommand ("NPXT" + Position + Chr(13))
-    End If
-End Function
-
-Private Function StageMoveToPositionY(PositionMetre As Double, CANN As Boolean)
-    Dim Position As String
-        Position = Hex(CLng(PositionMetre / Resolution))
-    While Len(Position) < 6
-        Position = "0" + Position
-    Wend
-    If Len(Position) > 6 Then
-        Position = Strings.Right(Position, 6)
-    End If
-    If CANN Then
-        SendStageCommand ("YT" + Position + Chr(13))
-    Else
-        SendCommand ("NPYT" + Position + Chr(13))
-    End If
-    
-End Function
-
-Private Function StageGetPositionX(CANN As Boolean) As Double
-    If CANN Then
-        StageGetPositionX = -SendStageCommandWaitForHexAnswer("Xp" + Chr(13)) * Resolution
-    Else
-        StageGetPositionX = -SendCommandWaitForHexAnswer("NPXp" + Chr(13)) * Resolution
-    End If
-End Function
-
-Private Function StageGetPositionY(CANN As Boolean) As Double
-    If CANN Then
-        StageGetPositionY = SendStageCommandWaitForHexAnswer("Yp" + Chr(13)) * Resolution
-    Else
-        StageGetPositionY = SendCommandWaitForHexAnswer("NPYp" + Chr(13)) * Resolution
-    End If
-End Function
-
-Private Sub SendStageCommand(command As String)
-    If Not Interface Is Nothing Then
-        Interface.bSendCmd (command)
-    End If
-End Sub
-            
-Private Function SendStageCommandWaitForAnswer(command As String) As Long
-    Dim Answer As String
-    
-    SendStageCommandWaitForAnswer = 0
-On Error GoTo ErrorExit
-    If Not Interface Is Nothing Then
-        Interface.bSendCmdWait4Answer command, Answer
-        If Answer <> "" Then
-            SendStageCommandWaitForAnswer = CLng(Strings.Right(Answer, Len(Answer) - 2))
-        End If
-    End If
-ErrorExit:
-End Function
-
-Private Function SendStageCommandWaitForHexAnswer(command As String) As Long
-    Dim Answer As String
-    
-    SendStageCommandWaitForHexAnswer = 0
-On Error GoTo ErrorExit
-    If Not Interface Is Nothing Then
-        Interface.bSendCmdWait4Answer command, Answer
-        If Answer <> "" Then
-            SendStageCommandWaitForHexAnswer = Val("&H" + Strings.Right(Answer, Len(Answer) - 2))
-            If SendStageCommandWaitForHexAnswer < 0 Then
-            SendStageCommandWaitForHexAnswer = SendStageCommandWaitForHexAnswer + &H10000
-            End If
-            If SendStageCommandWaitForHexAnswer > &H7FFFFF Then
-                SendStageCommandWaitForHexAnswer = SendStageCommandWaitForHexAnswer - &H1000000
-            End If
-        End If
-    End If
-ErrorExit:
-End Function
-
-Private Function SendCommand(command As String) As Long
-    Lsm5.DsRecording.StartScanTriggerOut = Lsm5.DsRecording.StartScanTriggerOut + command
-End Function
-
-Private Function SendCommandWaitForAnswer(command As String) As Long
-
-End Function
-
-Private Function SendCommandWaitForHexAnswer(command As String) As Long
-
-End Function
-
-Public Sub NoImageAxisChange()
- ExchangeXY = False
- MirrorX = False
- MirrorY = False
-End Sub
-
-Public Sub ImageAxisChange()
-Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS 1, ExchangeXY, MirrorX, MirrorY
-End Sub
-
-
-
-Public Function AreStageCoordinateExchanged() As Boolean
-    Dim ExchangeXY As Boolean
-    Dim MirrorX As Boolean
-    Dim MirrorY As Boolean
-    Dim bLSM As Boolean
-    Dim bLIVE As Boolean
-    Dim bCamera As Boolean
-    Dim lsystem As Integer
-    
-     UsedDevices40 bLSM, bLIVE, bCamera
-        If bLSM Then
-            lsystem = 0
-        ElseIf bLIVE Then
-            lsystem = 1
-        ElseIf bCamera Then
-            lsystem = 3
-        End If
-
-    Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS lsystem, ExchangeXY, MirrorX, MirrorY
-    AreStageCoordinateExchanged = ExchangeXY
-End Function
-
diff --git a/AutofocusScreen_LSM5_v1.7/src/SelectLocs.frm b/AutofocusScreen_LSM5_v1.7/src/SelectLocs.frm
deleted file mode 100644
index ee313bd..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/SelectLocs.frm
+++ /dev/null
@@ -1,26 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} SelectLocs 
-   Caption         =   "Select/Deselct Locations"
-   ClientHeight    =   1950
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   2910
-   OleObjectBlob   =   "SelectLocs.frx":0000
-   StartUpPosition =   2  'CenterScreen
-End
-Attribute VB_Name = "SelectLocs"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-
-Private Sub DeselctButton_Click()
-GridSelection x, y, XR, YR, False
-SelectLocs.Hide
-End Sub
-
-Private Sub SelectButton_Click()
-GridSelection x, y, XR, YR, True
-SelectLocs.Hide
-End Sub
diff --git a/AutofocusScreen_LSM5_v1.7/src/SelectLocs.frx b/AutofocusScreen_LSM5_v1.7/src/SelectLocs.frx
deleted file mode 100644
index a999387..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/src/SelectLocs.frx and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/src/Stage_Grid.bas b/AutofocusScreen_LSM5_v1.7/src/Stage_Grid.bas
deleted file mode 100644
index 1591642..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/Stage_Grid.bas
+++ /dev/null
@@ -1,812 +0,0 @@
-Attribute VB_Name = "Stage_Grid"
-Option Explicit
-Public Const PubGridPathData = "c:\AIM\macros\datafiles\"
-Public Const PubGridPath = "c:\AIM\macros\"
-Public Const GlobalMaximumPositions = 800
-Public GlobalXStep As Double
-Public GlobalYStep As Double
-Public GlobalXGrid As Long
-Public GlobalYGrid As Long
-Public GlobalOrderChanged As Boolean        'checks if values are changed without creating new locations_
-                                            '    then  the lost order is not showed, because it not actualized
-Public GlobalGridImage As DsRecordingDoc
-Public GlobalZGridImage As DsRecordingDoc
-Public GlobalGridX1 As Long
-Public GlobalGridY1 As Long
-Public GlobalGridStageX1 As Double
-Public GlobalGridStageY1 As Double
-Public GlobalGridStageZ1 As Double
-Public GlobalGridX2 As Long
-Public GlobalGridY2 As Long
-Public GlobalGridStageX2 As Double
-Public GlobalGridStageY2 As Double
-Public GlobalGridStageZ2 As Double
-Public GlobalReferencePoints As Long
-'Public GlobalKeepSteps As Boolean
-Public GlobalMeander As Boolean
-Public GlobalPositionsRecalled As Long
-Public GlobalPositionsStage As Long
-Public GlobalCurrentPosition As Long
-Public GlobalXpos() As Double
-Public GlobalYpos() As Double
-Public GlobalZpos() As Double
-Public GlobalLocationsName() As String
-Public GlobalLocationsNameOld() As String
-Public GlobalZposOld() As Double
-Public GlobalXposOld() As Double
-Public GlobalYposOld() As Double
-Public GlobalRelativeZ() As Double
-Public dsDoc As DsRecordingDoc
-Public Stage As CpStages
-Public GlobalProgressString As String
-Public GlobalColor As Long
-Public GettingZmap As Boolean
-Public GlobalZmapAquired As Boolean
-Public idpos As Long
-Public PubAbort As Boolean
-Public Grid As Boolean
-
-Public XR As Long
-Public YR As Long
-Public x As Long
-Public y As Long
-    
-
-
-
-Public GlobalDeActivatedLocations() As Boolean
-Public GlobalLocationsOrder() As Long
-Public GlobalLocationsOrderOld() As Long
-
-
-
-Public Const ZBacklash = -50
-
-
-Public Sub MakeBlankImage(DestImage As DsRecordingDoc, _
-BitsPerSample As Long, bpp As Long, Visible As Boolean, _
-ImgName As String, TimeSeries As Boolean, NumberScans As Long, XPixels As Long, YPixels As Long, Channels As Long)
-Dim i As Long
-
-Dim success As Integer
-Dim DataChannel As DsDataChannel
-Dim DataChannelIndex As Long
-Dim Track As DsTrack
-Dim TrackIndex As Long
-Dim lpReOpenBuff As OFSTRUCT
-Dim lpRootPathName As String
-Dim lpSectorsPerCluster As Long
-Dim lpBytesPerSector As Long
-Dim lpNumberOfFreeClusters As Long
-Dim lpTotalNumberOfClusters As Long
-Dim lSpace As Long
-Dim lFreeSpace As Double
-Dim fSize As Double
-Dim hFile As Long
-Dim zIndex As Long
-Dim TimeIndex As Long
-Dim Channel As Long
-Dim SourceChannel As Long
-Dim NumberChannels As Long
-Dim DestStackNumber As Long
-Dim TimeStampIndex As Long
-Dim indxArr() As Long
-Dim NumberOfSelected As Long
-Dim NumberOfStacks As Long
-
-'Dim Channels() As String
-Dim ReturnValue As Boolean
-Dim OK As Boolean
-Dim scnline As Variant
-Dim spl As Long
-Dim Tnum As Long
-Dim newTime As Double
-Dim myDate As Date
-Dim myDate1 As Date
-Dim newTime1 As Double
-Dim myTime As Date
-Dim OldImage As Object
-Dim ImageType As Long   'ImageType=1 Non Lambda Stack, ImageType=2 Lambda Stack
-                
-    If TimeSeries Then
-        Set DestImage = Lsm5.MakeNewImageDocument(XPixels, _
-        YPixels, 1, NumberScans, _
-        Channels, bpp, Visible)
-    Else
-        Set DestImage = Lsm5.MakeNewImageDocument(XPixels, _
-        YPixels, 1, 1, _
-        Channels, bpp, Visible)
-    End If
-    If (DestImage Is Nothing) Then
-        MsgBox "Cannot Create New Window!", VbExclamation
-        Exit Sub
-    End If
-    If TimeSeries Then
-        DestImage.Recording.TimeSeries = True
-    Else
-        DestImage.Recording.TimeSeries = False
-    End If
-
-    DestImage.SetTitle ImgName
-            
-    
-Finish:
-
-End Sub
-
-
-Public Sub RedrawGrid(GridImage As DsRecordingDoc)
-Dim BitsPerSample As Long
-Dim bpp As Long
-Dim ImgName As String
-Dim LsmMath As New LsmVectorMath
-Dim SpareArrayRed() As Single
-Dim SpareArrayBlue() As Single
-Dim SpareArrayGreen() As Single
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim iX As Long
-Dim iY As Long
-Dim PlaneSize As Long
-
-    If GridImage Is Nothing Then Exit Sub
-    XPixels = GridImage.GetDimensionX
-    YPixels = GridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    
-    PlaneSize = LsmMath.ImagePlaneSizeXY(GridImage)
-    ReDim SpareArrayRed(PlaneSize)
-    ReDim SpareArrayBlue(PlaneSize)
-    ReDim SpareArrayGreen(PlaneSize)
-    For yIndx = 1 To GlobalYGrid
-        For xIndx = 1 To GlobalXGrid
-            Start = YGroup * XPixels + (3 * YGroup * XPixels) * (yIndx - 1) + XGroup + _
-            3 * XGroup * (xIndx - 1) - 1
-            For iY = 1 To 2 * YGroup
-                For iX = 1 To 2 * XGroup
-                    If Not GlobalDeActivatedLocations(xIndx, yIndx) Then
-                        SpareArrayGreen(Start + iX + (iY - 1) * XPixels) = 0
-                        SpareArrayBlue(Start + iX + (iY - 1) * XPixels) = 4000
-                        SpareArrayRed(Start + iX + (iY - 1) * XPixels) = 0
-                    Else
-                        SpareArrayRed(Start + iX + (iY - 1) * XPixels) = 1000
-                        SpareArrayGreen(Start + iX + (iY - 1) * XPixels) = 0
-                        SpareArrayBlue(Start + iX + (iY - 1) * XPixels) = 0
-                    End If
-                Next iX
-            Next iY
-        Next xIndx
-    Next yIndx
-    LsmMath.WriteImagePlaneXY GridImage, 0, 0, 0, PlaneSize, SpareArrayRed(0)
-    LsmMath.WriteImagePlaneXY GridImage, 1, 0, 0, PlaneSize, SpareArrayGreen(0)
-    LsmMath.WriteImagePlaneXY GridImage, 2, 0, 0, PlaneSize, SpareArrayBlue(0)
-    DoEvents
-
-End Sub
-Public Sub RedrawZGrid(GridImage As DsRecordingDoc)
-Dim BitsPerSample As Long
-Dim bpp As Long
-Dim ImgName As String
-Dim LsmMath As New LsmVectorMath
-Dim SpareArrayBlue() As Single
-Dim SpareArrayRed() As Single
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim iX As Long
-Dim iY As Long
-Dim PlaneSize As Long
-Dim MinZValue As Double
-Dim MaxZValue As Double
-Dim ColorStep As Double
-Dim ZGridRange As Double
-Dim ZGridImage As DsRecording
-
-    MinZValue = 10000           'I choose any high number that canot be reached
-    
-    MaxZValue = -10000
-    For idpos = 1 To GlobalPositionsStage
-        If GlobalZpos(idpos) < MinZValue Then
-            MinZValue = GlobalZpos(idpos)
-        End If
-        If GlobalZpos(idpos) > MaxZValue Then
-            MaxZValue = GlobalZpos(idpos)
-        End If
-    Next idpos
-ZGridRange = MaxZValue - MinZValue
-
-If ZGridRange <= 0 Then
-MsgBox "ZGridRange <= 0!" + vbCrLf + "MaxValue =" + CStr(MaxZValue) + vbCrLf + ";MinValue = " + CStr(MinZValue)
-Exit Sub
-End If
-
-ColorStep = 4000 / ZGridRange
-
-
-
- '   If ZGridImage Is Nothing Then Exit Sub
-    XPixels = GridImage.GetDimensionX
-    YPixels = GridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    
-    PlaneSize = LsmMath.ImagePlaneSizeXY(GridImage)
-    ReDim SpareArrayBlue(PlaneSize)
-    ReDim SpareArrayRed(PlaneSize)
-    For yIndx = 1 To GlobalYGrid
-        For xIndx = 1 To GlobalXGrid
-         idpos = GlobalLocationsOrder(xIndx, yIndx)
-            Start = YGroup * XPixels + (3 * YGroup * XPixels) * (yIndx - 1) + XGroup + _
-            3 * XGroup * (xIndx - 1) - 1
-            
-                For iY = 1 To 2 * YGroup
-                    For iX = 1 To 2 * XGroup
-                        If Not GlobalDeActivatedLocations(xIndx, yIndx) Then
-                          SpareArrayBlue(Start + iX + (iY - 1) * XPixels) = (GlobalZpos(idpos) - MinZValue) * ColorStep + 96
-                          SpareArrayRed(Start + iX + (iY - 1) * XPixels) = 0
-                        Else
-                            SpareArrayRed(Start + iX + (iY - 1) * XPixels) = 500
-                            SpareArrayBlue(Start + iX + (iY - 1) * XPixels) = 0
-                        End If
-                    Next iX
-                Next iY
-            
-         Next xIndx
-    Next yIndx
-    LsmMath.WriteImagePlaneXY GridImage, 2, 0, 0, PlaneSize, SpareArrayBlue(0)
-    LsmMath.WriteImagePlaneXY GridImage, 0, 0, 0, PlaneSize, SpareArrayRed(0)
-    DoEvents
-    DisplayProgress "highest Z: " + CStr(MaxZValue) + vbCrLf + "lowest Z: " + CStr(MinZValue), RGB(0, &HC0, 0)
-End Sub
-Public Sub DrawCrossGrid(xIndx As Long, yIndx As Long)
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim iX As Long
-Dim iY As Long
-Dim x1 As Long
-Dim Y1 As Long
-Dim X2 As Long
-Dim Y2 As Long
-
-    If (GlobalGridImage Is Nothing) Then Exit Sub
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    x1 = XGroup + 3 * XGroup * (xIndx - 1)
-    Y1 = YGroup + 3 * YGroup * (yIndx - 1)
-    X2 = 3 * XGroup + 3 * XGroup * (xIndx - 1)
-    Y2 = 3 * YGroup + 3 * YGroup * (yIndx - 1)
-      
-    GlobalGridImage.VectorOverlay.Color = RGB(255, 255, 0)
-    GlobalGridImage.VectorOverlay.LineWidth = 1
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeLine, x1, Y1, X2, Y2
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeLine, x1, Y2, X2, Y1
-'    dsDoc.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeCircle, xCross, yCross, xCross, yCross + 30
-    GlobalGridImage.RedrawImage
-    
-End Sub
-
-Public Sub ConvertToStagePositionXY(XP As Double, YP As Double, Xnew As Double, Ynew As Double)
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim dExchange As Double
-    Dim x As Double
-    Dim y As Double
-    
-    x = XP
-    y = YP
-    On Error GoTo oldversion
-    
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    
-    If bMirrorX Then
-        x = -x
-    End If
-'    If Not bMirrorY Then
-    If bMirrorY Then
-        y = -y
-    End If
-        
-    If bExchangeXY Then
-        Ynew = x
-        Xnew = y
-    Else
-        Xnew = x
-        Ynew = y
-    End If
-            
-    Exit Sub
-oldversion:
-
-    Xnew = X11 * x + X21 * y
-    Ynew = X12 * x + X22 * y
-    
-nostage:
-
-End Sub
-
-Public Sub DoMouseEventsMulti(ByVal EventNr As Long, ByVal Param As Variant)
-    Dim x1 As Double
-    Dim Y1 As Double
-    Dim X2 As Double
-    Dim Y2 As Double
-    Dim X3 As Double
-    Dim Y3 As Double
-    
-    Dim Xtemp As Double
-    Dim Ytemp As Double
-    Dim xtemp1 As Double
-    Dim ytemp1 As Double
-'
-'    Dim x As Long
-'    Dim y As Long
-    Dim z As Long
-    Dim t As Long
-    Dim c As Long
-    
-'    Dim XR As Long
-'    Dim YR As Long
-
-    Dim eps As Long
-    eps = 5
-    Dim cond1 As Boolean
-    Dim cond2 As Boolean
-    Dim cond3 As Boolean
-    Dim Angle As Double
-    
-    Dim Positions As Long
-    Dim XPos() As Double
-    Dim YPos() As Double
-    Dim ZPos() As Double
-    Dim ZeroChanged As Boolean
-    Dim SetZeroMarked As Boolean
-    Dim Row As Long
-    Dim XPixel As Long
-    Dim YPixel As Long
-    Dim MyString As String
-    Dim Count As Long
-    Dim Style, Title, Response
-    Dim xIndx As Long
-    Dim yIndx As Long
-    Dim DiffX As Double
-    Dim DiffY As Double
-    Dim DiffXcorr As Double
-    Dim DiffYcorr As Double
-    Dim Xcorr As Double
-    Dim Ycorr As Double
-    
-    Dim DiffXGrid As Long
-    Dim DiffYGrid As Long
-  
-'    Set Stage = Lsm5.Hardware.CpStages
-On Error GoTo marke1
-
-Select Case EventNr
-    Case eEventDsScanStopping
-        DisplayProgress "Stopping", RGB(&HC0, &HC0, 0)
-        flgEvent = 8
-    Case eEventDsScanStopped
-        flgEvent = 7
-    Case Else
-        If (EventNr = Lsm5Vba.eImageWindowNoButtonMouseMoveEvent) Then
-            If (dsDoc Is Nothing) Then
-                
-                    If Not GlobalGridImage Is Nothing Then
-                     
-                    
-                        If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                        AutofocusForm.DisplayGridSelection x, y, xIndx, yIndx
-                        End If
-                    End If
-              
-                If Not GlobalZGridImage Is Nothing Then
-                    
-                        If GlobalZGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                        AutofocusForm.DisplayGridSelection x, y, xIndx, yIndx
-                        End If
-                    End If
-            Else
-'                If dsDoc.GetCurrentMousePosition(C, T, Z, Y, X) <> 0 Then
-'                    CenterForm.Label2 = "dx=" + _
-'                    Strings.Format(CDbl(X - xCross) * dsDoc.VoxelSizeX * 10 ^ 6, "0.00") + _
-'                    " " + Strings.Chr(181) + "m" + Strings.Chr(10) + _
-'                    "dy=" + Strings.Format(CDbl(Y - yCross) * dsDoc.VoxelSizeY * 10 ^ 6, "0.00") + _
-'                    " " + Strings.Chr(181) + "m"
-'                End If
-            End If
-        ElseIf (EventNr = ds.eImageWindowRightButtonUpEvent) Then
-            If Not GlobalGridImage Is Nothing Then
-                If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                    AutofocusForm.DisplayGridSelection x, y, xIndx, yIndx
-                  
-                
-                    Style = vbOKOnly + VbQuestion + VbDefaultButton2 ' Define buttons.
-                    Title = "Selecting Reference Locations"  ' Define title.
-
-                    Style = VbYesNo + VbQuestion + VbDefaultButton2 ' Define buttons.
-
-                    If GlobalReferencePoints = 2 Then
-                        MyString = "Is Stage Positioned at the Grid Location:" + vbCrLf + "Column=" + CStr(xIndx) + _
-                        vbCrLf + "Row=" + CStr(yIndx) + "?" + vbCrLf + "Do You Want to Use it as a Reference?" + vbCrLf + _
-                        "Previous Reference Points will be Deleted!"
-                    ElseIf GlobalReferencePoints = 1 Then
-                        MyString = "Is Stage Positioned at the Grid Location:" + vbCrLf + "Column=" + CStr(xIndx) + _
-                        vbCrLf + "Row=" + CStr(yIndx) + "?" + vbCrLf + "Do You Want to Use it as a Second Reference?"
-                    ElseIf GlobalReferencePoints = 0 Then
-                        MyString = "Is Stage Positioned at the Grid Location:" + vbCrLf + "Column=" + CStr(xIndx) + _
-                        vbCrLf + "Row=" + CStr(yIndx) + "?" + vbCrLf + "Do You Want to Use it as a First Reference?"
-                    End If
-                    Response = MsgBox(MyString, Style, Title)
-                    If Response = vbYes Then    ' User chose Yes.
-                        If GlobalReferencePoints = 2 Then
-                            GlobalReferencePoints = 1
-                            GlobalGridX1 = xIndx
-                            GlobalGridY1 = yIndx
-                            ReadLoc GlobalGridStageX1, GlobalGridStageY1
-                            GlobalGridStageZ1 = Lsm5.Hardware.CpFocus.Position
-                            GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-                            AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-                        ElseIf GlobalReferencePoints = 1 Then
-                            GlobalGridX2 = xIndx
-                            GlobalGridY2 = yIndx
-                            ReadLoc GlobalGridStageX2, GlobalGridStageY2
-                            GlobalGridStageZ2 = Lsm5.Hardware.CpFocus.Position
-                            DiffX = GlobalGridStageX2 - GlobalGridStageX1
-                            DiffY = GlobalGridStageY2 - GlobalGridStageY1
-'                            If Abs(DiffX) < 50 Or Abs(DiffY) < 50 Then
-'                                MsgBox "Selected Reference Locations are too Close!" + vbCrLf + _
-'                                "Please Select New Reference Point!"
-'                            Else
-                                DiffXGrid = GlobalGridX2 - GlobalGridX1
-                                DiffYGrid = GlobalGridY2 - GlobalGridY1
-                                If Abs(DiffXGrid) > 0 And Abs(DiffYGrid) > 0 Then
-'                                    If GlobalKeepSteps Then
-'                                        DiffXcorr = GlobalXStep * DiffXGrid
-'                                        DiffYcorr = GlobalYStep * DiffYGrid
-'                                        If (Abs(DiffXcorr - DiffX) >= Abs(GlobalXStep)) Or (Abs(DiffYcorr - DiffY) >= Abs(GlobalYStep)) Then
-'                                            MsgBox "The Difference Between Marked and Corrected Reference Points is Greater then the Grid Step!" + vbCrLf + _
-'                                            "Please Check if the Grid Steps are Correct!"
-'                                        Else
-'                                            Xcorr = (DiffXcorr - DiffX) / 2
-'                                            Ycorr = (DiffYcorr - DiffY) / 2
-'                                            GlobalGridStageX1 = GlobalGridStageX1 - Xcorr
-'                                            GlobalGridStageX2 = GlobalGridStageX2 + Xcorr
-'                                            GlobalGridStageY1 = GlobalGridStageY1 - Ycorr
-'                                            GlobalGridStageY2 = GlobalGridStageY2 + Ycorr
-'                                            GlobalReferencePoints = 2
-'                                            GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-'                                            AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-'                                            AutofocusForm.DrawCrossGrid GlobalGridX2, GlobalGridY2
-'
-'                                        End If
-'                                    Else
-                                        GlobalXStep = DiffX / DiffXGrid
-                                        GlobalYStep = DiffY / DiffYGrid
-                                        AutofocusForm.TextBoxXStep.Value = GlobalXStep
-                                        AutofocusForm.TextBoxYStep.Value = GlobalYStep
-                                        GlobalReferencePoints = 2
-                                        GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-                                        AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-                                        AutofocusForm.DrawCrossGrid GlobalGridX2, GlobalGridY2
-
-'                                    End If
-'                                End If
-                            End If
-
-                        ElseIf GlobalReferencePoints = 0 Then
-                            GlobalReferencePoints = 1
-                            GlobalGridX1 = xIndx
-                            GlobalGridY1 = yIndx
-                            ReadLoc GlobalGridStageX1, GlobalGridStageY1
-                            GlobalGridStageZ1 = Lsm5.Hardware.CpFocus.Position
-                            GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-                            AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-
-                        End If
-                    End If
-                
-                End If
-            End If
-        ElseIf (EventNr = Lsm5Vba.eImageWindowLeftButtonDownEvent) Then
-            If Not GlobalGridImage Is Nothing Then
-                If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
- '                   GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-'                    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeRectangle, X, Y, X, Y
-'                    GlobalGridImage.RedrawImage
-                    AutofocusForm.DrawRectangleGrid x, y, x, y
-                End If
-            End If
-       
-        ElseIf (EventNr = Lsm5Vba.eImageWindowLButtonMouseMoveEvent) Then
-               If Not GlobalGridImage Is Nothing Then
-                If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                    Count = GlobalGridImage.VectorOverlay.GetNumberDrawingElements
-                    If GlobalGridImage.VectorOverlay.GetKnot(Count - 1, 0, XR, YR) Then
-                        GlobalGridImage.VectorOverlay.RemoveDrawingElement Count - 1
-                        AutofocusForm.DrawRectangleGrid XR, YR, x, y
-                        AutofocusForm.DisplayGridSelection x, y, xIndx, yIndx
-                    End If
-                End If
-            End If
-       
-        ElseIf (EventNr = Lsm5Vba.eImageWindowLeftButtonUpEvent) Then
-        If (XR = x And YR = y) Then
-        GridOnOff x, y, XR, YR
-        GoTo Continue3
-        Else
-        GoTo Continue1
-        End If
- 
-Continue1:
-            If Not GlobalGridImage Is Nothing Then
-                If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                    Count = GlobalGridImage.VectorOverlay.GetNumberDrawingElements
-                    If GlobalGridImage.VectorOverlay.GetKnot(Count - 1, 0, x, y) Then
-                        If GlobalGridImage.VectorOverlay.GetKnot(Count - 1, 1, XR, YR) Then
-                            If (XR <> x) Or (YR <> y) Then
-                            SelectLocs.Show
-'                                Style = vbOKOnly + VbQuestion + VbDefaultButton2 ' Define buttons.
-'                                Title = "Select/Deselect Locations"  ' Define title.
-'
-'                '                GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLButtonMouseMoveEvent, 0
-'                '                GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonDownEvent, 0
-'                '                GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonUpEvent, 0
-'
-'                                Style = VbYesNo + VbQuestion + VbDefaultButton2 ' Define buttons.
-'                                MyString = "Select Locations - Click YES;" + vbCrLf + "Deselect Locations - Click NO"
-'                                Response = MsgBox(MyString, Style, Title)
-'                                If Response = vbYes Then    ' User chose Yes.
-'                                    GridSelection x, y, XR, YR, True
-'                                Else
-'                                    GridSelection x, y, XR, YR, False
-'                                End If
-Continue3:
-                     If Not GlobalGridImage Is Nothing Then
-                                GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-                                If GlobalReferencePoints = 2 Then
-                                    AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-                                    AutofocusForm.DrawCrossGrid GlobalGridX2, GlobalGridY2
-                                ElseIf GlobalReferencePoints = 1 Then
-                                    AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-                                End If
-                                RedrawGrid GlobalGridImage
-                               
-                            End If
-                           End If
-                        End If
-                    End If
-                End If
-            End If
-        End If
-    End Select
-'Set Stage = Nothing
-marke1:
-End Sub
-
-Public Sub GridSelection(x As Long, y As Long, XR As Long, YR As Long, Activate As Boolean)
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim iX As Long
-Dim iY As Long
-Dim Xmin As Long
-Dim Xmax As Long
-Dim Ymin As Long
-Dim Ymax As Long
-Dim xImage As Long
-Dim StartX As Long
-Dim yImage As Long
-Dim StartY As Long
-Dim Found As Boolean
-
-    If GlobalGridImage Is Nothing Then Exit Sub
-    If x >= XR Then
-        Xmin = XR
-        Xmax = x
-    Else
-        Xmin = x
-        Xmax = XR
-    End If
-    If y >= YR Then
-        Ymin = YR
-        Ymax = y
-    Else
-        Ymin = y
-        Ymax = YR
-    End If
-    
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    For yIndx = 1 To GlobalYGrid
-        For xIndx = 1 To GlobalXGrid
-            StartX = XGroup + 3 * XGroup * (xIndx - 1)
-            StartY = YGroup + 3 * YGroup * (yIndx - 1)
-            Found = False
-            For iY = 1 To 2 * YGroup
-                For iX = 1 To 2 * XGroup
-                    xImage = StartX + iX
-                    yImage = StartY + iY
-                    If xImage >= Xmin And xImage <= Xmax And yImage >= Ymin And yImage <= Ymax Then
-                        GlobalDeActivatedLocations(xIndx, yIndx) = Not Activate
-                        Found = True
-                        Exit For
-                    End If
-                    If Found Then Exit For
-                Next iX
-            Next iY
-        Next xIndx
-    Next yIndx
-    GlobalOrderChanged = True
-End Sub
-Public Sub GridOnOff(x As Long, y As Long, XR As Long, YR As Long)
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim iX As Long
-Dim iY As Long
-Dim Xmin As Long
-Dim Xmax As Long
-Dim Ymin As Long
-Dim Ymax As Long
-Dim xImage As Long
-Dim StartX As Long
-Dim yImage As Long
-Dim StartY As Long
-Dim Found As Boolean
-
-    If GlobalGridImage Is Nothing Then Exit Sub
-    If x >= XR Then
-        Xmin = XR
-        Xmax = x
-    Else
-        Xmin = x
-        Xmax = XR
-    End If
-    If y >= YR Then
-        Ymin = YR
-        Ymax = y
-    Else
-        Ymin = y
-        Ymax = YR
-    End If
-    
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    For yIndx = 1 To GlobalYGrid
-        For xIndx = 1 To GlobalXGrid
-            StartX = XGroup + 3 * XGroup * (xIndx - 1)
-            StartY = YGroup + 3 * YGroup * (yIndx - 1)
-            Found = False
-            For iY = 1 To 2 * YGroup
-                For iX = 1 To 2 * XGroup
-                    xImage = StartX + iX
-                    yImage = StartY + iY
-                    If xImage >= Xmin And xImage <= Xmax And yImage >= Ymin And yImage <= Ymax Then
-                        GlobalDeActivatedLocations(xIndx, yIndx) = Not GlobalDeActivatedLocations(xIndx, yIndx)
-                        Found = True
-                        Exit For
-                    End If
-                    If Found Then Exit For
-                Next iX
-            Next iY
-        Next xIndx
-    Next yIndx
-    GlobalOrderChanged = True
-End Sub
-
-
-
-
-
-
-Public Sub ReadLoc(x As Double, y As Double)
-    Dim cnt As Long
-    
-    cnt = 0
-    On Error GoTo retry
-retry:
-    If cnt > 1000 Then GoTo Finish
-    cnt = cnt + 1
-    x = Lsm5.Hardware.CpStages.PositionX
-    y = Lsm5.Hardware.CpStages.PositionY
-Finish:
-End Sub
-
-Public Sub CoordinateConversion(bExchangeXY As Boolean, bMirrorX As Boolean, bMirrorY As Boolean)
-    Dim bLSM As Boolean
-    Dim bLIVE As Boolean
-    Dim bCamera As Boolean
-    Dim lsystem As Long
-'    If GlobalSystemVersion = 32 Then
-'        Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisState bExchangeXY, bMirrorX, bMirrorY
-'    ElseIf GlobalSystemVersion > 32 Then
-        UsedDevices40 bLSM, bLIVE, bCamera
-        If bLSM Then
-            lsystem = 0
-        ElseIf bLIVE Then
-            lsystem = 1
-        ElseIf bCamera Then
-            lsystem = 3
-        End If
-'    End If
-    Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS lsystem, bExchangeXY, bMirrorX, bMirrorY
-
-End Sub
-
-
-
-
-Public Sub UsedDevices40(bLSM As Boolean, bLIVE As Boolean, bCamera As Boolean)
-Dim Scancontroller As AimScanController
-Dim TrackParameters As Object
-Dim Size As Long
-Dim lTrack As Long
-Dim eDeviceMode As Long
-    bLSM = False
-    bLIVE = False
-    bCamera = False
-    Set Scancontroller = Lsm5.ExternalDsObject.Scancontroller
-    Set TrackParameters = Scancontroller.TrackParameters
-    If TrackParameters Is Nothing Then Exit Sub
-    Size = TrackParameters.GetTrackArraySize
-    For lTrack = 0 To Size - 1
-       ' If TrackParameters.IsTrackUsed(lTrack) Then
-            eDeviceMode = TrackParameters.TrackDeviceMode(lTrack)
-            Select Case eDeviceMode
-                Case eAimDeviceModeLSM
-                    bLSM = True
-                   
-                Case eAimDeviceModeLSM_ChannelMode
-                    bLSM = True
-                   
-                Case eAimDeviceModeLSM_NDD
-                    bLSM = True
-                    
-                Case eAimDeviceModeLSM_DD
-                    bLSM = True
-                   
-                Case eAimDeviceModeSpectralImager
-                    bLSM = True
-                    Exit Sub
-                Case eAimDeviceModeRtScanner
-                    bLIVE = True
-                    Exit Sub
-                Case eAimDeviceModeCamera1
-                    bCamera = True
-                    Exit Sub
-                
-            End Select
-       ' End If
-    Next lTrack
-End Sub
diff --git a/AutofocusScreen_LSM5_v1.7/src/StoreApply.frm b/AutofocusScreen_LSM5_v1.7/src/StoreApply.frm
deleted file mode 100644
index b378d79..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/StoreApply.frm
+++ /dev/null
@@ -1,120 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} StoreApply 
-   Caption         =   "Store/Apply Grid"
-   ClientHeight    =   1380
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   5685
-   OleObjectBlob   =   "StoreApply.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "StoreApply"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-'This Form was kept to keep the possibility of saving the macro setting into the registry.
-' It is not used in current state of the macro
-
-
-
-
-
-Private Sub CommandButtonClose_Click()
-    Unload StoreApplyForm
-End Sub
-
-
-Sub FillRecipeList()
-    Dim Count As Long
-    Dim idx As Long
-    Dim MyMacroKey As String
-    Dim path As String
-    Dim success As Boolean
-    Dim result As Long
-    Dim key As String
-    ComboBoxRecipe.Clear
-    key = "UI\" + GlobalMacroKey
-    success = tools.RegExistKey(key)
-    If success Then
-        Count = tools.RegCountSubKeys(key)
-    Else
-        success = tools.RegCreateKey(key)
-    End If
-    If Count > 0 Then
-        For idx = 0 To Count - 1
-            ComboBoxRecipe.AddItem tools.RegSubkeyName(idx, key)
-        Next idx
-        If (Count > 0) Then
-            ComboBoxRecipe.ListIndex = 0
-        End If
-        ComboBoxRecipe.ListIndex = 0
-    End If
-End Sub
-
-
-Private Sub CommandButtonDelete_Click()
-    Dim myKey As String
-    Dim success As Boolean
-    Dim deleteOK As Boolean
-    Dim idx As Long
-    Dim lockNo As Long
-    Dim Msg, Style, Title, Help, Ctxt, Response, MyString
-    AutofocusForm.GetBlockValues
-    deleteOK = True
-    myKey = "UI\" + GlobalMacroKey + "\" + ComboBoxRecipe.Value
-    success = tools.RegExistKey(myKey)
-    If success Then
-        Msg = "Do You want to delete recipe " + ComboBoxRecipe.Value + "?"
-        Style = VbYesNo + VbCritical + VbDefaultButton2 ' Define buttons.
-        Title = "Recipe Delete"  ' Define title.
-        Response = MsgBox(Msg, Style, Title)
-        If Response = vbYes Then    ' User chose Yes.
-        Else    ' User chose No.
-            deleteOK = False
-        End If
-    Else
-    End If
-    If deleteOK Then
-        success = tools.RegDeleteKey(myKey)
-    End If
-    Unload StoreApply
-End Sub
-
-
-Private Sub CommandButtonStore_Click()
-Dim filenam As String
-Dim path As String
-Dim hFile As Long
-Dim fs
-Dim idx As Long
-Dim idy As Long
-
-
-path = "c:\AIM\macros\datafiles\"
-filnam = path + CStr(ComboBoxGrid.Value) + ".txt"
-hFile = FreeFile
-
-Set fs = CreateObject("Scripting.FileSystemObject")
-    fs.CreateTextFile filnam          'Create a file
-Open filnam For Output As hFile         'open file
-Print #hFile, TextBoxXGrid.Value
-Print #hFile, TextBoxYGrid.Value
-Print #hFile, TextBoxXStep.Value
-Print #hFile, TextBoxYGrid.Value
-
-For idy = 1 To GlobalYGrid
-     For idx = 1 To GlobalXGrid
-                       
-        Print #hFile, GlobalDeActivatedLocations(idx, idy)
-                                
-     Next idx
-Next idy
-Print #hFile, AutofocusForm.CheckBoxMeander.Value
-   
-End Sub
-
-
-Private Sub UserForm_Initialize()
-    FillRecipeList
-End Sub
diff --git a/AutofocusScreen_LSM5_v1.7/src/StoreApply.frx b/AutofocusScreen_LSM5_v1.7/src/StoreApply.frx
deleted file mode 100644
index 56997a7..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/src/StoreApply.frx and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/src/StoreApplyForm.frm b/AutofocusScreen_LSM5_v1.7/src/StoreApplyForm.frm
deleted file mode 100644
index f19479a..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/StoreApplyForm.frm
+++ /dev/null
@@ -1,176 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} StoreApplyForm 
-   Caption         =   "Store/Apply Grid"
-   ClientHeight    =   1350
-   ClientLeft      =   645
-   ClientTop       =   930
-   ClientWidth     =   5550
-   OleObjectBlob   =   "StoreApplyForm.frx":0000
-   StartUpPosition =   3  'Windows Default
-End
-Attribute VB_Name = "StoreApplyForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
- 
-Private Sub CommandButtonDelete_Click()
-Dim x As Long
-
-filnam = PubGridPathData + CStr(ComboBoxGrid.Value) + ".txt"
-Msg = "Do You want to delete grid '" + ComboBoxGrid.Value + "' ?"
-        Style = VbYesNo + VbCritical + VbDefaultButton2 ' Define buttons.
-        Title = "Grid Delete"  ' Define title.
-        Response = MsgBox(Msg, Style, Title)
-        If Response = vbYes Then
-            Kill filnam
-            x = ComboBoxGrid.ListIndex
-            ComboBoxGrid.RemoveItem (x)
-            ComboBoxGrid.Cut
-            ComboBoxGrid.Value = ""
-            FillRecipeList
-        End If
-End Sub
-
-Private Sub UserForm_Initialize()
-FilerQuery
-FillRecipeList
-
-End Sub
-
-
-Private Sub CommandButtonApply_Click()
-Dim filenam As String
-Dim hFile As Long
-Dim fs
-Dim idx As Long
-Dim idy As Long
-Dim Value As String
-filnam = PubGridPathData + CStr(ComboBoxGrid.Value) + ".txt"
-hFile = FreeFile
-
-Open filnam For Input As hFile
-Input #hFile, GlobalXGrid
-Input #hFile, GlobalYGrid
-Input #hFile, GlobalXStep
-Input #hFile, GlobalYStep
-
-
-AutofocusForm.TextBoxXGrid.Value = GlobalXGrid
-AutofocusForm.TextBoxYGrid.Value = GlobalYGrid
-AutofocusForm.TextBoxXStep.Value = GlobalXStep
-AutofocusForm.TextBoxYStep.Value = GlobalYStep
-
-ReDim GlobalDeActivatedLocations(GlobalXGrid, GlobalYGrid)
-For idy = 1 To GlobalYGrid
-     For idx = 1 To GlobalXGrid
-        Input #hFile, Value
-         GlobalDeActivatedLocations(idx, idy) = CBool(Value)
-     Next idx
-Next idy
-On Error Resume Next ' in older verios the meander varable wasnot saved to avoid, that you cannot use this files
-Input #hFile, Value
-GlobalMeander = CBool(Value)
-
-AutofocusForm.CheckBoxMeander.Value = GlobalMeander
-Close #hFile
-AutofocusForm.ShowGrid
-End Sub
-
-Private Sub CommandButtonClose_Click()
-   Unload StoreApplyForm
-End Sub
-
-Private Sub CommandButtonStore_Click()
-Dim filenam As String
-Dim filenew As String
-
-Dim fso As New FileSystemObject
-'Dim fold As Folder
-'Set fold = fso.GetFolder(PubGridPath)
-
-
-filenam = PubGridPathData + CStr(ComboBoxGrid.Value) + ".txt"
-filenew = CStr(ComboBoxGrid.Value)
-
-If fso.FileExists(filenam) = False Then
-    CreateNewFolder filenam
-Else
-        Msg = "File '" + ComboBoxGrid.Value + "' already exists." + vbCrLf + "Do You want to overwrite '" + ComboBoxGrid.Value + "' ?"
-        Style = VbYesNo + VbCritical + VbDefaultButton2 ' Define buttons.
-        Title = "Grid Delete"  ' Define title.
-        Response = MsgBox(Msg, Style, Title)
-        If Response = vbYes Then
-            CreateNewFolder filenam
-        Else
-            Exit Sub
-        End If
-End If
-
-
-FillRecipeList
-MsgBox "Grid " + filenew + " is stored successfully!"
-End Sub
-
-Sub FillRecipeList()
-    Dim Count As Long
-    Dim idx As Long
-    Dim filenam As String
-    Dim path As String
-    Dim success As Boolean
-    Dim result As Long
-    Dim key As String
-    ComboBoxGrid.Clear
-    Dim fso As New FileSystemObject
-    Dim fold As Folder
-    Dim f As File
-    Dim name As String
-    
-    
-    Set fold = fso.GetFolder(PubGridPathData)
-     For Each f In fold.Files
-        filenam = fso.GetFileName(f)
-     lenfilnam = Len(filenam)
-     name = Left(filenam, lenfilnam - 4)
-     
-      ComboBoxGrid.AddItem name
-      Next
-     i = ComboBoxGrid.ListCount
-     If i = 0 Then Exit Sub
-      ComboBoxGrid.Value = ComboBoxGrid.List(0)
-
-End Sub
-
-Private Sub FilerQuery()
-Dim fso As New FileSystemObject
-Dim fs
-Dim fold As Folder
-Set fold = fso.GetFolder(PubGridPath)
-If fso.FolderExists(PubGridPathData) = False Then
-    fso.CreateFolder (PubGridPathData)
-End If
-
-End Sub
-
-Private Sub CreateNewFolder(filnam As String)
-Dim hFile As Long
-Dim fs
-Dim idx As Long
-Dim idy As Long
-hFile = FreeFile
-Set fs = CreateObject("Scripting.FileSystemObject")
-        fs.CreateTextFile filnam          'Create a file
-    Open filnam For Output As hFile         'open file
-    Print #hFile, GlobalXGrid
-    Print #hFile, GlobalYGrid
-    Print #hFile, AutofocusForm.TextBoxXStep.Value
-    Print #hFile, AutofocusForm.TextBoxYStep.Value
-    For idy = 1 To GlobalYGrid
-     For idx = 1 To GlobalXGrid
-        Print #hFile, GlobalDeActivatedLocations(idx, idy)
-     Next idx
-Next idy
-    Print #hFile, AutofocusForm.CheckBoxMeander.Value
-Close #hFile
-End Sub
diff --git a/AutofocusScreen_LSM5_v1.7/src/StoreApplyForm.frx b/AutofocusScreen_LSM5_v1.7/src/StoreApplyForm.frx
deleted file mode 100644
index 498c9f0..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/src/StoreApplyForm.frx and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/src/TileScan.bas b/AutofocusScreen_LSM5_v1.7/src/TileScan.bas
deleted file mode 100644
index 093e1fd..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/TileScan.bas
+++ /dev/null
@@ -1,66 +0,0 @@
-Attribute VB_Name = "TileScan"
-Option Explicit
-Dim TileX As Integer
-Dim TileY As Integer
-Dim GlobalPositionsStageOld As Integer
-Dim FrameWidth As Double
-Dim FrameHeight As Double
-Dim RelFrameHeight As Double
-Dim RelFrameWidth As Double
-Dim Overlap As Double
-Dim Xnew As Double
-Dim Ynew As Double
-
-
-Public Sub Tile()
-TileX = AutofocusForm.TextBoxTileX.Value
-TileY = AutofocusForm.TextBoxTileY.Value
-Overlap = AutofocusForm.TextBoxOverlap.Value
-
-FrameWidth = Lsm5.DsRecording.FrameWidth
-FrameHeight = Lsm5.DsRecording.FrameHeight
-
-RelFrameWidth = FrameWidth - (FrameWidth * Overlap) / 100
-RelFrameHeight = FrameHeight - (FrameHeight * Overlap) / 100
-
-If (TileX > 1 Or TileY > 1) Then CalculateTileLocs
-
-End Sub
-
-
-Public Sub CalculateTileLocs()
-CopyPositionArrays
-
-End Sub
-
-
-Public Sub CopyPositionArrays()
-GlobalXposOld() = GlobalXpos()
-GlobalYposOld() = GlobalYpos()
-GlobalZposOld() = GlobalZpos()
-GlobalLocationsNameOld() = GlobalLocationsName()
-GlobalPositionsStageOld = GlobalPositionsStage
-GlobalPositionsStage = GlobalPositionsStage * TileX * TileY
-ReDim GlobalXpos(GlobalPositionsStage)
-ReDim GlobalYpos(GlobalPositionsStage)
-ReDim GlobalZpos(GlobalPositionsStage)
-ReDim GlobalLocationsName(GlobalPositionsStage)
-Dim n As Integer
-Dim TX As Integer
-Dim TY As Integer
-
-For n = 0 To GlobalPositionsStageOld - 1
-Xnew = GlobalXposOld(n + 1) - ((TileX - 1) / 2) * RelFrameWidth
-Ynew = GlobalYposOld(n + 1) - ((TileY - 1) / 2) * RelFrameHeight
-    For TY = 0 To TileY - 1
-        For TX = 0 To TileX - 1
-            GlobalXpos(n * TileX * TileY + (TY * TileX) + TX + 1) = Xnew + TX * RelFrameWidth
-            GlobalYpos(n * TileX * TileY + (TY * TileX) + TX + 1) = Ynew + TY * RelFrameHeight
-            GlobalZpos(n * TileX * TileY + (TY * TileX) + TX + 1) = GlobalZposOld(n + 1)
-            If Grid Then
-            GlobalLocationsName(n * TileX * TileY + (TY * TileX) + TX + 1) = GlobalLocationsNameOld(n + 1)
-            End If
-         Next TX
-     Next TY
-Next n
-End Sub
diff --git a/AutofocusScreen_LSM5_v1.7/src/ZValues.frm b/AutofocusScreen_LSM5_v1.7/src/ZValues.frm
deleted file mode 100644
index e825104..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/ZValues.frm
+++ /dev/null
@@ -1,24 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} ZValues 
-   Caption         =   "ZValues"
-   ClientHeight    =   2175
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   4365
-   OleObjectBlob   =   "ZValues.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "ZValues"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-Private Sub CommandButton1_Click()
-GlobalStageControlZValues = True
-ZValues.Hide
-End Sub
-
-Private Sub CommandButton2_Click()
-GlobalStageControlZValues = False
-ZValues.Hide
-End Sub
diff --git a/AutofocusScreen_LSM5_v1.7/src/ZValues.frx b/AutofocusScreen_LSM5_v1.7/src/ZValues.frx
deleted file mode 100644
index f4ad92b..0000000
Binary files a/AutofocusScreen_LSM5_v1.7/src/ZValues.frx and /dev/null differ
diff --git a/AutofocusScreen_LSM5_v1.7/src/newMacros.bas b/AutofocusScreen_LSM5_v1.7/src/newMacros.bas
deleted file mode 100644
index a7c2164..0000000
--- a/AutofocusScreen_LSM5_v1.7/src/newMacros.bas
+++ /dev/null
@@ -1,850 +0,0 @@
-Attribute VB_Name = "newMacros"
-Option Explicit
-Public SystemVersion As String
-Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
-Public Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
-Declare Function RegOpenKeyEx _
-    Lib "advapi32.dll" Alias "RegOpenKeyExA" _
-    (ByVal hKey As Long, ByVal lpSubKey As String, _
-    ByVal ulOptions As Long, ByVal samDesired As Long, _
-    phkResult As Long) As Long
-
-Public Declare Function RegCloseKey _
-    Lib "advapi32.dll" (ByVal hKey As Long) As Long
-
-Public Declare Function RegQueryValueEx _
-    Lib "advapi32.dll" Alias "RegQueryValueExA" _
-    (ByVal hKey As Long, ByVal lpValueName As String, _
-    ByVal lpReserved As Long, lpType As Long, _
-    lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
-
-Public Const VK_SPACE = &H20
-Public Const VK_RETURN = &HD
-Public Const VK_CANCEL = &H3
-Public Const VK_UP = &H26
-Public Const VK_DOWN = &H28
-Public Const VK_ESCAPE = &H1B
-Public Const VK_PAUSE = &H13
-Public Const VK_ADD = &H6B
-Public Const VK_SUBTRACT = &H6D
-Public Const HKEY_CLASSES_ROOT = &H80000000
-Public Const SYNCHRONIZE = &H100000
-Public Const READ_CONTROL = &H20000
-Public Const STANDARD_RIGHTS_READ = (READ_CONTROL)
-Public Const KEY_QUERY_VALUE = &H1
-Public Const KEY_ENUMERATE_SUB_KEYS = &H8
-Public Const KEY_NOTIFY = &H10
-Public Const KEY_READ = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
-
-Public Const REG_SZ = 1                         ' Unicode nul terminated string
-Public Const ERROR_SUCCESS = 0&
-
-Public Const vbOKOnly = 0   '  Display OK button only.
-Public Const VbOKCancel = 1 '  Display OK and Cancel buttons.
-Public Const VbAbortRetryIgnore = 2  ' Display Abort, Retry, and Ignore buttons.
-Public Const VbYesNoCancel = 3  '  Display Yes, No, and Cancel buttons.
-Public Const VbYesNo = 4 '  Display Yes and No buttons.
-Public Const VbRetryCancel = 5   ' Display Retry and Cancel buttons.
-Public Const VbCritical = 16 ' Display Critical Message icon.
-Public Const VbQuestion = 32 ' Display Warning Query icon.
-Public Const VbExclamation = 48  ' Display Warning Message icon.
-Public Const VbInformation = 64  ' Display Information Message icon.
-Public Const VbDefaultButton1 = 0    ' First button is default.
-Public Const VbDefaultButton2 = 256  ' Second button is default.
-Public Const VbDefaultButton3 = 512  ' Third button is default.
-Public Const VbDefaultButton4 = 768   'Fourth button is default.
-Public Const VbApplicationModal = 0  ' Application modal; the user must respond to the message box before continuing work in the current application.
-Public Const VbSystemModal = 4096   '  System modal; all applications are suspended until the user responds to the message box.
-'The first group of values (05) describes the number and type of buttons displayed in the dialog box; the second group (16, 32, 48, 64) describes the icon style; the third group (0, 256, 512) determines which button is the default; and the fourth group (0, 4096) determines the modality of the message box. When adding numbers to create a final value for the buttons argument, use only one number from each group.
-
-'Note   These constants are specified by Visual Basic for Applications. As a result, the names can be used anywhere in your code in place of the actual values.
-
-'Return Values
-Public Const vbOK = 1   '  OK
-Public Const vbCancel = 2    ' Cancel
-Public Const vbAbort = 3 ' Abort
-Public Const vbRetry = 4 '  Retry
-Public Const vbIgnore = 5   '  Ignore
-Public Const vbYes = 6  '  Yes
-Public Const vbNo = 7    ' No
-
-
-Public X11 As Double
-Public X12 As Double
-Public X21 As Double
-Public X22 As Double
-
-Public ScanStop As Boolean
-Public ScanPause As Boolean
-Public Running As Boolean
-Public ExtraBleach As Boolean
-Public AutomaticBleaching As Boolean
-Public BleachTable() As Boolean
-Public BleachStartTable() As Double
-Public BleachStopTable() As Double
-Public RepetitionNumber As Long
-
-Public Zoffset As Double
-Public MultipleLocation As Boolean
-Public LocationTracking As Boolean
-Public TrackZ As Boolean
-Public TrackingChannelString As String
-'Public PositionData As Workbook
-Public FrameAutofocussing As Boolean
-Public XMass As Double
-Public YMass As Double
-Public ZMass As Double
-Public ZShift As Double
-Public XShift As Double
-Public YShift As Double
-Public Zbefore As Double
-Public HRZBefore As Double
-Public HRZ As Boolean
-Public NoReflectionSignal As Boolean
-Public PubSentStageGrid As Boolean
-
-
-Public flgUserChange As Boolean
-Public flgEvent As Integer
-Public flg As Integer
-Public toContinue As Integer
-
-Public GlobalProjectName As String
-Public GlobalProject As String
-Public GlobalHelpName As String
-
-Public GlobalPrvTime As Double
-Public GlobalMacroKey As String
-Public GlobalCorrectionOffset As Double
-
-' Public BlockAutoConfiguration As String
-Public BlockTimeIndex As Long
-' Public BlockAutoConfigurationUse As Boolean
-
-Public TimerName As String
-Public BlockTimeDelay As Double
-Public SelectedTimeButton As Integer
-Public TimerButton1 As Double
-Public TimerButton2 As Double
-Public TimerButton3 As Double
-Public TimerButton4 As Double
-Public TimerButton5 As Double
-Public TimerButton6 As Double
-Public TimerUnit As Integer
-Public BlockRepetitions As Long
-
-Public TimerKey As String
-
-Public GlobalDataBaseName As String
-Public GlobalFileName As String
-Public GlobalImageIndex() As Long
-Public GlobalStripeIndex() As Long
-Public BlockZOffset As Double
-Public BlockZRange As Double
-Public BlockZStep As Double
-Public BlockHighSpeed As Boolean
-Public BlockLowZoom As Boolean
-Public BlockHRZ As Boolean
-Public PubSearchScan As Boolean
-
-Public BlockIsSingle As Boolean
-Public BlockSingleTrack As String
-Public BlockSingleTrackIndex As Long
-Public BlockMultiTrack As String
-Public BlockMultiTrackIndex As Long
-
-     
-Public Track As DsTrack
-Public TrackNumber As Integer
-Public TrackName As String
-Public success As Integer
-Public IsAutofocusTrackSelected As Boolean
-Public AutofocusTrack As Integer
-Public IsAcquisitionTrackSelected As Boolean
-Public ActiveChannels() As String
-
-Public DoNotGoOn As Boolean
-Public ChangeFocus As Boolean
-Public FocusChanged As Boolean
-Public Try As Long
-Public SystemName As String
-          
-Public GlobalBackupRecording As DsRecording
-Public ImageNumber As Long
-Public Const OFS_MAXPATHNAME = 128
-Public Const OF_EXIST = &H4000
-Public flgBreak As Boolean
-Public Const WM_COMMAND = &H111
-
-Public tools As Lsm5Tools
-Public Stage As CpStages
-
-Public TileX As Integer
-Public TileY As Integer
-Public Overlap As Double
-
-
-Public HelpNamePDF As String
-
-Public GlobalStageControlZValues As Boolean
-
-Public Type OFSTRUCT
-        cBytes As Byte
-        fFixedDisk As Byte
-        nErrCode As Integer
-        Reserved1 As Integer
-        Reserved2 As Integer
-        szPathName(OFS_MAXPATHNAME) As Byte
-End Type
-Public Type OVERLAPPED
-        Internal As Long
-        InternalHigh As Long
-        offset As Long
-        OffsetHigh As Long
-        hEvent As Long
-End Type
-Public Type SECURITY_ATTRIBUTES
-        nLength As Long
-        lpSecurityDescriptor As Long
-        bInheritHandle As Long
-End Type
-
-
-Public Declare Function OpenFile Lib "kernel32" (ByVal lpFileName As String, lpReOpenBuff As OFSTRUCT, _
-ByVal wStyle As Long) As Long
-
-Public Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
-
-Public Declare Function DeleteFile Lib "kernel32" Alias "DeleteFileA" (ByVal lpFileName As String) As Long
-
-Public Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" _
-(ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, _
-lpNumberOfFreeClusters As Long, lpTotalNumberOfClusters As Long) As Long
-
-Public Declare Function GetTickCount Lib "kernel32" () As Long
-
-
-
-Sub A_Setup()
-     AutofocusForm.Show
-End Sub
-
-
-
-
-
-
-Public Sub DisplayProgress(state As String, Color As Long)       'Used to display in the progress bar what the macro is doing
-    If (Color & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Then
-        AutofocusForm.ProgressLabel.ForeColor = 0
-    Else
-        AutofocusForm.ProgressLabel.ForeColor = &HFFFFFF
-    End If
-    AutofocusForm.ProgressLabel.BackColor = Color
-    AutofocusForm.ProgressLabel.Caption = state
-End Sub
-
-
-Public Sub AutoStore()    ' This was used to store values of the macro parameteres in the registry. This could be used for saving of the macro and resuisng them but is not working in its present state.
-    Dim myKey As String
-    Dim success As Boolean
-    Dim storeOK As Boolean
-    Dim idx As Long
-    Dim lockNo As Long
-    Dim Msg, Style, Title, Help, Ctxt, Response, MyString
-    AutofocusForm.GetBlockValues
-    storeOK = True
-    myKey = "UI\" + GlobalMacroKey + "\AutoStore"
-    success = tools.RegExistKey(myKey)
-    If success Then
-        success = tools.RegDeleteKey(myKey)
-    End If
-    success = tools.RegCreateKey(myKey)
-'    tools.RegStringValue(myKey, "BlockAutoConfiguration") = BlockAutoConfiguration
-    tools.RegLongValue(myKey, "BlockTimeIndex") = BlockTimeIndex
-'    tools.RegLongValue(myKey, "BlockAutoConfigurationUse") = BlockAutoConfigurationUse
-    tools.RegDoubleValue(myKey, "BlockHighSpeed") = BlockHighSpeed
-    tools.RegDoubleValue(myKey, "BlockLowZoom") = BlockLowZoom
-    tools.RegDoubleValue(myKey, "BlockHRZ") = BlockHRZ
-   
-    tools.RegDoubleValue(myKey, "BlockZoffset") = BlockZOffset
-    tools.RegDoubleValue(myKey, "BlockZRange") = BlockZRange
-    tools.RegDoubleValue(myKey, "BlockZStep") = BlockZStep
-End Sub
-
-
-Public Sub AutoRecall()   ' This was used to read values of the macro parameteres in the registry. This could be used for saving of the macro and resuisng them but is not working in its present state.
-    Dim myKey As String
-    Dim success As Boolean
-    Dim idx As Long
-    Dim lockNo As Long
-    Dim Msg, Style, Title, Help, Ctxt, Response, MyString As String
-    Dim Position As Long
-    Dim Range As Double
-    
-    myKey = "UI\" + GlobalMacroKey + "\AutoStore"
-    success = tools.RegExistKey(myKey)
-    If success Then
-        Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-        If Position >= 0 Then
-            Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-        Else
-            Range = 0#
-        End If
-    
-'        BlockAutoConfiguration = tools.RegStringValue(myKey, "BlockAutoConfiguration")
-        BlockTimeIndex = tools.RegLongValue(myKey, "BlockTimeIndex")
-'        BlockAutoConfigurationUse = tools.RegLongValue(myKey, "BlockAutoConfigurationUse")
-        BlockHighSpeed = tools.RegDoubleValue(myKey, "BlockHighSpeed")
-        BlockLowZoom = tools.RegDoubleValue(myKey, "BlockLowZoom")
-        HRZ = tools.RegDoubleValue(myKey, "BlockHRZ")
-        
-        BlockZOffset = tools.RegDoubleValue(myKey, "BlockZoffset")
-        BlockZRange = tools.RegDoubleValue(myKey, "BlockZRange")
-        BlockZStep = tools.RegDoubleValue(myKey, "BlockZStep")
-        If BlockZRange > Range * 0.9 Then
-            BlockZRange = Range * 0.9
-        End If
-        If Abs(BlockZOffset) > Range * 0.9 Then
-            BlockZOffset = 0
-        End If
-        
-        AutofocusForm.SetBlockValues
-      
-'        AutofocusForm.Re_Initialize
-    Else
-    End If
-End Sub
-
-
-Public Sub CopyRecording(Destination As DsRecording, Source As DsRecording)
-    Dim TS As DsTrack
-    Dim TD As DsTrack
-    Dim DataS As DsDataChannel
-    Dim DataD As DsDataChannel
-    Dim DetS As DsDetectionChannel
-    Dim DetD As DsDetectionChannel
-    Dim IlS As DsIlluminationChannel
-    Dim IlD As DsIlluminationChannel
-    Dim BS As DsBeamSplitter
-    Dim BD As DsBeamSplitter
-    Dim lT As Long
-    Dim lI As Long
-    Dim success As Integer
-    
-    Destination.Copy Source
- '   Destination.Objective = Source.Objective
-'    For lT = 0 To Destination.TrackCount - 1
-'
-'        Set TS = Source.TrackObjectByIndex(lT, success)
-'        Set TD = Destination.TrackObjectByIndex(lT, success)
-'
-'        TD.Collimator1Position = TS.Collimator1Position
-'        TD.Collimator2Position = TS.Collimator2Position
-'
-'        For lI = 0 To TD.DataChannelCount - 1
-'            Set DataS = TS.DataChannelObjectByIndex(lI, success)
-'            Set DataD = TD.DataChannelObjectByIndex(lI, success)
-'            DataD.ColorRef = DataS.ColorRef
-'        Next lI
-'
-'        For lI = 0 To TD.DetectionChannelCount - 1
-'            Set DetS = TS.DetectionChannelObjectByIndex(lI, success)
-'            Set DetD = TD.DetectionChannelObjectByIndex(lI, success)
-'            DetD.Filter1 = DetS.Filter1
-'            DetD.Filter2 = DetS.Filter2
-'            DetD.DetectorGain = DetS.DetectorGain
-'            DetD.AmplifierGain = DetS.AmplifierGain
-'            DetD.AmplifierOffset = DetS.AmplifierOffset
-'            DetD.PinholeDiameter = DetS.PinholeDiameter
-'        Next lI
-'
-'        For lI = 0 To TD.IlluminationChannelCount - 1
-'            Set IlS = TS.IlluminationObjectByIndex(lI, success)
-'            Set IlD = TD.IlluminationObjectByIndex(lI, success)
-'            IlD.Acquire = IlS.Acquire
-'            IlD.Power = IlS.Power
-'            IlD.DetectionChannelName = IlS.DetectionChannelName
-'        Next lI
-'
-'        For lI = 0 To TD.BeamSplitterCount - 1
-'            Set BS = TS.BeamSplitterObjectByIndex(lI, success)
-'            Set BD = TD.BeamSplitterObjectByIndex(lI, success)
-'            BD.Filter = BS.Filter
-'        Next lI
-'
-'    Next lT
-End Sub
-
-
-
-Public Sub StoreAquisitionParameters()
-    'stores the whole set of scan parameters
-    Set GlobalBackupRecording = Lsm5.CreateBackupRecording
-    CopyRecording GlobalBackupRecording, Lsm5.DsRecording
-End Sub
-Public Sub RestoreAquisitionParameters()
-    'Restores the image acquisition recording parameters
-     CopyRecording Lsm5.DsRecording, GlobalBackupRecording
-End Sub
-
-Public Sub SystemVersionOffset()
-SystemVersion = Lsm5.Info.VersionIs
-    If StrComp(SystemVersion, "2.8", vbBinaryCompare) >= 0 Then
-        If Lsm5.Info.IsAxioskop Then
-            If BlockHighSpeed Then
-                GlobalCorrectionOffset = 15
-            Else
-                GlobalCorrectionOffset = 1.2
-            End If
-        ElseIf Lsm5.Info.IsAxioplan Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioplan2 Then
-            GlobalCorrectionOffset = 0
-       ElseIf Lsm5.Info.IsAxioplan2i Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioVert Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxiovert100M Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxiovert200M Then
-            GlobalCorrectionOffset = 0
-        Else
-            GlobalCorrectionOffset = 0
-        End If
-    Else
-        If Lsm5.Info.IsAxioskop Then
-            If BlockHighSpeed Then
-                GlobalCorrectionOffset = 15
-            Else
-                GlobalCorrectionOffset = 1.2
-            End If
-        ElseIf Lsm5.Info.IsAxioplan Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioVert Then
-            GlobalCorrectionOffset = 0
-        Else
-            GlobalCorrectionOffset = 0
-        End If
-    End If
-
-End Sub
-
-
-Public Sub Autofocus_StackShift(ZRange As Double, ZStep As Double, HighSpeed As Boolean, Zoffset As Double)
-    Dim Position As Long
-    Dim Range As Double
-    Dim NoFrames As Long
-    Dim NewPicture As DsRecordingDoc
-    Dim BigZStep As Double
-
-'If GettingZmap And Not idpos = 1 Then GoTo ZStackagain
-AutofocusForm.ActivateAutofocusTrack HighSpeed
-    If Not IsAutofocusTrackSelected Then
-        MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-        ScanStop = True
-        Exit Sub
-    End If
-Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    
-    Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-    If Position >= 0 Then
-        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-    Else
-        Range = 0#
-    End If
-    If Range = 0 Then
-        MsgBox "Objective's working distance not defined! Cannot Autofocus!"
-        Exit Sub
-    End If
-    If ZRange > Range * 0.9 Then
-        ZRange = Range * 0.9
-    End If
-    If Abs(Zoffset) > Range * 0.9 Then
-        Zoffset = 0
-    End If
-    
-    SystemVersionOffset
-    
-
-    'Now this is a code specific for the DoAutofocus (is not in the SetAutofocus).
-    'This is to move to the offset position, with the focuswheel
-  If Not GettingZmap Then DisplayProgress "Autofocus 1", RGB(0, &HC0, 0)       'I added this at some points for troubleshooting.
-    Lsm5.Hardware.CpHrz.Position = 0
-  
-    
-ZStackagain:
-
-    Zbefore = Lsm5.Hardware.CpFocus.Position        'To remember the position of the focuswheel
-
-   
-     If Zoffset <= Range * 0.9 Then
-       Lsm5.Hardware.CpFocus.Position = Zbefore + Zoffset + GlobalCorrectionOffset + ZBacklash 'Move down 50um (=ZBacklash) below the position of the offset
-      Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-            Sleep (20)  '20ms
-           DoEvents
-       Loop
-       Lsm5.Hardware.CpFocus.Position = Zbefore + Zoffset + GlobalCorrectionOffset            'Moves up to the position of the offset
-       Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-           Sleep (20)
-           DoEvents
-        Loop
-   End If
-
-    Lsm5.DsRecording.FrameSpacing = ZStep
-    NoFrames = CLng(ZRange / ZStep) + 1                     'Calculates the number of frames per stack. Clng converts it to a long and rounds up the fraction
-    Lsm5.DsRecording.FramesPerStack = NoFrames
-    If NoFrames > 2048 Then                                 'overwrites the userdefined value if too many frames have been defined by the user
-        NoFrames = 2048
-    End If
-    Lsm5.DsRecording.Sample0Z = ZStep * NoFrames / 2        'Distance of the actual focus to the first Z position of the image (or line) to acquire in the stack.
-                                                            'I think this is only valid for the focus wheel and not the HRZ
-    AutofocusForm.AutofocusSetting HRZ, BlockHighSpeed
-
-
-  Lsm5.DsRecording.FrameSpacing = ZStep
-    NoFrames = CLng(ZRange / ZStep) + 1                     'Calculates the number of frames per stack. Clng converts it to a long and rounds up the fraction
-    Lsm5.DsRecording.FramesPerStack = NoFrames
-    If NoFrames > 2048 Then                                 'overwrites the userdefined value if too many frames have been defined by the user
-        NoFrames = 2048
-    End If
-    Lsm5.DsRecording.Sample0Z = ZStep * NoFrames / 2        'Distance of the actual focus to the first Z position of the image (or line) to acquire in the stack.
-                                                           
-     
-   '!!!!!!!!!!!!!!!!!!!!!! potential error source!!!!!!!!!!!!!!!!!!
-    If PubSearchScan Then
-      '  BigZStep = Range * 0.7 / 200
-      If HRZ And SystemName = "LIVE" Then
-
-        If Range > 1000 Then Range = 600
-
-        Lsm5.DsRecording.SpecialScanMode = "OnTheFly"
-        Lsm5.DsRecording.FramesPerStack = 1201
-        Lsm5.DsRecording.Sample0Z = Range / 2
-        Lsm5.DsRecording.FrameSpacing = Range / 1200
-        Sleep (100)
-        
-        Else
-       BigZStep = Range * 0.7 / 200
-
-
-       Lsm5.DsRecording.SpecialScanMode = "FocusStep"
-         NoFrames = CLng(Range * 0.7 / BigZStep) + 1
-        Lsm5.DsRecording.FramesPerStack = NoFrames
-        Lsm5.DsRecording.FrameSpacing = BigZStep
-        Lsm5.DsRecording.Sample0Z = BigZStep * NoFrames / 2
-        Sleep (20)
-        End If
-    End If
-        
-    Set NewPicture = Lsm5.StartScan
-  
-    
-    Do While NewPicture.IsBusy
-        If ScanStop Then
-            Lsm5.StopScan
-            'ScanStop = True
-            DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-            Exit Sub
-        End If
-        DoEvents
-        Sleep (10)
-    Loop
-  
-    Lsm5.tools.WaitForScanEnd False, 20
-  If Not GettingZmap Then DisplayProgress "Autofocus 6", RGB(0, &HC0, 0)
-    
-     AutofocusForm.MassCenter ("Autofocus")
-     If AreStageCoordinateExchanged Then
-            XShift = YMass
-            YShift = XMass
-     Else
-        XShift = XMass
-        YShift = -YMass
-     End If
-        ZShift = ZMass
-         'check if Z shift makes sense
-         If PubSearchScan = True Then Exit Sub
-       CheckRefControl BlockZRange
-
-' If Not (Running = True And AutofocusForm.CheckBoxZMap.Value = True) Then
-'        If (BlockZRange * 0.8 / 2) > Abs(ZShift) And Abs(ZShift) > 5 And NoReflectionSignal = False Then
-'    MovetoCorrectZPosition Zoffset
-'    GoTo ZStackagain
-'   End If
-   ' End If
-
-           
-    'MsgBox "trying to close AF image"
-    If NewPicture.IsValid Then
-        NewPicture.CloseAllWindows
-        'MsgBox "NewPicture.CloseAllWindows"
-    End If
-            
-    'End If
-    
-   
-   
-End Sub
-
-
-
-Public Sub Autofocus_MoveAquisition(LowZoom As Boolean, Zoffset As Double)
-Dim NoZStack As Boolean
-Const ZBacklash = -50
-Dim ZFocus As Double
-Dim Zbefore As Double
-Dim x As Double
-Dim y As Double
-
-
-
-    RestoreAquisitionParameters
-
-  '  Set GlobalBackupRecording = Nothing
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    AutofocusForm.ActivateAcquisitionTrack
-    If Lsm5.DsRecording.ScanMode = "ZScan" Or Lsm5.DsRecording.ScanMode = "Stack" Then  'Looks if a Z-Stack is going to be acquired
-        NoZStack = False
-    Else
-        NoZStack = True
-    End If
-
-    'Moving to the correct position in Z
-                                          'If using HRZ for autofocusing and there is no Zstack for image acquisition
-     '   ZFocus = Lsm5.Hardware.CpHrz.Position + ZShift - Zoffset
-     
-     'Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-    
-    If HRZ Then
-     ZFocus = Lsm5.Hardware.CpFocus.Position - Zoffset - ZShift
-       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash     'Moves down -50uM (ZBacklash) with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-    Else
-    ZFocus = Lsm5.Hardware.CpFocus.Position - Zoffset + ZShift
-       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash     'Moves down -50uM (ZBacklash) with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-    End If
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-        Sleep (100)
-        DoEvents
-   
-   
-
-    'Moving to the correct position in X and Y
- 
-    If FrameAutofocussing Then
-        x = Lsm5.Hardware.CpStages.PositionX - XShift  'the fact that it is "-" in this line and "+" in the next line  probably has to do with where the XY of the origin is set (top right corner and not botom left, I think)
-        y = Lsm5.Hardware.CpStages.PositionY - YShift
-        success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-         
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            If ScanStop Then
-                Lsm5.StopScan
-                AutofocusForm.StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-            DoEvents
-            Sleep (5)
-        Loop
-    End If
-    
-
-    DisplayProgress "Autofocus 14", RGB(0, &HC0, 0)
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    DisplayProgress "Autofocus 15", RGB(0, &HC0, 0)
-End Sub
-
-Private Sub MovetoCorrectZPosition(Zoffset As Double)
-Const ZBacklash = -50
-Dim ZFocus As Double
-Dim Zbefore As Double
-Dim x As Double
-Dim y As Double
-     ZFocus = Lsm5.Hardware.CpFocus.Position + Zoffset + ZShift
-       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash    'Moves down -50uM (ZBacklash) with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-        Sleep (100)
-        DoEvents
-End Sub
-
-
-
-
-Public Sub Autofocus_MoveAquisition_HRZ(LowZoom As Boolean, Zoffset As Double)
-Dim NoZStack As Boolean
-Const ZBacklash = -50
-Dim ZFocus As Double
-Dim Zbefore As Double
-Dim x As Double
-Dim y As Double
-
-
-
-    RestoreAquisitionParameters
-    
-    Set GlobalBackupRecording = Nothing
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    AutofocusForm.ActivateAcquisitionTrack
-    If Lsm5.DsRecording.ScanMode = "ZScan" Or Lsm5.DsRecording.ScanMode = "Stack" Then  'Looks if a Z-Stack is going to be acquired
-        NoZStack = False
-    Else
-        NoZStack = True
-    End If
-
-    'Moving to the correct position in Z
-    If HRZ And NoZStack Then                                            'If using HRZ for autofocusing and there is no Zstack for image acquisition
-     Lsm5.Hardware.CpHrz.Stepsize = 0.2
-     
-      Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-     '   ZFocus = Lsm5.Hardware.CpHrz.Position + ZShift - Zoffset
-     
-     'Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-  
-     ZFocus = Lsm5.Hardware.CpHrz.Position + Zoffset + ZShift
-       
-        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-        
-        DoEvents
-
-    Else                                        'either there is a Z stack for image acquisition or we're using the focuswheel for autofocussing
-        If HRZ Then                             ' Now I'm not sure with the signs and... I some point I just tried random combinations...
-            ZFocus = Lsm5.Hardware.CpHrz.Position - Zoffset - ZShift '         'ZBefore corresponds to the position where the focuswheel was before doing anything. Zshift is the calculated shift
-        Else                                    'If the HRZ is not calibrated the Z shift might be wrong
-            ZFocus = Zbefore + ZShift
-        End If
-       
-        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-    End If
-
-    'Moving to the correct position in X and Y
- 
-    If FrameAutofocussing Then
-        x = Lsm5.Hardware.CpStages.PositionX - XShift  'the fact that it is "-" in this line and "+" in the next line  probably has to do with where the XY of the origin is set (top right corner and not botom left, I think)
-        y = Lsm5.Hardware.CpStages.PositionY - YShift
-        success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-         
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            If ScanStop Then
-                Lsm5.StopScan
-                AutofocusForm.StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-            DoEvents
-            Sleep (5)
-        Loop
-    End If
-    
-
-    DisplayProgress "Autofocus 14", RGB(0, &HC0, 0)
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    DisplayProgress "Autofocus 15", RGB(0, &HC0, 0)
-End Sub
-
-Public Sub CheckRefControl(BlockZRange As Double)
-
-If Try = Empty Then Try = 1
-
-'checkif Z shift makes sense
-                 If AutofocusForm.CheckBoxRefControl.Value = True Then
-                    If Abs(ZShift) > (BlockZRange * 0.8 / 2) Or NoReflectionSignal Then
-                    PubSearchScan = True
-                    DoNotGoOn = False
-                    Try = Try + 1
-                       If Try >= 4 Then
-                       CountDownBox
-                        PubSearchScan = False
-                        NoReflectionSignal = False
-                        AutofocusForm.GetBlockValues 'Updates the parameters value for BlockZRange, BlockZStep..
-                        DisplayProgress "Autofocus 0", RGB(0, &HC0, 0)
-                        Lsm5.StopScan
-                       End If
-                       If Not FocusChanged Then
-                       If Try >= 4 Then
-                            Try = 1
-                            Exit Sub
-                       End If
-                       End If
-                    'Scan with Focuswheel abigger region,move to the brightest region and do the Piezoscanning again
-                       
-                       'Lsm5.Hardware.CpFocus.Position = Zbefore
-                       Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                       MovetoCorrectZPosition BlockZOffset
-                       'Zbefore = Zbefore + ZShift
-                       PubSearchScan = False
-                       NoReflectionSignal = False
-                       
-                       Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                     End If
-                 End If
-
-
-Try = 1
-
-End Sub
-
-Private Sub CountDownBox()
-DoNotGoOn = True
-Load CorrectFocusForm
-CorrectFocusForm.Show
-While DoNotGoOn = True
-DoEvents
-Sleep (10)
-Wend
-
-End Sub
-
-Public Sub PutStagePositionsInArray()
-ReDim GlobalXpos(GlobalPositionsStage)
-ReDim GlobalYpos(GlobalPositionsStage)
-ReDim GlobalZpos(GlobalPositionsStage)
-For idpos = 0 To GlobalPositionsStage - 1
-Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).GetMarkZ idpos, GlobalXpos(idpos + 1), GlobalYpos(idpos + 1), GlobalZpos(idpos + 1)
-'           GlobalXpos(idpos) = Lsm5.Hardware.CpStages.PositionX
-'           GlobalYpos(idpos) = Lsm5.Hardware.CpStages.PositionY
-'           GlobalZpos(idpos) = Lsm5.Hardware.CpFocus.Position
-            
-Next idpos
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/._AFSloader_AutofocusScreen_ZEN_version2.lvb b/AutofocusScreen_ZEN_v2_OfficialRelease/._AFSloader_AutofocusScreen_ZEN_version2.lvb
deleted file mode 100644
index c037649..0000000
Binary files a/AutofocusScreen_ZEN_v2_OfficialRelease/._AFSloader_AutofocusScreen_ZEN_version2.lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/._AutofocusScreen_ZEN_version2.lvb b/AutofocusScreen_ZEN_v2_OfficialRelease/._AutofocusScreen_ZEN_version2.lvb
deleted file mode 100644
index c037649..0000000
Binary files a/AutofocusScreen_ZEN_v2_OfficialRelease/._AutofocusScreen_ZEN_version2.lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/._concat.lvb b/AutofocusScreen_ZEN_v2_OfficialRelease/._concat.lvb
deleted file mode 100644
index c037649..0000000
Binary files a/AutofocusScreen_ZEN_v2_OfficialRelease/._concat.lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/AFSloader_AutofocusScreen_ZEN_version2.lvb b/AutofocusScreen_ZEN_v2_OfficialRelease/AFSloader_AutofocusScreen_ZEN_version2.lvb
deleted file mode 100644
index a727daa..0000000
Binary files a/AutofocusScreen_ZEN_v2_OfficialRelease/AFSloader_AutofocusScreen_ZEN_version2.lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_user_guide_version2.pdf b/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_user_guide_version2.pdf
deleted file mode 100644
index bfcbd83..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_user_guide_version2.pdf
+++ /dev/null
@@ -1,278 +0,0 @@
-Disclaimer
-
-The Autofocus Screen for ZEN is designed to work on Zeiss LSM 710/780 microscopes. We cannot
-guarantee that it will work on other configurations and we cannot take any responsibility for dam-
-age occuring during or after use.
-
-
-
-
-                     Autofocus Screen for ZEN - Users Guide
-Feature Overview
-
- Multi-Location Time Series
- Reflection based or Fluorescence based Autofocus
- Object Tracking
- Screening Experiments with user-defined Grid Formats
- Micropilot Support
- Flexible Combination of 2 independent Z-stack Settings in a Multi-Location Time-Lapse Experi-
-ment
-
-
-About this guide
-
-The AutofocusScreen macro is useful for automating a variety of imaging experiments. We included
-detailed examples for each mode to walk the user through every step of the experimental setup. The
-users can choose the application-mode they are interested in and get a jumpstart on macro-usage
-right away.
-
-Installing AutofocusScreen for ZEN
-
-To install the AutofocusScreen macro please copy the downloaded files into a directory on your
-computer. Use the Macro-Tab in ZEN, choose Macro... (ALT + F8), then select a menu entry
-number and name the macro in Text:. At last assign the path to the location of the AFSloader.
-lvb-file in Project:. To install the Concatenation Macro, please use the same procedure and assign
-a menu entry to the concat.lvb-file.
-
-For further assistance (access to the source code e.g.) please contact: xiang@embl.de
-                                                                        tischer@embl.de
-Autofocus Screen for ZEN                                                                                                     Interface Description
-
-
-
-                                     Single/Multi Location Experiments using Reflection based Autofocus
-
-   Experiment Setup Step by Step                                                       Further Notes
-                                                                    
-   Before starting the macro, set up the imaging                                       Setting up the track for Reflection-based Autofocus:
-   tracks for autofocus and acquisition in ZEN. With
-                                                                        
-   starting the macro, the tracks will appear in the
-   Autofocus and Acquisition tabs of the macro-                                    
-   interface. For Multi Position Experiments, set
-   xy-coordinates in the Stage-menu of ZEN, NOT                                  
-   in the Positions-menu.
-
- Start the macro and click the Single Location or                               
-   Multiple Location-Toggle, click Scan Line.
-                                                                        
- Choose the respective track for autofocus and set
-   up the parameters for the autofocus-track
-
- Move to the desired z-position with the z-focus-
-   wheel and acquire an image using ZEN.
-
- Click Get Current Position Offset for macro to
-   update the z-offset from glass slide
-
- Click Autofocus to check if the desired plane in
-   your sample is found correctly.
-                                                                            
- Choose the tracks you want to use for acquisition                                    Post-Acquisition Tracking Mode
-
- Select delay time between two rounds of acquisi-                                     For tracking moving objects/cells in xy use the track
-   tion. The actual time sampling in each round will                                  object(s)-button and select the track you want to
-   be the time the microscope needs for autofocus/                                     use for tracking. The xy-new focus will be adjusted
-   acquisition plus the delay time.                                                    to be the intensity weighted center of mass calculat-
-                                                                                       ed from the previous image. To adjust the focus in z
- Type in output path for storing acquired data                                        by the same method check Track Z, the autofocus
-                                                                                       will then be inactivated automatically.
- Click Start to start experiment
-                                                                                                                                               2
-Autofocus Screen for ZEN                                                                                                  Interface Description
-
-
-
-                                Single/Multi Location Experiments using Fluorescence based Autofocus
-
-
-   Experiment Setup Step by Step                                                   Further Notes
-                                                                 
-   Before starting the macro, set up the imaging                                    Frame Size determines how many pixels in x and
-   tracks for autofocus and acquisition in ZEN. With                              y are used for the Autofocus Stack.
-   starting the macro, the tracks will appear in the
-   Autofocus and Acquisition tabs of the macro-                                     Use an Z Offset if you are interested in a plane
-   interface. For Multi Position Experiments, set                                  below or above the brightest plane in the stack.
-   xy-coordinates in the Stage-menu of ZEN, NOT
-   in the Positions-menu.                                                         Z Range and Z Stack determine the Stack that is
-                                                                                used for Autofocussing.
- Start the macro and click the Single Location or
-   Multiple Location-Toggle, click Scan Frame.
-                                                                                   If checked, Max-Speed sets the line-average
-                                                                                   number to 1 and in case of using the frame-mode
- Choose the respective track for autofocus and set                                for Autofocus it will set the scanning to bi-direction-
-   up the parameters for the autofocus-track.
-                                                                                   al.
- Choose the tracks you want to use for acquisition
-
- Decide if you want to track the objects in xy                                    .
- Select delay time between two rounds of acquisi-
-   tion. The actual time sampling in each round will                     
-   be the time the microscope needs for autofocus/
-   acquisition plus the delay time.
-                                                                         
- Type in output path for storing acquired data
-
- Click Start to start experiment                                      
-
-
-
-
-                                                                                                                                            3
-Autofocus Screen for ZEN                                                                                                       Interface Description
-
-
-
-                                                           Experiments using Grid Scan
-
-   Experiment Setup Step by Step                                                         Further Notes
-
-   Before starting the macro, set up the imaging                                       Gridscan also allows a subgrid-option which can be
-   tracks for autofocus and acquisition in ZEN. With                                  useful for scanning multi-well dishes e.g., the me-
-   starting the macro, the tracks will appear in the                                  andering scan always starts at the left upper corner
-   Autofocus and Acquisition tabs of the macro-                                        (for both main grid and sub-grid) and then moves in
-   interface. Grid Scan works only in the Single                                      the x-direction first. The filenames of the positions
-   LocationMode.                                                                      are assigned successively in the order of acquisition,
-                                                                                       this is depicted in the figure below. The red dots cor-
- Choose the respective tracks for autofocus and                                      respond to the main grid, the blue dots correspond
-   set up the parameters for the autofocus-track.                                      to the sub-grid. In the example, 3x3 positions with
-   Grid Scan works with both Autofocus Modi, set                                      2x2 sub-positions are scanned. The 3rd sub-position
-   up Autofocus as described in the previous exam-                                     within the 2nd main-position for instance would
-   ples                                                                                then accordingly be assigned the location number
-                                                                                       2x2+3=7.
- Decide on the number of gridpoints and spac-
-   ing between the gridpoints. The subgrid-option is                                     For not using the sub-grid option, just keep the Sde-
-   described further on the right column.                                                fault ub-Positions 1x1.
-
- Choose the tracks you want to use for acquisition
-                                                                                                     L1    L2     L5    L6
-                                                              
- Decide if you want to track the objects in xy
-                                                                                                     L4    L3     L7
- Select delay time between two rounds of acquisi-                            
-   tion. The actual time sampling in each round will
-   be the time the microscope needs for autofocus/
-   acquisition plus the delay time.
-                                                                              
- Type in output path for storing acquired data
-
- Click Start to start experiment
-
-
-
-
-                                                                                                                                                  4
-Autofocus Screen for ZEN                                                                                                      Interface Description
-
-
-
-                                                        Experiments using Micropilot
-
-   Experiment Setup Step by Step                                                           Further Notes
-
-   Start and set up Micropilot before starting the                                         To download the micropilot software with docu-
-   Macro                                                                                   mentation and learn more about micropilot please
-                                                                                           refer to the following ressources:
- Define imaging tracks for identifying cells of                              
-   interest in ZEN, then choose either the Multi-                                           Micropilot: automation of fluorescence microsco-
-   Position or GridScan tab within the macro.                                              py-based imaging for systems biology. by Conrad et
-                                                                                           al. published in Nat Methods. 2011 Mar;8(3):246-9.
- Set up the imaging settings for acquiring images                                        Epub 2011 Jan 23.
-   of the cells of interest in the Micropilot tab                                      
-                                                                                           http://www.embl.de/almf/almf_services/hc_scree-
- Decide on whether or not to track the cells                                              ing/micropilot/
-
- Select appropriate delay time between two
-   rounds of acquisition. The lapse time and num-
-   ber of acquisitions can still be modified once the
-   acquisition has been started.
-
- Type in output path for storing acquired data
-
- It is recommended to use a z-piezo if available              
-   on the system.
-                                                                              
- Click Start to start experiment
-
-                                                                              
-
-
-
-
-                                                                                                                                                 5
-Autofocus Screen for ZEN                                                                                                          Interface Description
-
-
-
-                                                     Experiments using Additional Acquisition Mode
-
-   Experiment Setup Step by Step                                                            Further Notes
-                                                                         
-   Before starting the macro, set up the imaging                                            This mode allows for instance acquiring two z-
-                                                                                          stacks with different parameters for every position at
-   tracks for autofocus and acquisition in ZEN. With
-   starting the macro, the tracks will appear in the                                        each respective time point. Importantly it allows to
-   Autofocus and Acquisition tabs of the macro-                                             acquire the additional stack only every x-th (user-
-   interface. For Multi Position Experiments, set                                           defined) round. A simple example would be to
-   xy-coordinates in the Stage-menu of ZEN, NOT                                           image with high spatial and time resolution in the
-   in the Positions-menu.                                                                 Acquisition channel to see a subcellular structure,
-                                                                                            as described previously, and at the same time to
- Start the macro and click the Single Location or                                       acquire an overview image of the entire cell in an
-   Multiple Location-Toggle                                                              additional imaging track only every 5th round to
-                                                                                            minimize phototoxicity.
- Choose the respective track for autofocus in the
-   Autofocus-tab as described above and set up                                            The additional stack is then saved in an extra-folder.
-   the parameters for the autofocus-track
-                                                                                            It is recommended to use a z-piezo if available on
- Click on the Additional acquisition-tab, set                                            the system.
-  the stack parameters for the additional stack and
-  decide on how often - every x-the round - the ad-
-  ditional stack is supposed to be acquired.
-
- Choose the tracks you want to use for the regular-
-   acquisition, that is taken at every time point.
-                                                                                  
- Select delay time between two rounds of acquisi-
-   tion. The actual time sampling in each round will
-   be the time the microscope needs for autofocus/                                
-   acquisition plus the delay time.
-
- Type in output path for storing acquired data
-
- Click Start to start experiment
-
-
-                                                                                                                                                     6
-Autofocus Screen for ZEN                                                              Interface Description
-
-
-
-                                                            Concatenation Macro
-
-   Concatenate your Files Step by Step
-                                                                                  
- For concatenating images opened currently                                       
-   in ZEN, choose the Loaded Images Tab, for
-   concatenating all other images use the Stored                               
-   Images Tab.
-
- Choose the directory your files are saved in.
-
- If you want to concatenate only individual loca-
-   tions, put in the number of the resprective loca-
-   tions into the Select Location Tab. If you want
-   to concatenate all positions in the folder, put in
-   0 or leave field blank.
-
- Choose an output filename, the concatenated im-
-   ages will be stored in the source folder with the
-   respective prefix.
-
- Click the Concatenate Time per Location Tab to
-   start the concatenation routine
-
-
-
-
-                                                                                                        7
-
\ No newline at end of file
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_version2.lvb b/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_version2.lvb
deleted file mode 100644
index 02f2207..0000000
Binary files a/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_version2.lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_version2_noPasswd.lvb b/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_version2_noPasswd.lvb
deleted file mode 100644
index 446ac4b..0000000
Binary files a/AutofocusScreen_ZEN_v2_OfficialRelease/AutofocusScreen_ZEN_version2_noPasswd.lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/BUGS b/AutofocusScreen_ZEN_v2_OfficialRelease/BUGS
deleted file mode 100644
index 2b17605..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/BUGS
+++ /dev/null
@@ -1,15 +0,0 @@
-Loading bugs:
-	On a computer without VBA license (tested on ZEN2009 and ZEN2010)
-	The Autofocus can't be loaded if protected by a password. 
-	Using AFSloader gives error 'Macro edit not allowed'
-	Using AFSloader with a non protected AutofocusScreen_ZEN macro still get 'Macro edit not allowed'
-	Loading of AutofocusScreen_ZEN without macro works.
-	
-Compiling Bug:
-	Somehow the macro does not recognize Chr(13) as a member of class Strings (MCUCommands). 
-	Error is:
-		Compile error in hidden module MCUCommands
-	For version ZEN2011 the class is correctly recognized (rather puzziling)
-	The same code in the Macro changed by tishi does not create this error.
-Solution: If Chr(13) is replaced by String.Chr(13) then error is also gone on Zenn2009, 2010. This is changed in the main branch
-	
\ No newline at end of file
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/concat.lvb b/AutofocusScreen_ZEN_v2_OfficialRelease/concat.lvb
deleted file mode 100644
index db56686..0000000
Binary files a/AutofocusScreen_ZEN_v2_OfficialRelease/concat.lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AFSloader/LoadAutofocusScreen.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AFSloader/LoadAutofocusScreen.bas
deleted file mode 100644
index 798ccac..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AFSloader/LoadAutofocusScreen.bas
+++ /dev/null
@@ -1,23 +0,0 @@
-Attribute VB_Name = "LoadAutofocusScreen"
-Option Explicit
-
-Public gKey As Long
-Public Const LoaderMacroFileName As String = "AFSloader_AutofocusScreen_ZEN_version2.lvb"
-Public Const MainMacroFileName As String = "AutofocusScreen_ZEN_version2.lvb"
-Public Const StartupFunction = "newMacros.A_Setup"
-'
-
-
-Public Sub Start()
-    Dim fs As New FileSystemObject, libPath As String, p As Lsm5VbaProject
-    libPath = fs.GetParentFolderName(GetProjectObject(LoaderMacroFileName, 1).ProjectPath) & "\" & MainMacroFileName
-    If Not fs.FileExists(libPath) Then
-        MsgBox "AutoFocusScreen macro not found."
-        ProjectUnLoad LoaderMacroFileName
-    End If
-    ShowVBAEditor 0
-    gKey = Timer + 13957532
-    Set p = ProjectLoad(libPath, 0)
-    If p Is Nothing Then ProjectUnLoad LoaderMacroFileName Else p.ExecuteLine StartupFunction
-End Sub
-
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/AutofocusForm.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/AutofocusForm.frm
deleted file mode 100644
index 460a20f..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/AutofocusForm.frm
+++ /dev/null
@@ -1,5118 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} AutofocusForm 
-   Caption         =   "AutofocusScreen for ZEN"
-   ClientHeight    =   13065
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   7305
-   OleObjectBlob   =   "AutofocusForm.frx":0000
-   ShowModal       =   0   'False
-   StartUpPosition =   3  'Windows Default
-End
-Attribute VB_Name = "AutofocusForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-Option Explicit
-''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-''''''''''''''''''''''Version Description''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-'
-'20100919AutofocusScreen1.7ZEN.lvb -  online overnight test: worked
-' Testexperiment: 10 locations look for 3 cells or visit 5 locations and go to the highres-scan mode. 3 time-steps in high-res mode.
-' With line Autofocus for low-res and high-res
-' combination of 20100831dAutofocusScreen1.7ZEN.lvb and AFS1.7Thorsten
-'20100831dAutofocusScreen1.7ZEN.lvb - onlinetest: works for timeseries with Micropilot with Multi-Position, with correct delay, with line Autofocus in several positions
-' many things debuged in this version, would not go back to earlier versions
-'debuged filpath problem
-' closing pictures, automatic change of time delay,
-'''''''''''''''''''''End: Version Description'''''''''''''''''''''''''''''''''''''''''''''''''''''
-'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-
-Private Sub AutoExposure_brightness_Change()
-
-End Sub
-
-Private Sub AutoExposure_brightnessMin_Change()
-
-End Sub
-
-Private Sub AutoExposure_fracSat_Change()
-
-End Sub
-
-Private Sub AutoExposure_fracSatMax_Change()
-
-End Sub
-
-Private Sub AutoExposure_FrameSize_Change()
-
-End Sub
-
-Private Sub AutoExposure_Iterations_Change()
-
-End Sub
-
-Private Sub AutoExposure_maxIter_Change()
-
-End Sub
-
-Private Sub BSliderFrameSize_Change()
-
-End Sub
-
-Private Sub BSliderScanSpeed_Change()
-
-End Sub
-
-Private Sub CheckBoxActivatedGridScan_Click()
-            
-    If MultipleLocationToggle.Value = True Then
-       ' MsgBox "GridScan not compatible with Multiple Locations!"
-       CheckBoxActivatedGridScan.Value = False
-    End If
-    
-    If CheckBoxActivatedGridScan.Value = True Then
-       ' MsgBox "GridScan not compatible with Location Tracking!"
-        TrackingToggle.Value = False
-    End If
-    
-End Sub
-
-Private Sub CheckBoxActivatedGridScan_Initialise_Click()
-
-End Sub
-
-Private Sub CheckBoxActivatedOnlineImageAnalysis_Click()
-
-End Sub
-
-Private Sub CheckBoxAlterImage_Click()
-
-End Sub
-
-Private Sub CheckBoxInnactivateAutofocus_Click()    ' changes look of inactivated buttom if checked and verfies that the posacquisition Z tracking is not activated if autofocusing is reactivated
-                                                    
-    If CheckBoxInnactivateAutofocus.Value = False Then
-        CheckBoxInnactivateAutofocus.BackColor = &HFFFFFF
-    Else
-        CheckBoxInnactivateAutofocus.BackColor = 33023
-    End If
-
-End Sub
-
-Private Sub CheckBoxLowZoom_Click()
-
-End Sub
-
-Private Sub CheckBoxMoveHRZ_Click()
-
-End Sub
-
-
-Private Sub CheckBoxRefControl_Click()
-
-End Sub
-
-Private Sub CheckBoxZoomTrack1_Click()
-
-End Sub
-
-Private Sub CommandButton1_Click()
-
-    Dim dblTask As Double
-    Dim MacroPath As String
-    Dim Mypath As String
-    Dim MyPathPDF As String
-    
-    Dim bslash As String
-    Dim Success As Integer
-    Dim pos As Integer
-    Dim Start As Integer
-    Dim Count As Long
-    Dim ProjName As String
-    Dim indx As Integer
-    Dim AcrobatObject As Object
-    Dim AcrobatViewer As Object
-    Dim OK As Boolean
-    Dim StrPath As String
-    Dim ExecName As String
-        
-    Count = ProjectCount()
-    For indx = 0 To Count - 1
-        MacroPath = ProjectPath(indx, Success)
-        ProjName = ProjectTitle(indx, Success)
-        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, MacroPath, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            Mypath = Strings.Left(MacroPath, Start - 1)
-            MyPathPDF = Mypath + HelpNamePDF
-
-            OK = False
-            On Error GoTo RTFhelp
-            OK = FServerFromDescription("AcroExch.Document", StrPath, ExecName)
-            dblTask = Shell(ExecName + " " + MyPathPDF, vbNormalFocus)
-            
-RTFhelp:
-            If Not OK Then
-                MsgBox "Install Acrobat Viewer!"
-            End If
-            Exit For
-        End If
-    Next indx
-End Sub
-
-Private Sub CommandButtonALMFtest_Click()
-
-    Dim code As String
-    
-    ' code = "validCells_"+str(int(nBrightEnoughCells))+"_"+str(int(minCellsPerImage))+"_"+str(int(minCellsPerWell))
-    
-    code = "validCells_1_1_5"
-    
-    Dim codeArray() As String
-    codeArray = Split(code, "_")
-    
-       
-    Dim nGoodCells As Integer
-    Dim minGoodCellsPerImage As Integer
-    Dim minGoodCellsPerWell As Integer
-    
-    nGoodCells = CInt(codeArray(1))
-    minGoodCellsPerImage = CInt(codeArray(2))
-    minGoodCellsPerWell = CInt(codeArray(3))
-    
-    MsgBox "dd = " + CStr(minGoodCellsPerWell)
-    
-       
-    
-End Sub
-
-Private Sub BleachRegion(xShift As Double, yShift As Double)
-    Dim RecordingDoc As DsRecordingDoc
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim Laser As DsLaser
-    Dim DetectionChannel As DsDetectionChannel
-    Dim IlluminationChannel As DsIlluminationChannel
-    Dim DataChannel As DsDataChannel
-    Dim BeamSplitter As DsBeamSplitter
-    Dim Timers As DsTimers
-    Dim Markers As DsMarkers
-    Dim Success As Integer
-    Set Recording = Lsm5.DsRecording
-    Dim SampleObservationTime As Double
-    Dim SampleOX As Double
-    Dim SampleOY As Double
-    
-    
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-     
-    SampleOX = Recording.Sample0X
-    SampleOY = Recording.Sample0Y
-    Recording.Sample0X = xShift
-    Recording.Sample0Y = yShift
-    'x = Lsm5.Hardware.CpStages.PositionX - xShift
-    'y = Lsm5.Hardware.CpStages.PositionY - yShift
-    'Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-    ' maybe wait here till it is finished moving
-    Recording.SpecialScanMode = "NoSpecialMode"
-    Recording.scanMode = "Point"
-    Recording.TimeSeries = True
-    Recording.FramesPerStack = 1
-    Recording.StacksPerRecord = 50  ' timepoints x 1000
-    SampleObservationTime = Track.SampleObservationTime
-    MsgBox "SampleObservationTime = " + CStr(SampleObservationTime)
-    Track.SampleObservationTime = 0.0001 ' pixel-dwell time in seconds
-    Track.TimeBetweenStacks = 0#
-    'Timers.TimeInterval = 0#
-    
-    TakeImage
-    
-    Recording.Sample0X = SampleOX
-    Recording.Sample0Y = SampleOY
-    'x = Lsm5.Hardware.CpStages.PositionX + xShift
-    'y = Lsm5.Hardware.CpStages.PositionY + yShift
-    'Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-    ' maybe wait here till it is finished moving
-    Recording.SpecialScanMode = "NoSpecialMode"
-    Recording.scanMode = "Frame"
-    Recording.TimeSeries = False
-    Recording.FramesPerStack = 1
-    Recording.StacksPerRecord = 1  ' timepoints x 1000
-    Track.SampleObservationTime = SampleObservationTime ' pixel-dwell time in seconds
-    MsgBox "SampleObservationTime = " + CStr(SampleObservationTime)
-    
- 
-    'Recording.ScanMode = "Plane"
-    'Recording.FrameSpacing = 0.636243
-       
-        
-End Sub
-
-Public Function ComputeCenterAndAxis(dx As Double, dy As Double)
-
-    Dim i, j, iFrame, channel, ni, bitDepth As Long
-    Dim nj As Long
-    
-    Dim ic, jc, di, dj, PixelSize As Double
-    Dim tot As Double
-    
-    Dim th As Double
-    th = 20
-    
-    
-    'Dim ColMax As Integer
-    'Dim iRow As Integer
-    'Dim nRow As Integer
-    'Dim iFrame As Integer
-    'Dim gvRow As Variant  ' gv = gray value
-    'Dim iCol As Long
-    'Dim nCol As Long
-    'Dim bitDepth As Long
-    'Dim channel As Integer
-    'Dim gvMax As Double
-    'Dim gvMaxBitRange As Double
-    'Dim nSaturatedPixels As Long
-    'Dim maxGV_nSat(2) As Double
-    
-    
-    'DisplayProgress "Measuring Exposure...", RGB(0, &HC0, 0)
-  
-    'ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth '/ Lsm5.DsRecordingActiveDocObject.Recording.RtBinning
-    
-    'nRow = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-    'MsgBox "nRow = " + CStr(nRow)
-    
-'        ElseIf SystemName = "LSM" Then
-'            ColMax = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
-'            LineMax = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-'        Else
-'            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-''            Exit Sub
- '       End If
- '   End If
-    
-    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
-    'ReDim Intline(nLines) As Long
-    
-    'iFrame = 0
-    'gvMax = -1
-        
-    'iRow = 0
-    'channel = 0
-    'bitDepth = 0 ' leaves the internal bit depth
-    'gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-    
-    
-    
-    ni = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-    'nCol = 0
-    nj = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
-    
-    'Dim image(,) As Variant
-    
-    'Dim replyCounts(,,) As Short = New Short(2, 1, 2) {}
-    
-    Dim srcline As Variant
-    
-    Dim image() As Long
-    ReDim image(ni, nj)
-    
-    
-    'Dim x(1 To ni, 1 To 4) As Variant
-
-    'MsgBox "ni = " + CStr(ni) + " nj = " + CStr(nj)
-    
-   ' image = GetSubRegion(channel, xs, ys, zs, ts
-    
-    
-    'Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-        
-    PixelSize = Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing * 1000000
-        
-        
-    ' get the image  (put into a subprocedure)
-    iFrame = 0
-    channel = 0
-    bitDepth = 0 ' leaves the internal bit depth
-    For i = 0 To ni - 1
-        srcline = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, i, nj, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-        For j = 0 To nj - 1
-            image(i, j) = srcline(j)
-        Next j
-    Next i
-    'MsgBox "im = " + CStr(image(100, 100))
-        
-    ' computer center of mass
-    ic = 0
-    jc = 0
-    tot = 0
-    For i = 0 To ni - 1
-        For j = 0 To nj - 1
-            If (image(i, j) > th) Then
-                ic = ic + image(i, j) * i
-                jc = jc + image(i, j) * j
-                tot = tot + image(i, j)
-            End If
-        Next j
-    Next i
-    
-    ic = ic / tot
-    jc = jc / tot
-    'MsgBox "ic = " + CStr(ic) + " jc = " + CStr(jc) + " tot = " + CStr(tot)
-    
-    dx = (ic - ni / 2) * PixelSize
-    dy = (jc - nj / 2) * PixelSize
-    
-    ' compute displacement vector
-    di = 0
-    dj = 0
-    
-    For i = 0 To ni - 1
-        For j = 0 To nj - 1
-            If (image(i, j) > th) Then
-                di = di + image(i, j) * (i - ic) * Sgn(i - ic)
-                dj = dj + image(i, j) * (j - jc) * Sgn(i - ic)
-            End If
-        Next j
-    Next i
-    
-    di = di / tot
-    dj = dj / tot
-    'MsgBox "di = " + CStr(di) + " dj = " + CStr(dj) + " tot = " + CStr(tot)
-        
-        
-    'PixelSize
-        
-        
-        
-    '    For iCol = 0 To nCol - 1            'Now I'm scanning all the pixels in the line
-            
-     '       If (gvRow(iCol) > gvMax) Then
-      '          gvMax = gvRow(iCol)
-       '     End If
-
-    
-    
-    'iFrame = 0
-    'gvMax = -1
-    'iRow = 0
-    'Channel = 0
-    'bitDepth = 0 ' leaves the internal bit depth
-    'gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(Channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-    'MsgBox "nCol = " + CStr(nCol)
-    'MsgBox "bytes per pixel = " + CStr(bitDepth)
-
-    ' todo: is there another function to find this out??
-    'If (bitDepth = 1) Then
-    '    gvMaxBitRange = 255
-    'ElseIf (bitDepth = 2) Then
-    '    gvMaxBitRange = 65536
-    'End If
-    
-    'nSaturatedPixels = 0
- 
-End Function
-
-Private Sub AutoExposureLaser()
-
-    Dim gvMaxNorm As Double
-    Dim fractionSat As Double
-    Dim exposureOK As Boolean
-    Dim laserPower As Double
-    Dim i As Integer
-    Dim localBackupRecording As DsRecording
-    Dim nRow As Integer
-    Dim nCol As Integer
-    
-           
-    ' remember acquistion parameters
-    nCol = Lsm5.DsRecording.LinesPerFrame
-    nRow = Lsm5.DsRecording.SamplesPerLine
-    
-    ' set new acquisition parameters
-    Lsm5.DsRecording.LinesPerFrame = AutoExposure_FrameSize.Value
-    Lsm5.DsRecording.SamplesPerLine = AutoExposure_FrameSize.Value
-    
-            
-    exposureOK = False
-    i = 1
-    Do While (exposureOK = False)
-        
-        TakeImage
-        
-        MeasureExposure gvMaxNorm, fractionSat
-        
-        ' show the user the current values
-        AutoExposure_fracSat.Value = fractionSat
-        AutoExposure_brightness.Value = gvMaxNorm
-        AutoExposure_Iterations.Value = i
-        DoEvents
-    
-        If (fractionSat > AutoExposure_fracSatMax.Value) Then
-        
-            DisplayProgress "Image too bright: reducing laser...", RGB(0, &HC0, 0)
-            'MsgBox "too many (" + CStr(fractionSat) + ") saturated pixels; reducting laser power."
-            
-            laserPower = -1 ' -1 just give back the current laser power
-            SetGetLaserPower laserPower
-            laserPower = laserPower / 2
-            SetGetLaserPower laserPower
-            
-        ElseIf (gvMaxNorm < AutoExposure_brightnessMin.Value) Then
-            
-            DisplayProgress "Image too dim: increasing laser...", RGB(0, &HC0, 0)
-            
-            laserPower = -1 ' -1 just give back the current laser power
-            SetGetLaserPower laserPower
-            laserPower = laserPower * AutoExposure_brightnessMin.Value / gvMaxNorm
-            SetGetLaserPower laserPower
-        
-        Else
-            
-            exposureOK = True
-            
-        End If
-        
-        If ScanStop Then
-            Exit Sub
-        End If
-        
-        If i > AutoExposure_maxIter.Value Then
-            DisplayProgress "Could not find good exposure settings...", RGB(0, &HC0, 0)
-            Exit Sub
-        End If
-    
-        i = i + 1
-        
-    Loop
-    
-    
-    ' reset all acquistion parameters
-    Lsm5.DsRecording.LinesPerFrame = nCol
-    Lsm5.DsRecording.SamplesPerLine = nRow
-                     
-    
-End Sub
-
-
-
-Private Sub CommandButtonStoreApply_Click()
-    StoreApplyForm.Show 0
-End Sub
-
-Private Sub Label31_Click()
-
-End Sub
-
-Private Sub CommonDialog_Enter()
-
-End Sub
-
-Private Sub Frame16_Click()
-
-End Sub
-
-Private Sub TakeImage()
-
-    Dim ScanImage As DsRecordingDoc
-    
-    Set ScanImage = Lsm5.StartScan
-
-    DisplayProgress "Taking Image.......", RGB(0, &HC0, 0)
-    Do While ScanImage.IsBusy                                  ' Waiting untill the image acquisition is done
-        If ScanStop Then
-            Lsm5.StopScan
-            'GoTo Abort  ' how to exit while loop in VB ???
-            Exit Do
-        End If
-        DoEvents
-        Sleep (10)
-    Loop
-    DisplayProgress "Taking Image...DONE.", RGB(0, &HC0, 0)
-    
-'Abort:
-    
-End Sub
-
-
-Private Sub DisplayAmplifierDescriptions()  ' just for testing
-    
-  '  Dim amp As CpAmplifiers
- '   Set amp = Lsm5.Hardware.CpAmplifiers
-    
-'    Lsm5.Hardware.CpAmplifiers.Summary
-        
-    'MsgBox "Amp:" + Lsm5.Hardware.CpAmplifiers.name + CStr(Lsm5.Hardware.CpAmplifiers.Summary)
-    
-    Dim channel As DsDetectionChannel
-    
-    Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, Success)
-    Set channel = Track.DetectionChannelObjectByIndex(0, Success)
-
-    channel.DetectorGain = 300
-    MsgBox "Detector 0: " + CStr(channel.name) + " " + CStr(channel.DetectorGain)
-    channel.DetectorGain = 500
-    MsgBox "Detector 0: " + CStr(channel.name) + " " + CStr(channel.DetectorGain)
-                        
-    
-    'If Track.Acquire Then 'if track is activated for acquisition
-    '    For c = 1 To Track.DetectionChannelCount 'for every detection channel of track
-    '                Set Channel = Track.DetectionChannelObjectByIndex(c - 1, success)
-    '                If Channel.Acquire Then 'if channel is activated
-  
-     
-    
-    'MsgBox "Det: " + CStr(Lsm5.DsRecording.DetectionChannelOfActiveOrder.name)
-    
-    'Set channel = Lsm5.Hardware.
-    
-    'MsgBox "Amp:" + Lsm5.DsDetectionChannel.name
-    
-    'If (Lsm5.Hardware.CpPmts.Select(1)) Then
-    '    MsgBox "Amp:" + CStr(Lsm5.Hardware.CpPmts.DetectorType) + " " + CStr(Lsm5.Hardware.CpPmts.DetectorType)
-    'End If
-        
-    
-    
-End Sub
-Public Function SetGetLaserPower(power As Double)
-    
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim IlluminationChannel As DsIlluminationChannel
-    
-    Set Recording = Lsm5.DsRecording
-    Set Track = Recording.TrackObjectByIndex(0, Success)
-    Set IlluminationChannel = Track.IlluminationObjectByIndex(0, Success)
-
-    If (power > 0) Then
-        IlluminationChannel.power = power
-    End If
-    
-    power = IlluminationChannel.power
-    
-    
-End Function
- 
-
-Public Function MeasureExposure(fractionMax As Double, fractionSat As Double)
-   
-'    Lsm5Vba.Application.ThrowEvent eRootReuse, 0                   'Was there in the initial Zeiss macro, but it seems notnecessary
- '   DoEvents
-    
-    'Dim ColMax As Integer
-    Dim iRow As Integer
-    Dim nRow As Integer
-    Dim iFrame As Integer
-    Dim gvRow As Variant  ' gv = gray value
-    Dim iCol As Long
-    Dim nCol As Long
-    Dim bitDepth As Long
-    Dim channel As Integer
-    Dim gvMax As Double
-    Dim gvMaxBitRange As Double
-    Dim nSaturatedPixels As Long
-    Dim maxGV_nSat(2) As Double
-    
-    
-    DisplayProgress "Measuring Exposure...", RGB(0, &HC0, 0)
-  
-    'ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth '/ Lsm5.DsRecordingActiveDocObject.Recording.RtBinning
-    
-    nRow = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-    'MsgBox "nRow = " + CStr(nRow)
-    
-'        ElseIf SystemName = "LSM" Then
-'            ColMax = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
-'            LineMax = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-'        Else
-'            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-''            Exit Sub
- '       End If
- '   End If
-    
-    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
-    'ReDim Intline(nLines) As Long
-    
-    iFrame = 0
-    gvMax = -1
-        
-    iRow = 0
-    channel = 0
-    bitDepth = 0 ' leaves the internal bit depth
-    gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-    'MsgBox "nCol = " + CStr(nCol)
-    'MsgBox "bytes per pixel = " + CStr(bitDepth)
-
-    ' todo: is there another function to find this out??
-    If (bitDepth = 1) Then
-        gvMaxBitRange = 255
-    ElseIf (bitDepth = 2) Then
-        gvMaxBitRange = 65536
-    End If
-    
-    nSaturatedPixels = 0
-    
-    For iRow = 0 To nRow - 1
-        gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-        For iCol = 0 To nCol - 1            'Now I'm scanning all the pixels in the line
-            
-            If (gvRow(iCol) > gvMax) Then
-                gvMax = gvRow(iCol)
-            End If
-            
-            If (gvRow(iCol) = gvMaxBitRange) Then
-                nSaturatedPixels = nSaturatedPixels + 1
-                ' TODO: measure neighbouring saturated pixels
-            End If
-
-        Next iCol
-    Next iRow
-        
-    fractionMax = gvMax / gvMaxBitRange
-    fractionSat = nSaturatedPixels / (nRow * nCol)
-        
-    'MsgBox "maximal gray value in image = " + CStr(gvMax)
-    'MsgBox "fractional brightness of maximal gray value in image = " + CStr(fractionMax)
-    'MsgBox "number of saturated pixles = " + CStr(nSaturatedPixels)
-    'MsgBox "fraction of saturated pixles = " + CStr(fractionSat)
-      
-    DisplayProgress "Measuring Exposure...DONE", RGB(0, &HC0, 0)
-  
-End Function
-
-
-Private Sub GridScan_dX_Change()
-
-End Sub
-
-Private Sub Label13_Click()
-
-End Sub
-
-Private Sub Label44_Click()
-
-End Sub
-
-Private Sub Label48_Click()
-
-End Sub
-
-Private Sub Label51_Click()
-
-End Sub
-
-Private Sub MultiPage1_Change()
-
-End Sub
-
-Private Sub ScanLineToggle_Click()
-    ScanFrameToggle.Value = Not ScanLineToggle.Value 'if ScanFrame is true ScanLine is false (you can only chose one of them)
-    FrameAutofocussing = ScanFrameToggle.Value 'if ScanFrame is true than FrameAutofocusing (boolean variable) will be set true as well
-    FrameSizeLabel.Visible = ScanFrameToggle.Value 'FrameSize Label is only displayed if ScanFrame is activated
-    BSliderFrameSize.Visible = ScanFrameToggle.Value 'FrameSize Slider is only displayed if ScanFrame is activated
-'    BSliderScanSpeed.Visible = ScanLineToggle.Value
-'    ScanSpeedLabel.Visible = ScanLineToggle.Value
-End Sub
-
-Private Sub ScanFrameToggle_Click()
-    ScanLineToggle.Value = Not ScanFrameToggle.Value 'if ScanLine is chosen, ScanFrame will be unchecked
-    
-    FrameAutofocussing = ScanFrameToggle.Value 'if ScanFrame is true than FrameAutofocusing (boolean variable) will be set true
-    FrameSizeLabel.Visible = ScanFrameToggle.Value
-    BSliderFrameSize.Visible = ScanFrameToggle.Value
-    
-'    ScanSpeedLabel.Visible = ScanLineToggle.Value
-
-'         If SystemName = "LSM" Then
-'
-'            BSliderFrameSize.ValueEditable = True
-'             BSliderFrameSize.Min = 16
-'            BSliderFrameSize.Max = 1024
-'            BSliderFrameSize.Step = 128
-'            BSliderFrameSize.StepSmall = 4
-'           BSliderFrameSize.ValueDisplay = True
-'
-'        ElseIf SystemName = "LIVE" Then
-'
-'
-'            BSliderFrameSize.ValueEditable = False
-'            BSliderFrameSize.Min = 128
-'            BSliderFrameSize.Max = 1024
-'            BSliderFrameSize.Step = 128
-'            BSliderFrameSize.StepSmall = 128
-'            BSliderFrameSize.Value = 128
-'
-'        End If
-    
-End Sub
-
-Private Sub ScanSpeedLabel_Click()
-
-End Sub
-
-Private Sub SetFocusButton_Click()
-    
-    AutofocusForm.GetBlockValues                                             'Updates the parameters value for BlockZRange, BlockZStep....
-    SetFocus BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset   ' Performs the scan in Z (line or Frame, to find the offset value
-    
-    'MsgBox "ZShift " + CStr(ZShift)
-    'MsgBox "BlockZOffset " + CStr(BlockZOffset)
-    
-
-End Sub
-
-
-Private Sub AutofocusButton_Click()
-    
-    Dim AutofocusDoc As DsRecordingDoc
-    
-    Try = 1
-    AutofocusForm.GetBlockValues 'Updates the parameters value for BlockZRange, BlockZStep..
-    
-    DisplayProgress "Autofocus 0", RGB(0, &HC0, 0)
-    StopScanCheck
-    StoreAquisitionParameters
-    
-    ' do the AF
-    Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset, AutofocusDoc
-    
-    If ScanStop = True Then
-        GoTo Abort
-    End If
-    
-    ' check if Z shift makes sense
-    ' Todo: what is happening here?
-    CheckRefControl BlockZRange
-    If CheckBoxMoveHRZ.Value = True Then
-        Autofocus_MoveAquisition_HRZ BlockZOffset
-    Else
-        Autofocus_MoveAquisition BlockZOffset
-    End If
-    
-    If ScanStop = True Then
-        GoTo Abort
-    End If
-    
-    'DoAutofocus BlockZOffset, BlockZRange, BlockZStep, BlockHRZ, BlockLowZoom, BlockHighSpeed  ' Performs the scan in Z (line or Frame, to find the offset value
-
-    ActivateAcquisitionTrack
-    
-    If IsAcquisitionTrackSelected And IsAutofocusTrackSelected Then
-        
-        Sleep (20)
-        DoEvents
-        
-        DisplayProgress "AF: Taking image at found position...", RGB(0, &HC0, 0)
-    
-        ScanToImageNew AutofocusDoc
-    
-        Lsm5.tools.WaitForScanEnd False, 20       'Wait untill the scan is finnished, the waiting time is 20s. This could be too short in some instances
-    
-    End If
-    
-Abort:
-
-    If Not (GlobalBackupRecording Is Nothing) Then
-        RestoreAquisitionParameters
-        Set GlobalBackupRecording = Nothing
-        'Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-        DoEvents                                'Finnish everything which had started
-        'ActivateAcquisitionTrack                'Activates the tracks for image acquisition
-    End If
-    
-    If ScanStop = True Then
-        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-        ScanStop = False
-    Else
-        DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    End If
-
-End Sub
-
-
-Private Sub StartBleachButton_Click()
-    
-    Dim Success As Integer
-    Dim nt As Integer
-    
-    BleachingActivated = True
-    AutomaticBleaching = False
-    
-    If LocationTracking And TrackingChannelString = "" Then
-        MsgBox ("Select a channel for tracking, or uncheck the tracking button")
-        Exit Sub
-    End If
-    If MultipleLocation And Lsm5.Hardware.CpStages.MarkCount < 1 Then
-        MsgBox ("Select at least one location in the stage control window, or uncheck the multiple location button")
-        Exit Sub
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No Output Folder selected ! Cannot start acquisition.")
-        Exit Sub
-    End If
-    
-    
-    Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
-    
-    If Success Then
-        If Track.BleachPositionZ <> 0 Then
-            MsgBox ("This macro does not enable to bleach at a different Z position. Please uncheck the corresponding box in the Bleach Control Window")
-            Exit Sub
-        End If
-        
-        If Lsm5.IsValidBleachRoi Then
-            
-            If CheckBoxActivatedOnlineImageAnalysis Then
-                nt = TextBoxZoomCycles
-            Else
-                nt = BlockRepetitions
-            End If
-                    
-            If (Track.BleachScanNumber + 1) > nt Then
-                MsgBox ("Not enough repetitions to bleach; either increase the Number of Acquisitions, or, when using MicroPilot, the Cycles")
-                Exit Sub
-            End If
-            
-            FillBleachTable
-            AutomaticBleaching = True
-           'Track.UseBleachParameters = True ' deleted 20100818 , can probably not work with Micropilot
-        Else
-            MsgBox ("A bleaching ROI needs to be defined to start the macro in the bleaching mode")
-            Exit Sub
-        End If
-    Else
-        MsgBox ("A bleach track needs to be defined to start the macro in the bleaching mode")
-        Exit Sub
-    End If
-    
-    StoreAquisitionParameters
-    
-    StartAcquisition BleachingActivated
-End Sub
-
-Private Sub FillBleachTable()  'Fills a table for the macro to know when the bleaches have to occur. This works for FRAPs (and FLIPS if working with LSM 3.2)
-    
-    Dim i As Integer
-    Dim nt As Integer
-    Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
-    If Success Then
-        
-        If CheckBoxActivatedOnlineImageAnalysis Then
-            nt = TextBoxZoomCycles.Value
-        Else
-            nt = BlockRepetitions
-        End If
-            
-        ReDim BleachTable(nt)               'The bleach table contains as many timepoints as blockrepetitions
-        
-        'When working with the Lsm 2.8, remove all this test, except the one indicated line
-        If Track.EnableBleachRepeat Then
-            For i = Track.BleachScanNumber + 1 To nt Step Track.BleachRepeat
-                BleachTable(i) = True
-            Next
-        Else
-            BleachTable(Track.BleachScanNumber + 1) = True  'This is the only line to be kept when working with the Lsm 2.8
-        End If
-        
-    End If
-End Sub
-
-Private Sub StartButton_Click()
-    
-    ScanStop = False
-
-    Try = 1
-    BleachingActivated = False
-    AutomaticBleaching = False                                  'We do not do FRAps or FLIPS in this case. Bleaches can still be done with the "ExtraBleach" button.
-    If LocationTracking And TrackingChannelString = "" Then
-        MsgBox ("Select a channel for tracking, or uncheck the tracking button")
-        Exit Sub
-    End If
-    If MultipleLocation And Lsm5.Hardware.CpStages.MarkCount < 1 Then
-        MsgBox ("Select at least one location in the stage control window, or uncheck the multiple location button")
-        Exit Sub
-    End If
-    If GlobalDataBaseName = "" Then
-        MsgBox ("No Database selected ! Cannot start acquisition.")
-        Exit Sub
-    End If
-    
-    StoreAquisitionParameters
-    
-    StartAcquisition BleachingActivated 'This is the main function of the macro
-    
-End Sub
-
-Private Sub StartAcquisition(BleachingActivated)
-    Dim rettime, difftime As Double
-    Dim GlobalPrvTime As Double
-    Dim Location As Integer
-    Dim LocationNumber As Integer
-    Dim iLoc As Integer
-    Dim iLocMainGrid As Integer
-
-    Dim LocationName As String
-    Dim name As String
-    Dim alterName As String
-    Dim tilename As String
-    Dim x As Double
-    Dim XCor As Double
-    Dim y As Double
-    Dim YCor As Double
-    Dim z As Double
-    Dim ZCor As Double
-    Dim ZBacklash As Double                 'I forgot to initialize this to -50
-    Dim Success As Integer
-    Dim RelativeLocation As Integer
-    Dim StitchImage As RecordingDocument
-    Dim ScanImage As RecordingDocument
-    Dim RecordingDoc As DsRecordingDoc
-    Dim ImageCopy As New AimImageCopy
-    Dim Progress As AimProgress
-    Dim Scancontroller As AimScanController
-    Dim TileDatabaseName As String
-    Dim NameLength As Integer
-    Dim Myname As String
-    Dim Mypath As String
-    Dim TileXOld As Integer
-    Dim r As Integer
-    Dim Start As Long
-    Dim bslash As String
-    Dim pos As Long
-    Dim Bytesperpixel As Long
-    Dim StartTime As Double
-    Dim OnlineImageAnalysis As Boolean
-    Dim AlterDatabaseName As String
-    Dim filepath As String
-    Dim AlterImage As Boolean
-    Dim HighResExperimentCounter As Integer
-    Dim HighResCounter As Integer
-    Dim fullpathname As String
-    
-    
-    ' Set the offset in z-stack to 0; otherwise there can be errors...
-    Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * Int(Lsm5.DsRecording.FramesPerStack / 2)
-                       
-    ' Store current settings
-    CopyRecording BackupRecording, Lsm5.DsRecording
-    
-    
-    ' set up the imaging
-    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-    Set RecordingDoc = Lsm5.DsRecordingActiveDocObject
-    
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (20)
-            DoEvents
-        Wend
-    End If
-    
-    
-  
-    Grid = False  ' this is another Grid mode feature which is disabled
-    
-    ' CheckBoxActivatedOnlineImageAnalysis  refers to the MicroPilot
-    If CheckBoxActivatedOnlineImageAnalysis.Value = True Then
-        
-        Dim HighResArrayX() As Double
-        Dim HighResArrayY() As Double
-        Dim HighResArrayZ() As Double
-        ReDim Preserve HighResArrayX(100)
-        ReDim Preserve HighResArrayY(100)
-        ReDim Preserve HighResArrayZ(100)
-        OnlineImageAnalysis = True
-        HighResExperimentCounter = 0
-        HighResCounter = 0
-        SaveSetting "OnlineImageAnalysis", "macro", "code", 0
-        SaveSetting "OnlineImageAnalysis", "macro", "offsetx", 0
-        SaveSetting "OnlineImageAnalysis", "macro", "offsety", 0
-        
-    Else
-        
-        OnlineImageAnalysis = False
-    
-    End If
-    
-
-    
-    '' create stiching database: start *********************************
-    TileX = AutofocusForm.TextBoxTileX.Value
-    TileY = AutofocusForm.TextBoxTileY.Value
-    
-    If TileX > 1 Or TileY > 1 Then
-        Start = 1
-        bslash = "\"
-        pos = Start
-        Do While pos > 0
-            pos = InStr(Start, GlobalDataBaseName, bslash)
-            If pos > 0 Then
-                Start = pos + 1
-            End If
-        Loop
-        Mypath = Strings.Left(GlobalDataBaseName, Start - 1)
-        NameLength = Len(GlobalDataBaseName)
-        Myname = Strings.Right(GlobalDataBaseName, NameLength - Start + 1)
-        NameLength = Len(Myname)
-        Myname = Strings.Left(Myname, NameLength - 4)
-        TileDatabaseName = Mypath & Myname & "_tile.mdb"
-        TileDatabaseName = TileDatabaseName & "\" & Myname & "_tile.mdb"
-        
-    
-        Lsm5.NewDatabase (TileDatabaseName) ' Todo: has to be changed for ZEN
-    End If
-    '' create stiching database: end *********************************
-    
-    
-    InitializeStageProperties
-    SetStageSpeed 9, True
-    
-    GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-    If MultipleLocation Or Grid Then
-        PutStagePositionsInArray
-    End If
-    
-    
-            
-    RepetitionNumber = 1
-    Running = True  'Now we're starting. This will be set to false if the stop button is pressed or if we reached the total number of repetitions.
-    ChangeButtonStatus False ' disable buttons
-   
-    If TileX > 1 Or TileY > 1 Then
-        
-        Set Scancontroller = Lsm5.ExternalDsObject.Scancontroller
-    
-    End If
-    
-
-    If MultipleLocation Or Grid Then                    'Defines the Location Number parameter
-        
-        LocationNumber = Lsm5.Hardware.CpStages.MarkCount       'Counts the locations stored in the Stage control window from the LSM
-    
-    ElseIf (CheckBoxActivatedGridScan And CheckBoxActivatedGridScan_Initialise) Then ' Prepare the grid coordinates
-        
-        Dim tmpGridX As Double
-        Dim tmpGridY As Double
-        
-        Dim tmpGridXsub As Double
-        Dim tmpGridYsub As Double
-                
-        Dim iy As Integer
-        Dim ix As Integer
-        Dim iWell As Integer
-        Dim iyy As Integer
-        Dim ixx As Integer
-        Dim xDirection As Integer
-        Dim xxDirection As Integer
-        
-        ' MsgBox "Initialize all grid positions."
-        
-        LocationNumber = GridScan_nX.Value * GridScan_nY.Value * GridScan_nXsub.Value * GridScan_nYsub.Value
-        
-        If LocationNumber > 10000 Then
-            MsgBox "Sorry. Maximal number of locations is 10000. Please change nX and/or nY."
-        End If
-        
-        tmpGridX = Lsm5.Hardware.CpStages.PositionX
-        tmpGridY = Lsm5.Hardware.CpStages.PositionY
-        
-        iLoc = 1
-        iLocMainGrid = 0
-        xDirection = 1 ' meander
-        
-        For iy = 1 To GridScan_nY.Value
-            
-            For ix = 1 To GridScan_nX.Value
-                
-                If ix = 1 Then
-                    tmpGridX = tmpGridX
-                Else
-                    tmpGridX = tmpGridX + xDirection * GridScan_dX.Value
-                End If
-                    
-                iLocMainGrid = iLocMainGrid + 1
-                locationNumbersMainGrid(iLocMainGrid) = iLoc  ' remember where the main positions are
-                
-                ' Sub-Positions: start
-                tmpGridXsub = tmpGridX
-                tmpGridYsub = tmpGridY
-                
-                xxDirection = 1 ' meander
-                
-                For iyy = 1 To GridScan_nYsub.Value
-                    
-                    For ixx = 1 To GridScan_nXsub.Value
-                        
-                        If ixx = 1 Then
-                            tmpGridXsub = tmpGridXsub
-                        Else
-                            tmpGridXsub = tmpGridXsub + xxDirection * GridScan_dXsub.Value
-                        End If
-                            
-                        posGridX(iLoc) = tmpGridXsub
-                        posGridY(iLoc) = tmpGridYsub
-                        posGridXY_valid(iLoc) = 1 ' image this position
-                    
-                        iLoc = iLoc + 1
-                
-                    Next ixx
-                    
-                    xxDirection = xxDirection * (-1) ' meander
-                    tmpGridYsub = tmpGridYsub + GridScan_dYsub.Value
-                
-                Next iyy
-                ' Sub-Positions: end
-                
-            Next ix
-            
-            xDirection = xDirection * (-1) ' meander
-            tmpGridY = tmpGridY + GridScan_dY.Value
-        
-        Next iy
-    
-    
-    ElseIf CheckBoxActivatedGridScan Then
-    
-        LocationNumber = GridScan_nX.Value * GridScan_nY.Value * GridScan_nXsub.Value * GridScan_nYsub.Value
-        
-    Else
-        
-        LocationNumber = 1  'If using the single location you do not have to mark it in the stage control window.
-    
-    End If
-            
-            
-    If LocationTracking Or FrameAutofocussing Then
-        'Here you could add code for storing the XYZ position of the cells at each time point in Excel
-        'code is in "unused code" ExcelXYZstoring
-    End If
-    
-    
-    Do While Running   'As long as the macro is running we're in this loop
-    
-    
-        ' Todo: what is happening here?
-        If CheckBoxZMap.Value Then
-            RecalibrationFocusZMap ' cleaned 31.06.2010
-        End If
-        
-        
-        ' Todo: what is happening here?
-        ' Todo: remember the last focus position for each location!
-        If Not (LocationTracking Or FrameAutofocussing) Then
-            UpdateZvalues Grid, MultipleLocation, z ' cleaned 2010.07.15
-        End If
-        
-        
-        iLocMainGrid = 1
-        nGoodCellsPerWell = 0
-        iWell = 1
-        
-        For Location = 1 To LocationNumber    'This loops all the locations (only one if Single location is selected)
-                
-            If MultipleLocation Or Grid Then
-                
-                MoveToNextLocation ' in xy and z-positon
-            
-            ElseIf CheckBoxActivatedGridScan.Value Then
-                            
-                If CheckBoxGridScan_FindGoodPositions And (Location > 1) Then
-                    
-                    If nGoodCellsPerWell >= minGoodCellsPerWell Then
-                        
-                        MsgBox "Enough Cells Per Well " + CStr(nGoodCellsPerWell) + "/" + CStr(minGoodCellsPerWell) + ". Going to Next Well. "
-                          
-                        If (iWell + 1 > GridScan_nX.Value * GridScan_nY.Value) Then ' we are in the last well
-                        
-                            ' set all remaining positions to 0
-                            For iLoc = Location To LocationNumber
-                                posGridXY_valid(iLoc) = 0
-                            Next iLoc
-                        
-                        Else
-                            
-                            ' only set all positions till the next well to 0
-                            For iLoc = Location To locationNumbersMainGrid(iWell + 1) - 1
-                                posGridXY_valid(iLoc) = 0
-                            Next iLoc
-                            
-                        End If
-                            
-                            
-                        ' select next position
-                        Location = locationNumbersMainGrid(iWell + 1)
-                           
-                        ' stop if done
-                        MsgBox "iWell+1 " + CStr(iWell + 1)
-                        If (Location > LocationNumber) Or (iWell + 1 > GridScan_nX.Value * GridScan_nY.Value) Then
-                            MsgBox "Done with the Location Checking."
-                            GoTo DoneWithLocations
-                        End If
-                            
-                    End If
-                    
-                End If
-                                
-                                
-                ' move to next Grid location
-                
-                ' compute whether we are entering a new well
-                If ((Location - 1) Mod (GridScan_nXsub.Value * GridScan_nYsub.Value)) = 0 Then
-                    
-                    nGoodCellsPerWell = 0
-                    
-                    If Location > 1 Then  ' iWell is already initialised with 1
-                        
-                        iWell = iWell + 1
-                    
-                    End If
-                        
-                    
-                End If
-                
-                
-                If posGridXY_valid(Location) Then
-                
-                    'MsgBox "Imaging next position " + CStr(Location) + "/" + CStr(LocationNumber) + "; well " + CStr(iWell) + "; status " + CStr(posGridXY_valid(Location))
-                    x = posGridX(Location)
-                    y = posGridY(Location)
-                    'GoTo NextLocation ' skip this position
-                    
-                Else
-                    
-                    'MsgBox "Skipping next position " + CStr(Location) + "/" + CStr(LocationNumber) + "; well " + CStr(iWell) + "; status " + CStr(posGridXY_valid(Location))
-                    'x = posGridX(Location)
-                    'y = posGridY(Location)
-                    GoTo NextLocation ' skip this position
-                    
-                End If
-                    
-                
-                'MsgBox "GridScan: x = " + CStr(x) + " y = " + CStr(y)
-                
-                Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-                
-                Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                    If ScanStop Then
-                        Lsm5.StopScan
-                        StopAcquisition
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        Exit Sub
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-            
-            End If
-        
-                     
-            If CheckBoxInnactivateAutofocus Then  ' Looking if needs to perform an autofocus
-                 
-                 ZShift = 0
-            
-            ElseIf CheckBoxZMap.Value Then
-                
-                ' do nothing
-                 
-            Else ' perform AUTOFOCUS
-                 
-                 AutofocusForm.GetBlockValues
-                 DisplayProgress "Autofocus 0", RGB(0, &HC0, 0)
-                 StopScanCheck
-                 RestoreAquisitionParameters ' has to be there, because after hires mode settings would be wrong for autofocus
-                 ' take a z-stack and finds the brightest plane:
-                 Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset, RecordingDoc
-                 CheckRefControl BlockZRange
-                 ' move the xyz to the right position
-                 Autofocus_MoveAquisition BlockZOffset
-                            
-            End If
-          
-          
-            ' AfterAutofocus:
-            
-            
-            ' Restore settings, which are changed during the AF
-            CopyRecording Lsm5.DsRecording, BackupRecording
-           
-            
-            Lsm5.DsRecording.TimeSeries = True  ' This is for the concatenation I think: we're doing a timeseries with one timepoint. I'm not sure why is the reason for this
-            Lsm5.DsRecording.StacksPerRecord = 1
-            
-            
-            If MultipleLocation Or Grid Or CheckBoxActivatedGridScan.Value Then                'Sets the name of the image to store in the database
-                LocationName = "_L" & Location
-            Else
-                LocationName = ""
-            End If
-              
-            If Grid Then
-                LocationName = "_" & GlobalLocationsName(Location) & LocationName
-            End If
-        
-            If TileX > 1 Or TileY > 1 Then
-                
-                'name = GlobalFileName & LocationName & "_R" & RepetitionNumber
-                'ScanImage.SetTitle name
-                
-            Else ' no tiling
-            
-                      
-                ' Alternative Acquisitions
-                
-                If CheckBoxAlterLocation.Value = True Then
-                    If Location Mod TextBox_RoundAlterLocation = 0 Then
-                        ActivateAlterAcquisitionTrack
-                        DisplayProgress "using alternative tracks", RGB(0, 0, &HC0)
-                    End If
-                End If
-                
-                If CheckBoxAlterImage = True Then
-                    alterName = GlobalFileName & LocationName & "_R" & RepetitionNumber ' & "_Add"
-                    StartAlternativeImaging RecordingDoc, StartTime, GlobalDataBaseName & "_Additional", alterName
-                End If
-            
-                
-                ' Normal Acquisitions
-                
-                ' restore acquisition parameters again which have changed during the Additional Acquisition
-                CopyRecording Lsm5.DsRecording, BackupRecording
-                Sleep (500)
-                
-                name = GlobalFileName & LocationName & "_R" & RepetitionNumber
-                
-                ' set the tracks to be imaged
-                DisplayProgress "Acquiring location " & Location & "(" & LocationNumber & "), repetition " & RepetitionNumber, RGB(&HC0, &HC0, 0) 'Now we're going to do the acquisition
-            
-                AutofocusForm.ActivateAcquisitionTrack
-                Sleep (500)
-                
-                If Not IsAcquisitionTrackSelected Then      'An additional control....
-                    StopAcquisition
-                    MsgBox "No track selected for Acquisition! Cannot Acquire!"
-                    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-                    Exit Sub
-                End If
-                
-                     
-                ' **** HERE THE IMAGE IS ACQUIRED ****
-                'Set RecordingDoc = Lsm5.StartScan()
-                If RecordingDoc Is Nothing Then
-                    Set RecordingDoc = Lsm5.NewScanWindow
-                    While RecordingDoc.IsBusy
-                        Sleep (20)
-                        DoEvents
-                    Wend
-                End If
-                ScanToImageNew RecordingDoc
-                ' ************************************
-                
-            End If
-                
-           
-            If RepetitionNumber = 1 Then
-                StartTime = GetTickCount    'Get the time when the acquisition was started
-            End If
-                
-                
-            'Wait the end of the scan
-            While AcquisitionController.IsGrabbing
-                Sleep (20)
-                If ScanStop Then
-                    Lsm5.StopScan
-                    StopAcquisition
-                    DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                    Exit Sub
-                End If
-                DoEvents
-            Wend
-            
-            ' store all normal acquistion parameters
-            ' CopyRecording Lsm5.DsRecording, BackupRecording
-                
-            RecordingDoc.SetTitle name
-            
-            Lsm5.tools.WaitForScanEnd False, 10
-             
-          
-            '' stitching of tiles: start ********************************************************************
-            
-            If TileX > 1 Or TileY > 1 Then
-                
-                RelativeLocation = Location Mod (TileX * TileY)
-                If RelativeLocation = 0 Then RelativeLocation = (TileX * TileY)
-                
-                If Lsm5.DsRecording.TrackObjectByIndex(0, Success).DataChannelObjectByIndex(0, Success).BitsPerSample > 8 Then
-                    Bytesperpixel = 2
-                Else
-                    Bytesperpixel = 1
-                End If
-                
-                If RelativeLocation = 1 Then 'at each first frame of a new tile group define a new image
-                    
-                    If AreStageCoordinateExchanged Then
-                        
-                        If Lsm5.DsRecording.scanMode = "Stack" Then
-                            Set StitchImage = Lsm5.ExternalDsObject.MakeNewImageDocument(CLng(Lsm5.DsRecording.RtRegionWidth * TileY), _
-                                                                         CLng(Lsm5.DsRecording.RtRegionHeight * TileX), _
-                                                                         Lsm5.DsRecording.FramesPerStack, _
-                                                                         1, _
-                                                                         Lsm5.DsRecording.NumberOfChannels, _
-                                                                         Bytesperpixel, _
-                                                                         1)
-                        Else
-                            Set StitchImage = Lsm5.ExternalDsObject.MakeNewImageDocument(CLng(Lsm5.DsRecording.RtRegionWidth * TileY), _
-                                                                         CLng(Lsm5.DsRecording.RtRegionHeight * TileX), _
-                                                                         1, _
-                                                                         1, _
-                                                                         Lsm5.DsRecording.NumberOfChannels, _
-                                                                         Bytesperpixel, _
-                                                                         1)
-                        End If
-                
-                
-                    Else
-                    
-                        If Lsm5.DsRecording.scanMode = "Stack" Then
-                            Set StitchImage = Lsm5.ExternalDsObject.MakeNewImageDocument(CLng(Lsm5.DsRecording.RtRegionWidth * TileX), _
-                                                                         CLng(Lsm5.DsRecording.RtRegionHeight * TileY), _
-                                                                         Lsm5.DsRecording.FramesPerStack, _
-                                                                         1, _
-                                                                         Lsm5.DsRecording.NumberOfChannels, _
-                                                                         Bytesperpixel, _
-                                                                         1)
-                        Else
-                            Set StitchImage = Lsm5.ExternalDsObject.MakeNewImageDocument(CLng(Lsm5.DsRecording.RtRegionWidth * TileX), _
-                                                                         CLng(Lsm5.DsRecording.RtRegionHeight * TileY), _
-                                                                         1, _
-                                                                         1, _
-                                                                         Lsm5.DsRecording.NumberOfChannels, _
-                                                                         Bytesperpixel, _
-                                                                         1)
-                        End If
-                
-                    End If ' AreStageCoordinateExchanged
-                
-                
-                    ' Todo: overlap is still missing ??
-                                                                         
-                    If StitchImage Is Nothing Then Exit Sub
-                        
-                    
-                End If ' RelativeLocation = 1
-                  
-                
-                StitchImage.NeverAgainScanToTheImage
-                
-                ' ImageCopy.SourceImage = RecordingDoc.Image(0, False)
-      
-                ImageCopy.SourceImage = ScanImage.image(0, False)
-                ImageCopy.DestinationImage = StitchImage.image(0, False)
-            
-                '        If RelativeLocation Mod TileY = 0 Then
-                '        ImageCopy.DestinationY = 0
-                '        Else
-                If AreStageCoordinateExchanged Then
-                    
-                    If RelativeLocation = 1 Then r = 1
-                        
-                    ImageCopy.DestinationX = (TileY - r) * Lsm5.DsRecording.RtRegionWidth
-                        
-                    If RelativeLocation Mod TileX = 0 Then r = r + 1
-                        'If RelativeLocation Mod TileX = 0 Then
-                        '            ImageCopy.DestinationX = 0
-                        '        Else
-                        '
-                        ' ImageCopy.DestinationX = CLng(Abs(1 - Int((RelativeLocation - 1) / TileX)) * Lsm5.DsRecording.RtRegionWidth)
-                        '
-                        '      End If
-                        If RelativeLocation Mod TileX = 0 Then
-                            ImageCopy.DestinationY = 0
-                        Else
-                            ImageCopy.DestinationY = CLng((TileX - (RelativeLocation Mod TileX)) * Lsm5.DsRecording.RtRegionWidth)
-                        End If
-                
-                    Else
-                        
-                        ImageCopy.DestinationY = CLng(Int((RelativeLocation - 1) / TileX) * Lsm5.DsRecording.RtRegionWidth)
-                            
-                        If RelativeLocation Mod TileX = 0 Then
-                            ImageCopy.DestinationX = 0
-                        Else
-                            ImageCopy.DestinationX = CLng(Abs((RelativeLocation Mod TileX) - TileX) * Lsm5.DsRecording.RtRegionWidth)
-                        End If
-                    
-                    End If ' RelativeLocation Mod TileX = 0 Then r = r + 1
-                            
-                    If RelativeLocation = 1 Then
-                        ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-                        StitchImage.SetVoxelSizeX CLng(Lsm5.DsRecording.RtRegionWidth * TileX)
-                        StitchImage.SetVoxelSizeY CLng(Lsm5.DsRecording.RtRegionHeight * TileY)
-                        
-                    Else
-                        ImageCopy.ImageParameterCopyFlags = 0
-                    End If
-                        
-                    ImageCopy.Start
-                    Set Progress = ImageCopy
-                    
-                    While Not Progress.Ready
-                       DoEvents
-                       Sleep (10)
-                       If ScanStop Then Exit Sub
-                    Wend
-                                
-                                
-                    ' Save the stitched image
-                    If RelativeLocation = TileX * TileY Then
-                        tilename = "Tile_" & GlobalLocationsName(Location) & "_L" & (Location / RelativeLocation) & "_R" & RepetitionNumber
-                        StitchImage.SetTitle tilename
-                        ' GlobalImageIndex(RepetitionNumber) = StitchImage.SaveToDatabase(TileDatabaseName, tilename)
-                        
-                        fullpathname = TileDatabaseName & "\" & tilename & ".lsm"
-                        SaveDsRecordingDoc StitchImage, fullpathname
-                        StitchImage.CloseAllWindows
-                    End If
-            
-            
-            End If
-            
-            
-            ''end stitching ********************************
-                
-                
-            ' Todo: check: will it overwrite the other image?
-            
-                    
-                    
-            If BleachStartTable(RepetitionNumber) > 0 Then          'If a bleach was performed we add the information to the image metadata
-                
-                Lsm5.DsRecordingActiveDocObject.AddEvent (BleachStartTable(RepetitionNumber) - StartTime) / 1000, eEventTypeBleachStart, "Bleach Start"
-                Lsm5.DsRecordingActiveDocObject.AddEvent (BleachStopTable(RepetitionNumber) - StartTime) / 1000, eEventTypeBleachStop, "Bleach End"
-            
-            End If
-            
-            
-            ' Now we save the image ********************
-            
-            bslash = "\"
-            Mypath = GlobalDataBaseName + bslash
-            filepath = Mypath & name & ".lsm"
-            
-            
-            fullpathname = GlobalDataBaseName & "\" & name & ".lsm"
-            
-            If TileX > 1 Or TileY > 1 Then
-                
-                SaveDsRecordingDoc ScanImage, fullpathname
-            
-            Else
-                
-                ' HERE THE IMAGE IS FINALLY SAVED
-                SaveDsRecordingDoc RecordingDoc, fullpathname
-                ' *******************************
-                
-            End If
-            
-            If ScanStop Then
-                Lsm5.StopScan
-                StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-            
-               
-            If OnlineImageAnalysis = False Then ' without MicroPilot
-                
-                If BleachTable(RepetitionNumber) = True Then   'Check if we're performing a bleach before image acquisition
-                    
-                    Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
-                    If Success Then
-                        DisplayProgress "Bleaching...", &HFF00FF
-                        DoEvents
-                        Track.UseBleachParameters = True            'Bleach parameters are lasers lines, bleach iterations... stored in the bleach control window
-    '                   BleachStartTable(RepetitionNumber) = Lsm5.ExternalCpObject.pHardwareObjects.pScanController.GetDspTime
-                        BleachStartTable(RepetitionNumber) = GetTickCount      'Get the time right before bleach to store this in the image metadata
-                        Lsm5.Bleach 0
-                        Lsm5.tools.WaitForScanEnd False, 1                     'Waits for the end of the bleach during one second, I think this is not long enough
-                        BleachStopTable(RepetitionNumber) = GetTickCount       'Get the time right after bleach to store this in the image metadata
-    '                   BleachStopTable(RepetitionNumber) = Lsm5.ExternalCpObject.pHardwareObjects.pScanController.GetDspTime
-                        Track.UseBleachParameters = False  'switch off the bleaching
-                    Else
-                        MsgBox ("Could not set bleach track. Did not bleach.")
-                    End If
-                    If Location = LocationNumber Then   'Alowas again to do an extrableach at the en
-                        ExtraBleachButton.Caption = "Bleach"
-                        ExtraBleachButton.BackColor = &H8000000F
-                    End If
-                
-                End If
-                
-                ' todo:
-                ' but where is the bleaching image stored ??
-                
-            End If
-                        
-                        
-            If OnlineImageAnalysis = True Then ' MicroPilot Active
-                            
-                SaveSetting "OnlineImageAnalysis", "macro", "filepath", filepath
-                Do While RecordingDoc.IsBusy
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        Exit Sub
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-                
-                SaveSetting "OnlineImageAnalysis", "macro", "Refresh", 0
-                SaveSetting "OnlineImageAnalysis", "macro", "code", 1
-    '            Sleep (600)
-    '            SaveSetting "OnlineImageAnalysis", "Ainput", "Refresh", 0
-            
-            End If
-               
-                
-            If LocationTracking Or FrameAutofocussing Then
-                'not used at the moment find code in unusedCode: ExcelXYZstoring II
-            End If
-                
-                
-            ' Defining new (x,y)z positions *****************************
-            If LocationTracking Then 'This is if we're doing some postacquisition tracking
-                
-                DisplayProgress "Analysing the new position of location " & Location, &H80FF&
-                DoEvents
-                MassCenter ("Tracking")
-                XCor = XMass
-                YCor = YMass
-                If TrackZ Then
-                    ZCor = ZMass
-                Else
-                    If HRZ Then
-                        ZCor = 0
-    '                        Success = Lsm5.Hardware.CpHrz.Leveling
-                    Else
-                        ZCor = 0
-                    End If
-                End If
-                '''''changed
-                If AreStageCoordinateExchanged Then
-                    XCor = YMass
-                    YCor = XMass
-                End If
-                '''changed
-            
-            Else ' no location tracking
-                
-                ' Todo: find out what is happening here
-                XCor = 0
-                YCor = 0
-                If HRZ Then
-                    ZCor = 0
-                    Success = Lsm5.Hardware.CpHrz.Leveling   'This I think puts the HRZ to its resting position, and moves the focuswheel correspondingly
-                Else
-                    ZCor = 0
-                End If
-            
-            End If
-                    
-                    
-            Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                
-                If ScanStop Then
-                    Lsm5.StopScan
-                    StopAcquisition
-                    DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                    Exit Sub
-                End If
-                DoEvents
-                Sleep (5)
-                
-            Loop
-                
-                
-            x = Lsm5.Hardware.CpStages.PositionX + XCor                     'Records the current X,Y,Z positions
-            y = Lsm5.Hardware.CpStages.PositionY - YCor
-            z = Lsm5.Hardware.CpFocus.Position + ZCor
-            ' End: Defining new (x,y)z positions
-                
-            
-            ' Setting new (x,y)z positions ***************************
-            ' Todo: what is this doing ??? probably updating the positions
-            If MultipleLocation Or Grid Then
-            
-                Success = Lsm5.Hardware.CpStages.MarkClear(0)                   'Deletes the first mark location in the stage control (the current one)
-                                                                                'This deletion and new addition of the location was necessary to change the X, Y and Z properties of that location. I did not know how to do it otherwise
-                Lsm5.Hardware.CpStages.MinMarkDistance = 0.1                    'Put a very small mark distance to make it possible to have two cells coming close together. This parameter can be cahnged with the macro but is not accessible from the main software !
-                While Lsm5.Hardware.CpStages.MarkGetIndex(x, y) <> -1
-                    x = x + 0.1
-                    y = y + 0.1
-                Wend
-                
-                ' update the stage positions (particularly important for Location Tracking
-                Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ(x, y, z) 'Adds the location again,at the end of the list
-                
-                Lsm5.Hardware.CpStages.MinMarkDistance = 10                     'Put back the minimal marking distance to its default value
-                'test if this is working
-                Do While Lsm5.Info.IsAnyHardwareBusy
-                    Sleep (20)
-                    DoEvents
-                Loop
-                
-            Else  ' In the single location case with postacquisition tracking one still has to move to the new focus before next acquisition
-                
-                Lsm5.Hardware.CpFocus.Position = z + ZBacklash          'Note that ZBacklash was not initialized to -50
-                Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                    Sleep (20)
-                    DoEvents
-                Loop
-                Lsm5.Hardware.CpFocus.Position = z
-                Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                    Sleep (20)
-                    DoEvents
-                Loop
-                
-                If LocationTracking Then   ' In the single location case one also neess to correct for the XY movements if location tracking is activated
-                    Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-                    Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                        If ScanStop Then
-                            Lsm5.StopScan
-                            StopAcquisition
-                            DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                            Exit Sub
-                        End If
-                        DoEvents
-                        Sleep (5)
-                    Loop
-                End If
-            
-            End If
-                
-            ''  End: Setting new (x,y)z positions *******************************
-             
-             
-             
-            ' COMMUNICATION WITH MICROPILOT: START *****************
-              
-            If OnlineImageAnalysis Then
-                
-                MicroscopePilot RecordingDoc, BleachingActivated, HighResExperimentCounter, HighResCounter, HighResArrayX, HighResArrayY, HighResArrayZ
-            
-            End If
-            
-            If CheckBoxGridScan_FindGoodPositions Then
-                    
-                'MsgBox "nGoodCells " + CStr(nGoodCells) + " minGoodCells " + CStr(minGoodCellsPerImage)
-                
-                If nGoodCells >= minGoodCellsPerImage Then
-                    posGridXY_valid(Location) = 1 ' image this position
-                Else
-                    MsgBox "not enough cells; remove this image from position list"
-                    posGridXY_valid(Location) = 0 ' do not image this position
-                End If
-                
-            End If
-                
-            
-            ' COMMUNICATION WITH MICROPILOT: END *****************
-                 
-                 
-            ' the following is done here already, beacuse in case the imaging ends the
-            ' zoom settings are still on, which would be annoying
-            
-            ' reset all acquistion parameters
-            CopyRecording Lsm5.DsRecording, BackupRecording  ' destination <- source
-            
-            ' reset the imaging tracks
-            ActivateAcquisitionTrack
-             
-             
-NextLocation:
-        
-        
-        Next Location
-            
-            
-DoneWithLocations:
-            
-        
-        ' DONE WITH THE IMAGING....NOW POSTPROCESSING...
-        
-        If AutomaticBleaching Then
-            FillBleachTable     ' Updating the bleaching table before the next acquisitions, just in case there were changes n the bleaching window
-        End If
-        
-        
-        If (RepetitionNumber < BlockRepetitions) Then
-            
-            GlobalPrvTime = CDbl(GetTickCount) * 0.001      'Parameters for the waiting. This I took over from the initial Zeiss Macro
-            rettime = GlobalPrvTime
-            difftime = rettime - GlobalPrvTime
-            Do While (difftime <= BlockTimeDelay) And Not (BleachTable(RepetitionNumber + 1) = True)        'This loops define the waiting delay before going back to the first location
-                If ExtraBleach Then                                 'Modifies the bleaching table to do an Extrableach for al locatins at the next repetition
-                    ExtraBleach = False
-                    BleachTable(RepetitionNumber + 1) = True
-                End If
-                If ScanPause = True Then
-                    Pause
-                End If
-                If ScanStop Then
-                    StopAcquisition
-                    DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                    Exit Sub
-                End If
-                DisplayProgress "Waiting " & CStr(CInt(BlockTimeDelay - difftime)) + " s before scanning repetition  " & (RepetitionNumber + 1), RGB(&HC0, &HC0, 0)
-                DoEvents
-                Sleep (10)
-                rettime = CDbl(GetTickCount) * 0.001
-                difftime = rettime - GlobalPrvTime
-            Loop
-            GlobalPrvTime = rettime
-            
-        Else
-            
-            Running = False  ' done with everything
-        
-        End If
-        
-        RepetitionNumber = RepetitionNumber + 1
-        ' TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-        
-    
-    Loop ' RepetitonLoop ; Do While Running
-    
-    ' set back the tracks to be imaged
-    ActivateAcquisitionTrack
-            
-    StopAcquisition
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-
-
-End Sub
-
-Public Sub MassCenter(Context As String)
-    Dim scrline As Variant
-    Dim spl As Long
-    Dim bpp As Long
-    Dim ColMax As Long
-    Dim LineMax As Long
-    Dim FrameNumber As Integer
-    Dim PixelSize As Double
-    Dim FrameSpacing As Double
-    Dim Intline() As Long
-    Dim IntCol() As Long
-    Dim IntFrame() As Long
-    Dim channel As Integer
-    Dim frame As Long
-    Dim line As Long
-    Dim Col As Long
-    Dim MinColValue As Single
-    Dim minLineValue As Single
-    Dim minFrameValue As Single
-    Dim MaxColValue As Single
-    Dim MaxLineValue As Single
-    Dim MaxframeValue As Single
-    Dim LineSum As Double
-    Dim LineWeight As Single
-    Dim MidLine As Single
-    Dim Threshold As Single
-    Dim LineValue As Single
-    Dim PosValue As Single
-    Dim ColSum As Single
-    Dim ColWeight As Single
-    Dim MidCol As Single
-    Dim ColValue As Single
-    Dim FrameSum As Single
-    Dim FrameWeight As Single
-    Dim MidFrame As Single
-    Dim FrameValue As Single
-    
-   
-    'Lsm5Vba.Application.ThrowEvent eRootReuse, 0                   'Was there in the initial Zeiss macro, but it seems notnecessary
-    DoEvents
-    'Gets the dimensions of the image in X (Columns), Y (lines) and Z (Frames)
-    If FrameAutofocussing And SystemName = "LIVE" Then ' binning only with LIVE device
-        ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth '/ Lsm5.DsRecordingActiveDocObject.Recording.RtBinning
-        LineMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionHeight
-    Else
-        If SystemName = "LIVE" Then
-            ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth
-            LineMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionHeight
-        ElseIf SystemName = "LSM" Then
-            ColMax = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
-            LineMax = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-        Else
-            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-            Exit Sub
-        End If
-    End If
-    If Lsm5.DsRecordingActiveDocObject.Recording.scanMode = "ZScan" Or Lsm5.DsRecordingActiveDocObject.Recording.scanMode = "Stack" Then
-        FrameNumber = Lsm5.DsRecordingActiveDocObject.Recording.FramesPerStack
-    Else
-        FrameNumber = 1
-    End If
-    'Gets the pixel size
-    PixelSize = Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing * 1000000
-    'Gets the distance between frames in Z
-    FrameSpacing = Lsm5.DsRecordingActiveDocObject.Recording.FrameSpacing
-    
-    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
-    ReDim Intline(LineMax) As Long
-    ReDim IntCol(ColMax) As Long
-    ReDim IntFrame(FrameNumber) As Long
-
-    'Select the image channel on which to do the calculations
-    If Context = "Autofocus" Then       'Takes the first channel in the context of preacquisition focussing
-        channel = 0
-    ElseIf Context = "Tracking" Then    'Takes the channle selected in the pop-up menue when doing postacquisition tracking
-        For channel = 0 To Lsm5.DsRecordingActiveDocObject.GetDimensionChannels - 1
-            If Lsm5.DsRecordingActiveDocObject.ChannelName(channel) = Left(TrackingChannelString, 4) Then
-                Exit For
-            End If
-        Next channel
-    End If
-    
-   'lineMax = 1
-
-    'Reads the pixel values and fills the tables with the projected (integrated) pixels values in the three directions
-    For frame = 1 To FrameNumber
-        For line = 1 To LineMax
-            bpp = 0
-            channel = 0
-            scrline = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, frame - 1, line - 1, spl, bpp) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-            For Col = 2 To ColMax               'Now I'm scanning all the pixels in the line
-                Intline(line - 1) = Intline(line - 1) + scrline(Col - 1)
-                IntCol(Col - 1) = IntCol(Col - 1) + scrline(Col - 1)
-                IntFrame(frame - 1) = IntFrame(frame - 1) + scrline(Col - 1)
-            Next Col
-        Next line
-    Next frame
-    
-    'First it finds the minimum and maximum porjected (integrated) pixel values in the 3 dimensions
-    MinColValue = 4095 * LineMax * FrameNumber           'The maximum values are initially set to the maximum possible value
-    minLineValue = 4095 * ColMax * FrameNumber
-    minFrameValue = 4095 * LineMax * ColMax
-    MaxColValue = 0                                     'The maximun values are initialliy set to 0
-    MaxLineValue = 0
-    MaxframeValue = 0
-    For line = 1 To LineMax
-        If Intline(line - 1) < minLineValue Then
-            minLineValue = Intline(line - 1)
-        End If
-        If Intline(line - 1) > MaxLineValue Then
-            MaxLineValue = Intline(line - 1)
-        End If
-    Next line
-    For Col = 1 To ColMax
-        If IntCol(Col - 1) < MinColValue Then
-            MinColValue = IntCol(Col - 1)
-        End If
-        If IntCol(Col - 1) > MaxColValue Then
-            MaxColValue = IntCol(Col - 1)
-        End If
-    Next Col
-    For frame = 1 To FrameNumber
-        If IntFrame(frame - 1) < minFrameValue Then
-            minFrameValue = IntFrame(frame - 1)
-        End If
-        If IntFrame(frame - 1) > MaxframeValue Then
-            MaxframeValue = IntFrame(frame - 1)
-        End If
-    Next frame
-
-    'Calculates the threshold values. It is set to an arbitrary value of the minimum projected value plus 20% of the difference between the minimum and the maximum projected value.
-    'Then calculates the center of mass
-    LineSum = 0
-    LineWeight = 0
-    MidLine = (LineMax + 1) / 2
-    If CheckBoxRefControl.Value = True Then
-        If (MaxframeValue - minFrameValue) < minFrameValue * 0.5 Or MaxframeValue = 0 Then NoReflectionSignal = True
-    End If
-    Threshold = minLineValue + (MaxLineValue - minLineValue) * 0.8         'Threshold calculation
-    For line = 1 To LineMax
-        LineValue = Intline(line - 1) - Threshold                           'Subtracs the threshold
-        PosValue = LineValue + Abs(LineValue)                               'Makes sure that the value is positive or zero. If LineValue is negative, the Posvalue = 0; if Line value is positive, then Posvalue = 2*LineValue
-        LineWeight = LineWeight + (PixelSize * (line - MidLine)) * PosValue 'Calculates the weight of the Thresholded projected pixel values according to their position relative to the center of the image and sums them up
-        LineSum = LineSum + PosValue                                        'Calculates the sum of the thresholded pixel values
-    Next line
-    If LineSum = 0 Then
-        YMass = 0
-    Else
-        YMass = LineWeight / LineSum                                       'Normalizes the weights to get the center of mass
-    End If
-
-    ColSum = 0
-    ColWeight = 0
-    MidCol = (ColMax + 1) / 2
-    Threshold = MinColValue + (MaxColValue - MinColValue) * 0.8
-    For Col = 1 To ColMax
-        ColValue = IntCol(Col - 1) - Threshold
-        PosValue = ColValue + Abs(ColValue)
-        ColWeight = ColWeight + (PixelSize * (Col - MidCol)) * PosValue
-        ColSum = ColSum + PosValue
-    Next Col
-    If ColSum = 0 Then
-        XMass = 0
-    Else
-        XMass = ColWeight / ColSum
-    End If
-
-    FrameSum = 0
-    FrameWeight = 0
-    MidFrame = (FrameNumber + 1) / 2
-    Threshold = minFrameValue + (MaxframeValue - minFrameValue) * 0.8
-    For frame = 1 To FrameNumber
-        FrameValue = IntFrame(frame - 1) - Threshold
-        PosValue = FrameValue + Abs(FrameValue)
-        FrameWeight = FrameWeight + (FrameSpacing * (frame - MidFrame)) * PosValue
-        FrameSum = FrameSum + PosValue
-    Next frame
-    
-    If FrameSum = 0 Then
-        ZMass = 0
-    Else
-        ZMass = FrameWeight / FrameSum
-    End If
-        
-End Sub
-
-
-Private Sub StopButton_Click()
-        ScanStop = True
-        DisplayProgress "Restore Settings", RGB(&HC0, 0, 0)
-        ChangeButtonStatus True
-End Sub
-
-Public Sub StopAcquisition()
-    Dim FileName As String
-    Running = False
-    ScanStop = False
-    RepetitionNumber = 1
-    ScanPause = False
-    PauseButton.Caption = "Pause"
-    PauseButton.BackColor = &H8000000F
-    ExtraBleach = False
-    ExtraBleachButton.Caption = "Bleach"
-    ExtraBleachButton.BackColor = &H8000000F
-    ReDim BleachTable(BlockRepetitions)
-    ReDim BleachStartTable(BlockRepetitions)
-    ReDim BleachStopTable(BlockRepetitions)
-    BleachingActivated = False
-    If LocationTracking Or FrameAutofocussing Then
-'        For i = 1 To PositionData.Sheets.count
-'            PositionData.Sheets.Item(i).Select
-'            Cells.Select
-'            Selection.Columns.AutoFit
-'        Next i
-'        FileName = Left(DataBaseLabel, Len(DataBaseLabel) - 4) & ".xls"
-'        PositionData.SaveAs FileName:=FileName, FileFormat:=xlNormal, Password:="", WriteResPassword:="", ReadOnlyRecommended:=False, CreateBackup:=False
-'        PositionData.Close
-'        Excel.Application.Quit
-    End If
-    
-    ChangeButtonStatus True  'tischi
-
-End Sub
-
-Private Sub PauseButton_Click()
-    If Running Then
-        If ScanPause = False Then
-            ScanPause = True
-            PauseButton.Caption = "Resume"
-            PauseButton.BackColor = 12648447
-        Else
-            ScanPause = False
-            PauseButton.Caption = "Pause"
-            PauseButton.BackColor = &H8000000F
-        End If
-    Else
-        MsgBox "The acquisition has not started yet or is already finished. Cannot pause."
-    End If
-End Sub
-
-Public Sub Pause()
-    
-    Dim rettime As Double
-    Dim GlobalPrvTime As Double
-    SetFocusButton.Enabled = True
-    AutofocusButton.Enabled = True
-    GlobalPrvTime = CDbl(GetTickCount) * 0.001
-    rettime = GlobalPrvTime
-    difftime = rettime - GlobalPrvTime
-    Do While True
-        DisplayProgress "Pause " & CStr(CInt(difftime)) & " s", RGB(&HC0, &HC0, 0)
-        If ScanStop Then
-            Exit Sub
-        End If
-        If ScanPause = False Then
-            SetFocusButton.Enabled = False
-            AutofocusButton.Enabled = False
-            Exit Sub
-        End If
-        DoEvents
-        Sleep (20)
-        rettime = CDbl(GetTickCount) * 0.001
-        difftime = rettime - GlobalPrvTime
-    Loop
-
-End Sub
-
-
-Private Sub ExtraBleachButton_Click()
-    
-    If Running Then
-        ExtraBleach = True
-        ExtraBleachButton.Caption = "Will Bleach"
-        ExtraBleachButton.BackColor = 12648447
-    Else
-        MsgBox "The acquisition has not started yet or is already finished. Cannot bleach."
-    End If
-
-End Sub
-
-
-
-Private Sub GridToggle_Change()
-
-
-    If GridToggle.Value = True Then
-        
-        If MultipleLocationToggle.Value = True Then MultipleLocationToggle.Value = Not GridToggle.Value
-        If SingleLocationToggle.Value = True Then SingleLocationToggle.Value = Not GridToggle.Value
-        GridObjectsandVarialbles True
-        CheckBoxScannAll.Visible = False
-        StartBleachButton.Visible = False
-        ExtraBleachButton.Visible = False
-        If MultipleLocationToggle.Value = True Then MultipleLocationToggle.Value = Not GridToggle.Value
-        If SingleLocationToggle.Value = True Then SingleLocationToggle.Value = Not GridToggle.Value
-        
-    End If
-
-End Sub
-
-Private Sub MultipleLocationToggle_Change()
-    
-    If MultipleLocationToggle.Value = True Then
-        SetMultipleLocationToggle_True
-    Else
-        SingleLocationToggle.Value = True
-    End If
-    
-End Sub
-Private Sub SingleLocationToggle_Change()
-    
-    If SingleLocationToggle.Value = True Then
-        SetSingleLocationToggle_True
-    Else
-        MultipleLocationToggle.Value = True
-    End If
-
-End Sub
-
-Private Sub SetSingleLocationToggle_True()
-                
-        ' MsgBox "Setting Single Locations True"
-        
-        SingleLocationToggle.Value = True
-        MultipleLocationToggle.Value = False
-        MultipleLocation = False
-        Label15.Caption = ""
-        
-        ' CheckBoxScannAll.Visible = False
-        ' GridObjectsandVarialbles False
-        ' StartBleachButton.Visible = True
-        ' ExtraBleachButton.Visible = True
-        ' Frame15.Visible = False
-        ' If GridToggle.Value = True Then GridToggle.Value = Not SingleLocationToggle.Value
-
-End Sub
-  
-Private Sub SetMultipleLocationToggle_True()
-  
-        ' MsgBox "Setting Multiple Locations True"
-        
-        SingleLocationToggle.Value = False
-        MultipleLocationToggle.Value = True
-        MultipleLocation = True
-        Label15.Caption = "Define locations using the Stage (NOT the Positions) dialog !"
-        
-        CheckBoxActivatedGridScan.Value = False ' currently not compatible
-        
-        
-        ' CheckBoxScannAll.Visible = False
-        ' GridObjectsandVarialbles False
-        ' StartBleachButton.Visible = True
-        ' ZMapButton.Left = 12
-        ' ZMapButton.Top = 258
-        ' CheckBoxZMap.Left = 80
-        ' CheckBoxZMap.Top = 258
-        
-        'ZMapButton.Visible = True
-        'CheckBoxZMap.Visible = True
-        'ExtraBleachButton.Visible = True
-        'Frame15.Visible = True
-        'TextBoxTileX.Visible = True
-        'TextBoxTileY.Visible = True
-        'Tileframe.Visible = True
-        'Label17.Visible = True
-        'Label18.Visible = True
-        'Label20.Visible = True
-        'CreateLocationsButton.Visible = True
-        'TextBoxOverlap.Visible = True
-        'If GridToggle.Value = True Then GridToggle.Value = Not MultipleLocationToggle.Value
-        
-End Sub
-  
-  
-Private Sub GridObjectsandVarialbles(Activate As Boolean)
-   ' ZMapButton.Left = 198.05
-   ' ZMapButton.Top = 306
-    ZMapButton.Visible = Activate
-    CreateLocationsButton.Visible = Activate
-    CommandButtonRemove.Visible = Activate
-    CommandButtonGrid.Visible = Activate
-    CommandButtonStoreApply.Visible = Activate
-    TextBoxYGrid.Visible = Activate
-    TextBoxXGrid.Visible = Activate
-    TextBoxYStep.Visible = Activate
-    TextBoxXStep.Visible = Activate
-    Tileframe.Visible = Activate
-    Frame16.Visible = Activate
-    Frame15.Visible = Activate
-    Label1.Visible = Activate
-    Label2.Visible = Activate
-    Label3.Visible = Activate
-    Label4.Visible = Activate
-    Label5.Visible = Activate
-   ' Label16.Visible = Activate
-    Label7.Visible = Activate
-    Label17.Visible = Activate
-    Label18.Visible = Activate
-    Label20.Visible = Activate
-    TextBoxOverlap.Visible = Activate
-    TextBoxTileX.Visible = Activate
-    TextBoxTileY.Visible = Activate
-   ' CheckBoxKeepSteps.Visible = Activate
-    CheckBoxMeander.Visible = Activate
-  '  CheckBoxZMap.Left = 132
-   ' CheckBoxZMap.Top = 288
-    CheckBoxZMap.Visible = Activate
-    'LabelGrid.Visible = Activate
-    Label15.Visible = Not Activate
-    Grid = GridToggle.Value
-    MultipleLocation = MultipleLocationToggle.Value ' Sets the MultipleLocation Boolean to False
-
-
-End Sub
-
-Public Sub AutoFindTracks()
-
-    Dim i, j As Integer
-    Dim ChannelOK As Boolean
-    Dim DataChannel As DsDataChannel
-    Dim Color As Long
-    Dim ConfiguredTracks As Integer
-    Dim GoodTracks As Integer
-
-    
-    OptionButtonTrack1.Visible = False
-    OptionButtonTrack1.Enabled = False
-    OptionButtonTrack1.Value = False
-    CheckBoxTrack1.Visible = False
-    CheckBoxTrack1.Enabled = False
-    CheckBoxTrack1.Value = False
-    CheckBoxZoomTrack1.Visible = False
-    CheckBoxZoomTrack1.Enabled = False
-    CheckBoxZoomTrack1.Value = False
-    CheckBox2ndTrack1.Visible = False
-    CheckBox2ndTrack1.Enabled = False
-    CheckBox2ndTrack1.Value = False
-                         
-    
-    OptionButtonTrack2.Visible = False
-    OptionButtonTrack2.Enabled = False
-    OptionButtonTrack2.Value = False
-    CheckBoxTrack2.Visible = False
-    CheckBoxTrack2.Enabled = False
-    CheckBoxTrack2.Value = False
-    CheckBoxZoomTrack2.Visible = False
-    CheckBoxZoomTrack2.Enabled = False
-    CheckBoxZoomTrack2.Value = False
-    CheckBox2ndTrack2.Visible = False
-    CheckBox2ndTrack2.Enabled = False
-    CheckBox2ndTrack2.Value = False
-    
-    OptionButtonTrack3.Visible = False
-    OptionButtonTrack3.Enabled = False
-    OptionButtonTrack3.Value = False
-    CheckBoxTrack3.Visible = False
-    CheckBoxTrack3.Enabled = False
-    CheckBoxTrack3.Value = False
-    CheckBoxZoomTrack3.Visible = False
-    CheckBoxZoomTrack3.Enabled = False
-    CheckBoxZoomTrack3.Value = False
-    CheckBox2ndTrack3.Visible = False
-    CheckBox2ndTrack3.Enabled = False
-    CheckBox2ndTrack3.Value = False
-   
-    OptionButtonTrack4.Visible = False
-    OptionButtonTrack4.Enabled = False
-    OptionButtonTrack4.Value = False
-    CheckBoxTrack4.Visible = False
-    CheckBoxTrack4.Enabled = False
-    CheckBoxTrack4.Value = False
-    CheckBoxZoomTrack4.Visible = False
-    CheckBoxZoomTrack4.Enabled = False
-    CheckBoxZoomTrack4.Value = False
-    CheckBox2ndTrack4.Visible = False
-    CheckBox2ndTrack4.Enabled = False
-    CheckBox2ndTrack4.Value = False
-   
-
-    ConfiguredTracks = Lsm5.DsRecording.TrackCount
-    ChannelOK = False
-    GoodTracks = 0
-    
-    'The next line and the following "if" should be removed when working with the LSM 2.8 software (where the lambda mode is not defined)
-    Set Track = Lsm5.DsRecording.TrackObjectLambda(Success)
-    If Success Then
-        If Track.Acquire Then
-            MsgBox ("This macro does not work in the Lambda Mode. Please switch to the Channel Mode and reinitialize the Macro.")
-            Exit Sub
-        End If
-    End If
-            
-    For i = 1 To ConfiguredTracks
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, Success)
-        TrackName = Track.name
-        j = 0
-        'In the next line remove "Or Track.IslambdaTrack" when working with the LSM 2.8 software
-        If Not (Track.IsBleachTrack Or Track.IsLambdaTrack) Then
-            Do While (Not ChannelOK) And (j < Track.DataChannelCount)
-                Set DataChannel = Track.DataChannelObjectByIndex(j, Success)
-                If DataChannel.Acquire = True Then ChannelOK = True
-                Color = DataChannel.ColorRef
-                j = j + 1
-            Loop
-            If ChannelOK Then
-                If Not Track.IsRatioTrack Then
-                    GoodTracks = GoodTracks + 1
-                    If GoodTracks = 5 Then
-                        MsgBox ("This Macro only accepts 4 different tracks")
-                    End If
-                    If GoodTracks = 1 Then
-                        OptionButtonTrack1.Visible = True
-                        OptionButtonTrack1.Caption = TrackName
-                        OptionButtonTrack1.Enabled = True
-                        OptionButtonTrack1.BackColor = Color
-                        
-                        CheckBoxTrack1.Visible = True
-                        CheckBoxTrack1.Caption = TrackName
-                        CheckBoxTrack1.Enabled = True
-                        CheckBoxTrack1.BackColor = Color
-                        
-                        CheckBoxZoomTrack1.Visible = True
-                        CheckBoxZoomTrack1.Caption = TrackName
-                        CheckBoxZoomTrack1.Enabled = True
-                        CheckBoxZoomTrack1.BackColor = Color
-                        
-                        CheckBox2ndTrack1.Visible = True
-                        CheckBox2ndTrack1.Caption = TrackName
-                        CheckBox2ndTrack1.Enabled = True
-                        CheckBox2ndTrack1.BackColor = Color
-                        
-                    End If
-                    If GoodTracks = 2 Then
-                        OptionButtonTrack2.Visible = True
-                        OptionButtonTrack2.Caption = TrackName
-                        OptionButtonTrack2.Enabled = True
-                        OptionButtonTrack2.BackColor = Color
-                        CheckBoxTrack2.Visible = True
-                        CheckBoxTrack2.Caption = TrackName
-                        CheckBoxTrack2.Enabled = True
-                        CheckBoxTrack2.BackColor = Color
-                        
-                        CheckBoxZoomTrack2.Visible = True
-                        CheckBoxZoomTrack2.Caption = TrackName
-                        CheckBoxZoomTrack2.Enabled = True
-                        CheckBoxZoomTrack2.BackColor = Color
-                        
-                        CheckBox2ndTrack2.Visible = True
-                        CheckBox2ndTrack2.Caption = TrackName
-                        CheckBox2ndTrack2.Enabled = True
-                        CheckBox2ndTrack2.BackColor = Color
-                        
-                    End If
-                    If GoodTracks = 3 Then
-                        OptionButtonTrack3.Visible = True
-                        OptionButtonTrack3.Caption = TrackName
-                        OptionButtonTrack3.Enabled = True
-                        OptionButtonTrack3.BackColor = Color
-                        
-                        CheckBoxTrack3.Visible = True
-                        CheckBoxTrack3.Caption = TrackName
-                        CheckBoxTrack3.Enabled = True
-                        CheckBoxTrack3.BackColor = Color
-                        
-                        CheckBoxZoomTrack3.Visible = True
-                        CheckBoxZoomTrack3.Caption = TrackName
-                        CheckBoxZoomTrack3.Enabled = True
-                        CheckBoxZoomTrack3.BackColor = Color
-                        
-                        CheckBox2ndTrack3.Visible = True
-                        CheckBox2ndTrack3.Caption = TrackName
-                        CheckBox2ndTrack3.Enabled = True
-                        CheckBox2ndTrack3.BackColor = Color
-                        
-                    End If
-                    If GoodTracks = 4 Then
-                        OptionButtonTrack4.Visible = True
-                        OptionButtonTrack4.Caption = TrackName
-                        OptionButtonTrack4.Enabled = True
-                        OptionButtonTrack4.BackColor = Color
-                        
-                        CheckBoxTrack4.Visible = True
-                        CheckBoxTrack4.Caption = TrackName
-                        CheckBoxTrack4.Enabled = True
-                        CheckBoxTrack4.BackColor = Color
-                        
-                        CheckBoxZoomTrack4.Visible = True
-                        CheckBoxZoomTrack4.Caption = TrackName
-                        CheckBoxZoomTrack4.Enabled = True
-                        CheckBoxZoomTrack4.BackColor = Color
-                        
-                        CheckBox2ndTrack4.Visible = True
-                        CheckBox2ndTrack4.Caption = TrackName
-                        CheckBox2ndTrack4.Enabled = True
-                        CheckBox2ndTrack4.BackColor = Color
-                        
-                    End If
-                Else
-                    MsgBox ("This macro does not allow to use a Ratio Channel. The Ratio Channel will thus be disabled.")
-                    For j = 0 To Track.DataChannelCount - 1
-                        Set DataChannel = Track.DataChannelObjectByIndex(j, Success)
-                        DataChannel.Acquire = False
-                    Next
-                End If
-                ChannelOK = False
-            End If
-        End If
-    Next
-    If GoodTracks < 4 Then
-        TrackNumber = GoodTracks
-    Else
-        TrackNumber = 4
-    End If
-End Sub
-
-
-
-Private Sub BSliderZoffset_Change()
-    'Tests whether chosen Offset is less or equal to half of the working distance of the objective but why can't it be bigger??
-'    Dim Position As Long 'gets the postion of the actual objective revolver by number
-'    Dim Range As Double 'contains value of working distance in um
-    If flgUserChange Then '??? What is the sense of flgUserChange
-'        Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-'        If Position >= 0 Then ' ??? is it possible that Revolver Position has another value
-'            Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000# ' ??? why is there a # behind that number if range is already defined as double
-'                                                                                            ' in which unit is working distance read out and why multiplication with 1000
-'        Else
-'            Range = 0#
-'        End If
-'substituted29.06.2010 by Function Range
-        If Abs(BSliderZOffset.Value) > Range * 0.9 Then
-            BSliderZOffset.Value = 0
-            MsgBox "Zoffset has to be less than the working distance of the objective: " + CStr(Range) + " um"
-        End If
-    End If
-End Sub
-
-
-
-
-Private Sub BSliderZRange_Change()    ' It should be possible to change the limit of the range to bigger values than half of the working distance
-'    Dim Position As Long
-'    Dim Range As Double
-    If flgUserChange Then
-'        Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-'        If Position >= 0 Then
-'            Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-'        Else
-'            Range = 0#
-'        End If
-'substituted29.06.2010 by Function Range
-        If BSliderZRange.Value > Range * 0.9 Then
-            BSliderZRange.Value = Range * 0.9
-            MsgBox "ZRange has to be less or equal to the working distance of the objective: " + CStr(Range) + " um"
-        End If
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub CloseButton_Click()
-    AutoStore
-'    Excel.Application.DisplayAlerts = False
-'    Excel.Application.Quit
-    End
-End Sub
-
-Private Sub ReInitializeButton_Click()
-    Re_Initialize
-End Sub
-
-Private Sub CommandButtonStore_Click()
-    StoreApply.Show
-End Sub
-
-Private Sub TextBox_RoundAlterTrack_Change()
-
-End Sub
-
-Private Sub TextBox_RoundAlterLocation_Change()
-
-End Sub
-
-Private Sub TextBox1_Change()
-
-End Sub
-
-Private Sub TextBoxAlterAutofocusZOffset_Change()
-
-End Sub
-
-Private Sub TextBoxAlterInterval_Change()
-
-End Sub
-
-Private Sub TextBoxAlterNumSlices_Change()
-
-End Sub
-
-Private Sub TextBoxAlterZoom_Change()
-
-End Sub
-
-Private Sub TextBoxZoomAutofocusZOffset_Change()
-
-End Sub
-
-Private Sub TextBoxZoomCycles_Change()
-
-End Sub
-
-Private Sub UserForm_Initialize()           ' This contained some initialization  that have then been deleted or moved to Re_Start
-    Re_Start
-End Sub
-
-
-Private Sub Re_Start()                      'Initializations that need to be performed only at the first start of the Macro
-    Dim delay As Single
-    Dim standType As String
-    Dim Count As Long
-    Dim ImageDatabase As DsGuidedModeDatabase
-    Dim i As Long
-    Dim MruList As DsMruList
-    Dim cnt As Long
-    Dim lpReOpenBuff As OFSTRUCT
-    Dim wStyle As Long
-    Dim lpRootPathName As String
-    Dim lpSectorsPerCluster As Long
-    Dim lpBytesPerSector As Long
-    Dim lpNumberOfFreeClusters As Long
-    Dim lpTotalNumberOfClusters As Long
-    Dim lSpace As Long
-    Dim lFreeSpace As Double
-    Dim fSize As Double
-    Dim hFile As Long
-   
-    
-    Set tools = Lsm5.tools
-    GlobalMacroKey = "Autofocus"
-   
-'    bRunning = False
- '   LbStatus = "inactive"
-    flgUserChange = True
-    delay = 1
-    flgEvent = 7
-    flg = 0
-    Lsm5.StopScan
-    Wait (delay)
-    TimerUnit = 1
-    CommandTimeSec.BackColor = &HFF8080
-    BlockRepetitions = 1
-    ReDim Preserve GlobalImageIndex(BlockRepetitions)
-    ScanLineToggle.Value = True
-    'SingleLocationToggle.Value = True
-    Label15.Caption = ""
-    GlobalProject = "AutofocusScreen1.7"
-    GlobalProjectName = GlobalProject + ".lvb"
-    HelpNamePDF = "AutofocusScreen_help.pdf"
-    Re_Initialize ' Continues the initialization process
-  
-     
-    
-End Sub
-
-
-Public Sub Re_Initialize()                  'Initializations that need to be performed only when clicling the "initialize" button
-    Dim delay As Single
-    Dim standType As String
-    Dim Count As Long
-    Dim bLSM As Boolean
-    Dim bLIVE As Boolean
-    Dim bCamera As Boolean
-    
-'    StopAcquisition
-'    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    AutoFindTracks
-  
-    BSliderZOffset.Value = 0
-    BSliderZRange.Value = 80
-    BSliderZStep.Value = 0.1
-    TextBoxXGrid.Value = 3
-    TextBoxYGrid.Value = 2
-    TextBoxXStep.Value = -1125
-    TextBoxYStep.Value = 1125
-    BSliderScanSpeed = 1000
-    BSliderRepetitions = 300
-    BSliderTime = 1
-    
-    CheckBoxLowZoom = False
-    CheckBoxInnactivateAutofocus = False
-    PubSearchScan = False
-    NoReflectionSignal = False
-    PubSentStageGrid = False
-    GlobalZmapAquired = False
-    
-    
-'    took this out, because at the LSM we have an HRZ but the LSM Software does not give the right signal for that, but now you can can use the HRZ
-'    If Lsm5.Hardware.CpHrz.Exist("HRZ") = True Then     'Check if an HRZ is available. If not the "HRZ checkbox is not available.
-'        CheckBoxHRZ.Visible = True
-'        CheckBoxHRZ.Value = True
-'    Else
-'    CheckBoxHRZ.Visible = False
-'    CheckBoxHRZ.Value = False
-'    End If
-    
-    ScanLineToggle.Value = True
-    ' SingleLocationToggle.Value = True
-    UsedDevices40 bLSM, bLIVE, bCamera
-    ' Todo what is bLSM ?
-    If bLSM Then
-        SystemName = "LSM"
-        CheckBoxHighSpeed.Value = True
-'        CheckBoxHighSpeed.Visible = True
-'        CheckBoxHighSpeed.Top = 48
-'        CheckBoxLowZoom.Top = 71.35
-'        CheckBoxHRZ.Top = 90.95
-'        CheckBoxRefControl.Top = 110.6
-     
-        BSliderFrameSize.Min = 16
-        BSliderFrameSize.Max = 1024
-        BSliderFrameSize.Step = 8
-        BSliderFrameSize.StepSmall = 4
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    
-        DoEvents
-    ElseIf bLIVE Then
-        
-        SystemName = "LIVE"
-'            CheckBoxHighSpeed.Value = False
-'            CheckBoxHighSpeed.Visible = False
-'            CheckBoxHRZ.Top = 85
-'            CheckBoxRefControl.Top = 108
-'            CheckBoxLowZoom.Top = 60
-'            BSliderFrameSize.ValueEditable = False
-        BSliderFrameSize.Min = 128
-        BSliderFrameSize.Max = 1024
-        BSliderFrameSize.Step = 128
-        BSliderFrameSize.StepSmall = 128
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-                        
-    ElseIf bCamera Then
-        SystemName = "Camera"
-    End If
-    '  AutofocusForm.Caption = GlobalProject + " for " + SystemName
-    BleachingActivated = False
-      
-End Sub
-
-Private Sub CreditButton_Click()
-    CreditForm.Show
-End Sub
-
-Private Sub TrackingToggle_Click()                                          ' Sets the parameters for postacquisition tracking
-    
-    LocationTracking = TrackingToggle.Value
-    ComboBoxTrackingChannel.Visible = TrackingToggle.Value
-    FillTrackingChannelList
-    CheckBoxTrackZ.Visible = TrackingToggle.Value
-    If Lsm5.DsRecording.scanMode = "Stack" Then
-        CheckBoxTrackZ.Enabled = True
-    Else
-        CheckBoxTrackZ.Enabled = False
-        CheckBoxTrackZ.Value = False
-    End If
-
-End Sub
-
-
-'fills popup menu for chosing a track for post-acquisition tracking in ScanLine mode
-Private Sub FillTrackingChannelList()
-    Dim t As Integer
-    Dim c As Integer
-    Dim ca As Integer
-    Dim channel As DsDetectionChannel
-
-    ActivateAcquisitionTrack 'will set IsAcquisitionTrack selected true if a valid track is selected for acquisition, and "marks the track in the Zeiss config window
-    
-    ReDim ActiveChannels(Lsm5.Constants.MaxActiveChannels)  'ActiveChannels is a dynamic array (variable size), ReDim defines array size required next
-                                                            'Array size is (MaxActiveChannels gets) the total max number of active channels in all tracks
-    ComboBoxTrackingChannel.Clear 'Content of popup menu for chosing track for post-acquisition tracking is deleted
-    ca = 0
-    
-    If IsAcquisitionTrackSelected Then 'IsAcquisitionTrackSelected is True if one channel is activated in tracks 1-4
-        For t = 1 To TrackNumber 'This loop goes through all tracks and will collect all activated channels to display them in popup menu
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(t - 1, Success) 'goes through all defined tracks
-            If Track.Acquire Then 'if track is activated for acquisition
-                For c = 1 To Track.DetectionChannelCount 'for every detection channel of track
-                    Set channel = Track.DetectionChannelObjectByIndex(c - 1, Success)
-                    If channel.Acquire Then 'if channel is activated
-                        ca = ca + 1 'counter for active channels will increase by one
-                        ComboBoxTrackingChannel.AddItem Track.name & " " & channel.name 'entry is added to combo box to chose track for post-acquisition tracking
-                        ActiveChannels(ca) = channel.name & "-T" & Track.MultiplexOrder + 1  'adds entry to ActiveChannel Array with name of channel + name of track
-                    End If
-                Next c
-            End If
-        Next t
-        
-        ComboBoxTrackingChannel.Value = ComboBoxTrackingChannel.List(0) 'initially displayed text in popup menu is a blank line (first channel is 1).
-    End If
-End Sub
-Private Sub ComboBoxTrackingChannel_Change()        'Sets the name of the channel for PostAcquisition tracking.
-    TrackingChannelString = ActiveChannels(ComboBoxTrackingChannel.ListIndex + 1)
-End Sub
-Private Sub CheckBoxTrackZ_Click()
-    TrackZ = CheckBoxTrackZ.Value
-    If CheckBoxTrackZ.Value = True Then
-        CheckBoxInnactivateAutofocus.Value = True                  'If posacquisition Z-tracking is activated, it is necessary to deactivate autofocussing
-        CheckBoxInnactivateAutofocus.BackColor = 33023
-        CheckBoxTrackZ.BackColor = 33023
-    Else
-        CheckBoxTrackZ.BackColor = &H8000000F
-    End If
-End Sub
-
-Private Sub CommandTimeMin_Click()
-    TimerUnit = 60
-    BSliderTime.Max = 60                        'When workings with minutes the maximum delay that can be set with the slider is 1 hour
-    BSliderTime.Value = BlockTimeDelay / 60
-    CommandTimeMin.BackColor = &HFF8080
-    CommandTimeSec.BackColor = &H8000000F
-End Sub
-
-Private Sub CommandTimeSec_Click()
-    TimerUnit = 1
-    BSliderTime.Max = 180                       'When workings with seconds the maximum delay that can be set with the slider is 3 minutes
-    BSliderTime.Value = BlockTimeDelay
-    CommandTimeSec.BackColor = &HFF8080
-    CommandTimeMin.BackColor = &H8000000F
-End Sub
-
-Private Sub BSliderTime_Click()
-    BlockTimeDelay = BSliderTime.Value * TimerUnit                      'BlockTimedelay gets the value of the slider in seconds
-End Sub
-
-Private Sub BSliderRepetitions_Change()
-    If Not Running Then
-        BlockRepetitions = BSliderRepetitions.Value
-    ElseIf Not (BSliderRepetitions.Value <= (RepetitionNumber + 1)) Then
-        BlockRepetitions = BSliderRepetitions.Value
-    Else
-        BSliderRepetitions.Value = RepetitionNumber + 1
-        BlockRepetitions = BSliderRepetitions.Value
-    End If
-    
-    ReDim Preserve GlobalImageIndex(BlockRepetitions)           'The global image index I'm not sure how this is working.
-    ReDim Preserve BleachTable(BlockRepetitions)                'BleachTable defines when bleaching will have to occur
-    If AutomaticBleaching Then FillBleachTable                  'Reads the parameters defined in the Bleach control window of the main software
-    ReDim Preserve BleachStartTable(BlockRepetitions)           'This is to store the timepoints when the bleaches started. Preserve is to keep the timepoints if the slider is moved during an experiment
-    ReDim Preserve BleachStopTable(BlockRepetitions)            'This is to store the timepoints when the bleaches stopped. Preserve is to keep the timepoints if the slider is moved during an experiment
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub TextBoxFileName_Change()
-    GlobalFileName = TextBoxFileName.Value
-End Sub
-
-Private Sub CommandButtonSelectDataBase_Click()
-    Dim lpReOpenBuff As OFSTRUCT
-    Dim wStyle As Long
-    Dim hFile As Long
-    Dim flgUserChangeSaved As Boolean
-    flgUserChangeSaved = flgUserChange
-    flgUserChange = False
-
-    'Common Dialog is used to open folders and files in windows
-    CommonDialog.FileName = GlobalDataBaseName                      'remembers which was the latest Database that was opened
-    CommonDialog.Filter = "Database files ( *.mdb ) |*.mdb"         'filter to only display database files
-    CommonDialog.ShowOpen
-    hFile = OpenFile(CommonDialog.FileName, lpReOpenBuff, wStyle)
-    If hFile <> -1 Then
-        GlobalDataBaseName = CommonDialog.FileName                  'Store the path of the database in the GlobalDatabaseName variable
-        DataBaseLabel.Caption = CommonDialog.FileName
-    Else
-        MsgBox "Selected file does not exist"
-    End If
-    flgUserChange = flgUserChangeSaved
-End Sub
-
-Private Sub CommandButtonNewDataBase_Click()   'Creates a new database
-    'test for ZEN
-    GlobalDataBaseName = DatabaseTextbox.Value
-    DatabaseLable.Caption = GlobalDataBaseName
-
-'    Lsm5.NewDatabase (NewDatabase)              'Directly opens the LSM window to create a new database
-'    Lsm5.CloseAllDatabaseWindows                'Strange that this is there and not before the previous line...
-'    GlobalDataBaseName = Lsm5.MruDatabases.name(0)      'Write the name of the database in a varialbe (used afterwards for saving to the right database)
-'    DataBaseLabel.Caption = Lsm5.MruDatabases.name(0)   'Indicates the name of the databse for the user to check
-End Sub
- 
-Public Sub ActivateAutofocusTrack(HighSpeed As Boolean)
-    Dim i As Integer
-
-    IsAutofocusTrackSelected = False
-    For i = 1 To TrackNumber
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, Success)
-        If i = 1 Then
-            If OptionButtonTrack1.Value = True Then
-                Track.Acquire = 1
-                IsAutofocusTrackSelected = True
-                AutofocusTrack = i - 1
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 2 Then
-            If OptionButtonTrack2.Value = True Then
-                Track.Acquire = 1
-                IsAutofocusTrackSelected = True
-                AutofocusTrack = i - 1
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 3 Then
-            If OptionButtonTrack3.Value = True Then
-                Track.Acquire = 1
-                IsAutofocusTrackSelected = True
-                AutofocusTrack = i - 1
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 4 Then
-            If OptionButtonTrack4.Value = True Then
-                Track.Acquire = 1
-                IsAutofocusTrackSelected = True
-                AutofocusTrack = i - 1
-           Else
-                Track.Acquire = 0
-            End If
-        End If
-    Next i
-    
-    If HighSpeed Then
-        Track.SamplingNumber = 1
-    End If
-    
-    
-End Sub
-
-
-Public Sub ActivateAlterAcquisitionTrack()
-    Dim i As Integer
-         
-    IsAcquisitionTrackSelected = False
-    
-    For i = 1 To TrackNumber
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, Success)
-        If i = 1 Then
-            If CheckBox2ndTrack1.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 2 Then
-            If CheckBox2ndTrack2.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 3 Then
-            If CheckBox2ndTrack3.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 4 Then
-            If CheckBox2ndTrack4.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-    Next i
-
-End Sub
-
-
-Public Sub ActivateAcquisitionTrack()
-    Dim i As Integer
-
-    'this loop goes through all tracks; it will check for actual track in loop whether corresponding checkbox is activated
-    'if checkbox of one of tracks is selected IsAcquisitionTrack will be set true
-    'is this so complicated to be sure that if one track is chosen this track is a track that is defined in track list ???
-    
-    IsAcquisitionTrackSelected = False
-    For i = 1 To TrackNumber 'TrackNumber is maximum 4 or less (see definition with GoodTracks)
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, Success) 'choses track corresponding to track number
-        If i = 1 Then
-            If CheckBoxTrack1.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-    
-        End If
-        If i = 2 Then
-            If CheckBoxTrack2.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 3 Then
-            If CheckBoxTrack3.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 4 Then
-            If CheckBoxTrack4.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-    Next i
-
-End Sub
-
-
-
-Private Sub ActivateZoomTrack()
-    Dim i As Integer
-
-    IsAcquisitionTrackSelected = False
-    For i = 1 To TrackNumber
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(i - 1, Success)
-        If i = 1 Then
-            If CheckBoxZoomTrack1.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 2 Then
-            If CheckBoxZoomTrack2.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 3 Then
-            If CheckBoxZoomTrack3.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-        If i = 4 Then
-            If CheckBoxZoomTrack4.Value = True Then
-                Track.Acquire = 1
-                IsAcquisitionTrackSelected = True
-            Else
-                Track.Acquire = 0
-            End If
-        End If
-    Next i
-End Sub
-
-Sub Wait(PauseTime As Single)
-    Dim Start As Single
-    Start = Timer   ' Set start time.
-    Do While Timer < Start + PauseTime
-       DoEvents    ' Yield to other processes.
-       'Lsm5.DsRecording.StartScanTriggerIn
-    Loop
-End Sub
-
-Public Sub SetFocus(ZRange As Double, ZStep As Double, HighSpeed As Boolean, Zoffset As Double)
-    Dim SpeedCopy As Double
-    Dim ZoomXCopy As Double
-    Dim ZoomYCopy As Double
-    Dim SamplesPerLineCopy As Long
-    Dim LinesPerFrameCopy As Long
-    Dim ScanModeCopy As String
-    Dim SpecialScanModeCopy As String
-
-'    Dim Range As Double
-'    Dim Position As Long
-  
-    Dim MyRecording As DsRecording
-
-    Dim Tnum As Long
-    Dim i As Long
-    Dim Success As Integer
-    Dim NewPicture As DsRecordingDoc
-    Dim Pixel As Long
-    Dim scrline As Variant
-    Dim PxlArray() As Long
-    Dim spl As Long
-    Dim bpp As Long
-    Dim IntensityStr As String
-    Dim ChNumber As Long
-    Dim channel As Long
-    Dim LongRange As Long
-    Dim PxlMax As Long
-    Dim PxlTot As Long
-    Dim LineMax As Long
-    Dim StackSize As Double
-    Dim SavedSampling As Long
-    Dim key As String
-    Dim line As Long
-    Dim lT As Long
-    'Dim NoFrames As Long MadePublic29.06.2010
-    Dim SystemVersion As String
-    Dim Speed As Long
-    Dim MaxSpeed As Long
-    
-   
-        
-    Zbefore = Lsm5.Hardware.CpFocus.Position
-    
-    DisplayProgress "Get Offset Value", RGB(0, &HC0, 0)             'Gives information to the user
-    StopScanCheck
-    
-    ' ZAuto = 0   removed29.07.2010                                                    'I do not know why is this Z Auto there. I believe it is obsolete
-    ' ZBacklash = -50 'Has to do with the movements of the focus wheel that are "better" if they are long enough.
-    
-    StoreAquisitionParameters
-    
-    
-    ActivateAutofocusTrack HighSpeed                                'Sets the track for autofocussing (i.e. "selects" the track in the Zeiss config window )
-    If Not IsAutofocusTrackSelected Then                                'The variable IsAutofocusTrackSelected has been updated in the ActivateAutofocausTrack function
-        MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-        Exit Sub
-    End If
-  
-'    Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition       'Verifies that the working distnce is OK. Comes from the initial Zeiss autofocussing macro
-'    If Position >= 0 Then
-'        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-'    Else
-'        Range = 0#
-'    End If
-'substituted29.06.2010 by Function Range
-    
-    'MsgBox "Zoffset = " + CStr(Zoffset) + "; Range = " + CStr(Range) + "; ZRange = " + CStr(ZRange)
-    
-    If Range = 0 Then
-        MsgBox "Objective's working distance not defined! Cannot Autofocus!"
-        Exit Sub
-    End If
-    If ZRange > Range * 0.9 Then
-        ZRange = Range * 0.9
-    End If
-    If Abs(Zoffset) > Range * 0.9 Then                   'The offset has to be within half of the working distance. May want to change this when working with large samples in Z
-        Zoffset = 0
-    End If
-
-    SystemVersionOffset
-    
-    AutofocusForm.AutofocusSetting HRZ, BlockHighSpeed, BlockZStep
-    Lsm5.DsRecording.FrameSpacing = ZStep
-    NoFrames = CLng(ZRange / ZStep) + 1                     'Calculates the number of frames per stack. Clng converts it to a long and rounds up the fraction
-    Lsm5.DsRecording.FramesPerStack = NoFrames
-    
-    If NoFrames > 2048 Then                                 'overwrites the userdefined value if too many frames have been defined by the user
-        NoFrames = 2048
-    End If
-    
-    'If Not HRZ Then
-        Lsm5.DsRecording.Sample0Z = ZStep * NoFrames / 2
-    'End If                                                    'Distance of the actual focus to the first Z position of the image (or line) to acquire in the stack.
-                                                            'I think this is only valid for the focus wheel and not the HRZ
-    
-    If Zoffset <= Range * 0.9 Then
-       
-       'MsgBox " Doing ZBacklash "
-       
-       Lsm5.Hardware.CpFocus.Position = Zbefore - Zoffset + GlobalCorrectionOffset + ZBacklash 'Move down 50um (=ZBacklash) below the position of the offset
-       Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-            Sleep (20)  '20ms
-            DoEvents
-       Loop
-       Lsm5.Hardware.CpFocus.Position = Zbefore - Zoffset + GlobalCorrectionOffset             'Moves up to the position of the offset
-       Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-           Sleep (20)
-           DoEvents
-       Loop
-    
-    End If
-    
-
-    If Not FrameAutofocussing Then
-        Lsm5.DsRecording.scanMode = "ZScan"
-        If Not HRZ Then
-            Lsm5.DsRecording.SpecialScanMode = "OnTheFly"
-        End If
-    End If
-    
-    Set NewPicture = Lsm5.StartScan                             'Starts the image acquisition for autofocussing
-    Do While NewPicture.IsBusy                                  ' Waiting untill the image acquisition is done
-        If ScanStop Then
-            Lsm5.StopScan
-            GoTo Abort
-        End If
-        DoEvents
-        Sleep (10)
-    Loop
-    Lsm5.tools.WaitForScanEnd False, 40                        'This looks redoundant with the previous, but I had trried to remove it and had problems. It's better to have 2 contols than none !
- 
-    AutofocusForm.MassCenter ("Autofocus")                                    'Calculates the mass center in 3 dimensions
-    xShift = XMass
-    yShift = YMass
-    ZShift = ZMass
-    
-    'check if Z shift makes sense
-    CheckRefControl BlockZRange
-        
-    If Zoffset <= Range * 0.9 Then
-       Lsm5.Hardware.CpFocus.Position = Zbefore + GlobalCorrectionOffset + ZBacklash  'Move down 50um (=ZBacklash) below the position of the offset
-       Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-            Sleep (20)  '20ms
-            DoEvents
-       Loop
-       Lsm5.Hardware.CpFocus.Position = Zbefore + GlobalCorrectionOffset             'Moves up to the position of the offset
-       Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-           Sleep (20)
-           DoEvents
-       Loop
-    End If
-
-    If HRZ Then                             'The HRZ and the focus wheel are acquiring Z stacks in opposite directions
-        Zoffset = -ZShift + Zoffset
-    Else
-        Zoffset = -ZShift + Zoffset
-    End If
-    BSliderZOffset.Value = Zoffset          'Writes the calculated value in the offset value
-
-Abort:
-   RestoreAquisitionParameters
-    Set GlobalBackupRecording = Nothing
-'   Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents                                'Finnish everything which had started
-    'ActivateAcquisitionTrack                'Activates the tracks for image acquisition
-    
-    If ScanStop = True Then
-        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-        ScanStop = False
-    Else
-        DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    End If
-
-
-End Sub
-
-
-Public Sub SetBlockValues()
-'    Dim Position As Long
-'    Dim Range As Double
- 
-    CheckBoxHighSpeed.Value = BlockHighSpeed
-    CheckBoxLowZoom.Value = BlockLowZoom
-    CheckBoxHRZ.Value = BlockHRZ
-'    Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-'    If Position >= 0 Then
-'        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-'    Else
-'        Range = 0#
-'    End If
-'substituted29.06.2010 by Function Range
-    If BlockZRange > Range * 0.9 Then
-        BlockZRange = Range * 0.9
-    End If
-    If Abs(BlockZOffset) > Range * 0.9 Then
-        BlockZOffset = 0
-    End If
-    BSliderZOffset.Value = BlockZOffset
-    BSliderZRange.Value = BlockZRange
-    BSliderZStep.Value = BlockZStep
-
-End Sub
-
-
-Public Sub GetBlockValues()
-   
-    BlockHighSpeed = CheckBoxHighSpeed.Value
-    BlockLowZoom = CheckBoxLowZoom.Value
-    HRZ = CheckBoxHRZ.Value
-    BlockZOffset = BSliderZOffset.Value
-    BlockZRange = BSliderZRange.Value
-    BlockZStep = BSliderZStep.Value
-
-End Sub
-
-
-
-Private Function TimeDisplay(Value As Double) As String         'Calculates the String to display in a "user frindly format". Value is in seconds
-    Dim Hour, Min As Integer
-    Dim Sec As Double
-
-    Hour = Int(Value / 3600)                                        'calculates number of full hours                           '
-    Min = Int(Value / 60) - (60 * Hour)                             'calculates number of left minutes
-    Sec = (Fix((Value - (60 * Min) - (3600 * Hour)) * 100)) / 100   'calculates the number of left seconds
-    If (Hour = 0) And (Min = 0) Then                                'Defines a "user friendly" string to display the time
-        TimeDisplay = Sec & " sec"
-    ElseIf (Hour = 0) And (Sec = 0) Then
-        TimeDisplay = Min & " min"
-    ElseIf (Hour = 0) Then
-        TimeDisplay = Min & " min " & Sec
-    Else
-        TimeDisplay = Hour & " h " & Min
-    End If
-End Function
-
-
-Public Function AcquisitionTime() As Double
-    Dim Track1Speed, Track2Speed, Track3Speed, Track4Speed As Double
-    Dim Pixels As Long
-    Dim FrameNumber As Integer
-    Dim ScanDirection As Integer
-    Dim i As Integer
-   
-    Track1Speed = 0
-    Track2Speed = 0
-    Track3Speed = 0
-    Track4Speed = 0
-    If CheckBoxTrack1.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, Success)
-        Track1Speed = Track.SampleObservationTime
-    End If
-    If CheckBoxTrack2.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-        Track2Speed = Track.SampleObservationTime
-    End If
-    If CheckBoxTrack3.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(2, Success)
-        Track3Speed = Track.SampleObservationTime
-    End If
-    If CheckBoxTrack4.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(3, Success)
-        Track4Speed = Track.SampleObservationTime
-    End If
-    Pixels = Lsm5.DsRecording.LinesPerFrame * Lsm5.DsRecording.SamplesPerLine
-    FrameNumber = Lsm5.DsRecording.FramesPerStack
-    If Lsm5.DsRecording.ScanDirection = 0 Then
-        ScanDirection = 1
-    Else
-        ScanDirection = 2
-    End If
-    AcquisitionTime = (Track1Speed + Track2Speed + Track3Speed + Track4Speed) * Pixels * FrameNumber / ScanDirection * 3.3485
-End Function
-
-
-
-Private Sub CheckBoxTrack1_Change()
-'    AcquisitionTimeFrame.Caption = TimeDisplay(AcquisitionTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    FillTrackingChannelList
-End Sub
-
-Private Sub CheckBoxTrack2_Change()
-'    AcquisitionTimeFrame.Caption = TimeDisplay(AcquisitionTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    FillTrackingChannelList
-End Sub
-
-Private Sub CheckBoxTrack3_Change()
-'    AcquisitionTimeFrame.Caption = TimeDisplay(AcquisitionTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    FillTrackingChannelList
-End Sub
-
-Private Sub CheckBoxTrack4_Change()
-'    AcquisitionTimeFrame.Caption = TimeDisplay(AcquisitionTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-    FillTrackingChannelList
-End Sub
-
-
-
-Public Function AutofocusTime() As Double
-    Dim Speed As Double
-    Dim Pixels As Long
-    Dim FrameNumber As Integer
-    Dim ScanDirection As Integer
-    Dim i As Integer
-
-    Speed = 0
-    If CheckBoxHighSpeed.Value = True Then
-        Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(0, Success)
-        Speed = 1.76 * 10 ^ -6
-    Else
-        If OptionButtonTrack1.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-            Speed = Track.SampleObservationTime
-        End If
-        If OptionButtonTrack2.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-            Speed = Track.SampleObservationTime
-        End If
-        If OptionButtonTrack3.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-            Speed = Track.SampleObservationTime
-        End If
-        If OptionButtonTrack4.Value = True Then
-            Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(1, Success)
-            Speed = Track.SampleObservationTime
-        End If
-    End If
-    Pixels = 512
-    AutofocusForm.GetBlockValues
-    FrameNumber = CLng(BlockZRange / BlockZStep) + 1
-    If Lsm5.DsRecording.ScanDirection = 0 Then
-        ScanDirection = 1
-    Else
-        ScanDirection = 2
-    End If
-    If CheckBoxHRZ.Value = True Then
-        AutofocusTime = Speed * Pixels * FrameNumber * 3.3485 + 4.9
-    Else
-        AutofocusTime = Speed * Pixels * FrameNumber / ScanDirection * 3.3485 + 4.9
-    End If
-End Function
-
-
-
-Public Sub CheckBoxHRZ_Change() 'I was trying to display the time needed for autofocus, single image acquisition and total time of the experiments, but I gave and and commented out those functions
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Public Sub CheckBoxHighSpeed_Change()  'I was trying to display the time needed for autofocus, single image acquisition and total time of the experiments, but I gave and and commented out those functions
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub BSliderZStep_Change()  'I was trying to display the time needed for autofocus, single image acquisition and total time of the experiments, but I gave and and commented out those functions
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub OptionButtonTrack1_Click()
-    If OptionButtonTrack1.Value Then 'if track 1 checked others are not autofocus track but false
-        OptionButtonTrack2.Value = Not OptionButtonTrack1.Value
-        OptionButtonTrack3.Value = Not OptionButtonTrack1.Value
-        OptionButtonTrack4.Value = Not OptionButtonTrack1.Value
-        CheckAutofocusTrack (1) 'sets SelectedTrack to 1, see below
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub OptionButtonTrack2_Click()
-    If OptionButtonTrack2.Value Then
-        OptionButtonTrack1.Value = Not OptionButtonTrack2.Value
-        OptionButtonTrack3.Value = Not OptionButtonTrack2.Value
-        OptionButtonTrack4.Value = Not OptionButtonTrack2.Value
-        CheckAutofocusTrack (2)
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub OptionButtonTrack3_Click()
-    If OptionButtonTrack3.Value Then
-        OptionButtonTrack1.Value = Not OptionButtonTrack3.Value
-        OptionButtonTrack2.Value = Not OptionButtonTrack3.Value
-        OptionButtonTrack4.Value = Not OptionButtonTrack3.Value
-        CheckAutofocusTrack (3)
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-Private Sub OptionButtonTrack4_Click()
-    If OptionButtonTrack4.Value Then
-        OptionButtonTrack1.Value = Not OptionButtonTrack4.Value
-        OptionButtonTrack2.Value = Not OptionButtonTrack4.Value
-        OptionButtonTrack3.Value = Not OptionButtonTrack4.Value
-        CheckAutofocusTrack (4)
-    End If
-'    AutofocusTimeFrame.Caption = TimeDisplay(AutofocusTime)
-'    TotalTimeLeftFrame.Caption = TimeDisplay(TotalTimeLeft)
-End Sub
-
-
-'this Function checks whether the track that was selected for autofocusing only contains a single channel (alternetivly defines one of the checked channels)
-'and finds the name of the autofocusing channel
-Private Sub CheckAutofocusTrack(SelectedTrack)
-    Dim Track As DsTrack 'a new track is defined
-    Dim DataChannel As DsDataChannel    'a new interface to a data channel is defined
-                                        'contains channel dependend parameters of the
-                                        'scan memory/display/calculation of scan data during scan operation
-    Dim ActiveChannelNumber As Integer
-    Dim AutofocusChannel As String
-    Dim j As Integer
-    
-    Set Track = Lsm5.DsRecording.TrackObjectByMultiplexOrder(SelectedTrack - 1, Success)
-        'gets the track object by multiplexorder which starts with 0
-        'since selected track starts with 1 (see CheckAutofocusTrack (n)), 1 has to be substracted
-        
-    'the following loop will count the number of activated channels in the track chosen for autofocusing
-    ActiveChannelNumber = 0
-    
-    For j = 0 To Track.DataChannelCount - 1 'gets number of channels that are potentially activatable in track
-        Set DataChannel = Track.DataChannelObjectByIndex(j, Success) 'data channel corresponding to loop index is analysed
-        If DataChannel.Acquire = True Then  'checks whether the data channel corresponding to loop index is activated
-            ActiveChannelNumber = ActiveChannelNumber + 1 'counts the number of activated channels
-            If ActiveChannelNumber = 1 Then AutofocusChannel = DataChannel.name 'Gets the name of the first activated channel
-        End If
-    Next
-    
-    If ActiveChannelNumber > 1 Then 'if more than one channel is activated...
-        MsgBox ("The track you selected has more than one active Channel. " & AutofocusChannel & " will be used to calculate autofocus parameters.")
-    End If
-End Sub
-
-
-Public Function TotalTimeLeft() As Double
-    Dim Speed As Double
-    Dim Pixels As Long
-    Dim ScanDirection As Integer
-    Dim i As Integer
-    TotalTimeLeft = (AcquisitionTime + AutofocusTime + BlockTimeDelay) * (BlockRepetitions - RepetitionNumber + 1) - BlockTimeDelay
-End Function
-
-
-Public Sub AutofocusSetting(HRZ As Boolean, HighSpeed As Boolean, ZStep As Double)
-    
-    If BlockLowZoom Then                                         'Changes the zoom if necessary
-        Lsm5.DsRecording.ZoomX = 1
-        Lsm5.DsRecording.ZoomY = 1
-    End If
-        
-    Lsm5.DsRecording.TimeSeries = False                     'Disable the timeseries, because autofocussing is juste one image at one timepoint.
-    
-    If FrameAutofocussing Then                              'Setting the way the Stage is going to move in Z, plus speed and number of pixels
-        
-        Lsm5.DsRecording.scanMode = "Stack"                 'This is defining to acquire a Z stack of Z-Y images
-        
-        If HRZ Then
-            
-            Lsm5.DsRecording.SpecialScanMode = "ZScanner"
-        
-        Else
-    
-            ' !!!!!!!!!!!! potential error source  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-            ' improvement
-            If SystemName = "LSM" Then
-                Lsm5.DsRecording.SpecialScanMode = "FocusStep"
-        
-                'Lsm5.DsRecording.FrameSpacing = ZStep
-                '    NoFrames = CLng(ZRange / ZStep) + 1
-                '    Lsm5.DsRecording.FramesPerStack = NoFrames
-                '    If NoFrames > 2048 Then
-                '        NoFrames = 2048
-                '    End If
-                    Lsm5.DsRecording.Sample0Z = ZStep * NoFrames / 2
-            Else
-                Lsm5.DsRecording.SpecialScanMode = "OnTheFly"
-                Lsm5.DsRecording.FramesPerStack = 1201
-                Lsm5.DsRecording.Sample0Z = Range / 2
-                Lsm5.DsRecording.FrameSpacing = Range / 1200
-                Sleep (100)
-            End If
-                
-        End If
-        
-        
-        If HighSpeed Then
-            Lsm5.DsRecording.ScanDirection = 1                  'If Highspeed is selected it uses the bidirectionnal scanning
-        End If
-        If SystemName = "LIVE" Then
-            Lsm5.DsRecording.RtRegionWidth = BSliderFrameSize.Value 'If doing frame autofocussing it uses the userdefined frame size
-            Lsm5.DsRecording.RtBinning = 512 / BSliderFrameSize.Value
-            Lsm5.DsRecording.RtRegionHeight = BSliderFrameSize.Value
-        ElseIf SystemName = "LSM" Then
-            Lsm5.DsRecording.SamplesPerLine = BSliderFrameSize.Value  'If doing frame autofocussing it uses the userdefined frame size
-            'Lsm5.DsRecording.RtBinning = 4
-            Lsm5.DsRecording.LinesPerFrame = BSliderFrameSize.Value
-        Else
-            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-        Exit Sub
-        End If
-    
-    
-    Else  ' Not FrameAutoFocussing
-        
-        Lsm5.DsRecording.scanMode = "ZScan"                     'This is defining to acquire a single X-Z image, like what is done with the "Range" button in the LSM ScanControl window
-        If HRZ Then
-        
-            Lsm5.DsRecording.SpecialScanMode = "ZScanner"
-            If SystemName = "LIVE" Then
-                Lsm5.DsRecording.RtLinePeriod = 1 / BSliderScanSpeed.Value
-                Lsm5.DsRecording.RtRegionWidth = 512
-                Lsm5.DsRecording.RtRegionHeight = 1
-            ElseIf SystemName = "LSM" Then
-                'MsgBox "HRZ LSM 256"
-                Lsm5.DsRecording.SamplesPerLine = 256
-                Lsm5.DsRecording.LinesPerFrame = 1
-            Else
-                MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-                Exit Sub
-            End If
-           
-        Else ' Not HRZ
-        
-            'Lsm5.DsRecording.SpecialScanMode = "FocusStep" ' I this does not work, use "FocusStep"
-            Lsm5.DsRecording.SpecialScanMode = "OnTheFly"
-            
-        End If
-        
-        
-        If SystemName = "LIVE" Then
-            
-            Lsm5.DsRecording.RtLinePeriod = 1 / BSliderScanSpeed.Value
-            Lsm5.DsRecording.RtRegionWidth = 512
-            Lsm5.DsRecording.RtRegionHeight = 1
-            
-       
-        ElseIf SystemName = "LSM" Then
-                Lsm5.DsRecording.SamplesPerLine = 256
-                Lsm5.DsRecording.LinesPerFrame = 1
-        Else
-                MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-                Exit Sub
-        End If
-        
-    End If
-    
-    
-    Sleep (100)
-    
-End Sub
-
-''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-''''''''''''''''''''''''''''''''''Grid Definition'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-Private Sub TextBoxXgrid_Change()
-        If IsNumeric(TextBoxXGrid.Value) Then
-            GlobalXGrid = TextBoxXGrid.Value
-        Else
-             MsgBox "Please enter the number of columns!"
-        End If
-        
-        ReDim GlobalDeActivatedLocations(GlobalMaximumPositions, GlobalXGrid * GlobalYGrid)
-        ReDim GlobalLocationsOrder(GlobalMaximumPositions, GlobalXGrid * GlobalYGrid)
-        GlobalOrderChanged = True
-    End Sub
-
-Private Sub TextBoxYGrid_Change()
-                  
-        If IsNumeric(TextBoxYGrid.Value) Then
-            GlobalYGrid = TextBoxYGrid.Value
-        Else
-             MsgBox "Please enter the number of rows!"
-        End If
-        
-        
-        ReDim GlobalDeActivatedLocations(GlobalMaximumPositions, GlobalXGrid * GlobalYGrid)
-        ReDim GlobalLocationsOrder(GlobalMaximumPositions, GlobalXGrid * GlobalYGrid)
-        GlobalOrderChanged = True
-
-End Sub
-    
-
-Private Sub TextBoxXStep_Change()
-        If IsNumeric(TextBoxXStep.Value) Then
-            GlobalXStep = TextBoxXStep.Value
-        Else
-             MsgBox "Please enter the horizontal distance between two neighbouring locations!"
-        End If
-    
-End Sub
-
-
-Private Sub TextBoxYStep_Change()
-
-        If IsNumeric(TextBoxYStep.Value) Then
-            GlobalYStep = TextBoxYStep.Value
-        Else
-             MsgBox "Please enter the vertical distance between two neighbouring locations!"
-        End If
-
-   
-End Sub
-Private Sub CommandButtonGrid_Click()
-    ShowGrid
-End Sub
-
-
-Public Sub ShowGrid()
-    Dim BitsPerSample As Long
-    Dim bpp As Long
-    Dim ImgName As String
-    Dim LsmMath As New LsmVectorMath
-    Dim SpareArray() As Single
-    Dim XPixels As Long
-    Dim YPixels As Long
-    Dim XGroup As Long
-    Dim YGroup As Long
-    Dim xIndx As Long
-    Dim yIndx As Long
-    Dim Start As Long
-    Dim ix As Long
-    Dim iy As Long
-    Dim PlaneSize As Long
-    
-    
-    If Not GlobalGridImage Is Nothing Then
-        If Not GlobalGridImage.IsValid Then
-            Set GlobalGridImage = Nothing
-        Else
-             GlobalGridImage.CloseAllWindows
-             Set GlobalGridImage = Nothing
-            
-        End If
-    End If
-    
-    
-    If GlobalGridImage Is Nothing Then
-        BitsPerSample = 12
-        bpp = 2
-        XPixels = 1024
-        YPixels = 1024
-        XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-        YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-        If XGroup <= YGroup Then
-            YGroup = XGroup
-        Else
-            XGroup = YGroup
-        End If
-        XPixels = XGroup * (3 * GlobalXGrid + 1)
-        YPixels = YGroup * (3 * GlobalYGrid + 1)
-        MakeBlankImage GlobalGridImage, BitsPerSample, bpp, True, ImgName, False, 1, XPixels, YPixels, 3
-        GlobalGridImage.SetTitle "Location Grid"
-        GlobalGridImage.NeverAgainScanToTheImage
-        RedrawGrid GlobalGridImage
-        GlobalGridImage.VectorOverlay.LineWidth = 1
-        GlobalGridImage.VectorOverlay.Color = RGB(0, 255, 0)
-        GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-        If GlobalReferencePoints = 2 Then
-            DrawCrossGrid GlobalGridX1, GlobalGridY1
-            DrawCrossGrid GlobalGridX2, GlobalGridY2
-        ElseIf GlobalReferencePoints = 1 Then
-            DrawCrossGrid GlobalGridX1, GlobalGridY1
-        End If
-        
-        GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowNoButtonMouseMoveEvent, 1
-        GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLButtonMouseMoveEvent, 1
-        GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonDownEvent, 1
-        GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonUpEvent, 1
-        GlobalGridImage.EnableImageWindowEvent Ds.eImageWindowRightButtonUpEvent, 1
-        
-        DoEvents
-    End If
-End Sub
-
-Private Sub CommandButtonRemove_Click()
-Dim Msg, Style, Title, Help, Ctxt, Response, MyString
-    Msg = "Do You Want to Remove Selected Reference Points?"
-    Style = VbYesNo + VbQuestion + VbDefaultButton2   ' Define buttons.
-    Title = "Remove Reference Points"  ' Define title.
-    Response = MsgBox(Msg, Style, Title)
-    If Response = vbYes Then    ' User chose Yes.
-        GlobalReferencePoints = 0
-        If Not GlobalGridImage Is Nothing Then
-            If GlobalGridImage.IsValid Then
-                GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-            End If
-        End If
-    End If
-End Sub
-
-Private Sub CreateLocationsButton_Click()
-    Dim XPos As Double
-    Dim YPos As Double
-    Dim ZPos As Double
-    
-    Dim idx As Long
-    Dim idy As Long
-    Dim idt As Long
-    Dim x As Double
-    Dim y As Double
-    Dim det As Double
-    Dim A11 As Double
-    Dim A12 As Double
-    Dim A21 As Double
-    Dim A22 As Double
-    Dim x1 As Double
-    Dim Y1 As Double
-    
-    Dim result As Long
-    Dim ProgressString As String
-    Dim Color As Long
-    Dim ZeroChanged As Boolean
-    Dim SetZeroMarked As Boolean
-    Dim idpos As Long
-    Dim idold As Long
-    Dim OverWriteZ As Boolean
-    
-
-    If GridToggle Then
-    
-    OverWriteZ = PubFuncOverWriteZ
-   
-    ProgressString = "Please Wait..."
-    Color = RGB(&HC0, 0, 0)
-    DisplayProgress ProgressString, Color
-    DoEvents
-
-    If TextBoxYGrid.Value * TextBoxXGrid.Value <= GlobalMaximumPositions Then
-        flgUserChange = False
-        GlobalXGrid = TextBoxXGrid.Value
-        GlobalYGrid = TextBoxYGrid.Value
-        GlobalXStep = TextBoxXStep.Value
-        GlobalYStep = TextBoxYStep.Value
-        
-        'DisplayProgress GlobalXGrid, Color 'tischi
-        MsgBox "GlobalXGrid" + CStr(GlobalXGrid)
-        
-'       Stage.MarkClearAll
-        ZPos = GlobalGridStageZ1
-        If GlobalReferencePoints >= 1 Then
-            XPos = GlobalGridStageX1 - (GlobalGridX1 - 1) * GlobalXStep
-            YPos = GlobalGridStageY1 - (GlobalGridY1 - 1) * GlobalYStep
-'       Else does not wordk properly
-'           x = GetStagePositionX
-'           y = GetStagePositionY
-'           ConvertToStagePositionXY x, y, XPos, YPos
-        End If
-        GlobalPositionsRecalled = GlobalPositionsStage
-        GlobalPositionsStage = GlobalXGrid * GlobalYGrid
-        ReDim GlobalLocationsName(GlobalPositionsStage)
-        GlobalCurrentPosition = 1
-        If 1 = 0 Then 'GlobalPositionsStage <= 1 Then
-            ' MsgBox "hallo"
-            'GlobalPositionsStage = 1
-            'GlobalCurrentPosition = 1
-            'StartStopForm.ComboBoxLocation.AddItem "Present"
-        Else
-            det = -1 * 1 - 0 * 0
-          '  det = X11 * X22 - X21 * X12
-            If det = 0 Then
-                GlobalPositionsStage = 1
-                GlobalCurrentPosition = 1
-               ' StartStopForm.ComboBoxLocation.AddItem "Present"
-            
-            Else
-                SetZeroMarked = True
-                GetGlobalZZero SetZeroMarked, ZeroChanged
-                x1 = XPos
-                Y1 = YPos
-                ReDim GlobalXpos(GlobalXGrid * GlobalYGrid)
-                ReDim GlobalYpos(GlobalXGrid * GlobalYGrid)
-                If OverWriteZ Then ReDim GlobalZpos(GlobalXGrid * GlobalYGrid)
-            
-                
-                If GlobalMeander Then
-                    idpos = 0
-                    For idy = 1 To GlobalYGrid Step 2
-                        For idx = 1 To GlobalXGrid
-                            idt = (idy - 1) * GlobalXGrid + idx
-                            If Not GlobalDeActivatedLocations(idx, idy) Then
-                                idpos = idpos + 1
-                                
-                                GlobalLocationsOrder(idx, idy) = idpos
-                                GlobalLocationsName(idpos) = "Column" & idx & "_Row" & idy
-                                GlobalXpos(idpos) = x1 + (idx - 1) * GlobalXStep
-                                GlobalYpos(idpos) = Y1 + (idy - 1) * GlobalYStep
-                                If OverWriteZ Then
-                                    GlobalZpos(idpos) = ZPos
-                                Else
-                                    idold = GlobalLocationsOrderOld(idx, idy)
-                                    If idold = -1 Then
-                                        GlobalZpos(idpos) = ZPos
-                                    Else
-                                        GlobalZpos(idpos) = GlobalZposOld(idold)
-                                    End If
-                                End If
-                            Else
-                                GlobalLocationsOrder(idx, idy) = -1
-                            End If
-                        Next idx
-                        If idt >= GlobalXGrid * GlobalYGrid Then Exit For
-                        For idx = 1 To GlobalXGrid
-                            idt = idy * GlobalXGrid + GlobalXGrid - idx + 1
-                            If Not GlobalDeActivatedLocations(GlobalXGrid - idx + 1, idy + 1) Then
-                                idpos = idpos + 1
-                                
-                                GlobalLocationsOrder(GlobalXGrid - idx + 1, idy + 1) = idpos
-                                GlobalLocationsName(idpos) = "Column" & GlobalXGrid - idx + 1 & "_Row" & idy + 1
-                                GlobalXpos(idpos) = x1 + (GlobalXGrid - idx) * GlobalXStep
-                                GlobalYpos(idpos) = Y1 + idy * GlobalYStep
-                                If OverWriteZ Then
-                                    GlobalZpos(idpos) = ZPos
-                                Else
-                                idold = GlobalLocationsOrderOld(GlobalXGrid - idx + 1, idy + 1)
-                                    If idold = -1 Then
-                                        GlobalZpos(idpos) = ZPos
-                                    Else
-                                        GlobalZpos(idpos) = GlobalZposOld(idold)
-                                    End If
-                                End If
-                            Else
-                                GlobalLocationsOrder(GlobalXGrid - idx + 1, idy + 1) = -1
-                            End If
-                        Next idx
-                    Next idy
-                Else
-                    idpos = 0
-                    For idy = 1 To GlobalYGrid
-                        For idx = 1 To GlobalXGrid
-                            idt = (idy - 1) * GlobalXGrid + idx
-                            If Not GlobalDeActivatedLocations(idx, idy) Then
-                                idpos = idpos + 1
-                                GlobalLocationsName(idpos) = "Column" & idx & "_Row" & idy
-                                GlobalLocationsOrder(idx, idy) = idpos
-                                GlobalXpos(idpos) = x1 + (idx - 1) * GlobalXStep
-                                GlobalYpos(idpos) = Y1 + (idy - 1) * GlobalYStep
-                                If OverWriteZ Then
-                                    GlobalZpos(idpos) = ZPos
-                                Else
-                                    idold = GlobalLocationsOrderOld(idx, idy)
-                                    If idold = -1 Then
-                                        GlobalZpos(idpos) = ZPos
-                                    Else
-                                        GlobalZpos(idpos) = GlobalZposOld(idold)
-                                    End If
-                                End If
-                            Else
-                                GlobalLocationsOrder(idx, idy) = -1
-                            End If
-                        Next idx
-                    Next idy
-                End If
-            End If
-        End If
-        GlobalOrderChanged = False
-        GlobalPositionsStage = idpos
-        'GlobalPositions = GlobalPositionsStage
-        flgUserChange = False
-        flgUserChange = True
-        GlobalIsTile = False
-    Else
-        MsgBox "Number of locations in the grid cannot exceed " + CStr(GlobalMaximumPositions)
-    End If
-    Tile
-    DisplayProgress GlobalProgressString, GlobalColor
-    DoEvents
-     AutofocusForm.SetMarkedLocations GlobalPositionsStage
-     PubSentStageGrid = True
-     
-     ElseIf MultipleLocationToggle = True Then
-  
-    GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-     PutStagePositionsInArray
-     Tile
-     AutofocusForm.SetMarkedLocations GlobalPositionsStage
-     End If
-End Sub
-
-Public Sub DisplayGridSelection(x As Long, y As Long, xIndx As Long, yIndx As Long)
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim Start As Long
-Dim ix As Long
-Dim iy As Long
-Dim Xmin As Long
-Dim Xmax As Long
-Dim Ymin As Long
-Dim Ymax As Long
-Dim xImage As Long
-Dim StartX As Long
-Dim yImage As Long
-Dim StartY As Long
-Dim Found As Boolean
-Dim EndX As Long
-Dim EndY As Long
-Dim XPosition As Long
-Dim YPosition As Long
-Dim xMod As Long
-Dim yMod As Long
-Dim xString As String
-Dim yString As String
-Dim MyString As String
-
-    If GlobalGridImage Is Nothing And GlobalZGridImage Is Nothing Then Exit Sub
-    
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    XPosition = Int(x / XGroup) + 1
-    YPosition = Int(y / YGroup) + 1
-    xMod = XPosition Mod 3
-    yMod = YPosition Mod 3
-    xIndx = XPosition / 3
-    yIndx = YPosition / 3
-TileX = AutofocusForm.TextBoxTileX.Value
-TileY = AutofocusForm.TextBoxTileY.Value
-    If xMod = 1 Or yMod = 1 Then
-        xString = ""
-        yString = ""
-    Else
-        xString = CStr(xIndx)
-        yString = CStr(yIndx)
-    End If
-  '  LabelGrid.ForeColor = RGB(0, 0, 0)
-    MyString = "Column= " + xString + vbCrLf + "Row= " + yString
-    If Not GlobalOrderChanged Then
-        If GlobalLocationsOrder(xIndx, yIndx) > 0 Then
-            MyString = MyString + vbCrLf + "Mark= " + CStr((GlobalLocationsOrder(xIndx, yIndx) - 1) * TileX * TileY + 1) + " to " + CStr((GlobalLocationsOrder(xIndx, yIndx)) * TileX * TileY)
-        End If
-    End If
-    If GlobalZmapAquired Then
-         If GlobalLocationsOrder(xIndx, yIndx) > -1 Then
-            idpos = GlobalLocationsOrder(xIndx, yIndx)
-            MyString = MyString + vbCrLf + "z-Value= " + CStr(Round(GlobalZpos(idpos), 3))
-            End If
-         End If
-    DisplayProgress MyString, RGB(0, &HC0, 0)
-End Sub
-
-Public Sub DrawCrossGrid(xIndx As Long, yIndx As Long)
-    
-    Dim XPixels As Long
-    Dim YPixels As Long
-    Dim XGroup As Long
-    Dim YGroup As Long
-    Dim ix As Long
-    Dim iy As Long
-    Dim x1 As Long
-    Dim Y1 As Long
-    Dim X2 As Long
-    Dim Y2 As Long
-
-    If (GlobalGridImage Is Nothing) Then Exit Sub
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    x1 = XGroup + 3 * XGroup * (xIndx - 1)
-    Y1 = YGroup + 3 * YGroup * (yIndx - 1)
-    X2 = 3 * XGroup + 3 * XGroup * (xIndx - 1)
-    Y2 = 3 * YGroup + 3 * YGroup * (yIndx - 1)
-      
-    GlobalGridImage.VectorOverlay.Color = RGB(255, 255, 0)
-    GlobalGridImage.VectorOverlay.LineWidth = 1
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeLine, x1, Y1, X2, Y2
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeLine, x1, Y2, X2, Y1
-'    dsDoc.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeCircle, xCross, yCross, xCross, yCross + 30
-    GlobalGridImage.RedrawImage
-    
-End Sub
-
-Public Sub DrawRectangleGrid(x1 As Long, Y1 As Long, X2 As Long, Y2 As Long)
-
-    If (GlobalGridImage Is Nothing) Then Exit Sub
-      
-    GlobalGridImage.VectorOverlay.Color = RGB(0, 255, 0)
-    GlobalGridImage.VectorOverlay.LineWidth = 1
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeRectangle, x1, Y1, X2, Y2
-    GlobalGridImage.RedrawImage
-    
-End Sub
-
-
-Public Sub SetMarkedLocations(Positions As Long)
-    Dim idx As Long
-    Dim ZeroChanged As Boolean
-    Dim SetZeroMarked As Boolean
-    SetZeroMarked = False
- '   If GlobalIsStage And GlobalMultiLocation Then
-        If Positions > 1 Then
-            GetGlobalZZero SetZeroMarked, ZeroChanged
-'            If ZeroChanged Then
-'                FillLocationList
-'            End If
-            Lsm5.Hardware.CpStages.MarkClearAll
-            For idx = 1 To Positions
-                Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idx), GlobalYpos(idx), GlobalZpos(idx)
-            Next idx
-        End If
- '   End If
-End Sub
-
-
-Private Sub CheckBoxMeander_Click()
-    If flgUserChange Then
-        GlobalMeander = CheckBoxMeander.Value
-    End If
-End Sub
-
-'Private Sub CheckBoxKeepSteps_Click()
-' If flgUserChange Then
-'        GlobalKeepSteps = CheckBoxKeepSteps.Value
-'    End If
-'End Sub
-
-
-Private Sub ZMapButton_Click()
-Dim text As String
-Dim x As Double
-Dim y As Double
-Dim z As Double
-Dim Zbefore As Double
-Dim BitsPerSample As Long
-Dim bpp As Long
-Dim ImgName As String
-Dim SpareArray() As Single
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim ix As Long
-Dim iy As Long
-Dim PlaneSize As Long
-Dim idold As Long
-
-ZValues.Show
-InitializeStageProperties
-SetStageSpeed 8, True
-
-If PubSentStageGrid = False And (Grid Or StripeScanToggle.Value) Then
-    MsgBox "Please send the grid information to stage first!", VbExclamation
-    Exit Sub
-End If
-
-AutofocusForm.GetBlockValues 'Updates the parameters value for BlockZRange, BlockZStep..
-'DisplayProgress "Aquiring Reference", RGB(0, &HC0, 0)
-StopScanCheck
-StoreAquisitionParameters
-
-'got to Refcor1
-
-
-'Lsm5.Hardware.CpStages.PositionX = GlobalGridStageX1
-'Lsm5.Hardware.CpStages.PositionY = GlobalGridStageY1
-'While Lsm5.Hardware.CpStages.IsBusy
-'    DoEvents
-'Wend
-'Lsm5.Hardware.CpFocus.Position = GlobalGridStageZ1
-'While Lsm5.Hardware.CpFocus.IsBusy
-'    DoEvents
-'Wend
-'Sleep (20)
-''Aquire Z-Stack,Caluclate shift
-'
-'
-' Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-' If PubAbort Then GoTo Abort
-''Caluclate new z Position, Store Z in Array
-'GlobalGridStageZ1 = GlobalGridStageZ1 + ZShift
-GettingZmap = True
-GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-    If MultipleLocation Then
-    PutStagePositionsInArray
-    End If
-    
-
-If Grid Then
-    If GlobalMeander Then
-         For idpos = 1 To GlobalPositionsStage
-            If ScanStop Then
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                GoTo Abort
-             End If
-           
-          
-        If GlobalStageControlZValues = False Then
-           If idpos = 1 Then
-               Lsm5.Hardware.CpFocus.Position = GlobalGridStageZ1
-               Zbefore = GlobalGridStageZ1
-               While Lsm5.Hardware.CpFocus.IsBusy
-                  DoEvents
-               Wend
-           Else
-               Zbefore = GlobalZpos(idpos - 1)
-               Lsm5.Hardware.CpFocus.Position = GlobalZpos(idpos - 1)
-               While Lsm5.Hardware.CpFocus.IsBusy
-                  DoEvents
-               Wend
-           End If
-          
-        Else
-            Lsm5.Hardware.CpFocus.Position = GlobalZpos(idpos)
-            While Lsm5.Hardware.CpFocus.IsBusy
-                  DoEvents
-               Wend
-        End If
-         Lsm5.Hardware.CpStages.PositionX = GlobalXpos(idpos)
-        Lsm5.Hardware.CpStages.PositionY = GlobalYpos(idpos)
-           Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-           DisplayProgress "Aquiring idpos " & idpos & ", z= " & GlobalZpos(idpos), RGB(0, &HC0, 0)
-            Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-             'check if Z shift makes sense
-          CheckRefControl BlockZRange
-           'Calculate new Z and Store in Array
-           GlobalZpos(idpos) = Lsm5.Hardware.CpFocus.Position + BlockZOffset + ZShift
-           
-           Next idpos
-    Else
-       For Row = 1 To GlobalYGrid
-           For column = 1 To GlobalXGrid
-              If Not GlobalDeActivatedLocations(column, Row) Then
-                  idpos = GlobalLocationsOrder(column, Row)
-                  Lsm5.Hardware.CpStages.PositionX = GlobalXpos(idpos)
-                  Lsm5.Hardware.CpStages.PositionY = GlobalYpos(idpos)
-                  If Row = 1 And column = 1 Then
-                      Lsm5.Hardware.CpFocus.Position = GlobalGridStageZ1
-                      Zbefore = GlobalGridStageZ1
-                  ElseIf Row <> 1 And column = 1 Then
-                  idold = GlobalLocationsOrder(column, Row - 1)
-                    If idold = -1 Then
-                        Zbefore = GlobalZpos(idpos - 1)
-                    Else
-                            Zbefore = GlobalZpos(idold)
-                    End If
-                      Lsm5.Hardware.CpFocus.Position = Zbefore
-                Else
-                      Zbefore = GlobalZpos(idpos - 1)
-                      Lsm5.Hardware.CpFocus.Position = GlobalZpos(idpos - 1)
-                  End If
-                Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-                  DisplayProgress "Aquiring idpos " & idpos & ", z= " & GlobalZpos(idpos), RGB(0, &HC0, 0)
-                  'Aquire Z-Stack,Caluclate shift
-                   Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-             'check if Z shift makes sense
-          CheckRefControl BlockZRange
-           'Calculate new Z and Store in Array
-                  GlobalZpos(idpos) = Lsm5.Hardware.CpFocus.Position + BlockZOffset + ZShift
-               End If
-          Next column
-       Next Row
-    End If
-    Lsm5.Hardware.CpStages.MarkClearAll
-        For idpos = 1 To GlobalPositionsStage
-     '    GlobalZpos(idpos) = GlobalZpos(idpos)  + ZShift '?????? suchmarke
-           Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-        Next idpos
-Else ' Zmap in multilocation modus
-GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-    For idpos = 1 To GlobalPositionsStage
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                       GoTo Abort
-                    End If
-                    Lsm5.Hardware.CpStages.PositionX = GlobalXpos(idpos)
-                  Lsm5.Hardware.CpStages.PositionY = GlobalYpos(idpos)
-                  Lsm5.Hardware.CpFocus.Position = GlobalZpos(idpos)
- '                 Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-'            Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToMarkZ (0) 'Moves to the first location marked in the stage control
-              Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-                    If ScanStop Then
-                       DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                      GoTo Abort
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-              DisplayProgress "Aquiring idpos " & idpos, RGB(0, &HC0, 0)
-            Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-                    If ScanStop Then
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        GoTo Abort
-                    End If
-             'check if Z shift makes sense
-          CheckRefControl BlockZRange
-           'Calculate new Z and Store in Array
-           GlobalZpos(idpos) = Lsm5.Hardware.CpFocus.Position + BlockZOffset + ZShift
-           
-        
-'           success = Lsm5.Hardware.CpStages.MarkGet(0, x, y)
- '          success = Lsm5.Hardware.CpStages.MarkClear(0)
-'
-'            Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ x, y, z
-          Next idpos
-          Lsm5.Hardware.CpStages.MarkClearAll
-          For idpos = 1 To GlobalPositionsStage
-          Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-          Next idpos
-End If
-'Lsm5.Hardware.CpStages.MarkClearAll
-'        For idpos = 1 To GlobalPositionsStage
-'         GlobalZpos(idpos) = GlobalZpos(idpos) + ZShift
-'           Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-'        Next idpos
-GlobalZmapAquired = True
-DisplayProgress "Zmap ready", RGB(0, &HC0, 0)
-If Grid Then
-    If Not GlobalZGridImage Is Nothing Then
-            If Not GlobalZGridImage.IsValid Then
-                Set GlobalZGridImage = Nothing
-            Else
-                 GlobalZGridImage.CloseAllWindows
-                 Set GlobalZGridImage = Nothing
-                
-            End If
-        End If
-        If GlobalZGridImage Is Nothing Then
-            BitsPerSample = 12
-            bpp = 2
-            XPixels = 1024
-            YPixels = 1024
-            XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-            YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-            If XGroup <= YGroup Then
-                YGroup = XGroup
-            Else
-                XGroup = YGroup
-            End If
-            XPixels = XGroup * (3 * GlobalXGrid + 1)
-            YPixels = YGroup * (3 * GlobalYGrid + 1)
-            MakeBlankImage GlobalZGridImage, BitsPerSample, bpp, True, ImgName, False, 1, XPixels, YPixels, 3
-            GlobalZGridImage.SetTitle "Z Values"
-            GlobalZGridImage.NeverAgainScanToTheImage
-            
-            GlobalZGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowNoButtonMouseMoveEvent, 1
-            GlobalZGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLButtonMouseMoveEvent, 1
-            GlobalZGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonDownEvent, 1
-            GlobalZGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonUpEvent, 1
-            GlobalZGridImage.EnableImageWindowEvent Ds.eImageWindowRightButtonUpEvent, 1
-        End If
-    RedrawZGrid GlobalZGridImage
-End If
-'RestoreAquisitionParameters
-'GettingZmap = False
-CheckBoxZMap.Value = True
-Abort:
-RestoreAquisitionParameters
-GettingZmap = False
-PubAbort = False
-If ScanStop = True Then
-        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-        ScanStop = False
-End If
-End Sub
-
-
-Private Sub ChangeButtonStatus(Enable As Boolean)
-    
-    StartButton.Enabled = Enable
-    StartBleachButton.Enabled = Enable
-    CloseButton.Enabled = Enable
-    ReinitializeButton.Enabled = Enable
-        
-    
-End Sub
-
-
-Private Sub RecalibrationFocusZMap()
-Location = 1
-        MoveToNextLocation
-   
-        AutofocusForm.GetBlockValues                                'Updates the parameters value for BlockZRange, BlockZStep..
-        StopScanCheck
-        StoreAquisitionParameters
-        Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset
-        'check if Z shift makes sense
-        CheckRefControl BlockZRange
-        'Caluclate new z Position, Store Z in Array
-'        If Grid Or MultipleLocation Then
-'        Lsm5.Hardware.CpStages.MarkClearAll
-'        For idpos = 1 To GlobalPositionsStage
-'            GlobalZpos(idpos) = GlobalZpos(idpos) + ZShift
-'            Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-'        Next idpos
-'        Else
-'        GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-'            For idpos = 1 To GlobalPositionsStage
-'            success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).GetMarkZ(0, x, y, z)
-'           success = Lsm5.Hardware.CpStages.MarkClear(0)
-'            z = z + ZShift
-'            Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ x, y, z
-'        Next idpos
-'        End If
-        Sleep (100)
-        'Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-                 DoEvents
-         Sleep (100)
-                  
-        RestoreAquisitionParameters
-        'Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-                 DoEvents
-End Sub
-
-
-Private Sub MoveToNextLocation()
-        ' below command moves in x,y, and z
-        Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToMarkZ (0)  'Moves to the first location marked in the stage control
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy ' Wait that the movement is done
-            If ScanStop Then        'now when we're waiting for things to happen we allow the user to stop the macro
-                Lsm5.StopScan
-                StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-        DoEvents
-        Sleep (5)
-        Loop
-End Sub
-
-
-Private Sub StopScanCheck()
-    Lsm5.StopScan
-    ' Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-End Sub
-
-Private Sub UpdateZvalues(Grid, MultipleLocation, z)
-        
-        
-        Dim idpos As Integer
-        Dim sucess As Integer
-   
-        If Grid Or MultipleLocation Then
-            
-            Lsm5.Hardware.CpStages.MarkClearAll
-            For idpos = 1 To GlobalPositionsStage
-                GlobalZpos(idpos) = GlobalZpos(idpos) + ZShift
-                Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ GlobalXpos(idpos), GlobalYpos(idpos), GlobalZpos(idpos)
-               
-            Next idpos
-    
-        
-        Else  ' Todo: what is this doing?
-
-        '      GlobalPositionsStage = Lsm5.Hardware.CpStages.MarkCount
-       '     For idpos = 1 To GlobalPositionsStage
-        '        Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).GetMarkZ(0, x, y, z)
-         '       Success = Lsm5.Hardware.CpStages.MarkClear(0)
-                    
-         '       z = z + ZShift
-          '      Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ x, y, z
-          '  Next idpos
-             
-         End If
-    
-End Sub
-
-
-
-Private Sub CreateZoomDatabase(ZoomDatabaseName, HighResExperimentCounter, ZoomExpname)
-            'Create ZoomDatabase
-            Dim Start As Integer
-            Dim bslash As String
-            Dim pos As Long
-            Dim NameLength As Long
-            Dim Mypath As String
-            
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, GlobalDataBaseName, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            
-            Mypath = GlobalDataBaseName + bslash
-            NameLength = Len(GlobalDataBaseName)
-            ZoomExpname = Strings.Right(GlobalDataBaseName, NameLength - Start + 1)
-           ' NameLength = Len(Myname)
-           ' Myname = Strings.Left(Myname, NameLength - 4)
-            ZoomDatabaseName = Mypath & ZoomExpname & "_exp_" & HighResExperimentCounter & "_zoom"
-            ' Lsm5.NewDatabase (ZoomDatabaseName)
-           ' ZoomDatabaseName = ZoomDatabaseName & "\" & Myname & "_zoom.mdb"
-End Sub
-
-Private Sub CreateAlterImageDatabase(AlterDatabaseName, Mypath)
-        Dim Start As Integer
-        Dim bslash As String
-        Dim pos As Long
-        Dim NameLength As Long
-        Dim Myname As String
-
-         Start = 1
-         bslash = "\"
-         pos = Start
-         Do While pos > 0
-             pos = InStr(Start, GlobalDataBaseName, bslash)
-             If pos > 0 Then
-                 Start = pos + 1
-             End If
-         Loop
-         Mypath = Strings.Left(GlobalDataBaseName, Start - 1)
-         NameLength = Len(GlobalDataBaseName)
-         Myname = Strings.Right(GlobalDataBaseName, NameLength - Start + 1)
-         NameLength = Len(Myname)
-         ' Myname = Strings.Left(Myname, NameLength - 4)
-         AlterDatabaseName = Mypath & Myname & "_additionalTracks"
-        ' Lsm5.NewDatabase (AlterDatabaseName)
-        '  AlterDatabaseName = AlterDatabaseName & "\" & Myname & "_additionalTracks"
-         
-End Sub
-
-
-Private Sub MicroscopePilot(RecordingDoc As DsRecordingDoc, BleachingActivated, HighResExperimentCounter, HighResCounter, HighResArrayX, HighResArrayY, HighResArrayZ)
-    
-    Dim ZoomNumber As Integer
-    Dim code As String
-    Dim codeArray() As String
-        
-    ' Get Code from Windows registry
-    code = GetSetting(appname:="OnlineImageAnalysis", section:="macro", key:="code")
-
-    Do While (code = "1" Or code = "0")
-        DisplayProgress "Waiting for Micropilot...", RGB(0, &HC0, 0)
-        Sleep (100)
-        code = GetSetting(appname:="OnlineImageAnalysis", section:="macro", _
-                  key:="Code")
-                  DoEvents
-        
-        If ScanStop Then
-            Lsm5.StopScan
-            StopAcquisition
-            DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-            Exit Sub
-        End If
-                  
-    Loop
-    
-    'MsgBox ("Code = " + code)
-    
-    DisplayProgress "Received Code " + CStr(code), RGB(0, &HC0, 0)
-    
-    
-    If (CheckBoxGridScan_FindGoodPositions) Then
-        
-        codeArray = Split(code, "_")
-        
-        nGoodCells = CInt(codeArray(1))
-        minGoodCellsPerImage = CInt(codeArray(2))
-        minGoodCellsPerWell = CInt(codeArray(3))
-        
-        nGoodCellsPerWell = nGoodCellsPerWell + nGoodCells
-        
-        'MsgBox "nGoodCellsPerWell = " + CStr(nGoodCellsPerWell)
-    
-        GoTo Mark
-    
-    End If
-    
-
-    If code = "2" Then   ' no interesting cell
-    
-        DisplayProgress "Micropilot Code 2", RGB(0, &HC0, 0)
-        SaveSetting "OnlineImageAnalysis", "macro", "Refresh", 0
-        'SaveSetting "OnlineImageAnalysis", "Cinput", "Code", 0
-        If RecordingDoc.IsValid Then
-            RecordingDoc.CloseAllWindows
-            Set RecordingDoc = Nothing
-        End If
-        GoTo Mark '(because Image does not show any interesting pheotype)
-    
-    ElseIf code = "4" Then   'store position in a list
-    
-        DisplayProgress "Micropilot Code 4", RGB(0, &HC0, 0)
-        HighResCounter = HighResCounter + 1 ' Counts the postions, where Highres Imaging will be carried out
-        ' store postion from windows registry in array
-        StorePositioninHighResArray HighResArrayX, HighResArrayY, HighResArrayZ, HighResCounter
-        
-    ElseIf code = "5" Then ' start Highres Batch Imaging 1 to n postions
-        
-        DisplayProgress "Micropilot Code 5", RGB(0, &HC0, 0)
-        HighResCounter = HighResCounter + 1
-        ' store postion from windows registry in array
-       
-        StorePositioninHighResArray HighResArrayX, HighResArrayY, HighResArrayZ, HighResCounter
-        ' BatchHighresImagingRoutine
-        HighResExperimentCounter = HighResExperimentCounter + 1 ' counts the number of highres-multipositionexperiments (important for naming the datafolder)
-        
-        ' HERE THE IMAGES ARE ACQUIRED
-        BatchHighresImagingRoutine RecordingDoc, HighResArrayX, HighResArrayY, HighResArrayZ, HighResCounter, HighResExperimentCounter
-        'After the whole MultiposExperiment HighResCounter must be set to 0 again
-        HighResCounter = 0
-        ReDim HighResArrayX(100)
-        ReDim HighResArrayY(100)
-        ReDim HighResArrayZ(100)
-    
-    Else
-        
-        'Error Message "OnlineImageAnalysis Value = 'Code'"
-        MsgBox ("Invalid OnlineImageAnalysis Code = " & code)
-    
-    End If
-    
-    'Reset Code to 0 in Windows Registry
-    'SaveSetting "OnlineImageAnalysis", "Cinput", "Code", 0
-      
-Mark:
-        
-            
-End Sub
-
-
-Private Sub StartAlternativeImaging(RecordingDoc As DsRecordingDoc, StartTime As Double, AlterDatabaseName As String, name As String)
-        
-     'Alternative Acquisition in every .. round
-     'Dim zStageOld As Double
-     'Dim SampleOZold As Double
-    
-     If RepetitionNumber Mod TextBox_RoundAlterTrack = 0 Then
-           
-         'SampleOZold = Lsm5.DsRecording.Sample0Z
-        
-         Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-         If RecordingDoc Is Nothing Then
-              Set RecordingDoc = Lsm5.NewScanWindow
-              While RecordingDoc.IsBusy
-                   Sleep (20)
-                   DoEvents
-               Wend
-         End If
-            
-         
-         DisplayProgress "Acquiring Additional Track...", RGB(0, &HC0, 0)
-         
-         ActivateAlterAcquisitionTrack
-         Sleep (100)
-              
-         If Not IsAcquisitionTrackSelected Then      'An additional control....
-             StopAcquisition
-             MsgBox "No track selected for Acquisition! Cannot Acquire!"
-             DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-             Exit Sub
-         End If
-                
-         'MsgBox "Piezo Position = " + CStr(Lsm5.Hardware.CpHrz.Position)
-         '= 0  ' Center Piezo
-         'Sleep (100)
-         
-         
-         ' get and set the values from the GUI
-         Lsm5.DsRecording.ZoomX = TextBoxAlterZoom.Value
-         Lsm5.DsRecording.ZoomY = TextBoxAlterZoom.Value
-         Lsm5.DsRecording.FramesPerStack = TextBoxAlterNumSlices.Value
-         Lsm5.DsRecording.FrameSpacing = TextBoxAlterInterval.Value
-         If Lsm5.DsRecording.FramesPerStack > 1 Then
-            
-            Dim oldSpecialScanMode As String
-            oldSpecialScanMode = Lsm5.DsRecording.SpecialScanMode
-            If CheckBoxAlter_zPiezo Then
-                Lsm5.DsRecording.SpecialScanMode = "ZScanner"
-            Else
-                Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * Int(Lsm5.DsRecording.FramesPerStack / 2)
-                Lsm5.DsRecording.SpecialScanMode = "NoSpecialMode"
-            End If
-            Lsm5.DsRecording.scanMode = "Stack"
-         
-         End If
-         
-         'MsgBox "all settings set   " + CStr(Lsm5.DsRecording.Sample0Z)
-        
-         ' take the image
-         ScanToImageNew RecordingDoc
-    
-         While AcquisitionController.IsGrabbing
-             Sleep (20)
-             If ScanStop Then
-                 Lsm5.StopScan
-                 'ScanStop = True
-                 DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                 Exit Sub
-             End If
-             DoEvents
-         Wend
-
-        
-         If RepetitionNumber = 1 Then
-             StartTime = GetTickCount
-         End If
-         
-         Lsm5.tools.WaitForScanEnd False, 10
-         
-         
-         'MsgBox "Piezo Position = " + CStr(Lsm5.Hardware.CpHrz.Position)
-         
-         'Lsm5.Hardware.CpHrz.Position = 0  ' ReCenter Piezo
-         'Sleep (100)
-         
-         'MsgBox "done Alter"
-         
-         
-         RecordingDoc.SetTitle name
-        
-         
-         Dim fullpathname As String
-         fullpathname = AlterDatabaseName & "\" & name & ".lsm"
-         SaveDsRecordingDoc RecordingDoc, fullpathname
-         
-         'Lsm5.DsRecording.Sample0Z = SampleOZold
-         Lsm5.DsRecording.SpecialScanMode = oldSpecialScanMode
-         
-         
-      End If
-
-
-
-End Sub
-
-Private Sub StorePositioninHighResArray(HighResArrayX, HighResArrayY, HighResArrayZ, HighResCounter)
-    
-    ' store postion from windows registry in array
-    
-    Dim zoomXoffset As Double
-    Dim zoomYoffset As Double
-    Dim x As Double
-    Dim y As Double
-    Dim PixelSize As Double
-
-    zoomXoffset = GetSetting(appname:="OnlineImageAnalysis", section:="macro", key:="offsetx")
-    zoomYoffset = GetSetting(appname:="OnlineImageAnalysis", section:="macro", key:="offsety")
-    
-    If HRZ Then
-        Success = Lsm5.Hardware.CpHrz.Leveling   'This I think puts the HRZ to its resting position, and moves the focuswheel correspondingly
-    Else
-        ' do nothing
-    End If
-                
-    Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-        If ScanStop Then
-            Lsm5.StopScan
-            StopAcquisition
-            DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-            Exit Sub
-        End If
-        DoEvents
-        Sleep (5)
-    Loop
-
-    'Move x,y,
-     
-    PixelSize = Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing * 1000000
-    x = Lsm5.Hardware.CpStages.PositionX
-    y = Lsm5.Hardware.CpStages.PositionY
-    HighResArrayX(HighResCounter) = x - zoomXoffset * PixelSize
-    HighResArrayY(HighResCounter) = y + zoomYoffset * PixelSize
-    HighResArrayZ(HighResCounter) = Lsm5.Hardware.CpFocus.Position
-   ' MsgBox "Current Z Position = " + CStr(Lsm5.Hardware.CpFocus.Position)
-    DisplayProgress "Micropilot - Position stored", RGB(0, &HC0, 0)
-
-End Sub
-
-
-
-Private Sub BatchHighresImagingRoutine(RecordingDoc As DsRecordingDoc, HighResArrayX, HighResArrayY, HighResArrayZ, HighResCounter, HighResExperimentCounter)
-    
-    Dim PixelSize As Double
-    Dim Succes As Integer
-    Dim ZoomExpname As String
-    Dim ZoomImageIndex() As Long
-    ReDim Preserve ZoomImageIndex(10000)
-    Dim zoomname As String
-    Dim ZoomDatabaseName As String
-    'Timer and Looping Variables
-    Dim highrespos As Integer
-    Dim ZoomTimeDelay As Long
-    Dim ZoomRepetitions As Integer
-    Dim ZoomRepetitionNumber As Integer
-    Dim ZoomRunning As Boolean
-    Dim ZoomStartTime As Double
-    Dim ZoomNewTime As Double
-    Dim Zoomdifftime As Double
-    
-    Dim fullpathname As String
-     
-    ' set up the imaging
-    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-    'Set RecordingDoc = Lsm5.DsRecordingActiveDocObject
-    
-    If RecordingDoc Is Nothing Then
-        Set RecordingDoc = Lsm5.NewScanWindow
-        While RecordingDoc.IsBusy
-            Sleep (20)
-            DoEvents
-        Wend
-    End If
-    
-
-    'Create Database ' own folder for each new BatchHighres Experiment !
-    CreateZoomDatabase ZoomDatabaseName, HighResExperimentCounter, ZoomExpname
-    
-    
-    ' Set parameters for time loop
-    If BleachingActivated Then
-        ZoomRepetitions = 1 ' do everything in one go
-    Else
-        ZoomRepetitions = TextBoxZoomCycles.Value
-    End If
-                  
-    ZoomTimeDelay = TextBoxZoomCycleDelay.Value
-    ZoomRepetitionNumber = 1
-    ZoomRunning = True ' We are in this loop till all repetitions are done
-
-    Do While ZoomRunning = True ' We are in this loop till all repetitions are done (timerepetitions loop)
-        
-        'MsgBox "HighResCounter " + CStr(HighResCounter)
-        
-        For highrespos = 1 To HighResCounter ' Postition loop
-        
-                ' Move to Positon in x,y
-                DisplayProgress "Micropilot Code 5 - Move to Position", RGB(0, &HC0, 0)
-                Succes = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(HighResArrayX(highrespos), HighResArrayY(highrespos))
-        
-                Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-                    If ScanStop Then
-                        Lsm5.StopScan
-                        StopAcquisition
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        Exit Sub
-                    End If
-                    DoEvents
-                    Sleep (5)
-                Loop
-        
-                ' Move to Positon in z
-                'MsgBox "HighResArrayZ(highrespos) " + CStr(HighResArrayZ(highrespos))
-                'MsgBox "ZBacklash " + CStr(ZBacklash)
-                
-                Lsm5.Hardware.CpFocus.Position = HighResArrayZ(highrespos) + ZBacklash 'Move down 50um (=ZBacklash) below the position of the offset
-                Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-                     Sleep (20)  '20ms
-                     DoEvents
-                Loop
-                Lsm5.Hardware.CpFocus.Position = HighResArrayZ(highrespos)          'Moves up to the position of the offset
-                Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-                    Sleep (20)
-                    DoEvents
-                Loop
-                
-                'Autofocus
-                If CheckBoxZoomAutofocus.Value = True Then
-                    BlockZOffset = TextBoxZoomAutofocusZOffset.Value
-                    DisplayProgress "Micropilot Code 5 - Do Autofocus", RGB(0, &HC0, 0)
-                    Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset, RecordingDoc
-                    CheckRefControl BlockZRange
-                    Autofocus_MoveAquisition BlockZOffset
-                End If
-        
-                ' Load AcquisitionSettings
-                Lsm5.DsRecording.SamplesPerLine = TextBoxZoomFrameSize.Value
-                Lsm5.DsRecording.LinesPerFrame = TextBoxZoomFrameSize.Value
-                Sleep (100)
-                ActivateZoomTrack
-                Lsm5.DsRecording.ZoomX = TextBoxZoom.Value
-                Lsm5.DsRecording.ZoomY = TextBoxZoom.Value
-                
-                If BleachingActivated Then
-                                
-                    DisplayProgress "Bleaching...", &HFF00FF
-                        
-                    Set Track = Lsm5.DsRecording.TrackObjectBleach(Success)
-                    
-                    If Success Then
-                        Track.Acquire = True
-                        Lsm5.DsRecording.TimeSeries = True
-                        Lsm5.DsRecording.StacksPerRecord = TextBoxZoomCycles.Value
-                        Track.TimeBetweenStacks = TextBoxZoomCycleDelay.Value
-                        'MsgBox "Track.IsBleachTrack " + CStr(Track.IsBleachTrack)
-                        'MsgBox "BleachScanNumber " + CStr(Track.BleachScanNumber)
-                        DoEvents
-                        Track.UseBleachParameters = True            'Bleach parameters are lasers lines, bleach iterations... stored in the bleach control window
-                        'BleachStartTable(RepetitionNumber) = GetTickCount      'Get the time right before bleach to store this in the image metadata
-                                                               
-                        
-                        ScanToImageNew RecordingDoc
-    
-                        While AcquisitionController.IsGrabbing
-                            Sleep (20)
-                            If ScanStop Then
-                                Lsm5.StopScan
-                                'ScanStop = True
-                                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                                Exit Sub
-                            End If
-                            DoEvents
-                        Wend
-                    
-                        
-                        'Set RecordingDocNew = Lsm5.StartScan
-                        'Do While RecordingDocNew.IsBusy
-                        '   If ScanStop Then
-                        '        Lsm5.StopScan
-                        '        StopAcquisition
-                        '        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        '        Exit Sub
-                        '    End If
-                        '    DoEvents
-                        '    Sleep (5)
-                        'Loop
-                        
-                        Lsm5.tools.WaitForScanEnd False, 10
-                                                   
-                        
-                        Track.UseBleachParameters = False  'switch off the bleaching
-                        Lsm5.DsRecording.TimeSeries = False
-                        
-                    Else
-                    
-                        MsgBox ("Could not set bleach track. Did not bleach.")
-                    
-                    End If
-                
-                                 
-                    'Save Image
-                
-                    zoomname = "_L" & highrespos & "_Bleach"
-                    
-        
-                    fullpathname = ZoomDatabaseName & "\" & zoomname & ".lsm"
-                    SaveDsRecordingDoc RecordingDoc, fullpathname
-        
-                    DisplayProgress "Micropilot Code 5 - SaveImage", RGB(0, &HC0, 0)
-                    'If RecordingDocNew.IsValid Then
-                    '    RecordingDocNew.CloseAllWindows
-                    '    Set RecordingDoc = Nothing
-                    'End If
-                    
-                    
-                Else ' normal acquistion (non bleaching mode)
-                    
-                    Lsm5.DsRecording.FramesPerStack = TextBoxZoomNumSlices.Value
-                    Lsm5.DsRecording.FrameSpacing = TextBoxZoomInterval.Value
-                    
-                    Dim oldSpecialScanMode As String
-                    oldSpecialScanMode = Lsm5.DsRecording.SpecialScanMode
-                    If CheckBoxHighRes_zPiezo Then
-                        Lsm5.DsRecording.SpecialScanMode = "ZScanner"
-                    Else
-                        Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * Int(Lsm5.DsRecording.FramesPerStack / 2)
-                        Lsm5.DsRecording.SpecialScanMode = "NoSpecialMode"
-                    End If
-                    Lsm5.DsRecording.scanMode = "Stack"
-                         
-                    'Acquisition
-                    DisplayProgress "Micropilot Code 5 - Start Scan", RGB(0, &HC0, 0)
-                    If highrespos = 1 Then
-                        ZoomStartTime = CDbl(GetTickCount) * 0.001
-                    End If
-                    DisplayProgress "Acquisition HighRes Position " & highrespos, RGB(&HC0, &HC0, 0)
-                    
-                    
-                    ScanToImageNew RecordingDoc
-    
-                    While AcquisitionController.IsGrabbing
-                        Sleep (20)
-                        If ScanStop Then
-                            Lsm5.StopScan
-                            'ScanStop = True
-                            DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                            Exit Sub
-                        End If
-                        DoEvents
-                    Wend
-                                    
-                    'Set RecordingDocNew = Lsm5.StartScan
-                    'Do While RecordingDocNew.IsBusy
-                    '   If ScanStop Then
-                    '        Lsm5.StopScan
-                    '        StopAcquisition
-                    '        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                    '        Exit Sub
-                    '    End If
-                    '    DoEvents
-                    '    Sleep (5)
-                    'Loop
-                    
-                    Lsm5.tools.WaitForScanEnd False, 10
-            
-                    'Save Image
-                    
-                    zoomname = "_L" & highrespos & "_R" & ZoomRepetitionNumber
-                    fullpathname = ZoomDatabaseName & "\" & zoomname & ".lsm"
-                    SaveDsRecordingDoc RecordingDoc, fullpathname
-        
-                    DisplayProgress "Micropilot Code 5 - SaveImage", RGB(0, &HC0, 0)
-                    
-                    'If RecordingDocNew.IsValid Then
-                    '    RecordingDocNew.CloseAllWindows
-                    '    Set RecordingDoc = Nothing
-                    'End If
-                    
-                End If ' Bleaching
-
-                        
-                        
-                
-        Next highrespos ' End of postions loop
-        
-        
-    
-        If ZoomRepetitionNumber < ZoomRepetitions Then
-            ZoomNewTime = CDbl(GetTickCount) * 0.001
-            Zoomdifftime = ZoomNewTime - ZoomStartTime
-            Do While Zoomdifftime <= ZoomTimeDelay
-                Sleep (10)
-                DoEvents
-                If ScanStop Then
-                        StopAcquisition
-                        DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                        Exit Sub
-                End If
-                ZoomNewTime = CDbl(GetTickCount) * 0.001
-                Zoomdifftime = ZoomNewTime - ZoomStartTime
-                DisplayProgress "Waiting " & CStr(CInt(ZoomTimeDelay - Zoomdifftime)) + " s before scanning repetition  " & (ZoomRepetitionNumber + 1), RGB(&HC0, &HC0, 0)
-            Loop
-        Else
-            ZoomRunning = False ' now all repetitions are done, so  we leave the do while zoomrunnning = true loop
-        End If
-        ZoomRepetitionNumber = ZoomRepetitionNumber + 1
-    
-       
-    Loop  ' End of time repetition loop
-    
-    Sleep (1000)
-    
-    
-End Sub
-
-
-
-' Copied and adapted from MultiTimeSeries macro
-Public Function SaveDsRecordingDoc(Document As DsRecordingDoc, FileName As String) As Boolean
-    Dim Export As AimImageExport
-    Dim image As AimImageMemory
-    Dim Error As AimError
-    Dim Planes As Long
-    Dim Plane As Long
-    Dim Horizontal As enumAimImportExportCoordinate
-    Dim Vertical As enumAimImportExportCoordinate
-
-    On Error GoTo Done
-
-    'Set Image = EngelImageToHechtImage(Document).Image(0, True)
-    If Not Document Is Nothing Then
-        Set image = Document.RecordingDocument.image(0, True)
-    End If
-    
-    Set Export = Lsm5.CreateObject("AimImageImportExport.Export.4.5")
-'    Set Export = New AimImageExport
-    Export.FileName = FileName
-    Export.Format = eAimExportFormatLsm5
-    Export.StartExport image, image
-    Set Error = Export
-    Error.LastErrorMessage
-    
-    Planes = 1
-    Export.GetPlaneDimensions Horizontal, Vertical
-    
-    Select Case Vertical
-        Case eAimImportExportCoordinateY:
-             Planes = image.GetDimensionZ * image.GetDimensionT
-        Case eAimImportExportCoordinateZ:
-            Planes = image.GetDimensionT
-    End Select
-    
-    For Plane = 0 To Planes - 1
-        If ScanStop Then
-            SaveDsRecordingDoc = False
-            Export.FinishExport
-            Exit Function
-        End If
-        DoEvents
-        Export.ExportPlane Nothing
-    Next Plane
-    Export.FinishExport
-    SaveDsRecordingDoc = True
-    Exit Function
-Done:
-    MsgBox "Check Temporary Files Folder! Cannot Save Temporary File(s)!"
-    ScanStop = True
-    SaveDsRecordingDoc = False
-    Export.FinishExport
-    
-End Function
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/CorrectFocusForm.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/CorrectFocusForm.frm
deleted file mode 100644
index ee214dc..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/CorrectFocusForm.frm
+++ /dev/null
@@ -1,64 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} CorrectFocusForm 
-   Caption         =   "Correct Focus"
-   ClientHeight    =   2130
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   4410
-   OleObjectBlob   =   "CorrectFocusForm.frx":0000
-   ShowModal       =   0   'False
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "CorrectFocusForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-
-
-
-
-
-Private Sub ChangeFocusButton_Click()
-ChangeFocus = True
-FocusChanged = True
-RestoreAquisitionParameters
-Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-DoEvents
-AutofocusForm.ActivateAcquisitionTrack
- While ChangeFocus = True
-                       DoEvents
-                        Sleep (100)
-Wend
-
-End Sub
-
-Private Sub GoOnButton_Click()
-ChangeFocus = False
-Unload CorrectFocusForm
-DoNotGoOn = False
-End Sub
-
-
-
-Private Sub UserForm_Activate()
-Dim i As Long
-Dim j As Long
-i = 5
-ChangeFocus = False
-FocusChanged = False
-While i >= 1
-    
-    Label1.Caption = "The focus couldnot be found. Do You want to change the Position of the FocusWheel manually?" _
-                     + " If you donot press the Change Button, then prgramme will go on automatically in " _
-                     + CStr(i) + " sec."
-    Sleep (1000)
-    DoEvents
-    If ChangeFocus Then Exit Sub
-    i = i - 1
-Wend
-
-If i = 0 Then Unload CorrectFocusForm
-DoNotGoOn = False
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/CreditForm.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/CreditForm.frm
deleted file mode 100644
index 07ba948..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/CreditForm.frm
+++ /dev/null
@@ -1,24 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} CreditForm 
-   Caption         =   "Credit"
-   ClientHeight    =   3180
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   3585
-   OleObjectBlob   =   "CreditForm.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "CreditForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-
-Private Sub CloseButton_Click()
-    CreditForm.Hide
-End Sub
-
-Private Sub UserForm_Click()
-
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Functions.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Functions.bas
deleted file mode 100644
index 8f68d0a..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Functions.bas
+++ /dev/null
@@ -1,135 +0,0 @@
-Attribute VB_Name = "Functions"
-
-Public Function Range() As Double
-    Dim RevolverPosition As Long
-    RevolverPosition = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-    If RevolverPosition >= 0 Then
-        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(RevolverPosition) * 1000#
-    Else
-        Range = 0#
-    End If
-End Function
-
-
-Public Function GetGlobalZZero(SetZeroMarked As Boolean, ZeroChanged As Boolean)
-    Dim Count As Integer
-    Dim idx As Long
-    
-    Dim XPos As Double
-    Dim YPos As Double
-    Dim ZPos As Double
-    Dim x1 As Double
-    Dim Y1 As Double
-    Dim res1 As Integer
-
-    Dim Success As Boolean
-    Dim result As Long
-    Dim Positions As Long
-    ZeroChanged = False
-    If GlobalIsStage Then
-        Positions = Lsm5.Hardware.CpStages.MarkCount
-        ZPos = CpFocus.Position
-        result = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ(0, 0, 0)
-        If result <> (Positions + 1) Then
-            result = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).lAddMarkZ(10, 10, 0)
-        End If
-        result = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).GetMarkZ(Positions, GlobalXZero, GlobalYZero, GlobalZZero)
-        res1 = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).ClearMark(Positions)
-        
-        Positions = GlobalPositionsStage
-        If SetZeroMarked Then
-            GlobalZZeroMarked = GlobalZZero
-        Else
-            If Positions <= 1 Then
-                Positions = 1
-                If GlobalZZeroMarked <> GlobalZZero Then
-                    GlobalZZeroMarked = GlobalZZero
-                    ZeroChanged = True
-                End If
-                
-            Else
-                If GlobalZZeroMarked <> GlobalZZero Then
-                    For idx = 1 To Positions
-                        GlobalZpos(idx) = GlobalZpos(idx) + GlobalZZeroMarked - GlobalZZero
-                    Next idx
-                    GlobalZZeroMarked = GlobalZZero
-                    ZeroChanged = True
-    
-                End If
-            End If
-        End If
-    Else
-        GlobalZZero = 0
-        Positions = 0
-    End If
-End Function
-Function FServerFromDescription(strName As String, StrPath As String, ExecName As String) As Boolean
-    Dim lngResult As Long
-    Dim strTmp As String
-    Dim hKeyServer As Long
-    Dim strBuffer As String
-    Dim cb As Long
-    Dim i As Integer
-    
-    FServerFromDescription = False
-    
-    strTmp = VBA.Space(255)
-    strTmp = strName + "\CLSID"
-    lngResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strTmp, 0&, KEY_READ, hKeyServer)
-    
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    strBuffer = VBA.Space(255)
-    cb = Len(strBuffer)
-    
-    lngResult = RegQueryValueEx(hKeyServer, "", 0&, REG_SZ, ByVal strBuffer, cb)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    
-    lngResult = RegCloseKey(hKeyServer)
-    strTmp = VBA.Space(255)
-    strTmp = "CLSID\" + Strings.Left(strBuffer, cb - 1) + "\LocalServer32"
-    strBuffer = VBA.Space(255)
-    cb = Len(strBuffer)
-    lngResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strTmp, 0&, KEY_READ, hKeyServer)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-        
-    lngResult = RegQueryValueEx(hKeyServer, "", 0&, REG_SZ, ByVal strBuffer, cb)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    StrPath = Strings.Left(strBuffer, cb - 1)
-    ExecName = StrPath
-    lngResult = RegCloseKey(hKeyServer)
-    
-    i = Len(StrPath)
-    
-    Do Until (i = 0)
-        If (VBA.Mid(StrPath, i, 1) = "\") Then
-            StrPath = Strings.Left(StrPath, i - 1)
-            FServerFromDescription = True
-            Exit Do
-        End If
-        i = i - 1
-    Loop
-
-error_exit:
-    If (Not hKeyServer = 0) Then lngResult = RegCloseKey(hKeyServer)
-
-End Function
-
-Public Function PubFuncOverWriteZ() As Boolean
-Dim Msg, Style, Title, Help, Ctxt, Response, MyString
-If GlobalZmapAquired = True Then
-    Msg = "Do You Want to overwrite Z-Values?"
-    Style = VbYesNo + VbQuestion + VbDefaultButton2   ' Define buttons.
-    Title = "ZValues"  ' Define title.
-    Response = MsgBox(Msg, Style, Title)
-    If Response = vbYes Then ' User chose Yes.
-        PubFuncOverWriteZ = True
-    Else
-        PubFuncOverWriteZ = False
-        GlobalZposOld() = GlobalZpos()
-       GlobalLocationsOrderOld() = GlobalLocationsOrder()
-    End If
- Else
-    PubFuncOverWriteZ = True
-End If
-
-End Function
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/MCUCommands.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/MCUCommands.bas
deleted file mode 100644
index 87a1d34..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/MCUCommands.bas
+++ /dev/null
@@ -1,309 +0,0 @@
-Attribute VB_Name = "MCUCommands"
-
-Public Abort As Boolean
-Private Interface As Object
-Private Frequency As Double
-Private Resolution As Double
-
-Public ExchangeXY As Boolean
-Public MirrorX As Boolean
-Public MirrorY As Boolean
-  
-
-Public Sub InitializeStageProperties()
-    Set Interface = Lsm5.ExternalCpObject.pHardwareObjects.pInterfaces
-    Set Interface = Interface.pItem("CANN")
-    
-    Resolution = 0.00000025
-    Frequency = 2000000
-  
-End Sub
-
-Public Function GetStagePositionX(CANN As Boolean) As Double
-  
-   
-  
-    On Error GoTo nostage
-   
-    
-    If ExchangeXY Then
-        GetStagePositionX = StageGetPositionY(CANN) * 1000000#
-    Else
-        GetStagePositionX = StageGetPositionX(CANN) * 1000000#
-    End If
-    If MirrorX Then
-        GetStagePositionX = -GetStagePositionX
-    End If
-nostage:
-End Function
-
-Public Function GetStagePositionY(CANN As Boolean) As Double
-    
-
-    On Error GoTo nostage
-    
-    If ExchangeXY Then
-        GetStagePositionY = StageGetPositionX(CANN) * 1000000#
-    Else
-        GetStagePositionY = StageGetPositionY(CANN) * 1000000#
-    End If
-    If MirrorY Then
-    Else
-        GetStagePositionY = -GetStagePositionY
-    End If
-nostage:
-End Function
-
-Public Function SetStagePositionX(PositionMicrons As Double, CANN As Boolean)
-
-    Dim PositionMetre As Double
-    
-    PositionMetre = PositionMicrons * 0.000001
-    
-  
-    If MirrorX Then
-        PositionMetre = -PositionMetre
-    Else
-    End If
-    If ExchangeXY Then
-        StageMoveToPositionY PositionMetre, CANN
-        Exit Function
-    End If
-    On Error GoTo nostage
-    StageMoveToPositionX PositionMetre, CANN
-nostage:
-End Function
-
-Public Function SetStagePositionY(PositionMicrons As Double, CANN As Boolean)
-   
-    Dim PositionMetre As Double
-    
-    PositionMetre = PositionMicrons * 0.000001
-
-    If MirrorY Then
-    Else
-        PositionMetre = -PositionMetre
-    End If
-    If ExchangeXY Then
-        StageMoveToPositionX PositionMetre, CANN
-        Exit Function
-    End If
-    On Error GoTo nostage
-    StageMoveToPositionY PositionMetre, CANN
-nostage:
-End Function
-
-Public Function SetStageSpeed(StageSpeed As Double, CANN As Boolean) As Boolean
-
-    Dim SampleTimer As Double
-    Dim SamplingTime As Double
-    Dim v As Long
-    
-    SampleTimer = SendStageCommandWaitForAnswer("Xn" + Chr(13))
-    SamplingTime = 16 * (SampleTimer + 1) * (1 / Frequency)
-
-    v = CLng(StageSpeed * SamplingTime / Resolution)
-    If v = 0 Then
-        SetStageSpeed = False
-        Exit Function
-    End If
-    
-    If CANN Then
-        SendStageCommand "XV" + CStr(v) + Chr(13)
-        SendStageCommand "YV" + CStr(v) + Chr(13)
-        SetStageSpeed = True
-    Else
-        SendCommand "NPXV" + CStr(v) + Chr(13)
-        SendCommand "NPYV" + CStr(v) + Chr(13)
-    End If
-End Function
-    
-'-----------------------------------------------------------------------------
-'-----------------------------------------------------------------------------
-    
-Public Sub SetStageAcceleration(Accelearation As Double, CANN As Boolean)
-    If CANN Then
-        SendStageCommand "XA" + CStr(CLng(Accelearation)) + Chr(13)
-        SendStageCommand "YA" + CStr(CLng(Accelearation)) + Chr(13)
-    Else
-        SendCommand "NPXA" + CStr(CLng(Accelearation)) + Chr(13)
-        SendCommand "NPYA" + CStr(CLng(Accelearation)) + Chr(13)
-    End If
-End Sub
-
-Public Function GetStageAcceleration(CANN As Boolean) As Long
-    If CANN Then
-        GetStageAcceleration = SendStageCommandWaitForAnswer("Xa" + Chr(13))
-    Else
-        GetStageAcceleration = SendCommandWaitForAnswer("NPXa" + Chr(13))
-    End If
-End Function
-
-Public Function GetStageSpeed(CANN As Boolean) As Double
-    Dim SampleTimer As Double
-    Dim SamplingTime As Double
-
-    SampleTimer = SendStageCommandWaitForAnswer("Xn" + Chr(13))
-    SamplingTime = 16 * (SampleTimer + 1) * (1 / Frequency)
-    
-    If CANN Then
-        GetStageSpeed = SendStageCommandWaitForAnswer("Xv" + Chr(13)) * Resolution / SamplingTime
-    Else
-        GetStageSpeed = SendCommandWaitForAnswer("NPXv" + Chr(13)) * Resolution / SamplingTime
-    End If
-End Function
-
-Public Function IsStageBusy(CANN As Boolean) As Boolean
-    If CANN Then
-        IsStageBusy = (SendStageCommandWaitForAnswer("Xt" + Chr(13)) <> 0) _
-                   Or (SendStageCommandWaitForAnswer("Yt" + Chr(13)) <> 0)
-    Else
-        IsStageBusy = (SendCommandWaitForAnswer("NPXt" + Chr(13)) <> 0) _
-                   Or (SendCommandWaitForAnswer("NPYt" + Chr(13)) <> 0)
-    End If
-End Function
-
-Public Function GetMaximumStageSpeed() As Double
-    GetMaximumStageSpeed = 0.02703786166
-End Function
-
-Public Function GetMinimumStageSpeed() As Double
-    GetMinimumStageSpeed = 0.0003004206851
-End Function
-
-Private Function StageMoveToPositionX(PositionMetre As Double, CANN As Boolean)
-    Dim Position As String
-    
-    Position = Hex(CLng(-PositionMetre / Resolution))
-    While Len(Position) < 6
-        Position = "0" + Position
-    Wend
-    If Len(Position) > 6 Then
-        Position = Strings.Right(Position, 6)
-    End If
-    If CANN Then
-        SendStageCommand ("XT" + Position + Chr(13))
-    Else
-         SendCommand ("NPXT" + Position + Chr(13))
-    End If
-End Function
-
-Private Function StageMoveToPositionY(PositionMetre As Double, CANN As Boolean)
-    Dim Position As String
-        Position = Hex(CLng(PositionMetre / Resolution))
-    While Len(Position) < 6
-        Position = "0" + Position
-    Wend
-    If Len(Position) > 6 Then
-        Position = Strings.Right(Position, 6)
-    End If
-    If CANN Then
-        SendStageCommand ("YT" + Position + Chr(13))
-    Else
-        SendCommand ("NPYT" + Position + Chr(13))
-    End If
-    
-End Function
-
-Private Function StageGetPositionX(CANN As Boolean) As Double
-    If CANN Then
-        StageGetPositionX = -SendStageCommandWaitForHexAnswer("Xp" + Chr(13)) * Resolution
-    Else
-        StageGetPositionX = -SendCommandWaitForHexAnswer("NPXp" + Chr(13)) * Resolution
-    End If
-End Function
-
-Private Function StageGetPositionY(CANN As Boolean) As Double
-    If CANN Then
-        StageGetPositionY = SendStageCommandWaitForHexAnswer("Yp" + Chr(13)) * Resolution
-    Else
-        StageGetPositionY = SendCommandWaitForHexAnswer("NPYp" + Chr(13)) * Resolution
-    End If
-End Function
-
-Private Sub SendStageCommand(command As String)
-    If Not Interface Is Nothing Then
-        Interface.bSendCmd (command)
-    End If
-End Sub
-            
-Private Function SendStageCommandWaitForAnswer(command As String) As Long
-    Dim Answer As String
-    
-    SendStageCommandWaitForAnswer = 0
-On Error GoTo ErrorExit
-    If Not Interface Is Nothing Then
-        Interface.bSendCmdWait4Answer command, Answer
-        If Answer <> "" Then
-            SendStageCommandWaitForAnswer = CLng(Strings.Right(Answer, Len(Answer) - 2))
-        End If
-    End If
-ErrorExit:
-End Function
-
-Private Function SendStageCommandWaitForHexAnswer(command As String) As Long
-    Dim Answer As String
-    
-    SendStageCommandWaitForHexAnswer = 0
-On Error GoTo ErrorExit
-    If Not Interface Is Nothing Then
-        Interface.bSendCmdWait4Answer command, Answer
-        If Answer <> "" Then
-            SendStageCommandWaitForHexAnswer = Val("&H" + Strings.Right(Answer, Len(Answer) - 2))
-            If SendStageCommandWaitForHexAnswer < 0 Then
-            SendStageCommandWaitForHexAnswer = SendStageCommandWaitForHexAnswer + &H10000
-            End If
-            If SendStageCommandWaitForHexAnswer > &H7FFFFF Then
-                SendStageCommandWaitForHexAnswer = SendStageCommandWaitForHexAnswer - &H1000000
-            End If
-        End If
-    End If
-ErrorExit:
-End Function
-
-Private Function SendCommand(command As String) As Long
-    Lsm5.DsRecording.StartScanTriggerOut = Lsm5.DsRecording.StartScanTriggerOut + command
-End Function
-
-Private Function SendCommandWaitForAnswer(command As String) As Long
-
-End Function
-
-Private Function SendCommandWaitForHexAnswer(command As String) As Long
-
-End Function
-
-Public Sub NoImageAxisChange()
- ExchangeXY = False
- MirrorX = False
- MirrorY = False
-End Sub
-
-Public Sub ImageAxisChange()
-Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS 1, ExchangeXY, MirrorX, MirrorY
-End Sub
-
-
-
-Public Function AreStageCoordinateExchanged() As Boolean
-    Dim ExchangeXY As Boolean
-    Dim MirrorX As Boolean
-    Dim MirrorY As Boolean
-    Dim bLSM As Boolean
-    Dim bLIVE As Boolean
-    Dim bCamera As Boolean
-    Dim lsystem As Integer
-    
-     UsedDevices40 bLSM, bLIVE, bCamera
-        If bLSM Then
-            lsystem = 0
-        ElseIf bLIVE Then
-            lsystem = 1
-        ElseIf bCamera Then
-            lsystem = 3
-        End If
-
-    Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS lsystem, ExchangeXY, MirrorX, MirrorY
-    AreStageCoordinateExchanged = ExchangeXY
-End Function
-
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module1.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module1.bas
deleted file mode 100644
index 115e9a3..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module1.bas
+++ /dev/null
@@ -1,47 +0,0 @@
-Attribute VB_Name = "Module1"
-Sub Macro1()
-    '**************************************
-    'Recorded: 06/13/2012
-    'Descrption:
-    '**************************************
-    Dim RecordingDoc As DsRecordingDoc
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim Laser As DsLaser
-    Dim DetectionChannel As DsDetectionChannel
-    Dim IlluminationChannel As DsIlluminationChannel
-    Dim DataChannel As DsDataChannel
-    Dim BeamSplitter As DsBeamSplitter
-    Dim Timers As DsTimers
-    Dim Markers As DsMarkers
-    Dim Success As Integer
-    Set Recording = Lsm5.DsRecording
-     
-    Recording.Sample0Z = 1#
-     
-    '************* End ********************
-End Sub
-Sub Macro2()
-    '**************************************
-    'Recorded: 06/13/2012
-    'Descrption:
-    '**************************************
-    Dim RecordingDoc As DsRecordingDoc
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim Laser As DsLaser
-    Dim DetectionChannel As DsDetectionChannel
-    Dim IlluminationChannel As DsIlluminationChannel
-    Dim DataChannel As DsDataChannel
-    Dim BeamSplitter As DsBeamSplitter
-    Dim Timers As DsTimers
-    Dim Markers As DsMarkers
-    Dim Success As Integer
-    Set Recording = Lsm5.DsRecording
-     
-    Lsm5.DsRecording.Sample0Z = 1#
-    MsgBox ":asdsds"
-    
-     
-    '************* End ********************
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module2.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module2.bas
deleted file mode 100644
index fc3f432..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module2.bas
+++ /dev/null
@@ -1,125 +0,0 @@
-Attribute VB_Name = "Module2"
-Sub Macro1()
-    '**************************************
-    'Recorded: 06/14/2012
-    'Descrption:
-    '**************************************
-    Dim RecordingDoc As DsRecordingDoc
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim Laser As DsLaser
-    Dim DetectionChannel As DsDetectionChannel
-    Dim IlluminationChannel As DsIlluminationChannel
-    Dim DataChannel As DsDataChannel
-    Dim BeamSplitter As DsBeamSplitter
-    Dim Timers As DsTimers
-    Dim Markers As DsMarkers
-    Dim Success As Integer
-    Set Recording = Lsm5.DsRecording
-     
-    Recording.Sample0Z = 335.71
-    Recording.SpecialScanMode = "FocusStep"
-    Recording.scanMode = "Stack"
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Set DataChannel = Track.DataChannelObjectByIndex(0, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Set DataChannel = Track.DataChannelObjectByIndex(1, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Track.HdrImagingMode = 0
-    Track.HdrNumFrames = 1
-    Set DataChannel = Track.DataChannelObjectByIndex(1, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Track.HdrIntensity = 10
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Track.HdrImagingMode = 0
-    Set Track = Recording.TrackObjectByIndex(0, Success)
-    Recording.FrameSpacing = 0.666667
-    Recording.FramesPerStack = 4
-    Recording.FrameSpacing = 0.666667
-    Recording.FramesPerStack = 4
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set DataChannel = Track.DataChannelObjectByName("ChS1", Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(2, Success)
-    Set DataChannel = Track.DataChannelObjectByName("Ch2", Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(11, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-    Recording.FrameSpacing = 0.5
-    Recording.FramesPerStack = 5
-    Recording.FrameSpacing = 0.5
-    Recording.FramesPerStack = 5
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set DataChannel = Track.DataChannelObjectByName("ChS1", Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(2, Success)
-    Set DataChannel = Track.DataChannelObjectByName("Ch2", Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(11, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-    Recording.Sample0Z = 1#
-     
-    '************* End ********************
-End Sub
-Sub Macro2()
-    '**************************************
-    'Recorded: 06/14/2012
-    'Descrption:
-    '**************************************
-    Dim RecordingDoc As DsRecordingDoc
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim Laser As DsLaser
-    Dim DetectionChannel As DsDetectionChannel
-    Dim IlluminationChannel As DsIlluminationChannel
-    Dim DataChannel As DsDataChannel
-    Dim BeamSplitter As DsBeamSplitter
-    Dim Timers As DsTimers
-    Dim Markers As DsMarkers
-    Dim Success As Integer
-    Set Recording = Lsm5.DsRecording
-     
-    Recording.Sample0Z = 1#
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Recording.Sample0Z = 1.25
-    Recording.FramesPerStack = 6
-    Recording.Sample0Z = 1.25
-    Recording.FramesPerStack = 6
-    Recording.Sample0Z = 1.5
-    Recording.FramesPerStack = 7
-    Recording.Sample0Z = 1.5
-    Recording.FramesPerStack = 7
-    Recording.Sample0Z = 1.75
-    Recording.FramesPerStack = 8
-    Recording.Sample0Z = 1.75
-    Recording.FramesPerStack = 8
-    Recording.SpecialScanMode = "ZScanner"
-    Recording.Sample0Z = 1.75
-    Recording.FramesPerStack = 8
-    Recording.FrameSpacing = 0.5
-    Recording.Sample0Z = 1.75
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Recording.FrameSpacing = 1.5
-    Recording.Sample0Z = 5.25
-    Recording.FrameSpacing = 1.5
-    Recording.Sample0Z = 5.25
-    Set Track = Recording.TrackObjectByMultiplexOrder(0, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set DataChannel = Track.DataChannelObjectByName("ChS1", Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(2, Success)
-    Set DataChannel = Track.DataChannelObjectByName("Ch2", Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(11, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-    Set DetectionChannel = Track.DetectionChannelObjectByIndex(0, Success)
-    Set Track = Recording.TrackObjectByMultiplexOrder(1, Success)
-     
-    '************* End ********************
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module3.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module3.bas
deleted file mode 100644
index 70c6eab..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module3.bas
+++ /dev/null
@@ -1,55 +0,0 @@
-Attribute VB_Name = "Module3"
-Sub Macro1()
-    '**************************************
-    'Recorded: 06/15/2012
-    'Descrption:
-    '**************************************
-    Dim RecordingDoc As DsRecordingDoc
-    Dim Recording As DsRecording
-    Dim Track As DsTrack
-    Dim Laser As DsLaser
-    Dim DetectionChannel As DsDetectionChannel
-    Dim IlluminationChannel As DsIlluminationChannel
-    Dim DataChannel As DsDataChannel
-    Dim BeamSplitter As DsBeamSplitter
-    Dim Timers As DsTimers
-    Dim Markers As DsMarkers
-    Dim Success As Integer
-    Set Recording = Lsm5.DsRecording
-     
-    Recording.Sample0Z = 1#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 0#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = -1#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = -1#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 0#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 0#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 1#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 1#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 2#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 2#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 3#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 3#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 4#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 4#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 5#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 5#
-    Recording.FramesPerStack = 3
-    Recording.Sample0Z = 1#
-     
-    '************* End ********************
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module4.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module4.bas
deleted file mode 100644
index a0178a3..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Module4.bas
+++ /dev/null
@@ -1 +0,0 @@
-Attribute VB_Name = "Module4"
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/SelectLocs.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/SelectLocs.frm
deleted file mode 100644
index cd3a76a..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/SelectLocs.frm
+++ /dev/null
@@ -1,27 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} SelectLocs 
-   Caption         =   "Select/Deselct Locations"
-   ClientHeight    =   1950
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   2910
-   OleObjectBlob   =   "SelectLocs.frx":0000
-   StartUpPosition =   2  'CenterScreen
-End
-Attribute VB_Name = "SelectLocs"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-
-
-Private Sub DeselctButton_Click()
-GridSelection x, y, XR, YR, False
-SelectLocs.Hide
-End Sub
-
-Private Sub SelectButton_Click()
-GridSelection x, y, XR, YR, True
-SelectLocs.Hide
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Stage_Grid.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Stage_Grid.bas
deleted file mode 100644
index 4fd183a..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/Stage_Grid.bas
+++ /dev/null
@@ -1,808 +0,0 @@
-Attribute VB_Name = "Stage_Grid"
-
-Public Const PubGridPathData = "c:\AIM\macros\datafiles\"
-Public Const PubGridPath = "c:\AIM\macros\"
-Public Const GlobalMaximumPositions = 800
-Public GlobalXStep As Double
-Public GlobalYStep As Double
-Public GlobalXGrid As Long
-Public GlobalYGrid As Long
-Public GlobalOrderChanged As Boolean        'checks if values are changed without creating new locations_
-                                            '    then  the lost order is not showed, because it not actualized
-Public GlobalGridImage As DsRecordingDoc
-Public GlobalZGridImage As DsRecordingDoc
-Public GlobalGridX1 As Long
-Public GlobalGridY1 As Long
-Public GlobalGridStageX1 As Double
-Public GlobalGridStageY1 As Double
-Public GlobalGridStageZ1 As Double
-Public GlobalGridX2 As Long
-Public GlobalGridY2 As Long
-Public GlobalGridStageX2 As Double
-Public GlobalGridStageY2 As Double
-Public GlobalGridStageZ2 As Double
-Public GlobalReferencePoints As Long
-'Public GlobalKeepSteps As Boolean
-Public GlobalMeander As Boolean
-Public GlobalPositionsRecalled As Long
-Public GlobalPositionsStage As Long
-Public GlobalCurrentPosition As Long
-Public GlobalXpos() As Double
-Public GlobalYpos() As Double
-Public GlobalZpos() As Double
-Public GlobalLocationsName() As String
-Public GlobalLocationsNameOld() As String
-Public GlobalZposOld() As Double
-Public GlobalXposOld() As Double
-Public GlobalYposOld() As Double
-Public GlobalRelativeZ() As Double
-Public dsDoc As DsRecordingDoc
-Public Stage As CpStages
-Public GlobalProgressString As String
-Public GlobalColor As Long
-Public GettingZmap As Boolean
-Public GlobalZmapAquired As Boolean
-Public idpos As Long
-Public PubAbort As Boolean
-Public Grid As Boolean
-
-Public XR As Long
-Public YR As Long
-Public x As Long
-Public y As Long
-    
-
-
-
-Public GlobalDeActivatedLocations() As Boolean
-Public GlobalLocationsOrder() As Long
-Public GlobalLocationsOrderOld() As Long
-
-
-
-Public Const ZBacklash = -50
-
-
-Public Sub MakeBlankImage(DestImage As DsRecordingDoc, _
-BitsPerSample As Long, bpp As Long, Visible As Boolean, _
-ImgName As String, TimeSeries As Boolean, NumberScans As Long, XPixels As Long, YPixels As Long, Channels As Long)
-Dim i As Long
-
-Dim Success As Integer
-Dim DataChannel As DsDataChannel
-Dim DataChannelIndex As Long
-Dim Track As DsTrack
-Dim TrackIndex As Long
-Dim lpReOpenBuff As OFSTRUCT
-Dim lpRootPathName As String
-Dim lpSectorsPerCluster As Long
-Dim lpBytesPerSector As Long
-Dim lpNumberOfFreeClusters As Long
-Dim lpTotalNumberOfClusters As Long
-Dim lSpace As Long
-Dim lFreeSpace As Double
-Dim fSize As Double
-Dim hFile As Long
-Dim zIndex As Long
-Dim TimeIndex As Long
-Dim channel As Long
-Dim SourceChannel As Long
-Dim NumberChannels As Long
-Dim DestStackNumber As Long
-Dim TimeStampIndex As Long
-Dim indxArr() As Long
-Dim NumberOfSelected As Long
-Dim NumberOfStacks As Long
-
-'Dim Channels() As String
-Dim ReturnValue As Boolean
-Dim OK As Boolean
-Dim scnline As Variant
-Dim spl As Long
-Dim Tnum As Long
-Dim newTime As Double
-Dim myDate As Date
-Dim myDate1 As Date
-Dim newTime1 As Double
-Dim myTime As Date
-Dim OldImage As Object
-Dim ImageType As Long   'ImageType=1 Non Lambda Stack, ImageType=2 Lambda Stack
-                
-    If TimeSeries Then
-        Set DestImage = Lsm5.MakeNewImageDocument(XPixels, _
-        YPixels, 1, NumberScans, _
-        Channels, bpp, Visible)
-    Else
-        Set DestImage = Lsm5.MakeNewImageDocument(XPixels, _
-        YPixels, 1, 1, _
-        Channels, bpp, Visible)
-    End If
-    If (DestImage Is Nothing) Then
-        MsgBox "Cannot Create New Window!", VbExclamation
-        Exit Sub
-    End If
-    If TimeSeries Then
-        DestImage.Recording.TimeSeries = True
-    Else
-        DestImage.Recording.TimeSeries = False
-    End If
-
-    DestImage.SetTitle ImgName
-            
-    
-Finish:
-
-End Sub
-
-
-Public Sub RedrawGrid(GridImage As DsRecordingDoc)
-Dim BitsPerSample As Long
-Dim bpp As Long
-Dim ImgName As String
-Dim LsmMath As New LsmVectorMath
-Dim SpareArrayRed() As Single
-Dim SpareArrayBlue() As Single
-Dim SpareArrayGreen() As Single
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim ix As Long
-Dim iy As Long
-Dim PlaneSize As Long
-
-    If GridImage Is Nothing Then Exit Sub
-    XPixels = GridImage.GetDimensionX
-    YPixels = GridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    
-    PlaneSize = LsmMath.ImagePlaneSizeXY(GridImage)
-    ReDim SpareArrayRed(PlaneSize)
-    ReDim SpareArrayBlue(PlaneSize)
-    ReDim SpareArrayGreen(PlaneSize)
-    For yIndx = 1 To GlobalYGrid
-        For xIndx = 1 To GlobalXGrid
-            Start = YGroup * XPixels + (3 * YGroup * XPixels) * (yIndx - 1) + XGroup + _
-            3 * XGroup * (xIndx - 1) - 1
-            For iy = 1 To 2 * YGroup
-                For ix = 1 To 2 * XGroup
-                    If Not GlobalDeActivatedLocations(xIndx, yIndx) Then
-                        SpareArrayGreen(Start + ix + (iy - 1) * XPixels) = 0
-                        SpareArrayBlue(Start + ix + (iy - 1) * XPixels) = 4000
-                        SpareArrayRed(Start + ix + (iy - 1) * XPixels) = 0
-                    Else
-                        SpareArrayRed(Start + ix + (iy - 1) * XPixels) = 1000
-                        SpareArrayGreen(Start + ix + (iy - 1) * XPixels) = 0
-                        SpareArrayBlue(Start + ix + (iy - 1) * XPixels) = 0
-                    End If
-                Next ix
-            Next iy
-        Next xIndx
-    Next yIndx
-    LsmMath.WriteImagePlaneXY GridImage, 0, 0, 0, PlaneSize, SpareArrayRed(0)
-    LsmMath.WriteImagePlaneXY GridImage, 1, 0, 0, PlaneSize, SpareArrayGreen(0)
-    LsmMath.WriteImagePlaneXY GridImage, 2, 0, 0, PlaneSize, SpareArrayBlue(0)
-    DoEvents
-
-End Sub
-Public Sub RedrawZGrid(GridImage As DsRecordingDoc)
-Dim BitsPerSample As Long
-Dim bpp As Long
-Dim ImgName As String
-Dim LsmMath As New LsmVectorMath
-Dim SpareArrayBlue() As Single
-Dim SpareArrayRed() As Single
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim xIndx As Long
-Dim yIndx As Long
-Dim Start As Long
-Dim ix As Long
-Dim iy As Long
-Dim PlaneSize As Long
-Dim MinZValue As Double
-Dim MaxZValue As Double
-Dim ColorStep As Double
-Dim ZGridRange As Double
-Dim ZGridImage As DsRecording
-
-    MinZValue = 10000           'I choose any high number that canot be reached
-    
-    MaxZValue = -10000
-    For idpos = 1 To GlobalPositionsStage
-        If GlobalZpos(idpos) < MinZValue Then
-            MinZValue = GlobalZpos(idpos)
-        End If
-        If GlobalZpos(idpos) > MaxZValue Then
-            MaxZValue = GlobalZpos(idpos)
-        End If
-    Next idpos
-ZGridRange = MaxZValue - MinZValue
-
-If ZGridRange <= 0 Then
-MsgBox "ZGridRange <= 0!" + vbCrLf + "MaxValue =" + CStr(MaxZValue) + vbCrLf + ";MinValue = " + CStr(MinZValue)
-Exit Sub
-End If
-
-ColorStep = 4000 / ZGridRange
-
-
-
- '   If ZGridImage Is Nothing Then Exit Sub
-    XPixels = GridImage.GetDimensionX
-    YPixels = GridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    
-    PlaneSize = LsmMath.ImagePlaneSizeXY(GridImage)
-    ReDim SpareArrayBlue(PlaneSize)
-    ReDim SpareArrayRed(PlaneSize)
-    For yIndx = 1 To GlobalYGrid
-        For xIndx = 1 To GlobalXGrid
-         idpos = GlobalLocationsOrder(xIndx, yIndx)
-            Start = YGroup * XPixels + (3 * YGroup * XPixels) * (yIndx - 1) + XGroup + _
-            3 * XGroup * (xIndx - 1) - 1
-            
-                For iy = 1 To 2 * YGroup
-                    For ix = 1 To 2 * XGroup
-                        If Not GlobalDeActivatedLocations(xIndx, yIndx) Then
-                          SpareArrayBlue(Start + ix + (iy - 1) * XPixels) = (GlobalZpos(idpos) - MinZValue) * ColorStep + 96
-                          SpareArrayRed(Start + ix + (iy - 1) * XPixels) = 0
-                        Else
-                            SpareArrayRed(Start + ix + (iy - 1) * XPixels) = 500
-                            SpareArrayBlue(Start + ix + (iy - 1) * XPixels) = 0
-                        End If
-                    Next ix
-                Next iy
-            
-         Next xIndx
-    Next yIndx
-    LsmMath.WriteImagePlaneXY GridImage, 2, 0, 0, PlaneSize, SpareArrayBlue(0)
-    LsmMath.WriteImagePlaneXY GridImage, 0, 0, 0, PlaneSize, SpareArrayRed(0)
-    DoEvents
-    DisplayProgress "highest Z: " + CStr(MaxZValue) + vbCrLf + "lowest Z: " + CStr(MinZValue), RGB(0, &HC0, 0)
-End Sub
-Public Sub DrawCrossGrid(xIndx As Long, yIndx As Long)
-Dim XPixels As Long
-Dim YPixels As Long
-Dim XGroup As Long
-Dim YGroup As Long
-Dim ix As Long
-Dim iy As Long
-Dim x1 As Long
-Dim Y1 As Long
-Dim X2 As Long
-Dim Y2 As Long
-
-    If (GlobalGridImage Is Nothing) Then Exit Sub
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    x1 = XGroup + 3 * XGroup * (xIndx - 1)
-    Y1 = YGroup + 3 * YGroup * (yIndx - 1)
-    X2 = 3 * XGroup + 3 * XGroup * (xIndx - 1)
-    Y2 = 3 * YGroup + 3 * YGroup * (yIndx - 1)
-      
-    GlobalGridImage.VectorOverlay.Color = RGB(255, 255, 0)
-    GlobalGridImage.VectorOverlay.LineWidth = 1
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeLine, x1, Y1, X2, Y2
-    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeLine, x1, Y2, X2, Y1
-'    dsDoc.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeCircle, xCross, yCross, xCross, yCross + 30
-    GlobalGridImage.RedrawImage
-    
-End Sub
-
-Public Sub ConvertToStagePositionXY(XP As Double, YP As Double, Xnew As Double, Ynew As Double)
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim dExchange As Double
-    Dim x As Double
-    Dim y As Double
-    
-    x = XP
-    y = YP
-    On Error GoTo oldversion
-    
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    
-    If bMirrorX Then
-        x = -x
-    End If
-'    If Not bMirrorY Then
-    If bMirrorY Then
-        y = -y
-    End If
-        
-    If bExchangeXY Then
-        Ynew = x
-        Xnew = y
-    Else
-        Xnew = x
-        Ynew = y
-    End If
-            
-    Exit Sub
-oldversion:
-
-    Xnew = X11 * x + X21 * y
-    Ynew = X12 * x + X22 * y
-    
-nostage:
-
-End Sub
-
-Public Sub DoMouseEventsMulti(ByVal EventNr As Long, ByVal Param As Variant)
-    Dim x1 As Double
-    Dim Y1 As Double
-    Dim X2 As Double
-    Dim Y2 As Double
-    Dim X3 As Double
-    Dim Y3 As Double
-    
-    Dim Xtemp As Double
-    Dim Ytemp As Double
-    Dim xtemp1 As Double
-    Dim ytemp1 As Double
-'
-'    Dim x As Long
-'    Dim y As Long
-    Dim z As Long
-    Dim t As Long
-    Dim c As Long
-    
-'    Dim XR As Long
-'    Dim YR As Long
-
-    Dim eps As Long
-    eps = 5
-    Dim cond1 As Boolean
-    Dim cond2 As Boolean
-    Dim cond3 As Boolean
-    Dim Angle As Double
-    
-    Dim Positions As Long
-    Dim XPos() As Double
-    Dim YPos() As Double
-    Dim ZPos() As Double
-    Dim ZeroChanged As Boolean
-    Dim SetZeroMarked As Boolean
-    Dim Row As Long
-    Dim XPixel As Long
-    Dim YPixel As Long
-    Dim MyString As String
-    Dim Count As Long
-    Dim Style, Title, Response
-    Dim xIndx As Long
-    Dim yIndx As Long
-    Dim DiffX As Double
-    Dim DiffY As Double
-    Dim DiffXcorr As Double
-    Dim DiffYcorr As Double
-    Dim Xcorr As Double
-    Dim Ycorr As Double
-    
-    Dim DiffXGrid As Long
-    Dim DiffYGrid As Long
-  
-'    Set Stage = Lsm5.Hardware.CpStages
-On Error GoTo marke1
-
-Select Case EventNr
-    Case eEventDsScanStopping
-        DisplayProgress "Stopping", RGB(&HC0, &HC0, 0)
-        flgEvent = 8
-    Case eEventDsScanStopped
-        flgEvent = 7
-    Case Else
-        If (EventNr = Lsm5Vba.eImageWindowNoButtonMouseMoveEvent) Then
-            If (dsDoc Is Nothing) Then
-                
-                    If Not GlobalGridImage Is Nothing Then
-                     
-                    
-                        If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                        AutofocusForm.DisplayGridSelection x, y, xIndx, yIndx
-                        End If
-                    End If
-              
-                If Not GlobalZGridImage Is Nothing Then
-                    
-                        If GlobalZGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                        AutofocusForm.DisplayGridSelection x, y, xIndx, yIndx
-                        End If
-                    End If
-            Else
-'                If dsDoc.GetCurrentMousePosition(C, T, Z, Y, X) <> 0 Then
-'                    CenterForm.Label2 = "dx=" + _
-'                    Strings.Format(CDbl(X - xCross) * dsDoc.VoxelSizeX * 10 ^ 6, "0.00") + _
-'                    " " + Strings.Chr(181) + "m" + Strings.Chr(10) + _
-'                    "dy=" + Strings.Format(CDbl(Y - yCross) * dsDoc.VoxelSizeY * 10 ^ 6, "0.00") + _
-'                    " " + Strings.Chr(181) + "m"
-'                End If
-            End If
-        ElseIf (EventNr = DS45.eImageWindowRightButtonUpEvent) Then
-            If Not GlobalGridImage Is Nothing Then
-                If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                    AutofocusForm.DisplayGridSelection x, y, xIndx, yIndx
-                  
-                
-                    Style = vbOKOnly + VbQuestion + VbDefaultButton2 ' Define buttons.
-                    Title = "Selecting Reference Locations"  ' Define title.
-
-                    Style = VbYesNo + VbQuestion + VbDefaultButton2 ' Define buttons.
-
-                    If GlobalReferencePoints = 2 Then
-                        MyString = "Is Stage Positioned at the Grid Location:" + vbCrLf + "Column=" + CStr(xIndx) + _
-                        vbCrLf + "Row=" + CStr(yIndx) + "?" + vbCrLf + "Do You Want to Use it as a Reference?" + vbCrLf + _
-                        "Previous Reference Points will be Deleted!"
-                    ElseIf GlobalReferencePoints = 1 Then
-                        MyString = "Is Stage Positioned at the Grid Location:" + vbCrLf + "Column=" + CStr(xIndx) + _
-                        vbCrLf + "Row=" + CStr(yIndx) + "?" + vbCrLf + "Do You Want to Use it as a Second Reference?"
-                    ElseIf GlobalReferencePoints = 0 Then
-                        MyString = "Is Stage Positioned at the Grid Location:" + vbCrLf + "Column=" + CStr(xIndx) + _
-                        vbCrLf + "Row=" + CStr(yIndx) + "?" + vbCrLf + "Do You Want to Use it as a First Reference?"
-                    End If
-                    Response = MsgBox(MyString, Style, Title)
-                    If Response = vbYes Then    ' User chose Yes.
-                        If GlobalReferencePoints = 2 Then
-                            GlobalReferencePoints = 1
-                            GlobalGridX1 = xIndx
-                            GlobalGridY1 = yIndx
-                            ReadLoc GlobalGridStageX1, GlobalGridStageY1
-                            GlobalGridStageZ1 = Lsm5.Hardware.CpFocus.Position
-                            GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-                            AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-                        ElseIf GlobalReferencePoints = 1 Then
-                            GlobalGridX2 = xIndx
-                            GlobalGridY2 = yIndx
-                            ReadLoc GlobalGridStageX2, GlobalGridStageY2
-                            GlobalGridStageZ2 = Lsm5.Hardware.CpFocus.Position
-                            DiffX = GlobalGridStageX2 - GlobalGridStageX1
-                            DiffY = GlobalGridStageY2 - GlobalGridStageY1
-'                            If Abs(DiffX) < 50 Or Abs(DiffY) < 50 Then
-'                                MsgBox "Selected Reference Locations are too Close!" + vbCrLf + _
-'                                "Please Select New Reference Point!"
-'                            Else
-                                DiffXGrid = GlobalGridX2 - GlobalGridX1
-                                DiffYGrid = GlobalGridY2 - GlobalGridY1
-                                If Abs(DiffXGrid) > 0 And Abs(DiffYGrid) > 0 Then
-'                                    If GlobalKeepSteps Then
-'                                        DiffXcorr = GlobalXStep * DiffXGrid
-'                                        DiffYcorr = GlobalYStep * DiffYGrid
-'                                        If (Abs(DiffXcorr - DiffX) >= Abs(GlobalXStep)) Or (Abs(DiffYcorr - DiffY) >= Abs(GlobalYStep)) Then
-'                                            MsgBox "The Difference Between Marked and Corrected Reference Points is Greater then the Grid Step!" + vbCrLf + _
-'                                            "Please Check if the Grid Steps are Correct!"
-'                                        Else
-'                                            Xcorr = (DiffXcorr - DiffX) / 2
-'                                            Ycorr = (DiffYcorr - DiffY) / 2
-'                                            GlobalGridStageX1 = GlobalGridStageX1 - Xcorr
-'                                            GlobalGridStageX2 = GlobalGridStageX2 + Xcorr
-'                                            GlobalGridStageY1 = GlobalGridStageY1 - Ycorr
-'                                            GlobalGridStageY2 = GlobalGridStageY2 + Ycorr
-'                                            GlobalReferencePoints = 2
-'                                            GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-'                                            AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-'                                            AutofocusForm.DrawCrossGrid GlobalGridX2, GlobalGridY2
-'
-'                                        End If
-'                                    Else
-                                        GlobalXStep = DiffX / DiffXGrid
-                                        GlobalYStep = DiffY / DiffYGrid
-                                        AutofocusForm.TextBoxXStep.Value = GlobalXStep
-                                        AutofocusForm.TextBoxYStep.Value = GlobalYStep
-                                        GlobalReferencePoints = 2
-                                        GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-                                        AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-                                        AutofocusForm.DrawCrossGrid GlobalGridX2, GlobalGridY2
-
-'                                    End If
-'                                End If
-                            End If
-
-                        ElseIf GlobalReferencePoints = 0 Then
-                            GlobalReferencePoints = 1
-                            GlobalGridX1 = xIndx
-                            GlobalGridY1 = yIndx
-                            ReadLoc GlobalGridStageX1, GlobalGridStageY1
-                            GlobalGridStageZ1 = Lsm5.Hardware.CpFocus.Position
-                            GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-                            AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-
-                        End If
-                    End If
-                
-                End If
-            End If
-        ElseIf (EventNr = Lsm5Vba.eImageWindowLeftButtonDownEvent) Then
-            If Not GlobalGridImage Is Nothing Then
-                If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
- '                   GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-'                    GlobalGridImage.VectorOverlay.AddSimpleDrawingElement Lsm5Vba.eDrawingModeRectangle, X, Y, X, Y
-'                    GlobalGridImage.RedrawImage
-                    AutofocusForm.DrawRectangleGrid x, y, x, y
-                End If
-            End If
-       
-        ElseIf (EventNr = Lsm5Vba.eImageWindowLButtonMouseMoveEvent) Then
-               If Not GlobalGridImage Is Nothing Then
-                If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                    Count = GlobalGridImage.VectorOverlay.GetNumberDrawingElements
-                    If GlobalGridImage.VectorOverlay.GetKnot(Count - 1, 0, XR, YR) Then
-                        GlobalGridImage.VectorOverlay.RemoveDrawingElement Count - 1
-                        AutofocusForm.DrawRectangleGrid XR, YR, x, y
-                        AutofocusForm.DisplayGridSelection x, y, xIndx, yIndx
-                    End If
-                End If
-            End If
-       
-        ElseIf (EventNr = Lsm5Vba.eImageWindowLeftButtonUpEvent) Then
-        If (XR = x And YR = y) Then
-        GridOnOff x, y, XR, YR
-        GoTo Continue3
-        Else
-        GoTo Continue1
-        End If
- 
-Continue1:
-            If Not GlobalGridImage Is Nothing Then
-                If GlobalGridImage.GetCurrentMousePosition(c, t, z, y, x) <> 0 Then
-                    Count = GlobalGridImage.VectorOverlay.GetNumberDrawingElements
-                    If GlobalGridImage.VectorOverlay.GetKnot(Count - 1, 0, x, y) Then
-                        If GlobalGridImage.VectorOverlay.GetKnot(Count - 1, 1, XR, YR) Then
-                            If (XR <> x) Or (YR <> y) Then
-                            SelectLocs.Show
-'                                Style = vbOKOnly + VbQuestion + VbDefaultButton2 ' Define buttons.
-'                                Title = "Select/Deselect Locations"  ' Define title.
-'
-'                '                GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLButtonMouseMoveEvent, 0
-'                '                GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonDownEvent, 0
-'                '                GlobalGridImage.EnableImageWindowEvent Lsm5Vba.eImageWindowLeftButtonUpEvent, 0
-'
-'                                Style = VbYesNo + VbQuestion + VbDefaultButton2 ' Define buttons.
-'                                MyString = "Select Locations - Click YES;" + vbCrLf + "Deselect Locations - Click NO"
-'                                Response = MsgBox(MyString, Style, Title)
-'                                If Response = vbYes Then    ' User chose Yes.
-'                                    GridSelection x, y, XR, YR, True
-'                                Else
-'                                    GridSelection x, y, XR, YR, False
-'                                End If
-Continue3:
-                     If Not GlobalGridImage Is Nothing Then
-                                GlobalGridImage.VectorOverlay.RemoveAllDrawingElements
-                                If GlobalReferencePoints = 2 Then
-                                    AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-                                    AutofocusForm.DrawCrossGrid GlobalGridX2, GlobalGridY2
-                                ElseIf GlobalReferencePoints = 1 Then
-                                    AutofocusForm.DrawCrossGrid GlobalGridX1, GlobalGridY1
-                                End If
-                                RedrawGrid GlobalGridImage
-                               
-                            End If
-                           End If
-                        End If
-                    End If
-                End If
-            End If
-        End If
-    End Select
-'Set Stage = Nothing
-marke1:
-End Sub
-
-Public Sub GridSelection(x As Long, y As Long, XR As Long, YR As Long, Activate As Boolean)
-    Dim XPixels As Long
-    Dim YPixels As Long
-    Dim XGroup As Long
-    Dim YGroup As Long
-    Dim xIndx As Long
-    Dim yIndx As Long
-    Dim Start As Long
-    Dim ix As Long
-    Dim iy As Long
-    Dim Xmin As Long
-    Dim Xmax As Long
-    Dim Ymin As Long
-    Dim Ymax As Long
-    Dim xImage As Long
-    Dim StartX As Long
-    Dim yImage As Long
-    Dim StartY As Long
-    Dim Found As Boolean
-
-    If GlobalGridImage Is Nothing Then Exit Sub
-    If x >= XR Then
-        Xmin = XR
-        Xmax = x
-    Else
-        Xmin = x
-        Xmax = XR
-    End If
-    If y >= YR Then
-        Ymin = YR
-        Ymax = y
-    Else
-        Ymin = y
-        Ymax = YR
-    End If
-    
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    For yIndx = 1 To GlobalYGrid
-        For xIndx = 1 To GlobalXGrid
-            StartX = XGroup + 3 * XGroup * (xIndx - 1)
-            StartY = YGroup + 3 * YGroup * (yIndx - 1)
-            Found = False
-            For iy = 1 To 2 * YGroup
-                For ix = 1 To 2 * XGroup
-                    xImage = StartX + ix
-                    yImage = StartY + iy
-                    If xImage >= Xmin And xImage <= Xmax And yImage >= Ymin And yImage <= Ymax Then
-                        GlobalDeActivatedLocations(xIndx, yIndx) = Not Activate
-                        Found = True
-                        Exit For
-                    End If
-                    If Found Then Exit For
-                Next ix
-            Next iy
-        Next xIndx
-    Next yIndx
-    GlobalOrderChanged = True
-End Sub
-
-Public Sub GridOnOff(x As Long, y As Long, XR As Long, YR As Long)
-    Dim XPixels As Long
-    Dim YPixels As Long
-    Dim XGroup As Long
-    Dim YGroup As Long
-    Dim xIndx As Long
-    Dim yIndx As Long
-    Dim Start As Long
-    Dim ix As Long
-    Dim iy As Long
-    Dim Xmin As Long
-    Dim Xmax As Long
-    Dim Ymin As Long
-    Dim Ymax As Long
-    Dim xImage As Long
-    Dim StartX As Long
-    Dim yImage As Long
-    Dim StartY As Long
-    Dim Found As Boolean
-
-    If GlobalGridImage Is Nothing Then Exit Sub
-    If x >= XR Then
-        Xmin = XR
-        Xmax = x
-    Else
-        Xmin = x
-        Xmax = XR
-    End If
-    If y >= YR Then
-        Ymin = YR
-        Ymax = y
-    Else
-        Ymin = y
-        Ymax = YR
-    End If
-    
-    XPixels = GlobalGridImage.GetDimensionX
-    YPixels = GlobalGridImage.GetDimensionY
-    
-    XGroup = Int(XPixels / (3 * GlobalXGrid + 1))
-    YGroup = Int(YPixels / (3 * GlobalYGrid + 1))
-    For yIndx = 1 To GlobalYGrid
-        For xIndx = 1 To GlobalXGrid
-            StartX = XGroup + 3 * XGroup * (xIndx - 1)
-            StartY = YGroup + 3 * YGroup * (yIndx - 1)
-            Found = False
-            For iy = 1 To 2 * YGroup
-                For ix = 1 To 2 * XGroup
-                    xImage = StartX + ix
-                    yImage = StartY + iy
-                    If xImage >= Xmin And xImage <= Xmax And yImage >= Ymin And yImage <= Ymax Then
-                        GlobalDeActivatedLocations(xIndx, yIndx) = Not GlobalDeActivatedLocations(xIndx, yIndx)
-                        Found = True
-                        Exit For
-                    End If
-                    If Found Then Exit For
-                Next ix
-            Next iy
-        Next xIndx
-    Next yIndx
-    GlobalOrderChanged = True
-End Sub
-
-Public Sub ReadLoc(x As Double, y As Double)
-    Dim cnt As Long
-    
-    cnt = 0
-    On Error GoTo retry
-retry:
-    If cnt > 1000 Then GoTo Finish
-    cnt = cnt + 1
-    x = Lsm5.Hardware.CpStages.PositionX
-    y = Lsm5.Hardware.CpStages.PositionY
-Finish:
-End Sub
-
-Public Sub CoordinateConversion(bExchangeXY As Boolean, bMirrorX As Boolean, bMirrorY As Boolean)
-    Dim bLSM As Boolean
-    Dim bLIVE As Boolean
-    Dim bCamera As Boolean
-    Dim lsystem As Long
-'    If GlobalSystemVersion = 32 Then
-'        Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisState bExchangeXY, bMirrorX, bMirrorY
-'    ElseIf GlobalSystemVersion > 32 Then
-        UsedDevices40 bLSM, bLIVE, bCamera
-        If bLSM Then
-            lsystem = 0
-        ElseIf bLIVE Then
-            lsystem = 1
-        ElseIf bCamera Then
-            lsystem = 3
-        End If
-'    End If
-    Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS lsystem, bExchangeXY, bMirrorX, bMirrorY
-
-End Sub
-
-Public Sub UsedDevices40(bLSM As Boolean, bLIVE As Boolean, bCamera As Boolean)
-    Dim Scancontroller As AimScanController
-    Dim TrackParameters As AimTrackParameters
-    Dim Size As Long
-    Dim lTrack As Long
-    Dim eDeviceMode As Long
-    
-    bLSM = False
-    bLIVE = False
-    bCamera = False
-    Set Scancontroller = Lsm5.ExternalDsObject.Scancontroller
-    Set TrackParameters = Scancontroller.TrackParameters
-    If TrackParameters Is Nothing Then Exit Sub
-    Size = TrackParameters.GetTrackArraySize
-    For lTrack = 0 To Size - 1
-       ' If TrackParameters.IsTrackUsed(lTrack) Then
-            eDeviceMode = TrackParameters.TrackDeviceMode(lTrack)
-            Select Case eDeviceMode
-                Case eAimDeviceModeLSM
-                    bLSM = True
-                   
-                Case eAimDeviceModeLSM_ChannelMode
-                    bLSM = True
-                   
-                Case eAimDeviceModeLSM_NDD
-                    bLSM = True
-                    
-                Case eAimDeviceModeLSM_DD
-                    bLSM = True
-                   
-                Case eAimDeviceModeSpectralImager
-                    bLSM = True
-                    Exit Sub
-                
-                Case eAimDeviceModeRtScanner
-                    bLIVE = True
-                    Exit Sub
-                
-                Case eAimDeviceModeCamera1
-                    bCamera = True
-                    Exit Sub
-                
-            End Select
-       ' End If
-    Next lTrack
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/StoreApply.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/StoreApply.frm
deleted file mode 100644
index 317f724..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/StoreApply.frm
+++ /dev/null
@@ -1,117 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} StoreApply 
-   Caption         =   "Store/Apply Grid"
-   ClientHeight    =   1380
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   5685
-   OleObjectBlob   =   "StoreApply.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "StoreApply"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-'This Form was kept to keep the possibility of saving the macro setting into the registry.
-' It is not used in current state of the macro
-
-Private Sub CommandButtonClose_Click()
-    Unload StoreApplyForm
-End Sub
-
-
-Sub FillRecipeList()
-    Dim Count As Long
-    Dim idx As Long
-    Dim MyMacroKey As String
-    Dim path As String
-    Dim Success As Boolean
-    Dim result As Long
-    Dim key As String
-    ComboBoxRecipe.Clear
-    key = "UI\" + GlobalMacroKey
-    Success = tools.RegExistKey(key)
-    If Success Then
-        Count = tools.RegCountSubKeys(key)
-    Else
-        Success = tools.RegCreateKey(key)
-    End If
-    If Count > 0 Then
-        For idx = 0 To Count - 1
-            ComboBoxRecipe.AddItem tools.RegSubkeyName(idx, key)
-        Next idx
-        If (Count > 0) Then
-            ComboBoxRecipe.ListIndex = 0
-        End If
-        ComboBoxRecipe.ListIndex = 0
-    End If
-End Sub
-
-
-Private Sub CommandButtonDelete_Click()
-    Dim myKey As String
-    Dim Success As Boolean
-    Dim deleteOK As Boolean
-    Dim idx As Long
-    Dim lockNo As Long
-    Dim Msg, Style, Title, Help, Ctxt, Response, MyString
-    AutofocusForm.GetBlockValues
-    deleteOK = True
-    myKey = "UI\" + GlobalMacroKey + "\" + ComboBoxRecipe.Value
-    Success = tools.RegExistKey(myKey)
-    If Success Then
-        Msg = "Do You want to delete recipe " + ComboBoxRecipe.Value + "?"
-        Style = VbYesNo + VbCritical + VbDefaultButton2 ' Define buttons.
-        Title = "Recipe Delete"  ' Define title.
-        Response = MsgBox(Msg, Style, Title)
-        If Response = vbYes Then    ' User chose Yes.
-        Else    ' User chose No.
-            deleteOK = False
-        End If
-    Else
-    End If
-    If deleteOK Then
-        Success = tools.RegDeleteKey(myKey)
-    End If
-    Unload StoreApply
-End Sub
-
-
-Private Sub CommandButtonStore_Click()
-Dim filenam As String
-Dim path As String
-Dim hFile As Long
-Dim fs
-Dim idx As Long
-Dim idy As Long
-
-
-path = "c:\AIM\macros\datafiles\"
-filnam = path + CStr(ComboBoxGrid.Value) + ".txt"
-hFile = FreeFile
-
-Set fs = CreateObject("Scripting.FileSystemObject")
-    fs.CreateTextFile filnam          'Create a file
-Open filnam For Output As hFile         'open file
-Print #hFile, TextBoxXGrid.Value
-Print #hFile, TextBoxYGrid.Value
-Print #hFile, TextBoxXStep.Value
-Print #hFile, TextBoxYGrid.Value
-
-For idy = 1 To GlobalYGrid
-     For idx = 1 To GlobalXGrid
-                       
-        Print #hFile, GlobalDeActivatedLocations(idx, idy)
-                                
-     Next idx
-Next idy
-Print #hFile, AutofocusForm.CheckBoxMeander.Value
-   
-End Sub
-
-
-Private Sub UserForm_Initialize()
-    FillRecipeList
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/StoreApplyForm.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/StoreApplyForm.frm
deleted file mode 100644
index ad23b66..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/StoreApplyForm.frm
+++ /dev/null
@@ -1,179 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} StoreApplyForm 
-   Caption         =   "Store/Apply Grid"
-   ClientHeight    =   1350
-   ClientLeft      =   645
-   ClientTop       =   930
-   ClientWidth     =   5550
-   OleObjectBlob   =   "StoreApplyForm.frx":0000
-   StartUpPosition =   3  'Windows Default
-End
-Attribute VB_Name = "StoreApplyForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-
- 
-Private Sub CommandButtonDelete_Click()
-Dim x As Long
-
-filnam = PubGridPathData + CStr(ComboBoxGrid.Value) + ".txt"
-Msg = "Do You want to delete grid '" + ComboBoxGrid.Value + "' ?"
-        Style = VbYesNo + VbCritical + VbDefaultButton2 ' Define buttons.
-        Title = "Grid Delete"  ' Define title.
-        Response = MsgBox(Msg, Style, Title)
-        If Response = vbYes Then
-            Kill filnam
-            x = ComboBoxGrid.ListIndex
-            ComboBoxGrid.RemoveItem (x)
-            ComboBoxGrid.Cut
-            ComboBoxGrid.Value = ""
-            FillRecipeList
-        End If
-End Sub
-
-Private Sub UserForm_Initialize()
-FilerQuery
-FillRecipeList
-
-End Sub
-
-
-Private Sub CommandButtonApply_Click()
-Dim filenam As String
-Dim hFile As Long
-Dim fs
-Dim idx As Long
-Dim idy As Long
-Dim Value As String
-filnam = PubGridPathData + CStr(ComboBoxGrid.Value) + ".txt"
-hFile = FreeFile
-
-Open filnam For Input As hFile
-Input #hFile, GlobalXGrid
-Input #hFile, GlobalYGrid
-Input #hFile, GlobalXStep
-Input #hFile, GlobalYStep
-
-
-AutofocusForm.TextBoxXGrid.Value = GlobalXGrid
-AutofocusForm.TextBoxYGrid.Value = GlobalYGrid
-AutofocusForm.TextBoxXStep.Value = GlobalXStep
-AutofocusForm.TextBoxYStep.Value = GlobalYStep
-
-ReDim GlobalDeActivatedLocations(GlobalXGrid, GlobalYGrid)
-For idy = 1 To GlobalYGrid
-     For idx = 1 To GlobalXGrid
-        Input #hFile, Value
-         GlobalDeActivatedLocations(idx, idy) = CBool(Value)
-     Next idx
-Next idy
-On Error Resume Next ' in older verios the meander varable wasnot saved to avoid, that you cannot use this files
-Input #hFile, Value
-GlobalMeander = CBool(Value)
-
-AutofocusForm.CheckBoxMeander.Value = GlobalMeander
-Close #hFile
-AutofocusForm.ShowGrid
-End Sub
-
-Private Sub CommandButtonClose_Click()
-   Unload StoreApplyForm
-End Sub
-
-Private Sub CommandButtonStore_Click()
-Dim filenam As String
-Dim filenew As String
-
-Dim fso As New FileSystemObject
-'Dim fold As Folder
-'Set fold = fso.GetFolder(PubGridPath)
-
-
-filenam = PubGridPathData + CStr(ComboBoxGrid.Value) + ".txt"
-filenew = CStr(ComboBoxGrid.Value)
-
-If fso.FileExists(filenam) = False Then
-    CreateNewFolder filenam
-Else
-        Msg = "File '" + ComboBoxGrid.Value + "' already exists." + vbCrLf + "Do You want to overwrite '" + ComboBoxGrid.Value + "' ?"
-        Style = VbYesNo + VbCritical + VbDefaultButton2 ' Define buttons.
-        Title = "Grid Delete"  ' Define title.
-        Response = MsgBox(Msg, Style, Title)
-        If Response = vbYes Then
-            CreateNewFolder filenam
-        Else
-            Exit Sub
-        End If
-End If
-
-
-FillRecipeList
-MsgBox "Grid " + filenew + " is stored successfully!"
-End Sub
-
-Sub FillRecipeList()
-    Dim Count As Long
-    Dim idx As Long
-    Dim filenam As String
-    Dim path As String
-    Dim Success As Boolean
-    Dim result As Long
-    Dim key As String
-    ComboBoxGrid.Clear
-    Dim fso As New FileSystemObject
-    Dim fold As Folder
-    Dim f As File
-    Dim name As String
-    Dim lenfilnam As Integer
-    Dim i As Integer
-    
-    
-    Set fold = fso.GetFolder(PubGridPathData)
-     For Each f In fold.Files
-        filenam = fso.GetFileName(f)
-     lenfilnam = Len(filenam)
-     name = Left(filenam, lenfilnam - 4)
-     
-      ComboBoxGrid.AddItem name
-      Next
-     i = ComboBoxGrid.ListCount
-     If i = 0 Then Exit Sub
-      ComboBoxGrid.Value = ComboBoxGrid.List(0)
-
-End Sub
-
-Private Sub FilerQuery()
-Dim fso As New FileSystemObject
-Dim fs
-Dim fold As Folder
-Set fold = fso.GetFolder(PubGridPath)
-If fso.FolderExists(PubGridPathData) = False Then
-    fso.CreateFolder (PubGridPathData)
-End If
-
-End Sub
-
-Private Sub CreateNewFolder(filnam As String)
-Dim hFile As Long
-Dim fs
-Dim idx As Long
-Dim idy As Long
-hFile = FreeFile
-Set fs = CreateObject("Scripting.FileSystemObject")
-        fs.CreateTextFile filnam          'Create a file
-    Open filnam For Output As hFile         'open file
-    Print #hFile, GlobalXGrid
-    Print #hFile, GlobalYGrid
-    Print #hFile, AutofocusForm.TextBoxXStep.Value
-    Print #hFile, AutofocusForm.TextBoxYStep.Value
-    For idy = 1 To GlobalYGrid
-     For idx = 1 To GlobalXGrid
-        Print #hFile, GlobalDeActivatedLocations(idx, idy)
-     Next idx
-Next idy
-    Print #hFile, AutofocusForm.CheckBoxMeander.Value
-Close #hFile
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/TileScan.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/TileScan.bas
deleted file mode 100644
index 25966c2..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/TileScan.bas
+++ /dev/null
@@ -1,66 +0,0 @@
-Attribute VB_Name = "TileScan"
-
-Dim TileX As Integer
-Dim TileY As Integer
-Dim GlobalPositionsStageOld As Integer
-Dim FrameWidth As Double
-Dim FrameHeight As Double
-Dim RelFrameHeight As Double
-Dim RelFrameWidth As Double
-Dim Overlap As Double
-Dim Xnew As Double
-Dim Ynew As Double
-
-
-Public Sub Tile()
-TileX = AutofocusForm.TextBoxTileX.Value
-TileY = AutofocusForm.TextBoxTileY.Value
-Overlap = AutofocusForm.TextBoxOverlap.Value
-
-FrameWidth = Lsm5.DsRecording.FrameWidth
-FrameHeight = Lsm5.DsRecording.FrameHeight
-
-RelFrameWidth = FrameWidth - (FrameWidth * Overlap) / 100
-RelFrameHeight = FrameHeight - (FrameHeight * Overlap) / 100
-
-If (TileX > 1 Or TileY > 1) Then CalculateTileLocs
-
-End Sub
-
-
-Public Sub CalculateTileLocs()
-CopyPositionArrays
-
-End Sub
-
-
-Public Sub CopyPositionArrays()
-GlobalXposOld() = GlobalXpos()
-GlobalYposOld() = GlobalYpos()
-GlobalZposOld() = GlobalZpos()
-GlobalLocationsNameOld() = GlobalLocationsName()
-GlobalPositionsStageOld = GlobalPositionsStage
-GlobalPositionsStage = GlobalPositionsStage * TileX * TileY
-ReDim GlobalXpos(GlobalPositionsStage)
-ReDim GlobalYpos(GlobalPositionsStage)
-ReDim GlobalZpos(GlobalPositionsStage)
-ReDim GlobalLocationsName(GlobalPositionsStage)
-Dim n As Integer
-Dim TX As Integer
-Dim TY As Integer
-
-For n = 0 To GlobalPositionsStageOld - 1
-Xnew = GlobalXposOld(n + 1) - ((TileX - 1) / 2) * RelFrameWidth
-Ynew = GlobalYposOld(n + 1) - ((TileY - 1) / 2) * RelFrameHeight
-    For TY = 0 To TileY - 1
-        For TX = 0 To TileX - 1
-            GlobalXpos(n * TileX * TileY + (TY * TileX) + TX + 1) = Xnew + TX * RelFrameWidth
-            GlobalYpos(n * TileX * TileY + (TY * TileX) + TX + 1) = Ynew + TY * RelFrameHeight
-            GlobalZpos(n * TileX * TileY + (TY * TileX) + TX + 1) = GlobalZposOld(n + 1)
-            If Grid Then
-            GlobalLocationsName(n * TileX * TileY + (TY * TileX) + TX + 1) = GlobalLocationsNameOld(n + 1)
-            End If
-         Next TX
-     Next TY
-Next n
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/ZValues.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/ZValues.frm
deleted file mode 100644
index 68222d8..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/ZValues.frm
+++ /dev/null
@@ -1,25 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} ZValues 
-   Caption         =   "ZValues"
-   ClientHeight    =   2175
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   4365
-   OleObjectBlob   =   "ZValues.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "ZValues"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-Private Sub CommandButton1_Click()
-GlobalStageControlZValues = True
-ZValues.Hide
-End Sub
-
-Private Sub CommandButton2_Click()
-GlobalStageControlZValues = False
-ZValues.Hide
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/newMacros.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/newMacros.bas
deleted file mode 100644
index 54a6e1f..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/newMacros.bas
+++ /dev/null
@@ -1,923 +0,0 @@
-Attribute VB_Name = "newMacros"
-Option Explicit
-Public SystemVersion As String
-Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
-Public Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
-Declare Function RegOpenKeyEx _
-    Lib "advapi32.dll" Alias "RegOpenKeyExA" _
-    (ByVal hKey As Long, ByVal lpSubKey As String, _
-    ByVal ulOptions As Long, ByVal samDesired As Long, _
-    phkResult As Long) As Long
-
-Public Declare Function RegCloseKey _
-    Lib "advapi32.dll" (ByVal hKey As Long) As Long
-
-Public Declare Function RegQueryValueEx _
-    Lib "advapi32.dll" Alias "RegQueryValueExA" _
-    (ByVal hKey As Long, ByVal lpValueName As String, _
-    ByVal lpReserved As Long, lpType As Long, _
-    lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
-
-Public Const VK_SPACE = &H20
-Public Const VK_RETURN = &HD
-Public Const VK_CANCEL = &H3
-Public Const VK_UP = &H26
-Public Const VK_DOWN = &H28
-Public Const VK_ESCAPE = &H1B
-Public Const VK_PAUSE = &H13
-Public Const VK_ADD = &H6B
-Public Const VK_SUBTRACT = &H6D
-Public Const HKEY_CLASSES_ROOT = &H80000000
-Public Const SYNCHRONIZE = &H100000
-Public Const READ_CONTROL = &H20000
-Public Const STANDARD_RIGHTS_READ = (READ_CONTROL)
-Public Const KEY_QUERY_VALUE = &H1
-Public Const KEY_ENUMERATE_SUB_KEYS = &H8
-Public Const KEY_NOTIFY = &H10
-Public Const KEY_READ = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
-
-Public Const REG_SZ = 1                         ' Unicode nul terminated string
-Public Const ERROR_SUCCESS = 0&
-
-Public Const vbOKOnly = 0   '  Display OK button only.
-Public Const VbOKCancel = 1 '  Display OK and Cancel buttons.
-Public Const VbAbortRetryIgnore = 2  ' Display Abort, Retry, and Ignore buttons.
-Public Const VbYesNoCancel = 3  '  Display Yes, No, and Cancel buttons.
-Public Const VbYesNo = 4 '  Display Yes and No buttons.
-Public Const VbRetryCancel = 5   ' Display Retry and Cancel buttons.
-Public Const VbCritical = 16 ' Display Critical Message icon.
-Public Const VbQuestion = 32 ' Display Warning Query icon.
-Public Const VbExclamation = 48  ' Display Warning Message icon.
-Public Const VbInformation = 64  ' Display Information Message icon.
-Public Const VbDefaultButton1 = 0    ' First button is default.
-Public Const VbDefaultButton2 = 256  ' Second button is default.
-Public Const VbDefaultButton3 = 512  ' Third button is default.
-Public Const VbDefaultButton4 = 768   'Fourth button is default.
-Public Const VbApplicationModal = 0  ' Application modal; the user must respond to the message box before continuing work in the current application.
-Public Const VbSystemModal = 4096   '  System modal; all applications are suspended until the user responds to the message box.
-'The first group of values (05) describes the number and type of buttons displayed in the dialog box; the second group (16, 32, 48, 64) describes the icon style; the third group (0, 256, 512) determines which button is the default; and the fourth group (0, 4096) determines the modality of the message box. When adding numbers to create a final value for the buttons argument, use only one number from each group.
-
-'Note   These constants are specified by Visual Basic for Applications. As a result, the names can be used anywhere in your code in place of the actual values.
-
-'Return Values
-Public Const vbOK = 1   '  OK
-Public Const vbCancel = 2    ' Cancel
-Public Const vbAbort = 3 ' Abort
-Public Const vbRetry = 4 '  Retry
-Public Const vbIgnore = 5   '  Ignore
-Public Const vbYes = 6  '  Yes
-Public Const vbNo = 7    ' No
-
-
-Public X11 As Double
-Public X12 As Double
-Public X21 As Double
-Public X22 As Double
-
-Public ScanStop As Boolean
-Public ScanPause As Boolean
-Public Running As Boolean
-Public ExtraBleach As Boolean
-Public AutomaticBleaching As Boolean
-Public BleachTable() As Boolean
-Public BleachStartTable() As Double
-Public BleachStopTable() As Double
-Public RepetitionNumber As Long
-
-Public Zoffset As Double
-Public MultipleLocation As Boolean
-Public LocationTracking As Boolean
-Public TrackZ As Boolean
-Public TrackingChannelString As String
-'Public PositionData As Workbook
-Public FrameAutofocussing As Boolean
-Public XMass As Double
-Public YMass As Double
-Public ZMass As Double
-Public ZShift As Double
-Public xShift As Double
-Public yShift As Double
-Public Zbefore As Double
-Public HRZBefore As Double
-Public HRZ As Boolean
-Public NoReflectionSignal As Boolean
-Public PubSentStageGrid As Boolean
-Public BleachingActivated As Boolean
-
-Public flgUserChange As Boolean
-Public flgEvent As Integer
-Public flg As Integer
-Public toContinue As Integer
-
-Public GlobalProjectName As String
-Public GlobalProject As String
-Public GlobalHelpName As String
-
-Public GlobalPrvTime As Double
-Public GlobalMacroKey As String
-Public GlobalCorrectionOffset As Double
-
-'newPublic29.06.2010
-Public NoFrames As Long
-
-' Public BlockAutoConfiguration As String
-Public BlockTimeIndex As Long
-' Public BlockAutoConfigurationUse As Boolean
-
-Public TimerName As String
-Public BlockTimeDelay As Double
-Public SelectedTimeButton As Integer
-Public TimerButton1 As Double
-Public TimerButton2 As Double
-Public TimerButton3 As Double
-Public TimerButton4 As Double
-Public TimerButton5 As Double
-Public TimerButton6 As Double
-Public TimerUnit As Integer
-Public BlockRepetitions As Long
-
-Public TimerKey As String
-
-Public GlobalHighRes As Boolean
-Public GlobalDataBaseName As String
-Public GlobalFileName As String
-Public GlobalImageIndex() As Long
-Public GlobalStripeIndex() As Long
-Public BlockZOffset As Double
-Public BlockZRange As Double
-Public BlockZStep As Double
-Public BlockHighSpeed As Boolean
-Public BlockLowZoom As Boolean
-Public BlockHRZ As Boolean
-Public PubSearchScan As Boolean
-
-Public BlockIsSingle As Boolean
-Public BlockSingleTrack As String
-Public BlockSingleTrackIndex As Long
-Public BlockMultiTrack As String
-Public BlockMultiTrackIndex As Long
-
-
-     
-Public Track As DsTrack
-Public TrackNumber As Integer
-Public TrackName As String
-Public Success As Integer
-Public IsAutofocusTrackSelected As Boolean
-Public AutofocusTrack As Integer
-Public IsAcquisitionTrackSelected As Boolean
-Public ActiveChannels() As String
-
-Public DoNotGoOn As Boolean
-Public ChangeFocus As Boolean
-Public FocusChanged As Boolean
-Public Try As Long
-Public SystemName As String
-          
-Public GlobalBackupRecording As DsRecording
-Public BackupRecording As DsRecording
-Public ImageNumber As Long
-Public Const OFS_MAXPATHNAME = 128
-Public Const OF_EXIST = &H4000
-Public flgBreak As Boolean
-Public Const WM_COMMAND = &H111
-
-Public tools As Lsm5Tools
-Public Stage As CpStages
-
-Public TileX As Integer
-Public TileY As Integer
-Public Overlap As Double
-
-Public AcquisitionController As AimAcquisitionController40.AimScanController  'Debugging 20110131
-Public RecordingDocpub As DsRecordingDoc
-
-
-
-Public posGridX(10000) As Double
-Public posGridY(10000) As Double
-Public locationNumbersMainGrid(10000) As Integer
-Public posGridXY_valid(10000) As Integer
-Public nGoodCells As Integer
-Public minGoodCellsPerImage As Integer
-Public minGoodCellsPerWell As Integer
-Public nGoodCellsPerWell As Integer
-
-        
-Public HelpNamePDF As String
-
-Public GlobalStageControlZValues As Boolean
-
-Public Type OFSTRUCT
-        cBytes As Byte
-        fFixedDisk As Byte
-        nErrCode As Integer
-        Reserved1 As Integer
-        Reserved2 As Integer
-        szPathName(OFS_MAXPATHNAME) As Byte
-End Type
-Public Type OVERLAPPED
-        Internal As Long
-        InternalHigh As Long
-        offset As Long
-        OffsetHigh As Long
-        hEvent As Long
-End Type
-Public Type SECURITY_ATTRIBUTES
-        nLength As Long
-        lpSecurityDescriptor As Long
-        bInheritHandle As Long
-End Type
-
-
-Public Declare Function OpenFile Lib "kernel32" (ByVal lpFileName As String, lpReOpenBuff As OFSTRUCT, _
-ByVal wStyle As Long) As Long
-
-Public Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
-
-Public Declare Function DeleteFile Lib "kernel32" Alias "DeleteFileA" (ByVal lpFileName As String) As Long
-
-Public Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" _
-(ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, _
-lpNumberOfFreeClusters As Long, lpTotalNumberOfClusters As Long) As Long
-
-Public Declare Function GetTickCount Lib "kernel32" () As Long
-
-
-
-Sub A_Setup()
-     AutofocusForm.Show
-End Sub
-
-
-Public Sub DisplayProgress(state As String, Color As Long)       'Used to display in the progress bar what the macro is doing
-    If (Color & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Then
-        AutofocusForm.ProgressLabel.ForeColor = 0
-    Else
-        AutofocusForm.ProgressLabel.ForeColor = &HFFFFFF
-    End If
-    AutofocusForm.ProgressLabel.BackColor = Color
-    AutofocusForm.ProgressLabel.Caption = state
-End Sub
-
-
-Public Sub AutoStore()    ' This was used to store values of the macro parameteres in the registry. This could be used for saving of the macro and resuisng them but is not working in its present state.
-    Dim myKey As String
-    Dim Success As Boolean
-    Dim storeOK As Boolean
-    Dim idx As Long
-    Dim lockNo As Long
-    Dim Msg, Style, Title, Help, Ctxt, Response, MyString
-    AutofocusForm.GetBlockValues
-    storeOK = True
-    myKey = "UI\" + GlobalMacroKey + "\AutoStore"
-    Success = tools.RegExistKey(myKey)
-    If Success Then
-        Success = tools.RegDeleteKey(myKey)
-    End If
-    Success = tools.RegCreateKey(myKey)
-'    tools.RegStringValue(myKey, "BlockAutoConfiguration") = BlockAutoConfiguration
-    tools.RegLongValue(myKey, "BlockTimeIndex") = BlockTimeIndex
-'    tools.RegLongValue(myKey, "BlockAutoConfigurationUse") = BlockAutoConfigurationUse
-    tools.RegDoubleValue(myKey, "BlockHighSpeed") = BlockHighSpeed
-    tools.RegDoubleValue(myKey, "BlockLowZoom") = BlockLowZoom
-    tools.RegDoubleValue(myKey, "BlockHRZ") = BlockHRZ
-   
-    tools.RegDoubleValue(myKey, "BlockZoffset") = BlockZOffset
-    tools.RegDoubleValue(myKey, "BlockZRange") = BlockZRange
-    tools.RegDoubleValue(myKey, "BlockZStep") = BlockZStep
-End Sub
-
-
-Public Sub ScanToImage(RecordingDoc As DsRecordingDoc) ' new routine to scan overwrite the same image, even with several z-slices
-   ' Dim AcquisitionController As AimAcquisitionController40.AimScanController 'now public
-    Dim image As AimImage
-    
-    If Not RecordingDoc Is Nothing Then
-        Set image = RecordingDoc.RecordingDocument.image(0, True)
-
-        If Not image Is Nothing Then
-            Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-            AcquisitionController.DestinationImage(0) = image
-            AcquisitionController.DestinationImage(1) = Nothing
-            AcquisitionController.StartGrab eGrabModeSingle
-        End If
-    End If
-    
-End Sub
-
-Public Sub ScanToImageNew(RecordingDoc As DsRecordingDoc) ' new routine to scan overwrite the same image, even with several z-slices
-    'new changed on 30.05.2011 should then also scan and keep all the tracks...
-    'Dim AcquisitionController As AimAcquisitionController40.AimScanController 'now public
-    Dim ProgressFifo As IAimProgressFifo
-
-    Dim AcquisitionController As AimAcquisitionController40.AimScanController
-    Dim WasLocked As Double
-    
-    Dim gui As Object, treenode As Object
-    Set gui = Lsm5.ViewerGuiServer
-    
-    'MsgBox "preparing new image..."
-    
-    If Not RecordingDoc Is Nothing Then
-        
-        'MsgBox "taking new image..."
-        
-        Set treenode = RecordingDoc.RecordingDocument.image(0, True)
-        'Set treenode = Lsm5.NewDocument
-    
-        Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-        AcquisitionController.DestinationImage(0) = treenode 'EngelImageToHechtImage(GlobalSingleImage).Image(0, True)
-        AcquisitionController.DestinationImage(1) = Nothing
-        Set ProgressFifo = AcquisitionController.DestinationImage(0)
-        Lsm5.tools.CheckLockControllers True
-        
-        AcquisitionController.StartGrab eGrabModeSingle
-        If Not ProgressFifo Is Nothing Then ProgressFifo.Append AcquisitionController
-    End If
-    
-End Sub
-
-
-
-Public Sub AutoRecall()   ' This was used to read values of the macro parameteres in the registry. This could be used for saving of the macro and resuisng them but is not working in its present state.
-    Dim myKey As String
-    Dim Success As Boolean
-    Dim idx As Long
-    Dim lockNo As Long
-    Dim Msg, Style, Title, Help, Ctxt, Response, MyString As String
-'    Dim Position As Long
-   ' Dim Range As Double
-    
-    myKey = "UI\" + GlobalMacroKey + "\AutoStore"
-    Success = tools.RegExistKey(myKey)
-    If Success Then
-'        Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-'        If Position >= 0 Then
-'            Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-'        Else
-'            Range = 0#
-'        End If
-'substituted29.06.2010 by Function Range
-    
-'        BlockAutoConfiguration = tools.RegStringValue(myKey, "BlockAutoConfiguration")
-        BlockTimeIndex = tools.RegLongValue(myKey, "BlockTimeIndex")
-'        BlockAutoConfigurationUse = tools.RegLongValue(myKey, "BlockAutoConfigurationUse")
-        BlockHighSpeed = tools.RegDoubleValue(myKey, "BlockHighSpeed")
-        BlockLowZoom = tools.RegDoubleValue(myKey, "BlockLowZoom")
-        HRZ = tools.RegDoubleValue(myKey, "BlockHRZ")
-        
-        BlockZOffset = tools.RegDoubleValue(myKey, "BlockZoffset")
-        BlockZRange = tools.RegDoubleValue(myKey, "BlockZRange")
-        BlockZStep = tools.RegDoubleValue(myKey, "BlockZStep")
-        If BlockZRange > Range * 0.9 Then
-            BlockZRange = Range * 0.9
-        End If
-        If Abs(BlockZOffset) > Range * 0.9 Then
-            BlockZOffset = 0
-        End If
-        
-        AutofocusForm.SetBlockValues
-      
-'        AutofocusForm.Re_Initialize
-    Else
-    End If
-End Sub
-
-
-Public Sub CopyRecording(Destination As DsRecording, Source As DsRecording)
-    Dim TS As DsTrack
-    Dim TD As DsTrack
-    Dim DataS As DsDataChannel
-    Dim DataD As DsDataChannel
-    Dim DetS As DsDetectionChannel
-    Dim DetD As DsDetectionChannel
-    Dim IlS As DsIlluminationChannel
-    Dim IlD As DsIlluminationChannel
-    Dim BS As DsBeamSplitter
-    Dim BD As DsBeamSplitter
-    Dim lT As Long
-    Dim lI As Long
-    Dim Success As Integer
-    
-    Destination.Copy Source
-    Destination.FramesPerStack = Source.FramesPerStack
- '   Destination.Objective = Source.Objective
-'    For lT = 0 To Destination.TrackCount - 1
-'
-'        Set TS = Source.TrackObjectByIndex(lT, success)
-'        Set TD = Destination.TrackObjectByIndex(lT, success)
-'
-'        TD.Collimator1Position = TS.Collimator1Position
-'        TD.Collimator2Position = TS.Collimator2Position
-'
-'        For lI = 0 To TD.DataChannelCount - 1
-'            Set DataS = TS.DataChannelObjectByIndex(lI, success)
-'            Set DataD = TD.DataChannelObjectByIndex(lI, success)
-'            DataD.ColorRef = DataS.ColorRef
-'        Next lI
-'
-'        For lI = 0 To TD.DetectionChannelCount - 1
-'            Set DetS = TS.DetectionChannelObjectByIndex(lI, success)
-'            Set DetD = TD.DetectionChannelObjectByIndex(lI, success)
-'            DetD.Filter1 = DetS.Filter1
-'            DetD.Filter2 = DetS.Filter2
-'            DetD.DetectorGain = DetS.DetectorGain
-'            DetD.AmplifierGain = DetS.AmplifierGain
-'            DetD.AmplifierOffset = DetS.AmplifierOffset
-'            DetD.PinholeDiameter = DetS.PinholeDiameter
-'        Next lI
-'
-'        For lI = 0 To TD.IlluminationChannelCount - 1
-'            Set IlS = TS.IlluminationObjectByIndex(lI, success)
-'            Set IlD = TD.IlluminationObjectByIndex(lI, success)
-'            IlD.Acquire = IlS.Acquire
-'            IlD.Power = IlS.Power
-'            IlD.DetectionChannelName = IlS.DetectionChannelName
-'        Next lI
-'
-'        For lI = 0 To TD.BeamSplitterCount - 1
-'            Set BS = TS.BeamSplitterObjectByIndex(lI, success)
-'            Set BD = TD.BeamSplitterObjectByIndex(lI, success)
-'            BD.Filter = BS.Filter
-'        Next lI
-'
-'    Next lT
-End Sub
-
-
-
-Public Sub StoreAquisitionParameters()
-    'stores the whole set of scan parameters
-    Set GlobalBackupRecording = Lsm5.CreateBackupRecording
-    Set BackupRecording = Lsm5.CreateBackupRecording
-    CopyRecording GlobalBackupRecording, Lsm5.DsRecording
-    CopyRecording BackupRecording, Lsm5.DsRecording
-End Sub
-
-Public Sub RestoreAquisitionParameters()
-    'Restores the image acquisition recording parameters
-     CopyRecording Lsm5.DsRecording, GlobalBackupRecording
-End Sub
-
-Public Sub SystemVersionOffset()
-    SystemVersion = Lsm5.Info.VersionIs
-    If StrComp(SystemVersion, "2.8", vbBinaryCompare) >= 0 Then
-        If Lsm5.Info.IsAxioskop Then
-            If BlockHighSpeed Then
-                GlobalCorrectionOffset = 15
-            Else
-                GlobalCorrectionOffset = 1.2
-            End If
-        ElseIf Lsm5.Info.IsAxioplan Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioplan2 Then
-            GlobalCorrectionOffset = 0
-       ElseIf Lsm5.Info.IsAxioplan2i Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioVert Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxiovert100M Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxiovert200M Then
-            GlobalCorrectionOffset = 0
-        Else
-            GlobalCorrectionOffset = 0
-        End If
-    Else
-        If Lsm5.Info.IsAxioskop Then
-            If BlockHighSpeed Then
-                GlobalCorrectionOffset = 15
-            Else
-                GlobalCorrectionOffset = 1.2
-            End If
-        ElseIf Lsm5.Info.IsAxioplan Then
-            GlobalCorrectionOffset = 0
-        ElseIf Lsm5.Info.IsAxioVert Then
-            GlobalCorrectionOffset = 0
-        Else
-            GlobalCorrectionOffset = 0
-        End If
-    End If
-
-End Sub
-
-
-Public Sub Autofocus_StackShift(ZRange As Double, ZStep As Double, HighSpeed As Boolean, Zoffset As Double, NewPicture As DsRecordingDoc)
-    'Dim Position As Long
-    'Dim Range As Double
-    'Dim NoFrames As Long madePublic29.06.2010
-    Dim BigZStep As Double
-
-    Set AcquisitionController = Lsm5.ExternalDsObject.Scancontroller
-    If NewPicture Is Nothing Then
-        Set NewPicture = Lsm5.NewScanWindow
-        While NewPicture.IsBusy
-            Sleep (20)
-            DoEvents
-        Wend
-    End If
-
-    'If GettingZmap And Not idpos = 1 Then GoTo ZStackagain
-    AutofocusForm.ActivateAutofocusTrack HighSpeed ' if HighSpeed is ture the line-averaging will be set to 1
-    
-    If Not IsAutofocusTrackSelected Then
-        MsgBox "No track selected for Autofocus! Cannot Autofocus!"
-        ScanStop = True
-        Exit Sub
-    End If
-    'Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    
-    '    Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-    '    If Position >= 0 Then
-    '        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-    '    Else
-    '        Range = 0#
-    '    End If
-    '    substituted29.06.2010 by Function Range
-    
-    If Range = 0 Then
-        MsgBox "Objective's working distance not defined! Cannot Autofocus!"
-        Exit Sub
-    End If
-    If ZRange > Range * 0.9 Then
-        ZRange = Range * 0.9
-    End If
-    If Abs(Zoffset) > Range * 0.9 Then
-        Zoffset = 0
-    End If
-    
-    SystemVersionOffset
-    
-
-    'Now this is a code specific for the DoAutofocus (is not in the SetAutofocus).
-    'This is to move to the offset position, with the focuswheel
-    
-    If Not GettingZmap Then DisplayProgress "Autofocus 1", RGB(0, &HC0, 0)       'I added this at some points for troubleshooting.
-    
-    Lsm5.Hardware.CpHrz.Position = 0  ' center the piezo focus
-  
-    
-ZStackagain:
-
-    Zbefore = Lsm5.Hardware.CpFocus.Position        'To remember the position of the focuswheel
-    'Lsm5.DsRecording.SpecialScanMode = "ZScanner" ' is taken care of in AutofocusForm.AutofocusSetting
-   
-    If Zoffset <= Range * 0.9 Then
-        
-        Lsm5.Hardware.CpFocus.Position = Zbefore - Zoffset + GlobalCorrectionOffset + ZBacklash 'Move down 50um (=ZBacklash) below the position of the offset
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-           Sleep (20)  '20ms
-           DoEvents
-        Loop
-        Lsm5.Hardware.CpFocus.Position = Zbefore - Zoffset + GlobalCorrectionOffset            'Moves up to the position of the offset
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy                 'Waits that the objective movement is finished, code from the original macro
-           Sleep (20)
-           DoEvents
-        Loop
-    
-    End If
-
-    'Lsm5.DsRecording.FrameSpacing = ZStep
-    'NoFrames = CLng(ZRange / ZStep) + 1                     'Calculates the number of frames per stack. Clng converts it to a long and rounds up the fraction
-    'Lsm5.DsRecording.FramesPerStack = NoFrames
-    'If NoFrames > 2048 Then                                 'overwrites the userdefined value if too many frames have been defined by the user
-    '    NoFrames = 2048
-    'End If
-    'Lsm5.DsRecording.Sample0Z = ZStep * NoFrames / 2        'Distance of the actual focus to the first Z position of the image (or line) to acquire in the stack.
-                                                            'I think this is only valid for the focus wheel and not the HRZ
-    
-    AutofocusForm.AutofocusSetting HRZ, BlockHighSpeed, BlockZStep
-
-    Lsm5.DsRecording.FrameSpacing = ZStep
-    NoFrames = CLng(ZRange / ZStep) + 1                     'Calculates the number of frames per stack. Clng converts it to a long and rounds up the fraction
-    Lsm5.DsRecording.FramesPerStack = NoFrames
-    If NoFrames > 2048 Then                                 'overwrites the userdefined value if too many frames have been defined by the user
-        NoFrames = 2048
-    End If
-    Lsm5.DsRecording.Sample0Z = ZStep * NoFrames / 2        'Distance of the actual focus to the first Z position of the image (or line) to acquire in the stack.
-                                                           
-     
-    '!!!!!!!!!!!!!!!!!!!!!! potential error source!!!!!!!!!!!!!!!!!!
-    If PubSearchScan Then ' todo: what is this?
-        
-        '  BigZStep = Range * 0.7 / 200
-        If HRZ And SystemName = "LIVE" Then
-
-        '   If Range > 1000 Then Range = 600  deleted 30.06.2010
-
-            Lsm5.DsRecording.SpecialScanMode = "OnTheFly"
-            Lsm5.DsRecording.FramesPerStack = 1201
-            Lsm5.DsRecording.Sample0Z = Range / 2
-            Lsm5.DsRecording.FrameSpacing = Range / 1200
-            Sleep (100)
-        
-        Else
-        
-            BigZStep = Range * 0.7 / 200
-            Lsm5.DsRecording.SpecialScanMode = "FocusStep"
-            NoFrames = CLng(Range * 0.7 / BigZStep) + 1
-            Lsm5.DsRecording.FramesPerStack = NoFrames
-            Lsm5.DsRecording.FrameSpacing = BigZStep
-            Lsm5.DsRecording.Sample0Z = BigZStep * NoFrames / 2
-            Sleep (20)
-            
-        End If
-    
-    End If
-        
-    ' Here the Stack is acquired ***
-    'DisplayProgress "Acquiring AF stack...", RGB(&HC0, 0, 0)
-    'Set NewPicture = Lsm5.StartScan
-    ScanToImageNew NewPicture
-    
-    While AcquisitionController.IsGrabbing
-        Sleep (20)
-        If ScanStop Then
-            Lsm5.StopScan
-            'ScanStop = True
-            DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-            Exit Sub
-        End If
-        DoEvents
-    Wend
-    
-    Lsm5.tools.WaitForScanEnd False, 20
-    ' ******************************
-    
-
-    If Not GettingZmap Then DisplayProgress "Autofocus 6", RGB(0, &HC0, 0)
-  
-    AutofocusForm.MassCenter ("Autofocus")
-    If AreStageCoordinateExchanged Then
-           xShift = YMass
-           yShift = XMass
-    Else
-           xShift = -XMass
-           yShift = YMass
-    End If
-    
-    ZShift = ZMass
-    
-    
-    'check if Z shift makes sense
-    If PubSearchScan = True Then Exit Sub
-    CheckRefControl BlockZRange
-    
-    'NewPicture.CloseAllWindows
-    'Set NewPicture = Nothing
-     
-    ' If Not (Running = True And AutofocusForm.CheckBoxZMap.Value = True) Then
-    '        If (BlockZRange * 0.8 / 2) > Abs(ZShift) And Abs(ZShift) > 5 And NoReflectionSignal = False Then
-    '    MovetoCorrectZPosition Zoffset
-    '    GoTo ZStackagain
-    '   End If
-    ' End If
-    
-End Sub
-
-
-
-Public Sub Autofocus_MoveAquisition(Zoffset As Double)
-    
-    Dim NoZStack As Boolean
-    Const ZBacklash = -50
-    Dim ZFocus As Double
-    Dim Zbefore As Double
-    Dim x As Double
-    Dim y As Double
-
-    RestoreAquisitionParameters
-
-    '  Set GlobalBackupRecording = Nothing
-    '  Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    AutofocusForm.ActivateAcquisitionTrack
-    If Lsm5.DsRecording.scanMode = "ZScan" Or Lsm5.DsRecording.scanMode = "Stack" Then  'Looks if a Z-Stack is going to be acquired
-        NoZStack = False
-    Else
-        NoZStack = True
-    End If
-
-    ' Moving to the correct position in Z
-    ' Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-    ZFocus = Lsm5.Hardware.CpFocus.Position + Zoffset + ZShift
-    Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash     'Moves down -50uM (ZBacklash) with the focus wheel
-    Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-        Sleep (20)
-        DoEvents
-    Loop
-    
-    Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-    Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-        Sleep (20)
-        DoEvents
-    Loop
-
-    ' Todo: one might add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-    Sleep (100)
-    DoEvents
-   
-   
-    'Moving to the correct position in X and Y
-    If FrameAutofocussing Then
-        ' Todo: check whether it moves in the correct direction
-        x = Lsm5.Hardware.CpStages.PositionX - xShift  'the fact that it is "-" in this line and "+" in the next line  probably has to do with where the XY of the origin is set (top right corner and not botom left, I think)
-        y = Lsm5.Hardware.CpStages.PositionY - yShift
-        
-        Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-         
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            If ScanStop Then
-                Lsm5.StopScan
-                AutofocusForm.StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-            DoEvents
-            Sleep (5)
-        Loop
-    
-    End If
-    
-    ' center all z-stacks again!
-    Lsm5.DsRecording.Sample0Z = Lsm5.DsRecording.FrameSpacing * Int(Lsm5.DsRecording.FramesPerStack / 2)
-    
-    DisplayProgress "Autofocus 14", RGB(0, &HC0, 0)
-    'Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    DisplayProgress "Autofocus 15", RGB(0, &HC0, 0)
-
-End Sub
-
-Private Sub MovetoCorrectZPosition(Zoffset As Double)
-Const ZBacklash = -50
-Dim ZFocus As Double
-Dim Zbefore As Double
-Dim x As Double
-Dim y As Double
-     ZFocus = Lsm5.Hardware.CpFocus.Position + Zoffset + ZShift
-       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash    'Moves down -50uM (ZBacklash) with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-        Sleep (100)
-        DoEvents
-End Sub
-
-
-Public Sub Autofocus_MoveAquisition_HRZ(Zoffset As Double)
-    Dim NoZStack As Boolean
-    Const ZBacklash = -50
-    Dim ZFocus As Double
-    Dim Zbefore As Double
-    Dim x As Double
-    Dim y As Double
-
-    RestoreAquisitionParameters
-    
-    Set GlobalBackupRecording = Nothing
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    AutofocusForm.ActivateAcquisitionTrack
-    If Lsm5.DsRecording.scanMode = "ZScan" Or Lsm5.DsRecording.scanMode = "Stack" Then  'Looks if a Z-Stack is going to be acquired
-        NoZStack = False
-    Else
-        NoZStack = True
-    End If
-
-    'Moving to the correct position in Z
-    If HRZ And NoZStack Then                                            'If using HRZ for autofocusing and there is no Zstack for image acquisition
-        Lsm5.Hardware.CpHrz.Stepsize = 0.2
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-        DoEvents
-     '   ZFocus = Lsm5.Hardware.CpHrz.Position + ZShift - Zoffset
-     
-     'Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-  
-        ZFocus = Lsm5.Hardware.CpHrz.Position + Zoffset + ZShift
-       
-        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-        
-        DoEvents
-
-    Else                                        'either there is a Z stack for image acquisition or we're using the focuswheel for autofocussing
-        If HRZ Then                             ' Now I'm not sure with the signs and... I some point I just tried random combinations...
-            ZFocus = Lsm5.Hardware.CpHrz.Position - Zoffset - ZShift '         'ZBefore corresponds to the position where the focuswheel was before doing anything. Zshift is the calculated shift
-        Else                                    'If the HRZ is not calibrated the Z shift might be wrong
-            ZFocus = Zbefore + ZShift
-        End If
-       
-        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            Sleep (20)
-            DoEvents
-        Loop
-    End If
-
-    'Moving to the correct position in X and Y
- 
-    If FrameAutofocussing Then
-        x = Lsm5.Hardware.CpStages.PositionX - xShift  'the fact that it is "-" in this line and "+" in the next line  probably has to do with where the XY of the origin is set (top right corner and not botom left, I think)
-        y = Lsm5.Hardware.CpStages.PositionY - yShift
-        Success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-         
-        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-            If ScanStop Then
-                Lsm5.StopScan
-                AutofocusForm.StopAcquisition
-                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-                Exit Sub
-            End If
-            DoEvents
-            Sleep (5)
-        Loop
-    End If
-    
-
-    DisplayProgress "Autofocus 14", RGB(0, &HC0, 0)
-    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-    DoEvents
-    DisplayProgress "Autofocus 15", RGB(0, &HC0, 0)
-End Sub
-
-Public Sub CheckRefControl(BlockZRange As Double)
-    ' Todo: what is happening here?
-    If Try = Empty Then Try = 1
-        
-    'checkif Z shift makes sense
-    ' Todo: where is AutofocusForm.CheckBoxRefControl.Value  set?
-    If AutofocusForm.CheckBoxRefControl.Value = True Then
-        If Abs(ZShift) > (BlockZRange * 0.8 / 2) Or NoReflectionSignal Then
-            PubSearchScan = True
-            DoNotGoOn = False
-            Try = Try + 1
-           
-            If Try >= 4 Then
-                CountDownBox
-                PubSearchScan = False
-                NoReflectionSignal = False
-                AutofocusForm.GetBlockValues 'Updates the parameters value for BlockZRange, BlockZStep..
-                DisplayProgress "Autofocus 0", RGB(0, &HC0, 0)
-                Lsm5.StopScan
-            End If
-            
-            If Not FocusChanged Then
-                If Try >= 4 Then
-                   Try = 1
-                   Exit Sub
-                End If
-            End If
-            'Scan with Focuswheel abigger region,move to the brightest region and do the Piezoscanning again
-              
-            'Lsm5.Hardware.CpFocus.Position = Zbefore
-            Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset, RecordingDocpub
-            MovetoCorrectZPosition BlockZOffset
-            'Zbefore = Zbefore + ZShift
-            PubSearchScan = False
-            NoReflectionSignal = False
-              
-            Autofocus_StackShift BlockZRange, BlockZStep, BlockHighSpeed, BlockZOffset, RecordingDocpub
-        End If
-    End If
-
-    Try = 1
-
-End Sub
-
-Private Sub CountDownBox()
-DoNotGoOn = True
-Load CorrectFocusForm
-CorrectFocusForm.Show
-While DoNotGoOn = True
-DoEvents
-Sleep (10)
-Wend
-
-End Sub
-
-Public Sub PutStagePositionsInArray()
-ReDim GlobalXpos(GlobalPositionsStage)
-ReDim GlobalYpos(GlobalPositionsStage)
-ReDim GlobalZpos(GlobalPositionsStage)
-For idpos = 0 To GlobalPositionsStage - 1
-Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).GetMarkZ idpos, GlobalXpos(idpos + 1), GlobalYpos(idpos + 1), GlobalZpos(idpos + 1)
-'           GlobalXpos(idpos) = Lsm5.Hardware.CpStages.PositionX
-'           GlobalYpos(idpos) = Lsm5.Hardware.CpStages.PositionY
-'           GlobalZpos(idpos) = Lsm5.Hardware.CpFocus.Position
-            
-Next idpos
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/unusedCode.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/unusedCode.bas
deleted file mode 100644
index c1b4dfa..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/AutofocusScreen/unusedCode.bas
+++ /dev/null
@@ -1,433 +0,0 @@
-Attribute VB_Name = "unusedCode"
-'''''''''''''''''''''''''''''''''''''''''ExcelXYZstoring'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-'Excel.Application.Visible = True                               'The Excel stuff is to store the XYZ position of the cells at each time point
-'        Set PositionData = Excel.Workbooks.Add
-'        For Location = 1 To LocationNumber
-'            PositionData.Sheets.Add
-'            PositionData.ActiveSheet.name = "Location " & Location
-'            PositionData.ActiveSheet.Columns("A:A").Select
-'            Selection.NumberFormat = "m/d/yyyy h:mm:ss"
-'            PositionData.ActiveSheet.Cells(1, 1) = "Time"
-'            PositionData.ActiveSheet.Cells(1, 2) = "X (m)"
-'            PositionData.ActiveSheet.Cells(1, 3) = "Y (m)"
-'            PositionData.ActiveSheet.Cells(1, 4) = "Z (m)"
-'            PositionData.ActiveSheet.Cells(1, 6) = "Time delay"
-'            PositionData.ActiveSheet.Columns("F:F").Select
-'            Selection.NumberFormat = "[h]:mm:ss"
-'            PositionData.ActiveSheet.Cells(1, 7) = "Total Distance (m)"
-'        Next Location
-'''''''''''''''''''''''''''''''''''''''''End ExcelXYZstoring'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-
-'''''''''''''''''''''''''''ExcelXYZstoring II'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-'                PositionData.Sheets("Location " & Location).Select
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 1) = CDate(Lsm5.DsRecordingActiveDocObject.Recording.Sample0Time)
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 2) = Lsm5.Hardware.CpStages.PositionX
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 3) = Lsm5.Hardware.CpStages.PositionY
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 4) = Lsm5.Hardware.CpFocus.Position
-'                PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 6) = PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 1) - PositionData.ActiveSheet.Cells(2, 1)
-'                If RepetitionNumber > 1 Then
-'                    PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 7) = PositionData.ActiveSheet.Cells(RepetitionNumber, 7) + Sqr((PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 2) - PositionData.ActiveSheet.Cells(RepetitionNumber, 2)) ^ 2 + (PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 3) - PositionData.ActiveSheet.Cells(RepetitionNumber, 3)) ^ 2)
-'                Else
-'                    PositionData.ActiveSheet.Cells(RepetitionNumber + 1, 7) = 0
-'                End If
-'''''''''''''''''''''''''''''''''''''''''End ExcelXYZstoring II'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-
-
-
-
-
-' I could delete this procedure if I do not add any help button
-'Private Sub HelpButton_Click()
-'    Dim dblTask As Double
-'    Dim MacroPath As String
-'    Dim MyPath As String
-'    Dim bslash As String
-'    Dim Success As Integer
-'    Dim pos As Integer
-'    Dim Start As Integer
-'    Dim count As Long
-'    Dim ProjName As String
-'    Dim indx As Integer
-'
-'    count = ProjectCount()
-'    For indx = 0 To count - 1
-'        MacroPath = ProjectPath(indx, Success)
-'        ProjName = ProjectTitle(indx, Success)
-'        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
-'            Start = 1
-'            bslash = "\"
-'            pos = Start
-'            Do While pos > 0
-'                pos = InStr(Start, MacroPath, bslash)
-'                If pos > 0 Then
-'                    Start = pos + 1
-'                End If
-'            Loop
-'            MyPath = Left(MacroPath, Start - 1)
-'            MyPath = MyPath + GlobalHelpName
-'            dblTask = Shell("C:\Program Files\Windows NT\Accessories\wordpad.exe " + MyPath, vbNormalFocus)
-'            Exit For
-'        End If
-'    Next indx
-'End Sub
-
-
-' Autofocusroutines that worked for Meta
-'Public Sub Autofocus_MoveAquisition(Zoffset As Double)
-'Dim NoZStack As Boolean
-'Const ZBacklash = -50
-'Dim ZFocus As Double
-'Dim Zbefore As Double
-'Dim x As Double
-'Dim y As Double
-'
-'
-'
-'    RestoreAquisitionParameters
-'
-'  '  Set GlobalBackupRecording = Nothing
-'    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-'    DoEvents
-'    AutofocusForm.ActivateAcquisitionTrack
-'    If Lsm5.DsRecording.ScanMode = "ZScan" Or Lsm5.DsRecording.ScanMode = "Stack" Then  'Looks if a Z-Stack is going to be acquired
-'        NoZStack = False
-'    Else
-'        NoZStack = True
-'    End If
-'
-'    'Moving to the correct position in Z
-'                                          'If using HRZ for autofocusing and there is no Zstack for image acquisition
-'     '   ZFocus = Lsm5.Hardware.CpHrz.Position + ZShift - Zoffset
-'
-'     'Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-'
-'    If HRZ Then
-'     ZFocus = Lsm5.Hardware.CpFocus.Position - Zoffset - ZShift
-'       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash     'Moves down -50uM (ZBacklash) with the focus wheel
-'        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            Sleep (20)
-'            DoEvents
-'        Loop
-'        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-'        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            Sleep (20)
-'            DoEvents
-'        Loop
-'    Else
-'    ZFocus = Lsm5.Hardware.CpFocus.Position - Zoffset + ZShift
-'       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash     'Moves down -50uM (ZBacklash) with the focus wheel
-'        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            Sleep (20)
-'            DoEvents
-'        Loop
-'        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-'        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            Sleep (20)
-'            DoEvents
-'        Loop
-'    End If
-'''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-'        Sleep (100)
-'        DoEvents
-'
-'
-'
-'    'Moving to the correct position in X and Y
-'
-'    If FrameAutofocussing Then
-'        x = Lsm5.Hardware.CpStages.PositionX - XShift  'the fact that it is "-" in this line and "+" in the next line  probably has to do with where the XY of the origin is set (top right corner and not botom left, I think)
-'        y = Lsm5.Hardware.CpStages.PositionY - YShift
-'        success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-'
-'        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            If ScanStop Then
-'                Lsm5.StopScan
-'                AutofocusForm.StopAcquisition
-'                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-'                Exit Sub
-'            End If
-'            DoEvents
-'            Sleep (5)
-'        Loop
-'    End If
-'
-'
-'    DisplayProgress "Autofocus 14", RGB(0, &HC0, 0)
-'    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-'    DoEvents
-'    DisplayProgress "Autofocus 15", RGB(0, &HC0, 0)
-'End Sub
-'
-'Private Sub MovetoCorrectZPosition(Zoffset As Double)
-'Const ZBacklash = -50
-'Dim ZFocus As Double
-'Dim Zbefore As Double
-'Dim x As Double
-'Dim y As Double
-'     ZFocus = Lsm5.Hardware.CpFocus.Position + Zoffset + ZShift
-'       Lsm5.Hardware.CpFocus.Position = ZFocus + ZBacklash    'Moves down -50uM (ZBacklash) with the focus wheel
-'        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            Sleep (20)
-'            DoEvents
-'        Loop
-'        Lsm5.Hardware.CpFocus.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-'        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            Sleep (20)
-'            DoEvents
-'        Loop
-'''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-'        Sleep (100)
-'        DoEvents
-'End Sub
-'
-'
-'
-'
-'Public Sub Autofocus_MoveAquisition_HRZ(Zoffset As Double)
-'Dim NoZStack As Boolean
-'Const ZBacklash = -50
-'Dim ZFocus As Double
-'Dim Zbefore As Double
-'Dim x As Double
-'Dim y As Double
-'
-'
-'
-'  RestoreAquisitionParameters
-'
-'    Set GlobalBackupRecording = Nothing
-'    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-'    DoEvents
-'    AutofocusForm.ActivateAcquisitionTrack
-'    If Lsm5.DsRecording.ScanMode = "ZScan" Or Lsm5.DsRecording.ScanMode = "Stack" Then  'Looks if a Z-Stack is going to be acquired
-'        NoZStack = False
-'    Else
-'        NoZStack = True
-'    End If
-'
-'    'Moving to the correct position in Z
-'    If HRZ And NoZStack Then                                            'If using HRZ for autofocusing and there is no Zstack for image acquisition
-'     Lsm5.Hardware.CpHrz.Stepsize = 0.2
-'
-'      Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-'    DoEvents
-'     '   ZFocus = Lsm5.Hardware.CpHrz.Position + ZShift - Zoffset
-'
-'     'Defines the new focus position as the actual position plus the shift and goes back to the object position (that's why you need the offset)
-'
-'     ZFocus = Lsm5.Hardware.CpHrz.Position + Zoffset + ZShift
-'
-'        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-'        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            Sleep (20)
-'            DoEvents
-'        Loop
-'''''' If I want to do it properly, I should add a lot of controls here, to wait to be sure the HRZ can acces the position, and also to wait it is done...
-'
-'        DoEvents
-'
-'    Else                                        'either there is a Z stack for image acquisition or we're using the focuswheel for autofocussing
-'        If HRZ Then                             ' Now I'm not sure with the signs and... I some point I just tried random combinations...
-'            ZFocus = Lsm5.Hardware.CpHrz.Position - Zoffset - ZShift '         'ZBefore corresponds to the position where the focuswheel was before doing anything. Zshift is the calculated shift
-'        Else                                    'If the HRZ is not calibrated the Z shift might be wrong
-'            ZFocus = Zbefore + ZShift
-'        End If
-'
-'        Lsm5.Hardware.CpHrz.Position = ZFocus                     'Moves up to the focus position with the focus wheel
-'        Do While Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            Sleep (20)
-'            DoEvents
-'        Loop
-'    End If
-'
-'    'Moving to the correct position in X and Y
-'
-'    If FrameAutofocussing Then
-'        x = Lsm5.Hardware.CpStages.PositionX - XShift  'the fact that it is "-" in this line and "+" in the next line  probably has to do with where the XY of the origin is set (top right corner and not botom left, I think)
-'        y = Lsm5.Hardware.CpStages.PositionY - YShift
-'        success = Lsm5.ExternalCpObject.pHardwareObjects.pStage.pItem(0).MoveToPosition(x, y)
-'
-'        Do While Lsm5.Hardware.CpStages.IsBusy Or Lsm5.ExternalCpObject.pHardwareObjects.pFocus.pItem(0).bIsBusy
-'            If ScanStop Then
-'                Lsm5.StopScan
-'                AutofocusForm.StopAcquisition
-'                DisplayProgress "Stopped", RGB(&HC0, 0, 0)
-'                Exit Sub
-'            End If
-'            DoEvents
-'            Sleep (5)
-'        Loop
-'    End If
-'
-'
-'    DisplayProgress "Autofocus 14", RGB(0, &HC0, 0)
-'    Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-'    DoEvents
-'    DisplayProgress "Autofocus 15", RGB(0, &HC0, 0)
-'End Sub
-
-
-Public Function ComputeCenterAndAxis(dX As Double, dY As Double)
-
-    Dim i, j, iFrame, channel, ni, bitDepth As Long
-    Dim nj As Long
-    
-    Dim ic, jc, di, dj, PixelSize As Double
-    Dim tot As Double
-    
-    Dim th As Double
-    th = 20
-    
-    
-    'Dim ColMax As Integer
-    'Dim iRow As Integer
-    'Dim nRow As Integer
-    'Dim iFrame As Integer
-    'Dim gvRow As Variant  ' gv = gray value
-    'Dim iCol As Long
-    'Dim nCol As Long
-    'Dim bitDepth As Long
-    'Dim channel As Integer
-    'Dim gvMax As Double
-    'Dim gvMaxBitRange As Double
-    'Dim nSaturatedPixels As Long
-    'Dim maxGV_nSat(2) As Double
-    
-    
-    'DisplayProgress "Measuring Exposure...", RGB(0, &HC0, 0)
-  
-    'ColMax = Lsm5.DsRecordingActiveDocObject.Recording.RtRegionWidth '/ Lsm5.DsRecordingActiveDocObject.Recording.RtBinning
-    
-    'nRow = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-    'MsgBox "nRow = " + CStr(nRow)
-    
-'        ElseIf SystemName = "LSM" Then
-'            ColMax = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
-'            LineMax = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-'        Else
-'            MsgBox "The System is not LIVE or LSM! SystemName: " + SystemName
-''            Exit Sub
- '       End If
- '   End If
-    
-    'Initiallize tables to store projected (integrated) pixels values in the 3 dimensions
-    'ReDim Intline(nLines) As Long
-    
-    'iFrame = 0
-    'gvMax = -1
-        
-    'iRow = 0
-    'channel = 0
-    'bitDepth = 0 ' leaves the internal bit depth
-    'gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-    
-    
-    
-    ni = Lsm5.DsRecordingActiveDocObject.Recording.LinesPerFrame
-    'nCol = 0
-    nj = Lsm5.DsRecordingActiveDocObject.Recording.SamplesPerLine
-    
-    'Dim image(,) As Variant
-    
-    'Dim replyCounts(,,) As Short = New Short(2, 1, 2) {}
-    
-    Dim srcline As Variant
-    
-    Dim image() As Long
-    ReDim image(ni, nj)
-    
-    
-    'Dim x(1 To ni, 1 To 4) As Variant
-
-    'MsgBox "ni = " + CStr(ni) + " nj = " + CStr(nj)
-    
-   ' image = GetSubRegion(channel, xs, ys, zs, ts
-    
-    
-    'Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-        
-    PixelSize = Lsm5.DsRecordingActiveDocObject.Recording.SampleSpacing * 1000000
-        
-        
-    ' get the image  (put into a subprocedure)
-    iFrame = 0
-    channel = 0
-    bitDepth = 0 ' leaves the internal bit depth
-    For i = 0 To ni - 1
-        srcline = Lsm5.DsRecordingActiveDocObject.ScanLine(channel, 0, iFrame, i, nj, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-        For j = 0 To nj - 1
-            image(i, j) = srcline(j)
-        Next j
-    Next i
-    'MsgBox "im = " + CStr(image(100, 100))
-        
-    ' computer center of mass
-    ic = 0
-    jc = 0
-    tot = 0
-    For i = 0 To ni - 1
-        For j = 0 To nj - 1
-            If (image(i, j) > th) Then
-                ic = ic + image(i, j) * i
-                jc = jc + image(i, j) * j
-                tot = tot + image(i, j)
-            End If
-        Next j
-    Next i
-    
-    ic = ic / tot
-    jc = jc / tot
-    'MsgBox "ic = " + CStr(ic) + " jc = " + CStr(jc) + " tot = " + CStr(tot)
-    
-    dX = (ic - ni / 2) * PixelSize
-    dY = (jc - nj / 2) * PixelSize
-    
-    ' compute displacement vector
-    di = 0
-    dj = 0
-    
-    For i = 0 To ni - 1
-        For j = 0 To nj - 1
-            If (image(i, j) > th) Then
-                di = di + image(i, j) * (i - ic) * Sgn(i - ic)
-                dj = dj + image(i, j) * (j - jc) * Sgn(i - ic)
-            End If
-        Next j
-    Next i
-    
-    di = di / tot
-    dj = dj / tot
-    'MsgBox "di = " + CStr(di) + " dj = " + CStr(dj) + " tot = " + CStr(tot)
-        
-        
-    'PixelSize
-        
-        
-        
-    '    For iCol = 0 To nCol - 1            'Now I'm scanning all the pixels in the line
-            
-     '       If (gvRow(iCol) > gvMax) Then
-      '          gvMax = gvRow(iCol)
-       '     End If
-
-    
-    
-    'iFrame = 0
-    'gvMax = -1
-    'iRow = 0
-    'Channel = 0
-    'bitDepth = 0 ' leaves the internal bit depth
-    'gvRow = Lsm5.DsRecordingActiveDocObject.ScanLine(Channel, 0, iFrame, iRow, nCol, bitDepth) 'this is the lsm function how to read pixel values. It basically reads all the values in one X line. scrline is a variant but acts as an array with all those values stored
-    'MsgBox "nCol = " + CStr(nCol)
-    'MsgBox "bytes per pixel = " + CStr(bitDepth)
-
-    ' todo: is there another function to find this out??
-    'If (bitDepth = 1) Then
-    '    gvMaxBitRange = 255
-    'ElseIf (bitDepth = 2) Then
-    '    gvMaxBitRange = 65536
-    'End If
-    
-    'nSaturatedPixels = 0
- 
-End Function
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/A_Main_ModifySeries.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/A_Main_ModifySeries.bas
deleted file mode 100644
index 1714b78..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/A_Main_ModifySeries.bas
+++ /dev/null
@@ -1,146 +0,0 @@
-Attribute VB_Name = "A_Main_ModifySeries"
-Option Explicit
-
-Public flgBreak As Boolean
-Public GlobalTimeStart() As Double
-Public GlobalImageIndex() As Long
-Public GlobalNodes() As AimExperimentTreeNode
-Public TimeStampChange As Boolean
-Public ZStepChange As Boolean
-Public TimeNumberChange As Boolean
-Public GlobalSetWlChange As Boolean
-Public GlobalStartWl As Double
-Public GlobalStepWl As Double
-Public GlobalStartWlTmp As Double
-Public GlobalStepWlTmp As Double
-Public GlobalFileOptions As Long
-Public GlobalNumberOfStacks As Long
-Public GlobalTimeIntv As Double
-Public GlobalTimeStampDate As Date
-Public GlobalTimeStampTime As Date
-Public GlobalZStep As Long
-Public GlobalFileSource As Long
-Public GlobalDirName As String
-Public GlobalFiles() As String
-Public GlobalNumberFiles As Long
-Public GlobalUseBrowser As Boolean
-Public GlobalUseChannelColor As Boolean
-Public GlobalSingleImage As DsRecordingDoc
-Public GlobalImageDocument As AimExperimentTreeNode
-Public GlobalImage As AimImage
-Public GlobalNumberOfChannels As Long
-
-
-Declare Sub Sleep Lib "kernel32" (ByVal time As Long)
-
-Public Sub Main()
-    Dim SystemVersion As String
-    GlobalUseBrowser = False
-    GlobalProjectName = "ModifySeriesZEN.lvb"
-    GlobalHelpName = "ModifySeries.rtf"
-    GlobalHelpNamePDF = "ModifySeries.pdf"
-    
-    GlobalMacroKey = "AutoModify"
-    GlobalAutoStoreKey = "AutoModifyStore"
-    GlobalUseChannelColor = False
-    
-    GetPathAndVersion GlobalPath, GlobalSystemVersion, GlobalMacrosPath
-    
-    If GlobalSystemVersion >= 45 Then
-        DatabaseDialog.Show 0
-    Else
-        MsgBox "Program Requires LSM Release ZEN 2007 or Later"
-    End If
-End Sub
-
-Public Sub SetDefaultWl(NoOfChannels As Long, StartWl As Double, StepWl As Double)
-
-    StartWl = 400
-    If NoOfChannels <= 5 Then
-        StepWl = 10
-    Else
-        StepWl = 10
-    End If
-
-End Sub
-
-Public Sub AutoStoreModify()
-    Dim key As String
-    Dim myKey As String
-    
-    key = "UI\" + GlobalMacroKey
-    myKey = key + "\" + GlobalAutoStoreKey
-    If Lsm5.tools.RegExistKey(myKey) Then
-        Lsm5.tools.RegDeleteKey (myKey)
-    End If
-    DatabaseDialog.GetFormControls
-    Lsm5.tools.RegCreateKey (myKey)
-    
-    StoreRegistryModify key, myKey
-End Sub
-
-Public Sub ReadRegistryModify(key As String, myKey As String)
-    GlobalNumberOfStacks = Lsm5.tools.RegLongValue(myKey, "GlobalNumberOfStacks")
-    GlobalTimeIntv = Lsm5.tools.RegDoubleValue(myKey, "GlobalTimeIntv")
-    GlobalDirName = Lsm5.tools.RegStringValue(myKey, "Directory")
-    GlobalFileSource = Lsm5.tools.RegLongValue(myKey, "GlobalFileSource")
-       
-End Sub
-
-Public Sub StoreRegistryModify(key As String, myKey As String)
-    Lsm5.tools.RegLongValue(myKey, "GlobalNumberOfStacks") = GlobalNumberOfStacks
-    Lsm5.tools.RegDoubleValue(myKey, "GlobalTimeIntv") = GlobalTimeIntv
-    Lsm5.tools.RegStringValue(myKey, "Directory") = GlobalDirName
-    Lsm5.tools.RegLongValue(myKey, "GlobalFileSource") = GlobalFileSource
-
-End Sub
-
-Public Sub AutoRecallModify()
-    Dim key As String
-    Dim myKey As String
-    
-    User_flg = False
-    key = "UI\" + GlobalMacroKey
-    myKey = key + "\" + GlobalAutoStoreKey
-    
-    If Lsm5.tools.RegExistKey(myKey) Then
-        ReadRegistryModify key, myKey
-    Else
-        Lsm5.tools.RegCreateKey (myKey)
-        StoreRegistryModify key, myKey
-    End If
-    
-    DatabaseDialog.SetFormControls
-    User_flg = True
-End Sub
-
-Public Function MakeDestinationDS(DestinationImageDocument As RecordingDocument, _
-                                 DestinationImage As AimImage, _
-                                 SizeX As Long, _
-                                 SizeY As Long, _
-                                 SizeZ As Long, _
-                                 SizeT As Long, _
-                                 SizeC As Long, _
-                                 DataType As Long) As Boolean
-
-    Dim DS As Document
-'    Set DS = Lsm5.ExternalDsObject
-    MakeDestinationDS = False
-
-    Set DestinationImageDocument = Lsm5.ExternalDsObject.MakeNewImageDocument(SizeX, _
-                                                           SizeY, _
-                                                           SizeZ, _
-                                                           SizeT, _
-                                                           SizeC, _
-                                                           DataType, _
-                                                           1)
-
-    If Not (DestinationImageDocument Is Nothing) Then Set DestinationImage = DestinationImageDocument.Image(0, False)
-    If (DestinationImage Is Nothing) Then
-        MsgBox "Cannot Create New Image!"
-        Exit Function
-    Else
-        MakeDestinationDS = True
-    End If
-End Function
-
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ChannelNameForm.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ChannelNameForm.frm
deleted file mode 100644
index 8fa3af5..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ChannelNameForm.frm
+++ /dev/null
@@ -1,101 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} ChannelNameForm 
-   Caption         =   "Change Channel Names"
-   ClientHeight    =   2700
-   ClientLeft      =   45
-   ClientTop       =   435
-   ClientWidth     =   3990
-   OleObjectBlob   =   "ChannelNameForm.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "ChannelNameForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-Option Explicit
-
-Dim ChannelNameLoaded As Boolean
-
-Private Sub ChannelBox_Change()
-    If flgUserChange Then
-        flgUserChange = False
-        TextBox1.Value = GlobalImage.DisplayParameters.ChannelInformation.ChannelName(ChannelBox.ListIndex)
-        flgUserChange = True
-    End If
-End Sub
-
-Sub FillChannelList()
-    flgUserChange = False
-
-    Dim indx As Long
-    ChannelBox.Clear
-    For indx = 1 To GlobalNumberOfChannels
-        ChannelBox.AddItem CStr(indx)
-    Next indx
-    ChannelBox.ListIndex = 0
-    flgUserChange = True
-    
-End Sub
-
-
-
-Private Sub OkButton_Click()
-    SaveWindowPosition
-    Unload Me
-End Sub
-
-Private Sub TextBox1_Change()
-    If flgUserChange Then
-        GlobalImage.DisplayParameters.ChannelInformation.ChannelName(ChannelBox.ListIndex) = TextBox1.Value
-    End If
-End Sub
-
-Private Sub UserForm_Activate()
-    If Not ChannelNameLoaded Then
-        LoadWindowPosition
-    End If
-    ChannelNameLoaded = True
-
-End Sub
-
-Private Sub UserForm_Initialize()
-    FillChannelList
-    flgUserChange = False
-    TextBox1.Value = GlobalImage.DisplayParameters.ChannelInformation.ChannelName(ChannelBox.ListIndex)
-    flgUserChange = True
-
-End Sub
-
-
-Public Function LoadWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Left = Lsm5.tools.RegLongValue(PosKey, "Left")
-    Top = Lsm5.tools.RegLongValue(PosKey, "Top")
-    If Left < 1 Then Left = 0
-    If Top < 1 Then Top = 0
-    
-    If Left = 0 And Top = 0 Then
-                'Center frm
-                Left = 300
-                Top = 300
-'    SaveWindowPosition
-                Exit Function
-    End If
-End Function
-
-
-
-Public Sub SaveWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Lsm5.tools.RegLongValue(PosKey, "Left") = CInt(Left)
-    Lsm5.tools.RegLongValue(PosKey, "Top") = CInt(Top)
-End Sub
-
-Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
-    SaveWindowPosition
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/DatabaseDialog.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/DatabaseDialog.frm
deleted file mode 100644
index e47cd03..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/DatabaseDialog.frm
+++ /dev/null
@@ -1,2490 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} DatabaseDialog 
-   Caption         =   "Modify Images"
-   ClientHeight    =   11625
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   9135
-   OleObjectBlob   =   "DatabaseDialog.frx":0000
-   ShowModal       =   0   'False
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "DatabaseDialog"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-Option Explicit
-
-Dim DatabaseDialogLoaded As Boolean
-
-Public Sub FillListBox()
-    Dim ViewerGuiServer As AimViewerGuiServer
-    Dim ExperimentTree As AimExperimentTreeNode
-    Dim NumberOfSelected As Long
-    Dim Image As AimImage
-    Dim Node As Long
-    
-    Dim Files() As String
-    Dim PathNames() As String
-    Dim NumberFiles As Long
-    Dim index As Long
-    Dim DimensionT As Long
-    Dim DimensionZ As Long
-    If GlobalFileSource = 0 Then
-        Set ViewerGuiServer = Lsm5.ViewerGuiServer
-        Set ExperimentTree = ViewerGuiServer.ExperimentTree
-        
-        If OptionZStack.Value Then
-            ImagesListBox.MultiSelect = fmMultiSelectExtended
-        ElseIf OptionTimeStack.Value Then
-            ImagesListBox.MultiSelect = fmMultiSelectExtended
-        Else
-            ImagesListBox.MultiSelect = fmMultiSelectExtended
-        End If
-    
-        ImagesListBox.Clear
-        NumberOfSelected = 0
-        
-        For Node = 0 To ExperimentTree.NumberChildren - 1
-            If ExperimentTree.Child(Node).Type = eExperimentTeeeNodeTypeLsm Then
-                Set Image = ExperimentTree.Child(Node).Image(0)
-                If Not Image Is Nothing Then
-                
-                    If (OptionTimeStack.Value And Image.ImageMemory.GetDimensionT > 1) _
-                       Or (OptionZStack.Value And Image.ImageMemory.GetDimensionZ > 1) _
-                       Or ((Not OptionTimeStack.Value) And (Not OptionZStack.Value)) Then
-            
-                        ImagesListBox.AddItem ExperimentTree.Child(Node).Name
-                        ReDim Preserve GlobalNodes(NumberOfSelected + 1)
-                        Set GlobalNodes(NumberOfSelected + 1) = ExperimentTree.Child(Node)
-                        NumberOfSelected = NumberOfSelected + 1
-                    End If
-                End If
-            End If
-        Next Node
-    Else
-        GlobalNumberFiles = 0
-        ImagesListBox.Clear
-    
-        If ListFiles(Files, PathNames, NumberFiles, FileNameTextBox, "*.lsm") Then
-        
-            Image1.Visible = False
-            
-            For index = 0 To NumberFiles - 1
-                If ReadImageInformation(Image, DimensionT, DimensionZ, PathNames(index)) Then
-                    If (OptionTimeStack.Value And DimensionT > 1) _
-                       Or (OptionZStack.Value And DimensionZ > 1) _
-                       Or ((Not OptionTimeStack.Value) And (Not OptionZStack.Value)) Then
-                
-                        ImagesListBox.AddItem Files(index)
-                        ReDim Preserve GlobalFiles(GlobalNumberFiles + 1)
-                        GlobalFiles(GlobalNumberFiles + 1) = PathNames(index)
-                        GlobalNumberFiles = GlobalNumberFiles + 1
-                    End If
-                End If
-            Next index
-            SetButtons
-        End If
-    
-    
-    End If
-End Sub
-
-Private Function ReadImageInformation(Image As AimImage, DimensionT As Long, DimensionZ As Long, filename As String) As Boolean
-
-    ReadImageInformation = False
-    
-On Error GoTo ErrorExit
-
-    Dim Import As AimImageImport
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-'    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-    
-    Import.filename = filename
-    Import.ReadFullSizeFileInformation Image
-    DimensionT = Import.FileInfoSize(eAimImportExportCoordinateT)
-    DimensionZ = Import.FileInfoSize(eAimImportExportCoordinateZ)
-    ReadImageInformation = True
-    Exit Function
-    
-ErrorExit:
-End Function
-
-Private Sub BrowseButton_Click()
-    Dim Name As String
-    Name = FileNameTextBox
-    If GlobalUseBrowser Then
-        If BrowseForFolder(Name, "Input directory") Then
-            FileNameTextBox = Name
-            Lsm5.tools.RegStringValue("UI\" + GlobalMacroKey, "Directory") = FileNameTextBox
-        End If
-    Else
-        UseCommonDialog Name
-        FileNameTextBox = Name
-        Lsm5.tools.RegStringValue("UI\" + GlobalMacroKey, "Directory") = FileNameTextBox
-        
-    End If
-
-
-End Sub
-
-Private Sub UseCommonDialog(MyPath As String)
-    Dim lpReOpenBuff As OFSTRUCT
-    Dim wStyle As Long
-    Dim hFile As Long
-    Dim flgUserChangeSaved As Boolean
-    Dim lFreeSpace As Double
-    Dim lSpace As Long
-    Dim lngth As Long
-    Dim Name1 As String
-    Dim Start As Long
-    Dim pos As Long
-    Dim bslash As String
-    Dim idx As Long
-    Dim NumOfPositions As Long
-    Dim tmpString As String
-    Dim MyFile As String
-    Dim driveString As String
-    Dim fsTemp As New Scripting.FileSystemObject
-    
-    flgUserChangeSaved = flgUserChange
-    flgUserChange = False
-    
-    'Initialize Common Dialog control
-    If GlobalSystemVersion >= 30 Then
-        SetControlFlags
-    End If
-                                
-    If Not fsTemp.FolderExists(MyPath) Then
-        MyPath = "C:\"
-    End If
-    lngth = Len(MyPath)
-    If lngth >= 3 Then
-        tmpString = Strings.Right(MyPath, 1)
-        If tmpString <> "\" Then
-            MyPath = MyPath + "\"
-            lngth = lngth + 1
-        End If
-        tmpString = Strings.Left(MyPath, lngth - 1)
-        MyFile = Dir(tmpString, vbDirectory)
-        If MyFile <> "" Then
-        Else
-            tmpString = "C:\"
-            MyPath = tmpString
-            ChDir tmpString
-        End If
-        driveString = Strings.Left(MyPath, 1)
-        ChDrive driveString
-        ChDir tmpString
-        
-    End If
-    CommonDialog.filename = MyPath + "*.*"
-    CommonDialog.Filter = "Temporary Files Folder ( *.* ) |*.*"
-    
-    CommonDialog.ShowOpen
-    CommonDialog.FLAGS = 0
-    tmpString = CommonDialog.FileTitle
-    lngth = Len(CommonDialog.filename)
-    If lngth > 0 Then
-        Name1 = Strings.Left(CommonDialog.filename, lngth)
-        Start = 1
-        bslash = "\"
-        pos = Start
-        Do While pos > 0
-            pos = InStr(Start, Name1, bslash)
-            If pos > 0 Then
-                Start = pos + 1
-            End If
-        Loop
-        tmpString = Strings.Left(Name1, Start - 1)
-        If Len(tmpString) >= 3 Then
-            MyPath = tmpString
-            pos = InStr(MyPath, ":")
-            If pos <> 0 Then
-                Name1 = Strings.Left(MyPath, pos) + "\"
-            Else
-                Name1 = MyPath
-            End If
-            CheckDiskSpace Name1, lFreeSpace, lSpace
-'            If lFreeSpace < 10 ^ 8 Then
-'                MsgBox "Warning! Drive contains only " + Strings.Format(lFreeSpace / 10 ^ 6, "0.00") + " MB of free space or do not exists! Please check the destination!"
-'            Else
-'                MsgBox "Information! Drive contains  " + Strings.Format(lFreeSpace / 10 ^ 6, "0.00") + " MB of free space"
-'            End If
-        End If
-    End If
-    
-    flgUserChange = flgUserChangeSaved
-End Sub
-
-Public Sub SetControlFlags()
-    With CommonDialog
-       .FLAGS = cdlOFNPathMustExist
-       .FLAGS = .FLAGS Or cdlOFNHideReadOnly
-       .FLAGS = .FLAGS Or cdlOFNNoChangeDir
-       .FLAGS = .FLAGS Or cdlOFNExplorer
-       .FLAGS = .FLAGS Or cdlOFNNoValidate
-       .filename = "*.*"
-    End With
-
-End Sub
-
-Private Sub ButtonWl_Click()
-
-    DoEvents
-
-    GlobalStartWlTmp = GlobalStartWl
-    GlobalStepWlTmp = GlobalStepWl
-    
-    GlobalSetWlChange = False
-    SetWlForm.Show 1
-    If GlobalSetWlChange Then
-        GlobalStartWl = GlobalStartWlTmp
-        GlobalStepWl = GlobalStepWlTmp
-    End If
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-End Sub
-
-Private Sub ButtonToLambda_Click()
-    DoLambda
-End Sub
-
-Private Sub CommandButtonModifyChannel_Click()
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-
-    If LoadSourceImage(GlobalImageDocument, GlobalImage, ImagesListBox.ListIndex) Then
-        GlobalNumberOfChannels = GlobalImage.ImageMemory.GetDimensionC
-        If GlobalNumberOfChannels > 0 Then
-            ChannelNameForm.Show 0
-        End If
-    End If
-
-Finish:
-    flgBreak = False
-    User_flg = True
-
-End Sub
-
-Private Sub ConvertButton_Click()
-    DoConvertToT
-End Sub
-
-Private Sub ButtonToZ_Click()
-    DoConvertToZ
-End Sub
-
-Private Sub ButtonYZ_Click()
-    DoConvertYZ
-End Sub
-
-Private Sub ButtonXZ_Click()
-    DoConvertXZ
-End Sub
-
-Private Sub SetControls()
-    User_flg = False
-    If GlobalFileSource = 0 Then
-        FileNameTextBox.Visible = False
-        BrowseButton.Visible = False
-        Label1.Visible = False
-        OptionButton1.Value = True
-        OptionButton2.Value = False
-        
-    Else
-        FileNameTextBox.Visible = True
-        BrowseButton.Visible = True
-        Label1.Visible = True
-        OptionButton1.Value = False
-        OptionButton2.Value = True
-        
-    End If
-    User_flg = True
-End Sub
-
-Private Sub FileNameTextBox_Change()
-    If User_flg Then
-        FillListBox
-    End If
-End Sub
-
-Private Sub OptionButton1_Click()
-    If User_flg Then
-        GlobalFileSource = 0
-        OptionButton1.Value = True
-        OptionButton2.Value = False
-        FillListBox
-        Image1.Visible = False
-        SetControls
-        SetButtons
-        DisplayProgress "Select image...", RGB(&HC0, &HC0, 0)
-    End If
-
-End Sub
-
-Private Sub OptionButton2_Click()
-    If User_flg Then
-        GlobalFileSource = 1
-        OptionButton1.Value = False
-        OptionButton2.Value = True
-        FillListBox
-        Image1.Visible = False
-        SetControls
-        SetButtons
-        DisplayProgress "Select image...", RGB(&HC0, &HC0, 0)
-    End If
-
-End Sub
-
-Private Sub UserForm_Activate()
-    If Not DatabaseDialogLoaded Then
-        LoadWindowPosition
-    End If
-    DatabaseDialogLoaded = True
-
-End Sub
-
-Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
-    AutoStoreModify
-    SaveWindowPosition
-
-End Sub
-
-Private Sub ZStepButton_Click()
-    DoZStep
-End Sub
-
-Private Sub CommandButton1_Click()
-    flgBreak = True
-End Sub
-
-Private Sub MakeTimeButton_Click()
-    DoMakeTimeSeries
-End Sub
-
-Private Sub RotateButtonRight_Click()
-    DoRotateXY False
-End Sub
-
-Private Sub RotateButtonLeft_Click()
-    DoRotateXY True
-End Sub
-
-Private Sub ConcatenateTimeButton_Click()
-    DoConcatenate_Time
-End Sub
-
-Private Sub ConcatenateButton_Click()
-    DoConcatenate_Z
-End Sub
-
-Private Sub MirrorButton_Click()
-    DoMirrorXY
-End Sub
-
-Private Sub ReverseButton_Click()
-    DoReverseZ
-End Sub
-
-Private Sub TimeStartButton_Click()
-    DoSetStartTime
-End Sub
-
-Private Sub ExitButton_Click()
-    AutoStoreModify
-    SaveWindowPosition
-
-    End
-End Sub
-
-Private Sub HelpButton_Click()
-    DisplayHelp GlobalHelpNamePDF, GlobalHelpName
-
-'    Dim dblTask As Double
-'    Dim MacroPath As String
-'    Dim MyPath As String
-'    Dim bslash As String
-'    Dim success As Integer
-'    Dim pos As Integer
-'    Dim Start As Integer
-'    Dim count As Long
-'    Dim ProjName As String
-'    Dim indx As Integer
-'
-'    count = ProjectCount()
-'    For indx = 0 To count - 1
-'        MacroPath = ProjectPath(indx, success)
-'        ProjName = ProjectTitle(indx, success)
-'        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
-'            Start = 1
-'            bslash = "\"
-'            pos = Start
-'            Do While pos > 0
-'                pos = InStr(Start, MacroPath, bslash)
-'                If pos > 0 Then
-'                    Start = pos + 1
-'                End If
-'            Loop
-'            MyPath = Left(MacroPath, Start - 1)
-'            MyPath = MyPath + GlobalHelpName
-'            dblTask = Shell("C:\Program Files\Windows NT\Accessories\wordpad.exe " + MyPath, vbNormalFocus)
-'            Exit For
-'        End If
-'    Next indx
-End Sub
-
-Private Sub ImagesListBox_change()
-
-If User_flg Then
-    SetButtons
-End If
-End Sub
-
-Private Sub SetButtons()
-    Dim result As Boolean
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim SourceImage As AimImage
-    Dim Import As AimImageImport
-    Dim Thumbnail As AimImageBitmap
-On Error GoTo NoImage
-    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set Thumbnail = Lsm5.CreateObject("AimImageBitmap.Bitmap")
-    
-    User_flg = False
-    If (ImagesListBox.ListIndex <> -1) Then
-        RotateButtonLeft.Enabled = True
-        RotateButtonRight.Enabled = True
-        
-        MirrorButton.Enabled = True
-        
-        If OptionZStack.Value Then
-            OptionTimeStack.Value = False
-            OptionAllFiles.Value = False
-        
-            ConvertButton.Enabled = True
-            ReverseButton.Enabled = True
-            ZStepButton.Enabled = True
-            ConcatenateButton.Enabled = True
-            ConcatenateTimeButton.Enabled = False
-            MakeTimeButton.Enabled = False
-            ButtonToZ.Enabled = False
-            ButtonXZ.Enabled = True
-            ButtonYZ.Enabled = True
-            ButtonToLambda.Enabled = False
-            ButtonWl.Enabled = False
-            TimeStartButton.Enabled = False
-            
-        ElseIf OptionTimeStack.Value Then
-        
-            OptionTimeStack.Value = True
-            OptionZStack.Value = False
-            OptionAllFiles.Value = False
-            
-            ConvertButton.Enabled = False
-            ReverseButton.Enabled = False
-            ZStepButton.Enabled = False
-            
-            ConcatenateButton.Enabled = False
-            ConcatenateTimeButton.Enabled = True
-            MakeTimeButton.Enabled = False
-            ButtonToZ.Enabled = True
-            ButtonXZ.Enabled = False
-            ButtonYZ.Enabled = False
-            ButtonToLambda.Enabled = False
-            ButtonWl.Enabled = False
-            TimeStartButton.Enabled = True
-
-        Else
-            OptionTimeStack.Value = False
-            OptionZStack.Value = False
-            OptionAllFiles.Value = True
-            ConvertButton.Enabled = True
-            ButtonToZ.Enabled = True
-            
-            ReverseButton.Enabled = False
-            ZStepButton.Enabled = False
-            
-            ConcatenateButton.Enabled = True
-            ConcatenateTimeButton.Enabled = True
-            MakeTimeButton.Enabled = True
-            
-            ButtonXZ.Enabled = False
-            ButtonYZ.Enabled = False
-            TimeStartButton.Enabled = True
-            ButtonToLambda.Enabled = True
-            ButtonWl.Enabled = True
-        End If
-        If GlobalFileSource = 0 Then
-            If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-'                Set Thumbnail = SourceImageDocument.Thumbnail(0, 200, 200, SourceImage.ImageMemory.GetDimensionZ() / 2, SourceImage.ImageMemory.GetDimensionT() / 2, Nothing)
-                Set Thumbnail = SourceImageDocument.Thumbnail
-                If Not Thumbnail Is Nothing Then
-                    Image1.Picture = TransferPicture(Thumbnail).Picture
-                    Image1.Visible = True
-                    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-                Else
-                    Image1.Visible = False
-                    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-                End If
-            Else
-                Image1.Visible = True
-                DisplayProgress "Select image...", RGB(&HC0, &HC0, 0)
-            End If
-        Else
-            Import.filename = GlobalFiles(ImagesListBox.ListIndex + 1)
-            Import.ReadFullSizeFileInformation SourceImage
-            Import.ReadThumbnail Thumbnail, Import.FileInfoSize(eAimImportExportCoordinateT) / 2, _
-            Import.FileInfoSize(eAimImportExportCoordinateZ) / 2, 128, 128
-            
-            Image1.Visible = True
-            Image1.Picture = TransferPicture(Thumbnail).Picture
-            User_flg = True
-            Exit Sub
-        
-        End If
-    Else
-        Image1.Visible = False
-    
-        RotateButtonLeft.Enabled = False
-        RotateButtonRight.Enabled = False
-        MirrorButton.Enabled = False
-
-        ConcatenateButton.Enabled = False
-        ConcatenateTimeButton.Enabled = False
-        MakeTimeButton.Enabled = False
-        
-        ConvertButton.Enabled = False
-        ReverseButton.Enabled = False
-        ZStepButton.Enabled = False
-        
-        ButtonToZ.Enabled = False
-        ButtonXZ.Enabled = False
-        ButtonYZ.Enabled = False
-        TimeStartButton.Enabled = False
-        DisplayProgress "Select File...", RGB(&HC0, &HC0, 0)
-        
-    End If
-NoImage:
-    
-    User_flg = True
-End Sub
-
-Private Sub OptionAllFiles_Click()
-    If User_flg Then
-        GlobalFileOptions = 3
-        OptionAllFiles.Value = True
-        OptionZStack.Value = False
-        OptionTimeStack.Value = False
-        Frame1.Caption = "All images"
-        FillListBox
-        Image1.Visible = False
-        SetButtons
-        DisplayProgress "Select image...", RGB(&HC0, &HC0, 0)
-    End If
-End Sub
-
-Private Sub OptionTimeStack_Click()
-    If User_flg Then
-        GlobalFileOptions = 1
-        OptionTimeStack.Value = True
-        OptionZStack.Value = False
-        OptionAllFiles.Value = False
-        Frame1.Caption = "Time series"
-        FillListBox
-        Image1.Visible = False
-        SetButtons
-        DisplayProgress "Select image...", RGB(&HC0, &HC0, 0)
-    End If
-End Sub
-
-Private Sub OptionZStack_Click()
-    If User_flg Then
-        GlobalFileOptions = 2
-        OptionZStack.Value = True
-        OptionTimeStack.Value = False
-        OptionAllFiles.Value = False
-        Frame1.Caption = "Z-Stacks"
-        FillListBox
-        Image1.Visible = False
-        SetButtons
-        DisplayProgress "Select image...", RGB(&HC0, &HC0, 0)
-    End If
-End Sub
-
-Private Sub UserForm_Initialize()
-    flgBreak = False
-    SetDefaultWl 4, GlobalStartWl, GlobalStepWl
-    AutoRecallModify
-    FillListBox
-    SetFormControls
-    SetButtons
-    SetControls
-    User_flg = True
-    OptionAllFiles_Click
-    
-End Sub
-
-Public Sub GetFormControls()
-    User_flg = False
-    GlobalDirName = FileNameTextBox
-    If GlobalFileOptions = 1 Then
-        OptionZStack.Value = True
-        OptionTimeStack.Value = False
-        OptionAllFiles.Value = False
-    ElseIf GlobalFileOptions = 2 Then
-        OptionZStack.Value = False
-        OptionTimeStack.Value = True
-        OptionAllFiles.Value = False
-    ElseIf GlobalFileOptions = 3 Then
-        OptionZStack.Value = False
-        OptionTimeStack.Value = False
-        OptionAllFiles.Value = True
-    End If
-    User_flg = True
-End Sub
-
-Public Sub SetFormControls()
-    User_flg = False
-    FileNameTextBox = GlobalDirName
-    If GlobalFileOptions = 1 Then
-        OptionZStack.Value = True
-        OptionTimeStack.Value = False
-        OptionAllFiles.Value = False
-    ElseIf GlobalFileOptions = 2 Then
-        OptionZStack.Value = False
-        OptionTimeStack.Value = True
-        OptionAllFiles.Value = False
-    ElseIf GlobalFileOptions = 3 Then
-        OptionZStack.Value = False
-        OptionTimeStack.Value = False
-        OptionAllFiles.Value = True
-    End If
-    SetControls
-    User_flg = True
-End Sub
-
-Sub Heapsort(arr() As Double, hcount As Long, art() As Long)
-Dim i As Long
-Dim L As Long
-Dim Ir As Long
-Dim Rra As Double
-Dim Tra As Double
-Dim J As Long
-
-If hcount > 1 Then
-  For i = 1 To hcount
-    art(i) = i
-  Next i
-  L = CInt(hcount / 2) + 1
-  Ir = hcount
-Cont:
-  If L > 1 Then
-    L = L - 1
-    Rra = arr(art(L))
-    Tra = art(L)
-  Else
-    Rra = arr(art(Ir))
-    Tra = art(Ir)
-    art(Ir) = art(1)
-    Ir = Ir - 1
-    If Ir = 1 Then
-      art(1) = Tra
-      GoTo Done
-    End If
-  End If
-  i = L
-  J = L + L
-back:
-  If J <= Ir Then
-    If J < Ir Then
-      If arr(art(J)) < arr(art(J + 1)) Then
-        J = J + 1
-      End If
-    End If
-    If Rra < arr(art(J)) Then
-      art(i) = art(J)
-      i = J
-      J = J + J
-    Else
-      J = Ir + 1
-    End If
-    GoTo back
-  End If
-  art(i) = Tra
-  GoTo Cont
-Done:
-End If
-End Sub
-
-Public Function LoadSourceImage(Document As AimExperimentTreeNode, _
-                                 Image As AimImage, index As Long) As Boolean
-    Dim ViewerGuiServer As AimViewerGuiServer
-    Dim ViewerContext As AimImageViewerContext
-    Dim MyProgress As AimProgress
-    Dim ProgressFiFo As IAimProgressFifo
-
-    LoadSourceImage = False
-    If GlobalFileSource = 0 Then
-        If GlobalNodes(index + 1) Is Nothing Then Exit Function
-        Set Document = GlobalNodes(index + 1)
-        If Document Is Nothing Then Exit Function
-        Set Image = Document.Image(0)
-        If Image Is Nothing Then Exit Function
-        LoadSourceImage = True
-    Else
-        If (index = -1) Then Exit Function
-        Set ViewerGuiServer = Lsm5.ViewerGuiServer
-        ViewerGuiServer.LoadFile GlobalFiles(index + 1), True
-        Set ViewerContext = ViewerGuiServer.CurrentViewer
-        If ViewerContext Is Nothing Then Exit Function
-        Set Document = ViewerContext.ExperimentTreeNode
-    
-        Set Image = Document.Image(0)
-        If Image Is Nothing Then Exit Function
-        Set ProgressFiFo = Image
-        ProgressFiFo.Get MyProgress
-        If Not MyProgress Is Nothing Then
-            While Not MyProgress.Ready
-                Sleep 100
-                DoEvents
-            Wend
-        End If
-        If Image Is Nothing Then Exit Function
-        LoadSourceImage = True
-        
-        
-    End If
-End Function
-
-Private Function MakeDestination(Document As AimExperimentTreeNode, _
-                                 Image As AimImage, _
-                                 SizeX As Long, _
-                                 SizeY As Long, _
-                                 SizeZ As Long, _
-                                 SizeT As Long, _
-                                 SizeC As Long, _
-                                 DataType As enumAimImageDataType) As Boolean
-                                 
-    Dim ImageMemory As AimImageMemory
-
-    MakeDestination = False
-    Set Document = Lsm5.NewDocument
-    If Document Is Nothing Then Exit Function
-    Set Image = Document.Image(0)
-    If Image Is Nothing Then Exit Function
-    Set ImageMemory = Image
-    If ImageMemory Is Nothing Then Exit Function
-    
-On Error GoTo ErrorExit
-    ImageMemory.Create SizeC, SizeT, SizeZ, SizeY, SizeX, DataType
-    
-    MakeDestination = True
-    Exit Function
-ErrorExit:
-    MsgBox "Cannot Create New Image!"
-End Function
-
-Private Function WaitProgress(Progress As AimProgress)
-
-    WaitProgress = True
-    While Not Progress.Ready
-        DoEvents
-        Sleep (100)
-        If flgBreak Then
-            User_flg = True
-            WaitProgress = False
-            Exit Function
-        End If
-    Wend
-
-End Function
-
-Private Sub DoConvertToZ()
-
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-'    Dim DestinationImageDocument As RecordingDocument
-    
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim DataType As enumAimImageDataType
-
-On Error GoTo Finish
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    flgBreak = False
-    User_flg = False
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-    
-        If GlobalFileOptions = 3 Then
-            If SourceImage.ImageMemory.GetDimensionZ > 1 Then
-                MsgBox "This is Z Stack Image! No Conversion!"
-                GoTo Finish
-            End If
-        End If
-        DataType = SourceImage.ImageMemory.GetDataType(0)
-        If Not MakeDestination(DestinationImageDocument, _
-                               DestinationImage, _
-                               SourceImage.ImageMemory.GetDimensionX, _
-                               SourceImage.ImageMemory.GetDimensionY, _
-                               1, _
-                               1, _
-                               SourceImage.ImageMemory.GetDimensionC, _
-                               DataType) Then GoTo Finish
-                               
-'         If Not MakeDestinationDS(DestinationImageDocument, _
-'                               DestinationImage, _
-'                               SourceImage.ImageMemory.GetDimensionX, _
-'                               SourceImage.ImageMemory.GetDimensionY, _
-'                               1, _
-'                               1, _
-'                               SourceImage.ImageMemory.GetDimensionC, _
-'                               DataType) Then GoTo Finish
-                              
-        ImageCopy.SourceImage = SourceImage
-        ImageCopy.DestinationImage = DestinationImage
-        ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-'        ImageCopy.SourceCoordinateZ = eAimImageOperationCoordinateT
-        
-'        copy.SourceCoordinate(eAimImageOperationCoordinateC) = eAimImageOperationCoordinateC
-'        copy.SourceCoordinate(eAimImageOperationCoordinateX) = eAimImageOperationCoordinateX
-'        copy.SourceCoordinate(eAimImageOperationCoordinateY) = eAimImageOperationCoordinateY
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateT) = eAimImageOperationCoordinateZ
-        
-        
-        ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                          True
-        ImageCopy.Start
-        If DestinationImage.ImageMemory.VoxelSizeZ = 0 Then
-            DestinationImage.ImageMemory.VoxelSizeZ = DestinationImage.ImageMemory.VoxelSizeX
-        End If
-            
-        If Not WaitProgress(ImageCopy) Then GoTo Finish
-
-'        DestinationImageDocument.RedrawImage
-    End If
-    
-Finish:
-
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-    
-End Sub
-
-Private Sub DoConvertToT()
-
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim index As Long
-    Dim DataType As enumAimImageDataType
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-    
-        If GlobalFileOptions = 3 Then
-            If SourceImage.ImageMemory.GetDimensionT > 1 Then
-                MsgBox "This is Time Series Image! No Conversion!"
-                GoTo Finish
-            End If
-        End If
-        DataType = SourceImage.ImageMemory.GetDataType(0)
-            
-        If Not MakeDestination(DestinationImageDocument, _
-                               DestinationImage, _
-                               SourceImage.ImageMemory.GetDimensionX, _
-                               SourceImage.ImageMemory.GetDimensionY, _
-                               1, _
-                               1, _
-                               SourceImage.ImageMemory.GetDimensionC, _
-                               DataType) Then GoTo Finish
-                               
-'        If Not MakeDestinationDS(DestinationImageDocument, _
-'                               DestinationImage, _
-'                               SourceImage.ImageMemory.GetDimensionX, _
-'                               SourceImage.ImageMemory.GetDimensionY, _
-'                               1, _
-'                               1, _
-'                               SourceImage.ImageMemory.GetDimensionC, _
-'                               DataType) Then GoTo Finish
-
-        ImageCopy.SourceImage = SourceImage
-        ImageCopy.DestinationImage = DestinationImage
-        ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-'        ImageCopy.SourceCoordinateT = eAimImageOperationCoordinateZ
-'        copy.SourceCoordinate(eAimImageOperationCoordinateC) = eAimImageOperationCoordinateC
-'        copy.SourceCoordinate(eAimImageOperationCoordinateX) = eAimImageOperationCoordinateX
-'        copy.SourceCoordinate(eAimImageOperationCoordinateY) = eAimImageOperationCoordinateY
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateZ) = eAimImageOperationCoordinateT
-        
-        ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                          True
-        ImageCopy.Start
-        For index = 0 To DestinationImage.ImageMemory.GetDimensionT - 1
-            DestinationImage.ImageMemory.TimeStamp(index) = SourceImage.ImageMemory.VoxelSizeZ * index * 1000000
-        Next index
-            
-        If Not WaitProgress(ImageCopy) Then GoTo Finish
-        
-'        DestinationImageDocument.RedrawImage
-    End If
-
-Finish:
-
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-Private Sub DoConvertXZ()
-
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-'    Dim DestinationImageDocument As RecordingDocument
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim DataType As enumAimImageDataType
-
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-        DataType = SourceImage.ImageMemory.GetDataType(0)
-        If Not MakeDestination(DestinationImageDocument, _
-                               DestinationImage, _
-                               SourceImage.ImageMemory.GetDimensionX, _
-                               SourceImage.ImageMemory.GetDimensionZ, _
-                               1, _
-                               1, _
-                               SourceImage.ImageMemory.GetDimensionC, _
-                               DataType) Then GoTo Finish
-'        If Not MakeDestinationDS(DestinationImageDocument, _
-'                               DestinationImage, _
-'                               SourceImage.ImageMemory.GetDimensionX, _
-'                               SourceImage.ImageMemory.GetDimensionZ, _
-'                               1, _
-'                               1, _
-'                               SourceImage.ImageMemory.GetDimensionC, _
-'                               DataType) Then GoTo Finish
-
-        ImageCopy.SourceImage = SourceImage
-        ImageCopy.DestinationImage = DestinationImage
-        ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-'        ImageCopy.SourceCoordinateY = eAimImageOperationCoordinateZ
-'        ImageCopy.SourceCoordinateZ = eAimImageOperationCoordinateY
-        
-'        copy.SourceCoordinate(eAimImageOperationCoordinateC) = eAimImageOperationCoordinateC
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateZ) = eAimImageOperationCoordinateX
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateX) = eAimImageOperationCoordinateZ
-'        copy.SourceCoordinate(eAimImageOperationCoordinateY) = eAimImageOperationCoordinateY
-        
-        ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                          True
-        ImageCopy.Start
-            
-        If Not WaitProgress(ImageCopy) Then GoTo Finish
-        
-'        DestinationImageDocument.RedrawImage
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-Private Sub DoConvertYZ()
-
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-'    Dim DestinationImageDocument As RecordingDocument
-    
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim DataType As enumAimImageDataType
-
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-        DataType = SourceImage.ImageMemory.GetDataType(0)
-        If Not MakeDestination(DestinationImageDocument, _
-                               DestinationImage, _
-                               SourceImage.ImageMemory.GetDimensionY, _
-                               SourceImage.ImageMemory.GetDimensionZ, _
-                               1, _
-                               1, _
-                               SourceImage.ImageMemory.GetDimensionC, _
-                               DataType) Then GoTo Finish
-'        If Not MakeDestinationDS(DestinationImageDocument, _
-'                               DestinationImage, _
-'                               SourceImage.ImageMemory.GetDimensionY, _
-'                               SourceImage.ImageMemory.GetDimensionZ, _
-'                               1, _
-'                               1, _
-'                               SourceImage.ImageMemory.GetDimensionC, _
-'                               DataType) Then GoTo Finish
-            
-        ImageCopy.SourceImage = SourceImage
-        ImageCopy.DestinationImage = DestinationImage
-        ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-'        ImageCopy.SourceCoordinateY = eAimImageOperationCoordinateZ
-'        ImageCopy.SourceCoordinateZ = eAimImageOperationCoordinateX
-'        ImageCopy.SourceCoordinateX = eAimImageOperationCoordinateY
-        
-'        copy.SourceCoordinate(eAimImageOperationCoordinateC) = eAimImageOperationCoordinateC
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateZ) = eAimImageOperationCoordinateY
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateX) = eAimImageOperationCoordinateZ
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateY) = eAimImageOperationCoordinateX
-        
-        ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                          True
-        ImageCopy.Start
-        
-        If Not WaitProgress(ImageCopy) Then GoTo Finish
-        
-'        DestinationImageDocument.RedrawImage
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-Public Sub DoMirrorXY()
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim SourceImage As AimImage
-    Dim ImageCopy As AimImageCopy
-
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-        
-        ImageCopy.SourceImage = SourceImage
-        ImageCopy.DestinationImage = SourceImage
-        ImageCopy.ImageParameterCopyFlags = 0
-'        ImageCopy.SourceStrideX = -1
-'        ImageCopy.SourceX = SourceImage.ImageMemory.GetDimensionX - 1
-        
-        ImageCopy.SourceStride(eAimImageOperationCoordinateX) = -1
-        ImageCopy.Size(eAimImageOperationCoordinateX) = SourceImage.ImageMemory.GetDimensionX
-        ImageCopy.SourceStart(eAimImageOperationCoordinateX) = SourceImage.ImageMemory.GetDimensionX - 1
-        
-        ImageCopy.Start
-        
-        If Not WaitProgress(ImageCopy) Then GoTo Finish
-        
-        SourceImageDocument.RedrawImage
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-Private Sub DoRotateXY(DirectionLeft As Boolean)
-
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-'    Dim DestinationImageDocument As RecordingDocument
-    
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim DataType As enumAimImageDataType
-    
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-    
-        DataType = SourceImage.ImageMemory.GetDataType(0)
-        If Not MakeDestination(DestinationImageDocument, _
-                               DestinationImage, _
-                               SourceImage.ImageMemory.GetDimensionY, _
-                               SourceImage.ImageMemory.GetDimensionX, _
-                               1, _
-                               1, _
-                               SourceImage.ImageMemory.GetDimensionC, _
-                               DataType) Then GoTo Finish
-'        If Not MakeDestinationDS(DestinationImageDocument, _
-'                               DestinationImage, _
-'                               SourceImage.ImageMemory.GetDimensionY, _
-'                               SourceImage.ImageMemory.GetDimensionX, _
-'                               1, _
-'                               1, _
-'                               SourceImage.ImageMemory.GetDimensionC, _
-'                               DataType) Then GoTo Finish
-
-        ImageCopy.SourceImage = SourceImage
-        ImageCopy.DestinationImage = DestinationImage
-        ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-'        ImageCopy.SourceCoordinateX = eAimImageOperationCoordinateY
-'        ImageCopy.SourceCoordinateY = eAimImageOperationCoordinateX
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateY) = eAimImageOperationCoordinateX
-        ImageCopy.SourceCoordinate(eAimImageOperationCoordinateX) = eAimImageOperationCoordinateY
-        
-        If DirectionLeft Then
-'            ImageCopy.SourceStrideX = -1
-'            ImageCopy.SourceX = SourceImage.ImageMemory.GetDimensionX - 1
-            ImageCopy.SourceStride(eAimImageOperationCoordinateX) = -1
-            ImageCopy.Size(eAimImageOperationCoordinateX) = SourceImage.ImageMemory.GetDimensionX
-            ImageCopy.SourceStart(eAimImageOperationCoordinateX) = SourceImage.ImageMemory.GetDimensionX - 1
-        Else
-'            ImageCopy.SourceStrideY = -1
-'            ImageCopy.SourceY = SourceImage.ImageMemory.GetDimensionY - 1
-            ImageCopy.SourceStride(eAimImageOperationCoordinateY) = -1
-            ImageCopy.Size(eAimImageOperationCoordinateY) = SourceImage.ImageMemory.GetDimensionY
-            ImageCopy.SourceStart(eAimImageOperationCoordinateY) = SourceImage.ImageMemory.GetDimensionY - 1
-        End If
-        ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                          True
-        ImageCopy.Start
-            
-        If Not WaitProgress(ImageCopy) Then GoTo Finish
-        
-'        DestinationImageDocument.RedrawImage
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-Private Sub DoReverseZ()
-
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-'    Dim DestinationImageDocument As RecordingDocument
-    
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim DataType As enumAimImageDataType
-    
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-    
-        DataType = SourceImage.ImageMemory.GetDataType(0)
-        If Not MakeDestination(DestinationImageDocument, _
-                               DestinationImage, _
-                               SourceImage.ImageMemory.GetDimensionX, _
-                               SourceImage.ImageMemory.GetDimensionY, _
-                               1, _
-                               1, _
-                               SourceImage.ImageMemory.GetDimensionC, _
-                               DataType) Then GoTo Finish
-'        If Not MakeDestinationDS(DestinationImageDocument, _
-'                               DestinationImage, _
-'                               SourceImage.ImageMemory.GetDimensionX, _
-'                               SourceImage.ImageMemory.GetDimensionY, _
-'                               1, _
-'                               1, _
-'                               SourceImage.ImageMemory.GetDimensionC, _
-'                               DataType) Then GoTo Finish
-
-        ImageCopy.SourceImage = SourceImage
-        ImageCopy.DestinationImage = DestinationImage
-        ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-'        ImageCopy.SourceStrideZ = -1
-'        ImageCopy.SourceZ = SourceImage.ImageMemory.GetDimensionZ - 1
-        
-        ImageCopy.SourceStride(eAimImageOperationCoordinateZ) = -1
-        ImageCopy.Size(eAimImageOperationCoordinateZ) = SourceImage.ImageMemory.GetDimensionZ
-        ImageCopy.SourceStart(eAimImageOperationCoordinateZ) = SourceImage.ImageMemory.GetDimensionZ - 1
-        
-        
-        ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                          True
-        ImageCopy.Start
-            
-        If Not WaitProgress(ImageCopy) Then GoTo Finish
-        
-'        DestinationImageDocument.RedrawImage
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-
-Private Sub DoConcatenate_Time()
-
-    Dim SourceImageNodeDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-    
-'    Dim DestinationImageDocument As RecordingDocument
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim index As Long
-    Dim SizeT As Long
-    Dim SizeZ As Long
-    Dim SizeY As Long
-    Dim SizeX As Long
-    Dim SizeC As Long
-    
-    Dim Td As Long
-    Dim Ts As Long
-    Dim Cs As Long
-    Dim Cd As Long
-    Dim TimeSystemStart As Double
-    Dim TimeSystemStartLast As Double
-
-    Dim TimeDifference As Double
-    Dim TimeDifferenceLast As Double
-    Dim NumberOfSelected As Long
-    Dim PreviousTime As Double
-    Dim TimeStart() As Double
-    Dim TimeStamp() As Double
-    Dim TimeSort() As Double
-    Dim TimeStampMax As Double
-    Dim TimeStartMin As Double
-    Dim Nodes() As AimExperimentTreeNode
-    Dim IndexArray() As Long
-    Dim NumberOfImages As Long
-    Dim SlctFileName() As String
-    Dim ViewerGuiServer As AimViewerGuiServer
-    Dim ViewerContext As AimImageViewerContext
-    Dim MyProgress As AimProgress
-    Dim ProgressFiFo As IAimProgressFifo
-    
-    Dim Import As AimImageImport
-    Dim TmpImage As AimImage
-    Dim DataType As Long
-    Dim TmpTimeStamp As Double
-    Dim Count As Long
-    Dim EventTimeStamp As Double
-    Dim EventType As Long
-    Dim EventDescription As String
-    Dim Es As Long
-
-    Dim Name2 As String
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-    Set TmpImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If (ImagesListBox.ListIndex <> -1) Then
-        Set ViewerGuiServer = Lsm5.ViewerGuiServer
-        DisplayProgress "Working...", RGB(0, &HC0, 0)
-        
-        SizeT = 0
-        
-        NumberOfSelected = 0
-        TimeStampMax = 0
-        TimeStartMin = 10 ^ 10
-        NumberOfImages = ImagesListBox.ListCount
-        For index = 1 To NumberOfImages
-            If ImagesListBox.Selected(index - 1) Then
-                ReDim Preserve TimeStart(NumberOfSelected + 1)
-                ReDim Preserve Nodes(NumberOfSelected + 1)
-                ReDim Preserve TimeStamp(NumberOfSelected + 1)
-                ReDim Preserve TimeSort(NumberOfSelected + 1)
-                ReDim Preserve SlctFileName(NumberOfSelected + 1)
-                
-                If GlobalFileSource = 0 Then
-                    Set SourceImageNodeDocument = GlobalNodes(index)
-                    Set SourceImage = SourceImageNodeDocument.Image(0)
-                    Set Nodes(NumberOfSelected + 1) = SourceImageNodeDocument
-                Else
-                    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-                
-'                    Set SourceImage = New AimImage
-                    Import.filename = GlobalFiles(index)
-                    Import.ReadFullSizeFileInformation SourceImage
-                
-                End If
-                If GlobalFileSource = 0 Then
-                    SlctFileName(NumberOfSelected + 1) = SourceImageNodeDocument.Name
-                Else
-                    SlctFileName(NumberOfSelected + 1) = GlobalFiles(index)
-                End If
-                TimeStart(NumberOfSelected + 1) = CDbl(SourceImage.Characteristics.AcquisitionDateAndTime)
-                TimeStamp(NumberOfSelected + 1) = SourceImage.ImageMemory.TimeStamp(0)
-                If TimeStamp(NumberOfSelected + 1) > TimeStampMax Then TimeStampMax = TimeStamp(NumberOfSelected + 1)
-                If TimeStart(NumberOfSelected + 1) < TimeStartMin Then TimeStartMin = TimeStart(NumberOfSelected + 1)
-                If GlobalFileSource = 0 Then
-                    SizeT = SizeT + SourceImage.ImageMemory.GetDimensionT
-                    If SourceImage.ImageMemory.GetDimensionZ >= SizeZ Then SizeZ = SourceImage.ImageMemory.GetDimensionZ
-                    If SourceImage.ImageMemory.GetDimensionY >= SizeY Then SizeY = SourceImage.ImageMemory.GetDimensionY
-                    If SourceImage.ImageMemory.GetDimensionX >= SizeX Then SizeX = SourceImage.ImageMemory.GetDimensionX
-                    If SourceImage.ImageMemory.GetDimensionC >= SizeC Then SizeC = SourceImage.ImageMemory.GetDimensionC
-                    
-                Else
-                    SizeT = SizeT + Import.FileInfoSize(eAimImportExportCoordinateT)
-                    If Import.FileInfoSize(eAimImportExportCoordinateZ) >= SizeZ _
-                    Then SizeZ = Import.FileInfoSize(eAimImportExportCoordinateZ)
-                    If Import.FileInfoSize(eAimImportExportCoordinateY) >= SizeY _
-                    Then SizeY = Import.FileInfoSize(eAimImportExportCoordinateY)
-                    If Import.FileInfoSize(eAimImportExportCoordinateX) >= SizeX _
-                    Then SizeX = Import.FileInfoSize(eAimImportExportCoordinateX)
-                    If Import.FileInfoSize(eAimImportExportCoordinateC) >= SizeC _
-                    Then SizeC = Import.FileInfoSize(eAimImportExportCoordinateC)
-                    
-                End If
-                NumberOfSelected = NumberOfSelected + 1
-            End If
-            DisplayProgress "Reading File Info..." + Strings.Format(100 * index / NumberOfImages, "0") + "%", RGB(0, &HC0, 0)
-            DoEvents
-        Next index
-                
-        If NumberOfSelected < 2 Then
-            MsgBox "Select two or more time series Images!"
-            DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-            GoTo Finish
-        End If
-'        GlobalUseChannelColor = True
-        If TimeStampMax = 0 Then
-            TimeStampMax = 1
-        End If
-        For index = 1 To NumberOfSelected
-            TimeSort(index) = (TimeStart(index) - TimeStartMin) * 24 * 3600 + TimeStamp(index) / TimeStampMax / 10 ^ 3
-        Next index
-        
-        ReDim IndexArray(NumberOfSelected)
-        Heapsort TimeSort, NumberOfSelected, IndexArray
-        
-        Td = 0
-        PreviousTime = 0
-        DisplayProgress "Copying Files...", RGB(0, &HC0, 0)
-        
-        For index = 1 To NumberOfSelected
-            If GlobalFileSource = 0 Then
-                Set SourceImageNodeDocument = Nodes(IndexArray(index))
-                Set SourceImage = SourceImageNodeDocument.Image(0)
-            Else
-            
-'                Set SourceImage = New AimImage
-                Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'   Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-'    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-            
-                Import.filename = SlctFileName(IndexArray(index))
-                Import.ReadFullSizeFileInformation SourceImage
-                If Import.FileInfoChannelDataType(0) = eAimImageDataTypeU8 Then
-                    DataType = 1
-                Else
-                    DataType = 2
-                End If
-                SourceImage.ImageMemory.Create Import.FileInfoSize(eAimImportExportCoordinateC), _
-                                                    Import.FileInfoSize(eAimImportExportCoordinateT), _
-                                                    Import.FileInfoSize(eAimImportExportCoordinateZ), _
-                                                    Import.FileInfoSize(eAimImportExportCoordinateY), _
-                                                    Import.FileInfoSize(eAimImportExportCoordinateX), _
-                                                    Import.FileInfoChannelDataType(0)
-                                                    
-                Import.Import SourceImage
-            
-          
-            End If
-            
-            If index = 1 Then
-            
-'                 If Not MakeDestination(DestinationImageDocument, _
-'                                       DestinationImage, _
-'                                       SourceImage.ImageMemory.GetDimensionX, _
-'                                       SourceImage.ImageMemory.GetDimensionY, _
-'                                       SourceImage.ImageMemory.GetDimensionZ, _
-'                                       SizeT, _
-'                                       SourceImage.ImageMemory.GetDimensionC, _
-'                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-                                       
-                 If Not MakeDestination(DestinationImageDocument, _
-                                       DestinationImage, _
-                                       SizeX, _
-                                       SizeY, _
-                                       SizeZ, _
-                                       SizeT, _
-                                       SizeC, _
-                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-                                       
-'                If Not MakeDestinationDS(DestinationImageDocument, _
-'                                      DestinationImage, _
-'                                      SizeX, _
-'                                      SizeY, _
-'                                      SizeZ, _
-'                                      SizeT, _
-'                                      SizeC, _
-'                                      SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-                                       
-            
-                ImageCopy.SourceImage = SourceImage
-                ImageCopy.DestinationImage = DestinationImage
-                ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-            
-                ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                                  True
-                                                  
-'                DestinationImage.ImageMemory.Resize SizeT, _
-'                                                    SourceImage.ImageMemory.GetDimensionZ, _
-'                                                    SourceImage.ImageMemory.GetDimensionY, _
-'                                                    SourceImage.ImageMemory.GetDimensionX, _
-'                                                    eAimImageResizeTypePreserve
-                DestinationImage.ImageMemory.Resize SizeT, _
-                                                    SizeZ, _
-                                                    SizeY, _
-                                                    SizeX, _
-                                                    eAimImageResizeTypePreserve
-                GetPureName SlctFileName(IndexArray(index)), Name2
-                DestinationImageDocument.Name = Name2 + "_SUM"
-                ImageCopy.Start
-                If Not WaitProgress(ImageCopy) Then GoTo Finish
-
-'                DestinationImageDocument.SetTitle Name2 + "_SUM"
-           
-            
-            
-            
-            
-'                If Import.FileInfoChannelDataType(0) = eAimImageDataTypeU8 Then
-'                    DataType = 1
-'                Else
-'                    DataType = 2
-'                End If
-'
-'                Set DestinationImageDocument = EngelImageToHechtImage(SingleImage)
-'                Set DestinationImage = DestinationImageDocument.Image(0, True)
-'
-'                ImageCopy.SourceImage = SourceImage
-'                ImageCopy.DestinationImage = DestinationImage
-'                ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll - eAimImageParameterCopyEventList
-'
-'                ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-'                                                  True
-'
-'                DestinationImage.ImageMemory.Resize SizeT, _
-'                                                    SourceImage.ImageMemory.GetDimensionZ, _
-'                                                    SourceImage.ImageMemory.GetDimensionY, _
-'                                                    SourceImage.ImageMemory.GetDimensionX, _
-'                                                    eAimImageResizeTypePreserve
-'                DestinationImageDocument.SetTitle SlctFileName(IndexArray(Index)) + "_SUM"
-'                DestinationImageDocument.RedrawImage
-
-            Else
-                ImageCopy.SourceImage = SourceImage
-                ImageCopy.DestinationImage = DestinationImage
-'                ImageCopy.DestinationT = Td
-                ImageCopy.DestinationStart(eAimImageOperationCoordinateT) = Td
-
-                ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyTimeStamps ' Or eAimImageParameterCopyEventList
-                If GlobalUseChannelColor And GlobalSystemVersion >= 50 Then
-                    For Cd = 0 To DestinationImage.ImageMemory.GetDimensionC - 1
-'                        ImageCopy.ChannelAssignment(Cd) = -1
-                        For Cs = 0 To SourceImage.ImageMemory.GetDimensionC - 1
-                            If SourceImage.DisplayParameters.ChannelInformation.ChannelColor(Cs) = _
-                                       DestinationImage.DisplayParameters.ChannelInformation.ChannelColor(Cd) _
-                                       Then
-'                                ImageCopy.ChannelAssignment(Cd) = Cs
-                                ImageCopy.DestinationStart(eAimImageOperationCoordinateC) = Cd
-                                ImageCopy.SourceStart(eAimImageOperationCoordinateC) = Cs
-                                ImageCopy.Size(eAimImageOperationCoordinateC) = Cd + 1
-                                ImageCopy.Start
-                                If Not WaitProgress(ImageCopy) Then GoTo Finish
-                            End If
-                        Next Cs
-                    Next Cd
-                Else
-                    For Cd = 0 To DestinationImage.ImageMemory.GetDimensionC - 1
-'                        ImageCopy.ChannelAssignment(Cd) = -1
-                        For Cs = 0 To SourceImage.ImageMemory.GetDimensionC - 1
-                            If StrComp(SourceImage.DisplayParameters.ChannelInformation.ChannelName(Cs), _
-                                       DestinationImage.DisplayParameters.ChannelInformation.ChannelName(Cd), _
-                                       vbTextCompare) = 0 Then
-'                                ImageCopy.ChannelAssignment(Cd) = Cs
-                                ImageCopy.DestinationStart(eAimImageOperationCoordinateC) = Cd
-                                ImageCopy.SourceStart(eAimImageOperationCoordinateC) = Cs
-                                ImageCopy.Size(eAimImageOperationCoordinateC) = Cd + 1
-                                ImageCopy.Start
-                                If Not WaitProgress(ImageCopy) Then GoTo Finish
-                            End If
-                        Next Cs
-                    Next Cd
-                
-                End If
-            End If
-'            ImageCopy.Start
-'            If Not WaitProgress(ImageCopy) Then GoTo Finish
-            
-            If index > 1 Then
-                TimeDifference = CDbl((TimeStart(IndexArray(index)) - TimeStart(IndexArray(1))) * 24 * 3600)
-                TimeSystemStart = TimeDifference - SourceImage.ImageMemory.TimeStamp(0)
-                If TimeSystemStart > TimeSystemStartLast + 2 Then TimeSystemStartLast = TimeSystemStart
-                
-            Else
-                TimeDifference = 0
-                PreviousTime = SourceImage.ImageMemory.TimeStamp(0)
-                TimeSystemStart = TimeDifference - SourceImage.ImageMemory.TimeStamp(0)
-                TimeSystemStartLast = TimeDifference - SourceImage.ImageMemory.TimeStamp(0)
-                
-            End If
-            
-            For Ts = 0 To SourceImage.ImageMemory.GetDimensionT - 1
-                TmpTimeStamp = SourceImage.ImageMemory.TimeStamp(Ts)
-                DestinationImage.ImageMemory.TimeStamp(Td) = TmpTimeStamp _
-                                                           + TimeSystemStartLast
-                Td = Td + 1
-            Next Ts
-            
-            Count = SourceImage.EventList.Count
-            For Es = 0 To Count - 1
-                EventTimeStamp = SourceImage.EventList.time(Es)
-                EventType = SourceImage.EventList.Type(Es)
-                EventDescription = SourceImage.EventList.Description(Es)
-                DestinationImage.EventList.Append EventTimeStamp + TimeSystemStartLast, EventType, EventDescription
-            Next Es
-        Next index
-'        DestinationImageDocument.SetTitle SlctFileName(IndexArray(1)) + "_SUM"
-'        DestinationImageDocument.RedrawImage
-
-'        DestinationImageDocument.SetTitle Name2 + "_SUM"
-'        DestinationImageDocument.Name = Name2 + "_SUM"
-'        DestinationImageDocument.SetTitle Name2 + "_SUM"
-        DestinationImageDocument.Name = Name2 + "_SUM"
-        
-'        DestinationImageDocument.RedrawImage
-        
-'        ViewerGuiServer.Activate DestinationImageDocument
-        Lsm5Vba.Application.ThrowEvent eRootReuse, 0
-        DoEvents
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-
-Public Function SingleImage() As DsRecordingDoc
-    Dim ChNum As Long
-    Dim bpp As Long
-    Dim Tags As AimImage40.AimImageApplicationTags
-    Dim OtherTags As AimImage40.AimImageApplicationTags
-    Dim ViewerGuiServer As AimViewerGuiServer40.AimViewerGuiServer
-    Dim Tree As AimExperiment40.AimExperimentTreeNode
-    Dim Node As AimExperiment40.AimExperimentTreeNode
-    Dim GlobalSingleImageValid As Boolean
-    Dim index As Long
-    
-    GlobalSingleImageValid = False
-    
-    If Not GlobalSingleImage Is Nothing Then
-        If GlobalSystemVersion < 50 Then
-            GlobalSingleImageValid = GlobalSingleImage.IsValid
-        Else
-            If Not EngelImageToHechtImage(GlobalSingleImage) Is Nothing Then
-                Set Tags = EngelImageToHechtImage(GlobalSingleImage).Image(0, False)
-                If Not Tags Is Nothing Then
-                    Set ViewerGuiServer = Lsm5.ViewerGuiServer
-                    If Not ViewerGuiServer Is Nothing Then
-                        Set Tree = ViewerGuiServer.ExperimentTree
-                        If Not Tree Is Nothing Then
-                            For index = 0 To Tree.NumberChildren - 1
-                                Set Node = Tree.Child(index)
-                                If Not Node Is Nothing Then
-                                    If Node.Type = eExperimentTeeeNodeTypeLsm Then
-                                        Set OtherTags = Node.Image(0)
-                                        If Not OtherTags Is Nothing Then
-                                            Tags.SetBooleanValue "MultiTimeImageTest", False
-                                            If Not OtherTags.GetBooleanValue("MultiTimeImageTest", True) Then
-                                                Tags.SetBooleanValue "MultiTimeImageTest", True
-                                                If OtherTags.GetBooleanValue("MultiTimeImageTest", False) Then
-                                                    GlobalSingleImageValid = True
-                                                    Tags.Remove "MultiTimeImageTest"
-                                                    Exit For
-                                                End If
-                                            End If
-                                            Tags.Remove "MultiTimeImageTest"
-                                        End If
-                                    End If
-                                End If
-                            Next index
-                        End If
-                    End If
-                End If
-            End If
-        End If
-    End If
-    If Not GlobalSingleImageValid Then
-        ChNum = Lsm5.DsRecording.NumberOfChannels
-        Set GlobalSingleImage = Lsm5.MakeNewImageDocument(512, 512, 1, 1, ChNum, bpp, True)
-    End If
-    Set SingleImage = GlobalSingleImage
-End Function
-
-
-Private Sub DoConcatenate_Z()
-
-    Dim SourceImageNodeDocument As AimExperimentTreeNode
-'    Dim DestinationImageDocument As RecordingDocument
-    Dim DestinationImageDocument As AimExperimentTreeNode
-    
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim index As Long
-    Dim SizeZ As Long
-    Dim Zd As Long
-    Dim Cs As Long
-    Dim Cd As Long
-    Dim NumberOfSelected As Long
-    Dim Nodes() As AimExperimentTreeNode
-    Dim SlctFileName() As String
-    Dim NumberOfImages As Long
-    Dim Import As AimImageImport
-    Dim DataType As Long
-
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If (ImagesListBox.ListIndex <> -1) Then
-        DisplayProgress "Working...", RGB(0, &HC0, 0)
-        SizeZ = 0
-        NumberOfSelected = 0
-        NumberOfImages = ImagesListBox.ListCount
-        
-        For index = 1 To NumberOfImages
-            If ImagesListBox.Selected(index - 1) Then
-                ReDim Preserve Nodes(NumberOfSelected + 1)
-                ReDim Preserve SlctFileName(NumberOfSelected + 1)
-                
-                If GlobalFileSource = 0 Then
-                    Set SourceImageNodeDocument = GlobalNodes(index)
-                    Set SourceImage = SourceImageNodeDocument.Image(0)
-                    Set Nodes(NumberOfSelected + 1) = SourceImageNodeDocument
-                    SlctFileName(NumberOfSelected + 1) = SourceImageNodeDocument.Name
-                    SizeZ = SizeZ + SourceImage.ImageMemory.GetDimensionT
-                    
-                Else
-                    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'   Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-'    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-                
-'                    Set SourceImage = New AimImage
-                    Import.filename = GlobalFiles(index)
-                    Import.ReadFullSizeFileInformation SourceImage
-                    SlctFileName(NumberOfSelected + 1) = GlobalFiles(index)
-                    SizeZ = SizeZ + Import.FileInfoSize(eAimImportExportCoordinateZ)
-                End If
-
-                NumberOfSelected = NumberOfSelected + 1
-            End If
-            DisplayProgress "Reading File Info..." + Strings.Format(100 * index / NumberOfImages, "0") + "%", RGB(0, &HC0, 0)
-            DoEvents
-            
-        Next index
-                
-        If NumberOfSelected < 2 Then
-            MsgBox "Select two or more z-stack files!"
-            DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-            GoTo Finish
-        End If
-        DisplayProgress "Copying Files...", RGB(0, &HC0, 0)
-        Zd = 0
-        For index = 1 To NumberOfSelected
-            
-'            Set SourceImageNodeDocument = Nodes(Index)
-'            Set SourceImage = SourceImageNodeDocument.Image(0)
-            If GlobalFileSource = 0 Then
-                Set SourceImageNodeDocument = Nodes(index)
-                Set SourceImage = SourceImageNodeDocument.Image(0)
-            Else
-                Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'   Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-'    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-            
-'                Set SourceImage = New AimImage
-                Import.filename = SlctFileName(index)
-                Import.ReadFullSizeFileInformation SourceImage
-                If Import.FileInfoChannelDataType(0) = eAimImageDataTypeU8 Then
-                    DataType = 1
-                Else
-                    DataType = 2
-                End If
-                SourceImage.ImageMemory.Create Import.FileInfoSize(eAimImportExportCoordinateC), _
-                                                    Import.FileInfoSize(eAimImportExportCoordinateT), _
-                                                    Import.FileInfoSize(eAimImportExportCoordinateZ), _
-                                                    Import.FileInfoSize(eAimImportExportCoordinateY), _
-                                                    Import.FileInfoSize(eAimImportExportCoordinateX), _
-                                                    Import.FileInfoChannelDataType(0)
-                                                    
-                Import.Import SourceImage
-            
-          
-            End If
-  
-            
-            If index = 1 Then
-                If Not MakeDestination(DestinationImageDocument, _
-                                       DestinationImage, _
-                                       SourceImage.ImageMemory.GetDimensionX, _
-                                       SourceImage.ImageMemory.GetDimensionY, _
-                                       1, _
-                                       1, _
-                                       SourceImage.ImageMemory.GetDimensionC, _
-                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-'
-'                If Not MakeDestinationDS(DestinationImageDocument, _
-'                                      DestinationImage, _
-'                                      SizeX, _
-'                                      SizeY, _
-'                                      SizeZ, _
-'                                      SizeT, _
-'                                      SizeC, _
-'                                      SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-
-'                If Not MakeDestinationDS(DestinationImageDocument, _
-'                                       DestinationImage, _
-'                                       SourceImage.ImageMemory.GetDimensionX, _
-'                                       SourceImage.ImageMemory.GetDimensionY, _
-'                                       1, _
-'                                       1, _
-'                                       SourceImage.ImageMemory.GetDimensionC, _
-'                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-                                       
-                                       
-
-'                If Import.FileInfoChannelDataType(0) = eAimImageDataTypeU8 Then
-'                    DataType = 1
-'                Else
-'                    DataType = 2
-'                End If
-'
-'                Set DestinationImageDocument = EngelImageToHechtImage(SingleImage)
-'                Set DestinationImage = DestinationImageDocument.Image(0, True)
-            
-                ImageCopy.SourceImage = SourceImage
-                ImageCopy.DestinationImage = DestinationImage
-                ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-            
-                ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                                  True
-                                                  
-                DestinationImage.ImageMemory.Resize SourceImage.ImageMemory.GetDimensionT, _
-                                                    SizeZ, _
-                                                    SourceImage.ImageMemory.GetDimensionY, _
-                                                    SourceImage.ImageMemory.GetDimensionX, _
-                                                    eAimImageResizeTypePreserve
-                DestinationImageDocument.Name = SlctFileName(index) + "_SUM"
-'                DestinationImageDocument.SetTitle SlctFileName(index) + "_SUM"
-                ImageCopy.Start
-                If Not WaitProgress(ImageCopy) Then GoTo Finish
-                
-            Else
-                ImageCopy.SourceImage = SourceImage
-                ImageCopy.DestinationImage = DestinationImage
-                ImageCopy.DestinationStart(eAimImageOperationCoordinateZ) = Zd
-'                ImageCopy.DestinationZ = Zd
-                ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyEventList
-                
-                For Cd = 0 To DestinationImage.ImageMemory.GetDimensionC - 1
-'                    ImageCopy.ChannelAssignment(Cd) = -1
-                    For Cs = 0 To SourceImage.ImageMemory.GetDimensionC - 1
-                        If StrComp(SourceImage.DisplayParameters.ChannelInformation.ChannelName(Cs), _
-                                   DestinationImage.DisplayParameters.ChannelInformation.ChannelName(Cd), _
-                                   vbTextCompare) = 0 Then
-'                            ImageCopy.ChannelAssignment(Cd) = Cs
-                            ImageCopy.DestinationStart(eAimImageOperationCoordinateC) = Cd
-                            ImageCopy.SourceStart(eAimImageOperationCoordinateC) = Cs
-                            ImageCopy.Size(eAimImageOperationCoordinateC) = Cd + 1
-                            ImageCopy.Start
-                            If Not WaitProgress(ImageCopy) Then GoTo Finish
-                        End If
-                    Next Cs
-                Next Cd
-            End If
-            
-            
-            Zd = Zd + SourceImage.ImageMemory.GetDimensionZ
-        Next index
-        DestinationImageDocument.Name = SlctFileName(1) + "_SUM"
-'        DestinationImageDocument.SetTitle SlctFileName(index) + "_SUM"
-        
-'        DestinationImageDocument.RedrawImage
-        
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-    
-End Sub
-
-Private Sub DoZStep()
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim SourceImage As AimImage
-
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-        
-        GlobalZStep = 10 ^ 6 * SourceImage.ImageMemory.VoxelSizeZ
-        ZStepForm.Show 1
-        If ZStepChange Then
-            SourceImage.ImageMemory.VoxelSizeZ = GlobalZStep / 10 ^ 6
-        End If
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-Private Sub DoSetStartTime()
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim SourceImage As AimImage
-    Dim DateValue As Double
-    Dim TimeValue As Double
-
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-        
-        GlobalTimeStampDate = SourceImage.Characteristics.AcquisitionDateAndTime
-        GlobalTimeStampTime = SourceImage.Characteristics.AcquisitionDateAndTime
-            
-        TimeStampForm.Show 1
-        If TimeStampChange Then
-            DateValue = CDbl(GlobalTimeStampDate)
-            DateValue = CDbl(CLng(DateValue))
-            TimeValue = CDbl(GlobalTimeStampTime)
-            TimeValue = TimeValue - CDbl(Int(TimeValue))
-        
-            SourceImage.Characteristics.AcquisitionDateAndTime = CDate(DateValue + TimeValue)
-        End If
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-
-End Sub
-
-
-
-Private Sub DoLambda()
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-'    Dim DestinationImageDocument As RecordingDocument
-    
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim C As Long
-    Dim C1 As Long
-    Dim Z As Long
-    Dim T As Long
-    Dim Data() As Byte
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-    
-        If SourceImage.DisplayParameters.Type = eAimImageDisplayTypeSpectral Then
-            If Not MakeDestination(DestinationImageDocument, _
-                                   DestinationImage, _
-                                   SourceImage.ImageMemory.GetDimensionX, _
-                                   SourceImage.ImageMemory.GetDimensionY, _
-                                   1, _
-                                   1, _
-                                   SourceImage.ImageMemory.GetDimensionC, _
-                                   SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-                                   
-            DestinationImage.DisplayParameters.Type = eAimImageDisplayTypeImage
-    
-            ImageCopy.SourceImage = SourceImage
-            ImageCopy.DestinationImage = DestinationImage
-            ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll - eAimImageParameterCopyAcquisitionParameters - eAimImageParameterCopyDisplayType
-            
-            ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                              True
-            ImageCopy.Start
-                
-            If Not WaitProgress(ImageCopy) Then GoTo Finish
-            
-            DestinationImage.DisplayParameters.Type = eAimImageDisplayTypeImage
-
-'            MsgBox "This image is a lambda stack"
-        Else
-            DisplayProgress "Working... ", RGB(0, &HC0, 0)
-            
-        
-            If SourceImage.ImageMemory.GetDimensionC = 1 And SourceImage.ImageMemory.GetDimensionT > 1 Then
-                If SourceImage.ImageMemory.GetDimensionT > 40 Then
-                    MsgBox "Too Many Time Points to Convert to Lambda Stack!"
-                    GoTo Finish
-                End If
-
-                If Not MakeDestination(DestinationImageDocument, _
-                                       DestinationImage, _
-                                       SourceImage.ImageMemory.GetDimensionX, _
-                                       SourceImage.ImageMemory.GetDimensionY, _
-                                       1, _
-                                       1, _
-                                       SourceImage.ImageMemory.GetDimensionT, _
-                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-'                If Not MakeDestinationDS(DestinationImageDocument, _
-'                                       DestinationImage, _
-'                                       SourceImage.ImageMemory.GetDimensionX, _
-'                                       SourceImage.ImageMemory.GetDimensionY, _
-'                                       1, _
-'                                       1, _
-'                                       SourceImage.ImageMemory.GetDimensionT, _
-'                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-'
-'                ReDim Data(SourceImage.ImageMemory.GetDimensionX * SourceImage.ImageMemory.GetDimensionY)
-'
-'                For T = 0 To SourceImage.ImageMemory.GetDimensionT - 1
-'                    For Z = 0 To SourceImage.ImageMemory.GetDimensionZ - 1
-'                        SourceImage.ImageMemory.GetSubregion 0, _
-'                                                             0, _
-'                                                             0, _
-'                                                             Z, _
-'                                                             T, _
-'                                                             1, _
-'                                                             1, _
-'                                                             1, _
-'                                                             1, _
-'                                                             SourceImage.ImageMemory.GetDimensionX, _
-'                                                             SourceImage.ImageMemory.GetDimensionY, _
-'                                                             1, _
-'                                                             1, _
-'                                                             eAimImageDataTypeU8, SourceImage.ImageMemory.GetDimensionX * SourceImage.ImageMemory.GetDimensionY, _
-'                                                             Data(0)
-'
-'                        DestinationImage.ImageMemory.SetSubregion T, _
-'                                                                  0, _
-'                                                                  0, _
-'                                                                  Z, _
-'                                                                  0, _
-'                                                                  1, _
-'                                                                  1, _
-'                                                                  1, _
-'                                                                  1, _
-'                                                                  SourceImage.ImageMemory.GetDimensionX, _
-'                                                                  SourceImage.ImageMemory.GetDimensionY, _
-'                                                                  1, _
-'                                                                  1, _
-'                                                                  0, _
-'                                                                  0, _
-'                                                                  0, _
-'                                                                  eAimImageDataTypeInvalid, _
-'                                                                  SourceImage.ImageMemory.GetDimensionX * SourceImage.ImageMemory.GetDimensionY, _
-'                                                                  Data(0)
-'                    Next Z
-'                Next T
-
-                ImageCopy.SourceImage = SourceImage
-                ImageCopy.DestinationImage = DestinationImage
-                ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-                'ImageCopy.SourceCoordinate(eAimImageOperationCoordinateC) = eAimImageOperationCoordinateT
-
-                For C = 0 To SourceImage.ImageMemory.GetDimensionT - 1
-
-'                    For C1 = 0 To SourceImage.ImageMemory.GetDimensionT - 1
-'                        ImageCopy.ChannelAssignment(C1) = -1
-'                    Next C1
-'                    ImageCopy.ChannelAssignment(C) = 0
-
-                    ImageCopy.DestinationStart(eAimImageOperationCoordinateC) = C
-                    ImageCopy.SourceStart(eAimImageOperationCoordinateT) = C
-                    ImageCopy.SourceStart(eAimImageOperationCoordinateC) = 0
-'                    ImageCopy.Size(eAimImageOperationCoordinateC) = Cd + 1
-                    ImageCopy.Size(eAimImageOperationCoordinateC) = C + 1
-                    ImageCopy.Size(eAimImageOperationCoordinateT) = 1
-'                    ImageCopy.SizeT = 1
-'                    ImageCopy.SourceT = C
-                   ' ImageCopy.Size(eAimImageOperationCoordinateT) = 1
-
-
-'                    ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-'                                                      True
-                    ImageCopy.Start
-                    DisplayProgress "Copying Image " + CStr(C + 1) + " out of " + CStr(SourceImage.ImageMemory.GetDimensionT), RGB(0, &HC0, 0)
-
-                    If Not WaitProgress(ImageCopy) Then GoTo Finish
-
-                Next C
-                DestinationImage.DisplayParameters.Type = eAimImageDisplayTypeSpectral
-                For C = 0 To DestinationImage.ImageMemory.GetDimensionC - 1
-                    DestinationImage.ImageMemory.DetectionWavelengthStart(C) = (GlobalStartWl + C * GlobalStepWl - GlobalStepWl / 2) * 0.000000001
-                    DestinationImage.ImageMemory.DetectionWavelengthEnd(C) = (GlobalStartWl + C * GlobalStepWl + GlobalStepWl / 2) * 0.000000001
-                    DestinationImage.DisplayParameters.ChannelInformation.ChannelName(C) = CStr((GlobalStartWl + C * GlobalStepWl) + GlobalStepWl / 2)
-                Next C
-
-
-'            If SourceImage.ImageMemory.GetDimensionC = 1 And SourceImage.ImageMemory.GetDimensionT > 1 Then
-'                If Not MakeDestination(DestinationImageDocument, _
-'                                       DestinationImage, _
-'                                       SourceImage.ImageMemory.GetDimensionX, _
-'                                       SourceImage.ImageMemory.GetDimensionY, _
-'                                       SourceImage.ImageMemory.GetDimensionZ, _
-'                                       1, _
-'                                       SourceImage.ImageMemory.GetDimensionT, _
-'                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-'
-'                ImageCopy.SourceImage = SourceImage
-'                ImageCopy.DestinationImage = DestinationImage
-'                ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-'
-''                ImageCopy.SourceStrideT = 1
-''                ImageCopy.Sourcec = SourceImage.ImageMemory.GetDimensionT - 1
-'                ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-'                                                  True
-'                For C = 0 To SourceImage.ImageMemory.GetDimensionT - 1
-'                    For C1 = 0 To SourceImage.ImageMemory.GetDimensionT - 1
-'                        ImageCopy.ChannelAssignment(C1) = -1
-'                    Next C1
-'                    ImageCopy.ChannelAssignment(C) = 0
-'                    ImageCopy.SizeT = 1
-'                    ImageCopy.SourceT = C
-'                    ImageCopy.Start
-'                    If Not WaitProgress(ImageCopy) Then GoTo Finish
-'
-'                Next C
-'
-'                DestinationImage.DisplayParameters.Type = eAimImageDisplayTypeSpectral
-'                For C = 0 To DestinationImage.ImageMemory.GetDimensionC - 1
-'                    DestinationImage.ImageMemory.DetectionWavelengthStart(C) = (GlobalStartWl + C * GlobalStepWl) * 0.000000001
-'                    DestinationImage.ImageMemory.DetectionWavelengthEnd(C) = (GlobalStartWl + C * GlobalStepWl) * 0.000000001
-''                    DestinationImage.DisplayParameters.ChannelInformation.ChannelColor(C) = RGB(255, 255, 255)
-'                    DestinationImage.DisplayParameters.ChannelInformation.ChannelName(C) = CStr((GlobalStartWl + C * GlobalStepWl) + GlobalStepWl / 2)
-'
-'                Next C
-            Else
-                If SourceImage.ImageMemory.GetDimensionC = 1 Then
-                    MsgBox "Image Should Have More than One Channel!"
-                    GoTo Finish
-                End If
-            
-                If Not MakeDestination(DestinationImageDocument, _
-                                       DestinationImage, _
-                                       SourceImage.ImageMemory.GetDimensionX, _
-                                       SourceImage.ImageMemory.GetDimensionY, _
-                                       1, _
-                                       1, _
-                                       SourceImage.ImageMemory.GetDimensionC, _
-                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-'                If Not MakeDestinationDS(DestinationImageDocument, _
-'                                       DestinationImage, _
-'                                       SourceImage.ImageMemory.GetDimensionX, _
-'                                       SourceImage.ImageMemory.GetDimensionY, _
-'                                       1, _
-'                                       1, _
-'                                       SourceImage.ImageMemory.GetDimensionC, _
-'                                       SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-                                       
-        
-                ImageCopy.SourceImage = SourceImage
-                ImageCopy.DestinationImage = DestinationImage
-                ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll
-                
-                ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                                  True
-                ImageCopy.Start
-                    
-                If Not WaitProgress(ImageCopy) Then GoTo Finish
-                
-                DestinationImage.DisplayParameters.Type = eAimImageDisplayTypeSpectral
-                For C = 0 To DestinationImage.ImageMemory.GetDimensionC - 1
-                    DestinationImage.ImageMemory.DetectionWavelengthStart(C) = (GlobalStartWl + C * GlobalStepWl) * 0.000000001
-                    DestinationImage.ImageMemory.DetectionWavelengthEnd(C) = (GlobalStartWl + C * GlobalStepWl) * 0.000000001
-'                    DestinationImage.DisplayParameters.ChannelInformation.ChannelColor(C) = RGB(255, 255, 255)
-                    DestinationImage.DisplayParameters.ChannelInformation.ChannelName(C) = CStr((GlobalStartWl + C * GlobalStepWl) + GlobalStepWl / 2)
-                    
-                Next C
-            End If
-        End If
-'        DestinationImageDocument.RedrawImage
-    End If
-
-Finish:
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-End Sub
-
-
-Private Sub DoMakeTimeSeries()
-
-    Dim SourceImageDocument As AimExperimentTreeNode
-    Dim DestinationImageDocument As AimExperimentTreeNode
-'    Dim DestinationImageDocument As RecordingDocument
-    
-    Dim SourceImage As AimImage
-    Dim DestinationImage As AimImage
-    Dim ImageCopy As AimImageCopy
-    Dim T As Long
-
-On Error GoTo Finish
-
-    flgBreak = False
-    User_flg = False
-'    Set SourceImage = Lsm5.CreateObject("AimImage.Image")
-'    Set SourceImageDocument = Lsm5.CreateObject("AimExperiment.TreeNode")
-'    Set Import = Lsm5.CreateObject("AimImageImportExport.Import")
-    Set ImageCopy = Lsm5.CreateObject("AimImageProcessing.Copy")
-
-    If LoadSourceImage(SourceImageDocument, SourceImage, ImagesListBox.ListIndex) Then
-    
-        If SourceImage.ImageMemory.GetDimensionT > 1 Then
-            MsgBox "This is Time Series Image! Use Single Image!"
-            GoTo Finish
-        End If
-        
-        TimeNumberChange = False
-        NumOfTimes.Show 1
-        
-        If TimeNumberChange Then
-            If Not MakeDestination(DestinationImageDocument, _
-                                   DestinationImage, _
-                                   SourceImage.ImageMemory.GetDimensionX, _
-                                   SourceImage.ImageMemory.GetDimensionY, _
-                                   1, _
-                                   GlobalNumberOfStacks, _
-                                   SourceImage.ImageMemory.GetDimensionC, _
-                                   SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-'            If Not MakeDestinationDS(DestinationImageDocument, _
-'                                   DestinationImage, _
-'                                   SourceImage.ImageMemory.GetDimensionX, _
-'                                   SourceImage.ImageMemory.GetDimensionY, _
-'                                   1, _
-'                                   1, _
-'                                   SourceImage.ImageMemory.GetDimensionC, _
-'                                   SourceImage.ImageMemory.GetDataType(0)) Then GoTo Finish
-                                   
-            ImageCopy.SourceImage = SourceImage
-            ImageCopy.DestinationImage = DestinationImage
-            ImageCopy.ImageParameterCopyFlags = eAimImageParameterCopyAll - eAimImageParameterCopyDisplayType
-'            ImageCopy.SourceStrideT = 0
-'            ImageCopy.SizeT = GlobalNumberOfStacks
-            
-            ImageCopy.SourceStride(eAimImageOperationCoordinateT) = 1
-            ImageCopy.Size(eAimImageOperationCoordinateT) = 1 'GlobalNumberOfStacks
-            ImageCopy.SourceStart(eAimImageOperationCoordinateT) = 0
-            
-            ImageCopy.CreateDestinationMemory eAimImageDataTypeInvalid, _
-                                            False
-            For T = 1 To GlobalNumberOfStacks
-                ImageCopy.DestinationStart(eAimImageOperationCoordinateT) = T - 1
-                ImageCopy.Start
-                If Not WaitProgress(ImageCopy) Then GoTo Finish
-            Next T
-            For T = 0 To GlobalNumberOfStacks - 1
-                DestinationImage.ImageMemory.TimeStamp(T) = DestinationImage.ImageMemory.TimeStamp(0) + T * GlobalTimeIntv
-            Next T
-                
-            If Not WaitProgress(ImageCopy) Then GoTo Finish
-        End If
-    End If
-    
-Finish:
-
-    flgBreak = False
-    DisplayProgress "Ready", RGB(&HC0, &HC0, 0)
-    User_flg = True
-    
-End Sub
-
-Public Sub DisplayProgress(state As String, Color As Long)
-    If (Color & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Then
-        ProgressLabel.ForeColor = 0
-    Else
-        ProgressLabel.ForeColor = &HFFFFFF
-    End If
-    ProgressLabel.BackColor = Color
-    ProgressLabel.Caption = state
-    DoEvents
-End Sub
-
-Public Sub GetPureName(Path As String, Name As String)
-
-    Dim pos As Integer
-    Dim Start As Integer
-    Dim bslash As String
-    Dim lngth As String
-    Dim dot As String
-    Dim tmpName As String
-    
-        Start = 1
-        bslash = "\"
-        dot = "."
-        pos = Start
-        Do While pos > 0
-            pos = InStr(Start, Path, bslash)
-            If pos > 0 Then
-                Start = pos + 1
-            End If
-        Loop
-        lngth = Strings.Len(Path)
-        tmpName = Strings.Right(Path, lngth - Start + 1)
-        Start = 1
-        pos = Start
-        Do While pos > 0
-            pos = InStr(Start, tmpName, dot)
-            If pos > 0 Then
-                Start = pos + 1
-            End If
-        Loop
-        Name = Strings.Left(tmpName, Start - 2)
-        
-    End Sub
-
-Public Function LoadWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Left = Lsm5.tools.RegLongValue(PosKey, "Left")
-    Top = Lsm5.tools.RegLongValue(PosKey, "Top")
-    If Left < 1 Then Left = 0
-    If Top < 1 Then Top = 0
-    
-    If Left = 0 And Top = 0 Then
-                'Center frm
-                Left = 300
-                Top = 300
-'    SaveWindowPosition
-                Exit Function
-    End If
-End Function
-
-
-
-Public Sub SaveWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Lsm5.tools.RegLongValue(PosKey, "Left") = CInt(Left)
-    Lsm5.tools.RegLongValue(PosKey, "Top") = CInt(Top)
-End Sub
-
-
-
-
-
-' m1tle mitosys modification
-Private Sub SelectLocationTextBox_Change()
-    EnsureOnlyNumbers
-End Sub
-
-' m1tle mitosys modification
-Private Sub EnsureOnlyNumbers()
-    If TypeName(Me.ActiveControl) = "TextBox" Then
-        With Me.ActiveControl
-            If Not IsNumeric(.Value) And .Value <> vbNullString Then
-                MsgBox "Sorry, only numbers allowed"
-                .Value = vbNullString
-            End If
-        End With
-    End If
-End Sub
-
-' m1tle mitosys modification
-Private Sub SelectLocationButton_Click()
-    SelectLocation (Val(SelectLocationTextBox.Text))
-End Sub
-
-Private Sub SelectLocation(loc As Integer)
-    Dim indexL As Integer
-    Dim indexL2 As Integer
-    Dim index As Integer
-    For index = 0 To ImagesListBox.ListCount - 1
-        indexL = InStr(1, ImagesListBox.list(index, 0), "_L")
-        indexL2 = InStr(indexL + 1, ImagesListBox.list(index, 0), "_")
-        ImagesListBox.Selected(index) = False
-        If Not ((indexL = 0) Or (indexL2 = 0)) Then
-            If loc = Val(Mid(ImagesListBox.list(index, 0), indexL + 2, indexL2 - indexL - 2)) Then
-                ImagesListBox.Selected(index) = True
-            End If
-        End If
-    Next index
-End Sub
-
-' m1tle mitosys modification
-Private Sub ConcatenateTimePerLocationButton_Click()
-    ' find minimum and maximum location number
-    Dim minLoc As Integer
-    Dim maxLoc As Integer
-    Dim locVal As Integer
-    Dim indexL As Integer
-    Dim indexL2 As Integer
-    minLoc = 10000
-    maxLoc = -1
-    Dim outputfile As String
-    Dim filename As String
-    
-    Dim index As Integer
-    For index = 0 To ImagesListBox.ListCount - 1
-        indexL = InStr(1, ImagesListBox.list(index, 0), "_L")
-        indexL2 = InStr(indexL + 1, ImagesListBox.list(index, 0), "_")
-        If Not ((indexL = 0) Or (indexL2 = 0)) Then
-            locVal = Val(Mid(ImagesListBox.list(index, 0), indexL + 2, indexL2 - indexL - 2))
-            If locVal < minLoc Then
-                minLoc = locVal
-            End If
-            If locVal > maxLoc Then
-                maxLoc = locVal
-            End If
-        End If
-    Next index
-    
-    If (minLoc = 100000) Or (maxLoc = -1) Then
-        MsgBox ("No minimum and maximum location numbers found in filenames!")
-    End If
-        
-    outputfile = FileNameTextBox & OutputFilenameBox
-    If (Len(outputfile) < 4) Or (Not (Right(outputfile, 4) = ".lsm")) Then
-        outputfile = outputfile & ".lsm"
-    End If
-    
-    filename = Left(outputfile, Len(outputfile) - 4)
-    
-    For index = minLoc To maxLoc
-        outputfile = filename & "_L" & CStr(index) & ".lsm"
-        SelectLocation (index)
-        DoConcatenate_Time
-        SaveDsRecordingDoc Lsm5.DsRecordingActiveDocObject, outputfile
-    Next index
-    
-End Sub
-
-
-' Copied and adapted from MultiTimeSeries macro
-Public Function SaveDsRecordingDoc(Document As DsRecordingDoc, filename As String) As Boolean
-    Dim Export As AimImageExport
-    Dim Image As AimImageMemory
-    Dim Error As AimError
-    Dim Planes As Long
-    Dim Plane As Long
-    Dim Horizontal As enumAimImportExportCoordinate
-    Dim Vertical As enumAimImportExportCoordinate
-
-    On Error GoTo Done
-
-    'Set Image = EngelImageToHechtImage(Document).Image(0, True)
-    If Not Document Is Nothing Then
-        Set Image = Document.RecordingDocument.Image(0, True)
-    End If
-    
-    Set Export = Lsm5.CreateObject("AimImageImportExport.Export.4.5")
-'    Set Export = New AimImageExport
-    Export.filename = filename
-    Export.Format = eAimExportFormatLsm5
-    Export.StartExport Image, Image
-    Set Error = Export
-    Error.LastErrorMessage
-    
-    Planes = 1
-    Export.GetPlaneDimensions Horizontal, Vertical
-    
-    Select Case Vertical
-        Case eAimImportExportCoordinateY:
-             Planes = Image.GetDimensionZ * Image.GetDimensionT
-        Case eAimImportExportCoordinateZ:
-            Planes = Image.GetDimensionT
-    End Select
-    
-    For Plane = 0 To Planes - 1
-        DoEvents
-        Export.ExportPlane Nothing
-    Next Plane
-    Export.FinishExport
-    SaveDsRecordingDoc = True
-    Exit Function
-Done:
-    MsgBox "Check Temporary Files Folder! Cannot Save Temporary File(s)!"
-    SaveDsRecordingDoc = False
-    Export.FinishExport
-    
-End Function
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/FileHandling.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/FileHandling.bas
deleted file mode 100644
index 90cd3a6..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/FileHandling.bas
+++ /dev/null
@@ -1,267 +0,0 @@
-Attribute VB_Name = "FileHandling"
-Option Explicit
-Public Const INVALID_HANDLE_VALUE = -1
-Public Const MAX_PATH = 260
-Public Const OFN_FILEMUSTEXIST = &H1000
-Public Const OFN_HIDEREADONLY = &H4
-Public Const OFN_PATHMUSTEXIST = &H800
-Public Const OFN_OVERWRITEPROMPT = &H2
-
-Public Type OPENFILENAME
-    lStructSize As Long
-    hwndOwner As Long
-    hInstance As Long
-    lpstrFilter As String
-    lpstrCustomFilter As String
-    nMaxCustomFilter As Long
-    nFilterIndex As Long
-    lpstrFile As String
-    nMaxFile As Long
-    lpstrFileTitle As String
-    nMaxFileTitle As Long
-    lpstrInitialDir As String
-    lpstrTitle As String
-    FLAGS As Long
-    nFileOffset As Integer
-    nFileExtension As Integer
-    lpstrDefExt As String
-    lCustData As Long
-    lpfnHook As Long
-    lpTemplateName As String
-End Type
-
-Public Type BROWSEINFO
-    hwndOwner As Long
-    lpRoot As Long
-    lpstrDirectory As String
-    lpstrTitle As String
-    ilFlags As Long
-    lpCallback As Long
-    lParam As Long
-    iImage As Long
-End Type
-    
-Public Type FILETIME
-        dwLowDateTime As Long
-        dwHighDateTime As Long
-End Type
-
-Public Type WIN32_FIND_DATA
-        dwFileAttributes As Long
-        ftCreationTime As FILETIME
-        ftLastAccessTime As FILETIME
-        ftLastWriteTime As FILETIME
-        nFileSizeHigh As Long
-        nFileSizeLow As Long
-        dwReserved0 As Long
-        dwReserved1 As Long
-        cFileName As String * MAX_PATH
-        cAlternate As String * 14
-End Type
-
-Public Declare Function SHBrowseForFolder Lib "shell32.dll" Alias "SHBrowseForFolderA" (lpBi As BROWSEINFO) As Long
-Public Declare Function SHGetPathFromIDList Lib "shell32.dll" Alias "SHGetPathFromIDListA" (ByVal list As Long, ByVal lpPath As String) As Long
-Public Declare Function FindFirstFile Lib "kernel32" Alias "FindFirstFileA" (ByVal lpFileName As String, lpFindFileData As WIN32_FIND_DATA) As Long
-Public Declare Function FindNextFile Lib "kernel32" Alias "FindNextFileA" (ByVal hFindFile As Long, lpFindFileData As WIN32_FIND_DATA) As Long
-Public Declare Function FindClose Lib "kernel32" (ByVal hFindFile As Long) As Long
-Public Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (lpofn As OPENFILENAME) As Long
-Public Declare Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (lpofn As OPENFILENAME) As Long
-Public Declare Function GetFocus Lib "user32" () As Long
-
-
-Public Function OpenFileNameBox(Name As String, FileType As String, FileExtension As String) As Boolean
-    Dim filebox As OPENFILENAME
-    Dim result As Long
-    Dim Directory As String
-    Dim index As String
-    
-    OpenFileNameBox = False
-    On Error GoTo ErrorExit
-    
-    Directory = CurDir
-    If Len(Directory) > 0 Then
-        If Not Right(Directory, 1) = "\" Then
-            Directory = Directory + "\"
-        End If
-    End If
-    Name = Directory + Name
-    
-    With filebox
-        .lStructSize = Len(filebox)
-        .hwndOwner = GetFocus
-        .hInstance = 0
-        If FileType = "" Then
-            .lpstrFilter = "All Files (*.*)" & vbNullChar & "*.*" & vbNullChar & vbNullChar
-        Else
-            .lpstrFilter = FileType + " (" + FileExtension + ")" + vbNullChar + FileExtension + vbNullChar _
-                           + "All Files (*.*)" + vbNullChar + "*.*" + vbNullChar & vbNullChar
-        End If
-        .nMaxCustomFilter = 0
-        .nFilterIndex = 1
-        .lpstrFile = Name + Space(256) & vbNullChar
-        .nMaxFile = Len(.lpstrFile)
-        .lpstrFileTitle = Space(256) & vbNullChar
-        .nMaxFileTitle = Len(.lpstrFileTitle)
-        .lpstrInitialDir = vbNullChar
-        .lpstrTitle = "Open" & vbNullChar
-        .FLAGS = OFN_PATHMUSTEXIST Or OFN_FILEMUSTEXIST Or OFN_HIDEREADONLY
-        .nFileOffset = 0
-        .nFileExtension = 0
-        .lCustData = 0
-        .lpfnHook = 0
-    End With
-    
-    result = GetOpenFileName(filebox)
-    OpenFileNameBox = result <> 0
-    If result <> 0 Then
-        Name = VBA.Left(filebox.lpstrFile, InStr(filebox.lpstrFile, vbNullChar) - 1)
-        Directory = Name
-        index = Len(Directory)
-        Do While index > 0
-            If Mid(Directory, index, 1) = "\" Then Exit Do
-            If Mid(Directory, index, 1) = ":" Then Exit Do
-            index = index - 1
-        Loop
-        If index > 0 Then
-            Directory = Left(Directory, index)
-            ChDir Directory
-        End If
-    End If
-ErrorExit:
-End Function
-
-Public Function SaveFileNameBox(Name As String, FileType As String, FileExtension As String) As Boolean
-    Dim filebox As OPENFILENAME  ' open file dialog structure
-    Dim result As Long           ' result of opening the dialog
-    
-    With filebox
-        .lStructSize = Len(filebox)
-            .hwndOwner = 0 'Me.hWnd
-        .hInstance = 0
-        If FileType = "" Then
-            .lpstrFilter = "All Files (*.*)" & vbNullChar & "*.*" & vbNullChar & vbNullChar
-        Else
-            .lpstrFilter = FileType + " (" + FileExtension + ")" + vbNullChar + FileExtension + vbNullChar _
-                           + "All Files (*.*)" + vbNullChar + "*.*" + vbNullChar & vbNullChar
-        End If
-                
-        .nMaxCustomFilter = 0
-        .nFilterIndex = 1
-        .lpstrFile = Name + Space(256) & vbNullChar
-        .nMaxFile = Len(.lpstrFile)
-        .lpstrFileTitle = Space(256) & vbNullChar
-        .nMaxFileTitle = Len(.lpstrFileTitle)
-        .lpstrInitialDir = vbNullChar
-        .lpstrTitle = "Save" & vbNullChar
-        .FLAGS = OFN_OVERWRITEPROMPT Or OFN_HIDEREADONLY
-        .nFileOffset = 0
-        .nFileExtension = 0
-        .lCustData = 0
-        .lpfnHook = 0
-    End With
-    
-    result = GetSaveFileName(filebox)
-    SaveFileNameBox = result <> 0
-    If result <> 0 Then
-        Name = VBA.Left(filebox.lpstrFile, InStr(filebox.lpstrFile, vbNullChar) - 1)
-    End If
-End Function
-
-Public Function BrowseForFolder(Name As String, Title As String) As Boolean
-    Dim bi As BROWSEINFO
-    Dim result As Long
-    Dim Directory As String
-    Dim index As String
-    Dim NewName As String
-    
-    BrowseForFolder = False
-    On Error GoTo ErrorExit
-    
-    If Len(Name) > 0 Then
-        NewName = Name
-        ChDir NewName
-    Else
-        Directory = CurDir
-        If Len(Directory) > 0 Then
-            If Not Right(Directory, 1) = "\" Then
-                Directory = Directory + "\"
-            End If
-        End If
-        NewName = Directory + Name
-    End If
-    
-    bi.hwndOwner = GetFocus
-    bi.lpRoot = 0
-    bi.lpstrDirectory = NewName + Space(4096) & vbNullChar
-    bi.lpstrTitle = Title
-    bi.ilFlags = 0
-    bi.lpCallback = 0
-    bi.lParam = 0
-    bi.iImage = 0
-    
-    result = SHBrowseForFolder(bi)
-    If result <> 0 Then
-        NewName = Space(4096) & vbNull
-        If SHGetPathFromIDList(result, NewName) Then
-            
-            Directory = VBA.Left(NewName, InStr(NewName, vbNullChar) - 1)
-            Name = Directory
-            index = Len(Directory)
-            Do While index > 0
-                If Mid(Directory, index, 1) = "\" Then Exit Do
-                If Mid(Directory, index, 1) = ":" Then Exit Do
-                index = index - 1
-            Loop
-            If index > 0 Then
-                ChDir Directory
-            End If
-            BrowseForFolder = True
-        End If
-    End If
-ErrorExit:
-End Function
-
-Public Function ListFiles(Files() As String, PathNames() As String, NumberFiles As Long, Directory As String, Mask As String) As Boolean
-
-    Dim FindData As WIN32_FIND_DATA
-    Dim Path As String
-    Dim PathWithMask As String
-    Dim Name As String
-    Dim Handle As Long
-    Dim index As Long
-    
-    ListFiles = False
-    
-    ReDim Files(0)
-    ReDim PathNames(0)
-    NumberFiles = 0
-    
-    Path = Directory
-    If Len(Path) > 0 Then
-        If Not Right(Path, 1) = "\" Then
-            Path = Path + "\"
-        End If
-    End If
-    PathWithMask = Path + Mask
-    
-    index = 0
-    Handle = FindFirstFile(PathWithMask, FindData)
-    If Handle = INVALID_HANDLE_VALUE Then
-        ListFiles = True
-        Exit Function
-    End If
-
-    Do
-        NumberFiles = NumberFiles + 1
-        ReDim Preserve Files(NumberFiles + 1)
-        ReDim Preserve PathNames(NumberFiles + 1)
-        Name = FindData.cFileName
-        Name = VBA.Left(Name, InStr(Name, vbNullChar) - 1)
-        Files(NumberFiles - 1) = Name
-        PathNames(NumberFiles - 1) = Path + Name
-    Loop While FindNextFile(Handle, FindData)
-    FindClose Handle
-    
-    ListFiles = True
-End Function
-
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ModuleUtilities.bas b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ModuleUtilities.bas
deleted file mode 100644
index 8452797..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ModuleUtilities.bas
+++ /dev/null
@@ -1,1883 +0,0 @@
-Attribute VB_Name = "ModuleUtilities"
-Option Explicit
-
-Public Const WM_COMMAND = &H111
-
-Public Const VK_SPACE = &H20
-Public Const VK_RETURN = &HD
-Public Const VK_CANCEL = &H3
-Public Const VK_UP = &H26
-Public Const VK_DOWN = &H28
-Public Const VK_ESCAPE = &H1B
-Public Const VK_PAUSE = &H13
-Public Const VK_ADD = &H6B
-Public Const VK_SUBTRACT = &H6D
-Public Const HKEY_CLASSES_ROOT = &H80000000
-Public Const SYNCHRONIZE = &H100000
-Public Const READ_CONTROL = &H20000
-Public Const STANDARD_RIGHTS_READ = (READ_CONTROL)
-Public Const KEY_QUERY_VALUE = &H1
-Public Const KEY_ENUMERATE_SUB_KEYS = &H8
-Public Const KEY_NOTIFY = &H10
-Public Const KEY_READ = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
-
-Public Const REG_SZ = 1                         ' Unicode nul terminated string
-
-
-Public Const OFS_MAXPATHNAME = 128
-Public Const OF_EXIST = &H4000
-
-Public Const ERROR_SUCCESS = 0&
-
-Public Const vbOKOnly = 0   '  Display OK button only.
-Public Const VbOKCancel = 1 '  Display OK and Cancel buttons.
-Public Const VbAbortRetryIgnore = 2  ' Display Abort, Retry, and Ignore buttons.
-Public Const VbYesNoCancel = 3  '  Display Yes, No, and Cancel buttons.
-Public Const VbYesNo = 4 '  Display Yes and No buttons.
-Public Const VbRetryCancel = 5   ' Display Retry and Cancel buttons.
-Public Const VbCritical = 16 ' Display Critical Message icon.
-Public Const VbQuestion = 32 ' Display Warning Query icon.
-Public Const VbExclamation = 48  ' Display Warning Message icon.
-Public Const VbInformation = 64  ' Display Information Message icon.
-Public Const VbDefaultButton1 = 0    ' First button is default.
-Public Const VbDefaultButton2 = 256  ' Second button is default.
-Public Const VbDefaultButton3 = 512  ' Third button is default.
-Public Const VbDefaultButton4 = 768   'Fourth button is default.
-Public Const VbApplicationModal = 0  ' Application modal; the user must respond to the message box before continuing work in the current application.
-Public Const VbSystemModal = 4096   '  System modal; all applications are suspended until the user responds to the message box.
-'The first group of values (05) describes the number and type of buttons displayed in the dialog box; the second group (16, 32, 48, 64) describes the icon style; the third group (0, 256, 512) determines which button is the default; and the fourth group (0, 4096) determines the modality of the message box. When adding numbers to create a final value for the buttons argument, use only one number from each group.
-
-'Note   These constants are specified by Visual Basic for Applications. As a result, the names can be used anywhere in your code in place of the actual values.
-
-'Return Values
-Public Const vbOK = 1   '  OK
-Public Const vbCancel = 2    ' Cancel
-Public Const vbAbort = 3 ' Abort
-Public Const vbRetry = 4 '  Retry
-Public Const vbIgnore = 5   '  Ignore
-Public Const vbYes = 6  '  Yes
-Public Const vbNo = 7    ' No
-
-Public Const eEventFocus = 5
-Public Const eEventStage = 6
-
-Public Const eEventUpdate = 25
-
-
-Public GlobalSystemVersion As Long
-Public GlobalMacroVersion As String
-
-Public GlobalPath As String
-Public GlobalMacrosPath As String
-
-Public GlobalProjectName As String
-Public GlobalHelpName As String
-Public GlobalHelpNamePDF As String
-Public GlobalHelpName1 As String
-Public GlobalHelpNamePDF1 As String
-Public GlobalHelpName2 As String
-Public GlobalHelpNamePDF2 As String
-Public GlobalHelpName3 As String
-Public GlobalHelpNamePDF3 As String
-Public GlobalHelpName4 As String
-Public GlobalHelpNamePDF4 As String
-Public GlobalHelpName5 As String
-Public GlobalHelpNamePDF5 As String
-Public GlobalHelpName6 As String
-Public GlobalHelpNamePDF6 As String
-Public GlobalHelpName7 As String
-Public GlobalHelpNamePDF7 As String
-Public GlobalHelpName8 As String
-Public GlobalHelpNamePDF8 As String
-Public GlobalHelpName9 As String
-Public GlobalHelpNamePDF9 As String
-Public GlobalHelpName10 As String
-Public GlobalHelpNamePDF10 As String
-Public GlobalHelpName11 As String
-Public GlobalHelpNamePDF11 As String
-Public GlobalHelpName12 As String
-Public GlobalHelpNamePDF12 As String
-Public GlobalHelpName14 As String
-Public GlobalHelpNamePDF14 As String
-Public GlobalHelpNamePDF15 As String
-Public GlobalHelpName15 As String
-
-Public GlobalHelpNamePDF16 As String
-Public GlobalHelpNamePDF17 As String
-Public GlobalHelpNamePDF18 As String
-Public GlobalHelpNamePDF19 As String
-Public GlobalHelpNamePDF20 As String
-Public GlobalHelpNamePDF21 As String
-Public GlobalHelpNamePDF22 As String
-Public GlobalHelpNamePDF23 As String
-Public GlobalHelpNamePDF24 As String
-Public GlobalHelpNamePDF25 As String
-Public GlobalHelpNamePDF26 As String
-Public GlobalHelpNamePDF27 As String
-Public GlobalHelpNamePDF28 As String
-Public GlobalHelpNamePDF29 As String
-Public GlobalHelpNamePDF30 As String
-
-Public GlobalErrorFile As String
-Public GlobalTimelineFile As String
-
-Public GlobalHelpNameScale As String
-Public GlobalMacroKey As String
-
-Public GlobalAutoStoreKey As String
-
-Public GlobalIsStage As Boolean
-Public tools As Lsm5Tools
-Public Stage As CpStages
-Public GlobalOptions As Lsm5Options
-
-Public ScanInterrupt As Boolean
-
-Public flgUserChange As Boolean
-Public User_flg As Boolean
-
-Public flgEvent As Integer
-
-Public GlobalIsFRET As Boolean
-Public GlobalPi As Double
-
-Public GlobalProgressString As String
-Public GlobalColor As Long
-
-Public GlobalRecallLocations As Boolean
-
-Public GlobalSampleObservationTime(13) As Double
-Public GlobalIsDSP As Boolean
-
-Public GlobalStageCounter As Long
-Public GlobalStageText As String
-
-Public GlobalSystemGroup As String
-Public GlobalIsDuo As Boolean
-
-Public X11 As Double
-Public X12 As Double
-Public X21 As Double
-Public X22 As Double
-
-Public Type OFSTRUCT
-        cBytes As Byte
-        fFixedDisk As Byte
-        nErrCode As Integer
-        Reserved1 As Integer
-        Reserved2 As Integer
-        szPathName(OFS_MAXPATHNAME) As Byte
-End Type
-Public Type OVERLAPPED
-        Internal As Long
-        InternalHigh As Long
-        Offset As Long
-        OffsetHigh As Long
-        hEvent As Long
-End Type
-Public Type SECURITY_ATTRIBUTES
-        nLength As Long
-        lpSecurityDescriptor As Long
-        bInheritHandle As Long
-End Type
-
-
-Public Declare Function OpenFile Lib "kernel32" (ByVal lpFileName As String, lpReOpenBuff As OFSTRUCT, _
-ByVal wStyle As Long) As Long
-
-Public Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
-
-Public Declare Function DeleteFile Lib "kernel32" Alias "DeleteFileA" (ByVal lpFileName As String) As Long
-
-Public Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" _
-(ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, _
-lpNumberOfFreeClusters As Long, lpTotalNumberOfClusters As Long) As Long
-
-
-
-Public Declare Function GetTickCount Lib "kernel32" () As Long
-Public Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
-Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
-Public Declare Function RegOpenKeyEx _
-    Lib "advapi32.dll" Alias "RegOpenKeyExA" _
-    (ByVal hKey As Long, ByVal lpSubKey As String, _
-    ByVal ulOptions As Long, ByVal samDesired As Long, _
-    phkResult As Long) As Long
-
-Public Declare Function RegCloseKey _
-    Lib "advapi32.dll" (ByVal hKey As Long) As Long
-
-Public Declare Function RegQueryValueEx _
-    Lib "advapi32.dll" Alias "RegQueryValueExA" _
-    (ByVal hKey As Long, ByVal lpValueName As String, _
-    ByVal lpReserved As Long, lpType As Long, _
-    lpData As Any, lpcbData As Long) As Long         ' Note that if you declare the lpData parameter as String, you must pass it By Value.
-    
-Public Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
-Public Declare Function QueryPerformanceCounter Lib "kernel32" (lpPerformanceCount As Any) As Long
-Public Declare Function QueryPerformanceFrequency Lib "kernel32" (lpFrequency As Any) As Long
-Public Declare Function GetModuleHandle Lib "kernel32" (ByVal lpModuleName As String) As Long
-Public Declare Function SetWindowLong Lib "user32" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
-Public Const GWL_EXSTYLE = (-20)
-Public Const WS_EX_TOPMOST = &H8&
-
-Public Const SWP_NOMOVE = 2
-Public Const SWP_NOSIZE = 1
-Public Const FLAGS = SWP_NOMOVE Or SWP_NOSIZE
-Public Const HWND_TOPMOST = -1
-Public Const HWND_NOTOPMOST = -2
-
-Public Declare Function SetWindowPos Lib "user32" _
-      (ByVal hwnd As Long, _
-      ByVal hWndInsertAfter As Long, _
-      ByVal x As Long, _
-      ByVal y As Long, _
-      ByVal cx As Long, _
-      ByVal cy As Long, _
-      ByVal wFlags As Long) As Long
-      
-Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
-
-Public Function SetTopMostWindow(hwnd As Long, Topmost As Boolean) _
-   As Long
-
-   If Topmost = True Then 'Make the window topmost
-      SetTopMostWindow = SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, _
-         0, FLAGS)
-   Else
-      SetTopMostWindow = SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, _
-         0, 0, FLAGS)
-      SetTopMostWindow = False
-   End If
-End Function
-
-
-
-Public Sub BleachROI()
-
-'The first example generates a rectangular region and bleaches this region.
-
-    Dim Left As Long
-    Dim Right As Long
-    Dim Top As Long
-    Dim Bottom As Long
-    Dim Width As Long
-    Dim Height As Long
-    Dim Row As Long
-    Dim Column As Long
-    Dim BytesPerRow As Long
-
-'The bleach rectangle
-
-    Left = 10
-    Top = 10
-    Width = 100
-    Height = 100
-
-' 32-bit alignment
-    BytesPerRow = ((Width + 31) / 32) * 4
-
-'Generate the bitmask memory
-    Dim Mask() As Byte
-    ReDim Mask(BytesPerRow * Height)
-    
-'Fill the bitmask
-    For Row = 0 To Height - 1
-    For Column = 0 To BytesPerRow - 1
-    Mask(Row * BytesPerRow + Column) = 255
-    Next Column
-    Next Row
-
-'Transfer the bitmask to the scan-controller
-    Lsm5.ExternalCpObject.pHardwareObjects.pScanController.SetBleachRoi _
-Left, Top, Width, Height, CVar(Mask)
-
-'Start the bleach - Use the scan-controller and not "Lsm5.Bleach" cause
-'the latter would overwrite the region with the
-'region currently stored in the "DS" - The first argument has no meaning.
-'The second argument must be "0".
-
-    Lsm5.ExternalCpObject.pHardwareObjects.pScanController.Bleach 0, 0
-
-End Sub
-
-
-Public Sub ReadMask()
-
-'The second example uses the region from the vector overlay. The vector
-'overlay returns a mask with one byte per
-'pixel. One has to convert to the format "one bit per pixel" which the
-'scan-controller accepts.
-
-    Dim IndexSource As Long
-    Dim IndexDestination As Long
-    Dim MaskByte As Byte
-    Dim Factor As Long
-    Dim Left As Long
-    Dim Top As Long
-    Dim Right As Long
-    Dim Bottom As Long
-    Dim Width As Long
-    Dim Height As Long
-    Dim MaskSource() As Byte
-    Dim BytesPerRow As Long
-    Dim Row As Long
-    Dim Column As Long
-'Get current overlay mask
-    MaskSource(0) = _
-Lsm5.DsRecordingActiveDocObject.VectorOverlay.MakeRoiMask(Left, Top, _
-Right, Bottom, 0, 0, Lsm5.DsRecordingActiveDocObject.GetDimensionX, _
-Lsm5.DsRecordingActiveDocObject.GetDimensionY, 1)
-
-    Width = Right - Left
-    Height = Bottom - Top
-'32 bit alignment (scan controller wants it - but vector overlay mask
-' requires no special aligment)
-    BytesPerRow = ((Width + 31) / 32) * 4
-
-'Create memory for the bitmask
-    Dim MaskDestination() As Byte
-    ReDim MaskDestination(BytesPerRow * Height)
-       
-'Convert One-byte-per-pixel to One-bit-per-pixel
-
-    IndexSource = 0
-    IndexDestination = 0
-    For Row = 0 To Height - 1
-        Factor = 1
-        MaskByte = 0
-        For Column = 0 To Width - 1
-            MaskByte = MaskByte + Factor * MaskSource(IndexSource)
-            IndexSource = IndexSource + 1
-            Factor = Factor * 2
-            If (Factor > 255) Then
-                MaskDestination(IndexDestination) = MaskByte
-                IndexDestination = IndexDestination + 1
-                Factor = 1
-                MaskByte = 0
-            End If
-        Next Column
-        If (Factor > 1) Then
-            MaskDestination(IndexDestination) = MaskByte
-            IndexDestination = IndexDestination + 1
-        End If
-    Next Row
-
-'Transfer the bitmask to the scan-controller
-    Lsm5.ExternalCpObject.pHardwareObjects.pScanController.SetBleachRoi _
-Left, Top, Width, Height, CVar(MaskDestination)
-
-'Start the bleach
-    Lsm5.ExternalCpObject.pHardwareObjects.pScanController.Bleach 0, 0
-    
-End Sub
-    
-Public Sub DisplayHelp(HelpNamePDF As String, HelpName As String)
-    Dim dblTask As Double
-    Dim MacroPath As String
-    Dim MyPath As String
-    Dim MyPathPDF As String
-    
-    Dim bslash As String
-    Dim Success As Integer
-    Dim pos As Integer
-    Dim Start As Integer
-    Dim Count As Long
-    Dim ProjName As String
-    Dim indx As Integer
-    Dim AcrobatObject As Object
-    Dim AcrobatViewer As Object
-    Dim OK As Boolean
-    Dim StrPath As String
-    Dim ExecName As String
-    
-    Count = ProjectCount()
-    For indx = 0 To Count - 1
-        MacroPath = ProjectPath(indx, Success)
-        ProjName = ProjectTitle(indx, Success)
-        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, MacroPath, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            MyPath = Strings.Left(MacroPath, Start - 1)
-            MyPathPDF = MyPath + HelpNamePDF
-            MyPath = MyPath + HelpName
-            OK = False
-            On Error GoTo RTFhelp
-            OK = FServerFromDescription("AcroExch.Document", StrPath, ExecName)
-            dblTask = Shell(ExecName + " " + MyPathPDF, vbNormalFocus)
-            
-'            Set AcrobatViewer = CreateObject("AcroExch.app")
-'            If Not AcrobatViewer Is Nothing Then
-'                Set AcrobatObject = CreateObject("AcroExch.AVDoc")
-'                If Not AcrobatObject Is Nothing Then
-'                    OK = AcrobatViewer.Show
-'                    If OK Then
-'                        OK = AcrobatObject.Open(MyPathPDF, MyPathPDF)
-'                    End If
-'                Else
-'                    OK = False
-'                End If
-'            Else
-'                OK = False
-'            End If
-RTFhelp:
-            If Not OK Then
-                MsgBox "Install Acrobat Viewer!"
-'                dblTask = Shell("C:\Program Files\Windows NT\Accessories\wordpad.exe " + MyPath, vbNormalFocus)
-            End If
-            Exit For
-        End If
-    Next indx
-End Sub
-
-    
-    
-Function FServerFromDescription(strName As String, StrPath As String, ExecName As String) As Boolean
-    Dim lngResult As Long
-    Dim strTmp As String
-    Dim hKeyServer As Long
-    Dim strBuffer As String
-    Dim cb As Long
-    Dim i As Integer
-    
-    FServerFromDescription = False
-    
-    strTmp = VBA.Space(255)
-    strTmp = strName + "\CLSID"
-    lngResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strTmp, 0&, KEY_READ, hKeyServer)
-    
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    strBuffer = VBA.Space(255)
-    cb = Len(strBuffer)
-    
-    lngResult = RegQueryValueEx(hKeyServer, "", 0&, REG_SZ, ByVal strBuffer, cb)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    
-    lngResult = RegCloseKey(hKeyServer)
-    strTmp = VBA.Space(255)
-    strTmp = "CLSID\" + Strings.Left(strBuffer, cb - 1) + "\LocalServer32"
-    strBuffer = VBA.Space(255)
-    cb = Len(strBuffer)
-    lngResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, strTmp, 0&, KEY_READ, hKeyServer)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-        
-    lngResult = RegQueryValueEx(hKeyServer, "", 0&, REG_SZ, ByVal strBuffer, cb)
-    If (Not lngResult = ERROR_SUCCESS) Then GoTo error_exit
-    StrPath = Strings.Left(strBuffer, cb - 1)
-    ExecName = StrPath
-    lngResult = RegCloseKey(hKeyServer)
-    
-    i = Len(StrPath)
-    
-    Do Until (i = 0)
-        If (VBA.Mid(StrPath, i, 1) = "\") Then
-            StrPath = Strings.Left(StrPath, i - 1)
-            FServerFromDescription = True
-            Exit Do
-        End If
-        i = i - 1
-    Loop
-
-error_exit:
-    If (Not hKeyServer = 0) Then lngResult = RegCloseKey(hKeyServer)
-
-End Function
-
-
-Public Sub CopyRecording(destination As DsRecording, Source As DsRecording)
-    Dim Ts As DsTrack
-    Dim Td As DsTrack
-    Dim DataS As DsDataChannel
-    Dim DataD As DsDataChannel
-    Dim DetS As DsDetectionChannel
-    Dim DetD As DsDetectionChannel
-    Dim IlS As DsIlluminationChannel
-    Dim IlD As DsIlluminationChannel
-    Dim BS As DsBeamSplitter
-    Dim BD As DsBeamSplitter
-    Dim lT As Long
-    Dim lI As Long
-    Dim Success As Integer
-   
-    '''''''''''''''''''''''''''start inserted lines
-    destination.Copy Source
-    
-    destination.SpecialScanMode = Source.SpecialScanMode
-    destination.ScanMode = Source.ScanMode
-    
-    For lI = 1 To destination.TrackCount - Source.TrackCount
-        destination.TrackRemove destination.TrackCount - lI
-    Next lI
-    
-    For lI = 1 To destination.LaserCount - Source.LaserCount
-        destination.LaserRemove destination.LaserCount - lI
-    Next lI
-    
-    For lI = 1 To destination.TimersCount - Source.TimersCount
-        destination.TimersRemove destination.TimersCount - lI
-    Next lI
-    
-    For lI = 1 To destination.MarkersCount - Source.MarkersCount
-        destination.MarkersRemove destination.MarkersCount - lI
-    Next lI
-    
-    For lT = 0 To destination.TrackCount - 1
-        If lT < Source.TrackCount Then
-            Set Ts = Source.TrackObjectByIndex(lT, Success)
-            Set Td = destination.TrackObjectByIndex(lT, Success)
-            
-            For lI = 1 To Td.BeamSplitterCount - Ts.BeamSplitterCount
-                Td.BeamSplitterRemove Td.BeamSplitterCount - lI
-            Next lI
-                        
-            For lI = 1 To Td.DataChannelCount - Ts.DataChannelCount
-                Td.DataChannelRemove Td.DataChannelCount - lI
-            Next lI
-            
-            For lI = 1 To Td.DetectionChannelCount - Ts.DetectionChannelCount
-                Td.DetectionChannelRemove Td.DetectionChannelCount - lI
-            Next lI
-            
-            For lI = 1 To Td.IlluminationChannelCount - Ts.IlluminationChannelCount
-                Td.IlluminationChannelRemove Td.IlluminationChannelCount - lI
-            Next lI
-            
-            
-        End If
-    Next lT
-
-   '''''''''''''''''''''''''''end inserted lines
-    If GlobalSystemVersion >= 30 Then
-        NewCopyRecording destination, Source
-    Else
-        OldCopyRecording destination, Source
-    End If
-End Sub
-
-Public Sub NewCopyRecording(destination As DsRecording, Source As DsRecording)
-    Dim Ts As DsTrack
-    Dim Td As DsTrack
-    Dim DataS As DsDataChannel
-    Dim DataD As DsDataChannel
-    Dim DetS As DsDetectionChannel
-    Dim DetD As DsDetectionChannel
-    Dim IlS As DsIlluminationChannel
-    Dim IlD As DsIlluminationChannel
-    Dim BS As DsBeamSplitter
-    Dim BD As DsBeamSplitter
-    Dim lT As Long
-    Dim lI As Long
-    Dim Success As Integer
-    
-        destination.Copy Source
-        For lT = 0 To destination.TrackCount - 1
-        
-            Set Ts = Source.TrackObjectByIndex(lT, Success)
-            Set Td = destination.TrackObjectByIndex(lT, Success)
-            Td.DataChannelCount
-        Next lT
-
-        destination.Objective = Source.Objective
-        For lT = 0 To destination.TrackCount - 1
-        
-            Set Ts = Source.TrackObjectByIndex(lT, Success)
-            Set Td = destination.TrackObjectByIndex(lT, Success)
-            
-            Td.Collimator1Value = Ts.Collimator1Value
-            Td.Collimator2Value = Ts.Collimator2Value
-            Td.SpiCenterWavelength = Ts.SpiCenterWavelength
-            
-            For lI = 0 To Td.DataChannelCount - 1
-                Set DataS = Ts.DataChannelObjectByIndex(lI, Success)
-                Set DataD = Td.DataChannelObjectByIndex(lI, Success)
-'                DataD.ColorRef = DataS.ColorRef
-            Next lI
-            
-            For lI = 0 To Td.DetectionChannelCount - 1
-                Set DetS = Ts.DetectionChannelObjectByIndex(lI, Success)
-                Set DetD = Td.DetectionChannelObjectByIndex(lI, Success)
-                DetD.Filter1 = DetS.Filter1
-                DetD.Filter2 = DetS.Filter2
-                DetD.DetectorGain = DetS.DetectorGain
-                DetD.AmplifierGain = DetS.AmplifierGain
-                DetD.AmplifierOffset = DetS.AmplifierOffset
-                DetD.PinholeDiameter = DetS.PinholeDiameter
-                DetD.DetectorGainABC1 = DetS.DetectorGainABC1
-                DetD.DetectorGainABC2 = DetS.DetectorGainABC2
-                DetD.AmplifierGainABC1 = DetS.AmplifierGainABC1
-                DetD.AmplifierGainABC2 = DetS.AmplifierGainABC2
-                DetD.AmplifierOffsetABC1 = DetS.AmplifierOffsetABC1
-                DetD.AmplifierOffsetABC2 = DetS.AmplifierOffsetABC2
-                DetD.SpiWavelengthStart1 = DetS.SpiWavelengthStart1
-                DetD.SpiWavelengthEnd1 = DetS.SpiWavelengthEnd1
-                DetD.SpiWavelengthStart2 = DetS.SpiWavelengthStart2
-                DetD.SpiWavelengthEnd2 = DetS.SpiWavelengthEnd2
-                DetD.SpiSpectralScanChannels = DetS.SpiSpectralScanChannels
-                
-            Next lI
-            
-            For lI = 0 To Td.IlluminationChannelCount - 1
-                Set IlS = Ts.IlluminationObjectByIndex(lI, Success)
-                Set IlD = Td.IlluminationObjectByIndex(lI, Success)
-                IlD.Acquire = IlS.Acquire
-                IlD.Power = IlS.Power
-                IlD.DetectionChannelName = IlS.DetectionChannelName
-                IlD.PowerABC1 = IlS.PowerABC1
-                IlD.PowerABC2 = IlS.PowerABC2
-            Next lI
-            
-            For lI = 0 To Td.BeamSplitterCount - 1
-                Set BS = Ts.BeamSplitterObjectByIndex(lI, Success)
-                Set BD = Td.BeamSplitterObjectByIndex(lI, Success)
-                If Success Then
-                    BD.Filter = BS.Filter
-                End If
-            Next lI
-            
-        Next lT
-
-End Sub
-
-Public Sub OldCopyRecording(destination As DsRecording, Source As DsRecording)
-    Dim Ts As DsTrack
-    Dim Td As DsTrack
-    Dim DataS As DsDataChannel
-    Dim DataD As DsDataChannel
-    Dim DetS As DsDetectionChannel
-    Dim DetD As DsDetectionChannel
-    Dim IlS As DsIlluminationChannel
-    Dim IlD As DsIlluminationChannel
-    Dim BS As DsBeamSplitter
-    Dim BD As DsBeamSplitter
-    Dim lT As Long
-    Dim lI As Long
-    Dim Success As Integer
-
-        destination.Copy Source
-        destination.Objective = Source.Objective
-        For lT = 0 To destination.TrackCount - 1
-        
-            Set Ts = Source.TrackObjectByIndex(lT, Success)
-            Set Td = destination.TrackObjectByIndex(lT, Success)
-            
-'            TD.Collimator1Position = TS.Collimator1Position
-'            TD.Collimator2Position = TS.Collimator2Position
-            
-            For lI = 0 To Td.DataChannelCount - 1
-                Set DataS = Ts.DataChannelObjectByIndex(lI, Success)
-                Set DataD = Td.DataChannelObjectByIndex(lI, Success)
-                DataD.ColorRef = DataS.ColorRef
-            Next lI
-            
-            For lI = 0 To Td.DetectionChannelCount - 1
-                Set DetS = Ts.DetectionChannelObjectByIndex(lI, Success)
-                Set DetD = Td.DetectionChannelObjectByIndex(lI, Success)
-                DetD.Filter1 = DetS.Filter1
-                DetD.Filter2 = DetS.Filter2
-                DetD.DetectorGain = DetS.DetectorGain
-                DetD.AmplifierGain = DetS.AmplifierGain
-                DetD.AmplifierOffset = DetS.AmplifierOffset
-                DetD.PinholeDiameter = DetS.PinholeDiameter
-            Next lI
-            
-            For lI = 0 To Td.IlluminationChannelCount - 1
-                Set IlS = Ts.IlluminationObjectByIndex(lI, Success)
-                Set IlD = Td.IlluminationObjectByIndex(lI, Success)
-                IlD.Acquire = IlS.Acquire
-                IlD.Power = IlS.Power
-                IlD.DetectionChannelName = IlS.DetectionChannelName
-            Next lI
-            
-            For lI = 0 To Td.BeamSplitterCount - 1
-                Set BS = Ts.BeamSplitterObjectByIndex(lI, Success)
-                Set BD = Td.BeamSplitterObjectByIndex(lI, Success)
-                BD.Filter = BS.Filter
-            Next lI
-            
-        Next lT
-
-
-End Sub
-
-
-Public Sub CheckDiskSpace(lpRootPathName As String, lFreeSpace As Double, lSpace As Long)
-    Dim lpSectorsPerCluster As Long
-    Dim lpBytesPerSector As Long
-    Dim lpNumberOfFreeClusters As Long
-    Dim lpTotalNumberOfClusters As Long
-    
-    lSpace = GetDiskFreeSpace(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, _
-                            lpNumberOfFreeClusters, lpTotalNumberOfClusters)
-    lFreeSpace = CDbl(lpSectorsPerCluster) * CDbl(lpBytesPerSector) * CDbl(lpNumberOfFreeClusters)
-
-End Sub
-
-Public Sub AutofocusRange(ZRange As Double, OffRange As Double, MsgZRange As String, MsgOffRange As String)
-
-    Dim Position As Long
-    Dim Range As Double
-
-    Position = Lsm5.Hardware.CpObjectiveRevolver.RevolverPosition
-    If Position >= 0 Then
-        Range = Lsm5.Hardware.CpObjectiveRevolver.FreeWorkingDistance(Position) * 1000#
-    Else
-        Range = 0#
-    End If
-    OffRange = Range
-    ZRange = Range
-    MsgOffRange = "Zoffset has to be less or equal to the working distance of the objective: " + CStr(OffRange) + " um"
-    MsgZRange = "ZRange has to be less or equal to the working distance of the objective: " + CStr(ZRange) + " um"
-
-End Sub
-
-Public Sub MoveToLoc(x As Double, y As Double)
-    Dim X1 As Double
-    Dim Y1 As Double
-    Dim cnt As Long
-    Dim WaitTime As Long
-    Dim PreviousX As Double
-    Dim PreviousY As Double
-    Dim CurrentX As Double
-    Dim CurrentY As Double
-    Dim Msg, Style, Title, Response
-    Dim StageTime As Long
-    
-    cnt = 0
-    On Error GoTo retry
-retry:
-    If cnt > 1000 Then GoTo Finish
-    cnt = cnt + 1
-    
-    X1 = Stage.PositionX
-    Y1 = Stage.PositionY
-    Stage.PositionX = x
-    Stage.PositionY = y
-    
-        PreviousX = X1
-        PreviousY = Y1
-        WaitTime = 0
-        
-        While Lsm5.Hardware.CpStages.IsBusy
-            DoEvents
-            Sleep 100
-            If ScanInterrupt Then Exit Sub
-            WaitTime = WaitTime + 1
-            If WaitTime > 100 Then
-                CurrentX = Stage.PositionX
-                CurrentY = Stage.PositionY
-            
-                If (Abs(CurrentX - PreviousX) < 1) And (Abs(CurrentY - PreviousY) < 1) Then
-'                    StageTime = GetTickCount
-                
-                    If GlobalStageCounter = 1 Then
-                        Msg = "The stage did not move for more than 10 seconds:" _
-                        + Strings.Chr(13) + Strings.Chr(10) + "Instance " + CStr(GlobalStageCounter) _
-                        + ", Time = " + Strings.Format(Now, "hh:mm:ss mm/dd/yy") + Strings.Chr(13) + Strings.Chr(10) + _
-                        "X = " + CStr(CurrentX) + Strings.Chr(13) + Strings.Chr(10) + "Y = " + CStr(CurrentY)
-                        GlobalStageText = Msg
-                    Else
-                        Msg = Strings.Chr(13) + Strings.Chr(10) + "Instance " + CStr(GlobalStageCounter) _
-                        + ", Time = " + Strings.Format(Now, "hh:mm:ss mm/dd/yy") + Strings.Chr(13) + Strings.Chr$(10) + _
-                        "X = " + CStr(CurrentX) + Strings.Chr(13) + Strings.Chr(10) + "Y = " + CStr(CurrentY)
-                        GlobalStageText = GlobalStageText + Msg
-
-                    End If
-'                    Print #GlobaliFile, GlobalStageText
-
-                    GlobalStageCounter = GlobalStageCounter + 1
-                    Style = vbInfoText + VbExclamation ' Define buttons.
-                    Title = "Stage Did't Move"  ' Define title.
-'                    Response = MsgBox(Msg, Style, Title)
-''                    StageErrorForm.TextBox1.Text = GlobalStageText
-''                    StageErrorForm.Show 0
-                
-'                    ScanInterrupt = True
-'                    Exit Sub
-                End If
-                PreviousX = CurrentX
-                PreviousY = CurrentY
-                WaitTime = 0
-            End If
-        Wend
-Finish:
-'        UpdateCurrPos StartStop.LabelFocus, StartStop.LabelCurrentPos
-
-End Sub
-
-
-Public Sub ReadLoc(x As Double, y As Double)
-    Dim cnt As Long
-    
-    cnt = 0
-    On Error GoTo retry
-retry:
-    If cnt > 1000 Then GoTo Finish
-    cnt = cnt + 1
-    x = Stage.PositionX
-    y = Stage.PositionY
-Finish:
-End Sub
-
-Public Sub MoveToLocUsingScreenCoordinates(x As Double, y As Double)
-    Dim X1 As Double
-    Dim Y1 As Double
-    Dim cnt As Long
-    Dim WaitTime As Long
-    Dim PreviousX As Double
-    Dim PreviousY As Double
-    Dim CurrentX As Double
-    Dim CurrentY As Double
-        
-    cnt = 0
-    On Error GoTo retry
-retry:
-    If cnt > 1000 Then GoTo Finish
-    cnt = cnt + 1
-        
-    X1 = GetStagePositionX
-    Y1 = GetStagePositionY
-    
-    SetStagePositionXY x, y
-    
-       
-    PreviousX = X1
-    PreviousY = Y1
-    WaitTime = 0
-    
-    While Lsm5.Hardware.CpStages.IsBusy
-        DoEvents
-        Sleep 100
-        If ScanInterrupt Then Exit Sub
-        WaitTime = WaitTime + 1
-        If WaitTime > 50 Then
-            CurrentX = GetStagePositionX
-            CurrentY = GetStagePositionY
-        
-            If (Abs(CurrentX - PreviousX) < 1) And (Abs(CurrentY - PreviousY) < 1) Then
-                MsgBox "The stage did not move for more than 5 seconds." + Chr(13) + Chr(10) + _
-                       "Assuming that end of the stage positionning range has been reached.", VbExclamation
-                ScanInterrupt = True
-                Exit Sub
-            End If
-            PreviousX = CurrentX
-            PreviousY = CurrentY
-            WaitTime = 0
-        End If
-    Wend
-Finish:
-End Sub
-
-Public Sub WaitWhileImageBusy(Image As DsRecordingDoc)
-If Not Image Is Nothing Then
-    Do While Image.IsBusy
-        DoEvents
-        Sleep 20
-        If ScanInterrupt Then Exit Sub
-    Loop
-End If
-End Sub
-Public Function GetStagePositionX() As Double
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim x As Double
-    Dim y As Double
-    DoEvents
-    GetStagePositionX = 0#
-    Dim cnt As Long
-    
-    cnt = 0
-    On Error GoTo retry
-retry:
-    If cnt > 1000 Then GoTo nostage
-    cnt = cnt + 1
-        
-    x = Lsm5.Hardware.CpStages.PositionX
-    y = Lsm5.Hardware.CpStages.PositionY
-    GetStagePositionX = x
-    On Error GoTo oldversion
-    
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    If bExchangeXY Then
-        GetStagePositionX = y
-    End If
-    
-    If bMirrorX Then
-        GetStagePositionX = -GetStagePositionX
-    End If
-    Exit Function
-oldversion:
-    GetStagePositionX = X11 * x + X12 * y
-nostage:
-End Function
-
-Public Function GetStagePositionY() As Double
-
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim x As Double
-    Dim y As Double
-
-    GetStagePositionY = 0#
-    Dim cnt As Long
-    
-    cnt = 0
-    On Error GoTo retry
-retry:
-    If cnt > 1000 Then GoTo nostage
-    cnt = cnt + 1
-        
-    x = Lsm5.Hardware.CpStages.PositionX
-    y = Lsm5.Hardware.CpStages.PositionY
-    GetStagePositionY = y
-     
-    On Error GoTo oldversion
-    
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    
-    If bExchangeXY Then
-        GetStagePositionY = x
-    End If
-    
-    If bMirrorY Then
-'    If Not bMirrorY Then
-        GetStagePositionY = -GetStagePositionY
-    End If
-    Exit Function
-oldversion:
-   GetStagePositionY = X21 * x + X22 * y
-nostage:
-End Function
-
-Public Sub SetStagePositionXY(XP As Double, YP As Double)
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim dExchange As Double
-    Dim x As Double
-    Dim y As Double
-    
-    x = XP
-    y = YP
-    On Error GoTo oldversion
-    
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    
-    If bMirrorX Then
-        x = -x
-    End If
-    
-    If bMirrorY Then
-'    If Not bMirrorY Then
-        y = -y
-    End If
-    
-    On Error GoTo nostage
-    
-    If bExchangeXY Then
-        Lsm5.Hardware.CpStages.PositionY = x
-        Lsm5.Hardware.CpStages.PositionX = y
-    Else
-        Lsm5.Hardware.CpStages.PositionX = x
-        Lsm5.Hardware.CpStages.PositionY = y
-    End If
-            
-    Exit Sub
-oldversion:
-
-    Lsm5.Hardware.CpStages.PositionX = X11 * x + X21 * y
-    Lsm5.Hardware.CpStages.PositionY = X12 * x + X22 * y
-    
-nostage:
-
-End Sub
-
-Public Sub ConvertToStagePositionXY(XP As Double, YP As Double, xnew As Double, ynew As Double)
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim dExchange As Double
-    Dim x As Double
-    Dim y As Double
-    
-    x = XP
-    y = YP
-    On Error GoTo oldversion
-    
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    
-    If bMirrorX Then
-        x = -x
-    End If
-'    If Not bMirrorY Then
-    If bMirrorY Then
-        y = -y
-    End If
-        
-    If bExchangeXY Then
-        ynew = x
-        xnew = y
-    Else
-        xnew = x
-        ynew = y
-    End If
-            
-    Exit Sub
-oldversion:
-
-    xnew = X11 * x + X21 * y
-    ynew = X12 * x + X22 * y
-    
-nostage:
-
-End Sub
-
-Public Sub ConvertStageToScreenXY(XP As Double, YP As Double, xnew As Double, ynew As Double)
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim dExchange As Double
-    Dim x As Double
-    Dim y As Double
-    
-    x = XP
-    y = YP
-    On Error GoTo oldversion
-    
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    
-    If bExchangeXY Then
-        ynew = x
-        xnew = y
-    Else
-        xnew = x
-        ynew = y
-    End If
-    
-    If bMirrorX Then
-        xnew = -xnew
-    End If
-'    If Not bMirrorY Then
-    If bMirrorY Then
-        ynew = -ynew
-    End If
-        
-            
-    Exit Sub
-oldversion:
-
-    xnew = X11 * x + X12 * y
-    ynew = X21 * x + X22 * y
-    
-nostage:
-
-End Sub
-
-Public Sub SetStagePositionX(XP As Double)
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim x As Double
-
-    x = XP
-    
-    On Error GoTo oldversion
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    If bMirrorX Then
-        x = -x
-    End If
-    On Error GoTo nostage
-    
-    If bExchangeXY Then
-        Lsm5.Hardware.CpStages.PositionY = x
-    Else
-        Lsm5.Hardware.CpStages.PositionX = x
-    End If
-        
-    Exit Sub
-oldversion:
-
-    Lsm5.Hardware.CpStages.PositionX = x
-nostage:
-
-End Sub
-
-
-Public Sub SetStagePositionY(YP As Double)
-
-    Dim bExchangeXY As Boolean
-    Dim bMirrorX As Boolean
-    Dim bMirrorY As Boolean
-    Dim dExchange As Double
-    Dim y As Double
-
-    y = YP
-    
-    On Error GoTo oldversion
-    
-    CoordinateConversion bExchangeXY, bMirrorX, bMirrorY
-    
-    If Not bMirrorY Then
-        y = -y
-    End If
-    On Error GoTo nostage
-    
-    If bExchangeXY Then
-        Lsm5.Hardware.CpStages.PositionX = y
-    Else
-        Lsm5.Hardware.CpStages.PositionY = y
-    End If
-        
-    Exit Sub
-oldversion:
-
-    Lsm5.Hardware.CpStages.PositionY = y
-nostage:
-
-End Sub
-
-Public Sub GetPathAndVersion(Path As String, ThisSystemVersion As Long, pathUp As String)
-
-    Dim OK As Boolean
-    Dim SystemVersion As String
-    Dim Count As Long
-    Dim MacroPath As String
-    Dim ProjName As String
-    Dim Success As Integer
-    Dim pos As Integer
-    Dim Start As Integer
-    Dim indx As Integer
-    Dim bslash As String
-    Dim path1 As String
-    Dim lngth As Long
-
-    Count = ProjectCount()
-    For indx = 0 To Count - 1
-        MacroPath = ProjectPath(indx, Success)
-        ProjName = ProjectTitle(indx, Success)
-        If StrComp(ProjName, GlobalProjectName, vbTextCompare) = 0 Then
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, MacroPath, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            Path = Strings.Left(MacroPath, Start - 1)
-            lngth = Strings.Len(Path)
-            path1 = Strings.Left(Path, lngth - 1)
-            Start = 1
-            bslash = "\"
-            pos = Start
-            Do While pos > 0
-                pos = InStr(Start, path1, bslash)
-                If pos > 0 Then
-                    Start = pos + 1
-                End If
-            Loop
-            pathUp = Strings.Left(path1, Start - 1)
-            
-            Exit For
-        End If
-    Next indx
-            
-    SystemVersion = Lsm5.Info.VersionIs
-    SystemVersion = Replace(SystemVersion, ",", ".")
-    If StrComp(SystemVersion, "5.5", vbBinaryCompare) >= 0 Then
-        ThisSystemVersion = 55
-    ElseIf StrComp(SystemVersion, "5.0", vbBinaryCompare) >= 0 Then
-        ThisSystemVersion = 50
-    ElseIf StrComp(SystemVersion, "4.5", vbBinaryCompare) >= 0 Then
-        ThisSystemVersion = 45
-    ElseIf StrComp(SystemVersion, "4.0", vbBinaryCompare) >= 0 Then
-        ThisSystemVersion = 40
-    ElseIf StrComp(SystemVersion, "3.5", vbBinaryCompare) >= 0 Then
-        ThisSystemVersion = 35
-    ElseIf StrComp(SystemVersion, "3.2", vbBinaryCompare) >= 0 Then
-        ThisSystemVersion = 32
-        
-    ElseIf StrComp(SystemVersion, "3.0", vbBinaryCompare) >= 0 Then
-        ThisSystemVersion = 30
-    Else
-        If StrComp(SystemVersion, "2.8", vbBinaryCompare) >= 0 Then
-            ThisSystemVersion = 28
-        Else
-            ThisSystemVersion = 25
-        End If
-    End If
-    
-    End Sub
-
-Public Sub Wait(PauseTime As Single)
-    Dim Start As Single
-    Start = Timer   ' Set start time.
-    Do While Timer < Start + PauseTime
-       DoEvents    ' Yield to other processes.
-       'Lsm5.DsRecording.StartScanTriggerIn
-    Loop
-End Sub
-
-
-Public Sub FillComboList(TheComboBox As MSForms.ComboBox, key As String)
-    Dim Count As Integer
-    Dim idx As Integer
-    Dim flgUserChangeSaved As Boolean
-    Dim flgUserChangeSaved1 As Boolean
-    
-    Dim theString As String
-    flgUserChangeSaved1 = flgUserChange
-    flgUserChangeSaved = User_flg
-    User_flg = False
-    flgUserChange = False
-    
-    TheComboBox.Clear
-    Count = tools.RegCountSubKeys(key)
-    If Count > 0 Then
-        For idx = 0 To Count - 1
-            theString = tools.RegSubkeyName(idx, key)
-            TheComboBox.AddItem tools.RegSubkeyName(idx, key)
-        Next idx
-    End If
-    User_flg = flgUserChangeSaved
-    flgUserChange = flgUserChangeSaved1
- 
-End Sub
-
-
-Public Sub SetComboValues(AComboBox As MSForms.ComboBox, Conf As String, ConfIndex As Long, Keep As Boolean)
-' Add 01/30/03 start
-    Dim Count As Long
-'    Keep = True
-    Count = AComboBox.ListCount
-    If ConfIndex < Count Then
-        AComboBox.Text = Conf
-        ConfIndex = AComboBox.ListIndex
-        If ConfIndex < 0 Then
-            ConfIndex = -1
-            Conf = ""
-            AComboBox.Text = Conf
-            Keep = False
-
-        End If
-    Else
-        ConfIndex = -1
-        Conf = ""
-        Keep = False
-
-    End If
-    
-End Sub
-
-
-Public Sub DisplayProgress(ProgressLabel As MSForms.Label, state As String, Color As Long)
-    If (Color & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Or ((Color / 256) & &HFF) > 128 Then
-        ProgressLabel.ForeColor = 0
-    Else
-        ProgressLabel.ForeColor = &HFFFFFF
-    End If
-    ProgressLabel.BackColor = Color
-    ProgressLabel.Caption = state
-End Sub
-
-'Sub Macro1()
-'
-'    Dim DS As Document
-'    Dim HechtImage As RecordingDocument
-'    Dim EngelImage As DsRecordingDoc
-'
-'    Set DS = Lsm5.ExternalDsObject
-'
-'    Set HechtImage = DS.MakeNewImageDocument(100, 100, 1, 1, 2, 1, 1)
-'
-'    Set EngelImage = HechtImageToEngelImage(HechtImage)
-'
-'End Sub
-
-
-
-'Function HechtImageToEngelImage(HechtImage As RecordingDocument) As DsRecordingDoc
-'
-'    Dim Ds As Document
-'    Dim EngelImage As DsRecordingDoc
-'    Dim index As Long
-'    Dim ImageIndex As Long
-'    Dim title As String
-'    Dim OriginalTitle As String
-'    Dim Success As Integer
-'
-'    Set Ds = Lsm5.ExternalDsObject
-'    If Not HechtImage Is Nothing Then
-'        OriginalTitle = HechtImage.title
-'        For index = 1 To 1000000
-'            title = "XXXXXX" + CStr(index)
-'            If (Ds.RecordingDocuments.Item(title) Is Nothing) Then
-'                HechtImage.SetTitle title
-'                title = HechtImage.title
-'                For ImageIndex = 0 To 1000000
-'                    Set EngelImage = Lsm5.DsRecordingDocObject(ImageIndex, Success)
-'                    If EngelImage Is Nothing Then Exit For
-'                    If EngelImage.title = title Then
-'                        EngelImage.SetTitle OriginalTitle
-'                        Set HechtImageToEngelImage = EngelImage
-'                        HechtImage.SetTitle OriginalTitle
-'                        Exit Function
-'                    End If
-'                Next ImageIndex
-'            End If
-'        Next index
-'    End If
-'    Set HechtImageToEngelImage = Nothing
-'
-'End Function
-Function HechtImageToEngelImage(HechtImage As RecordingDocument) As DsRecordingDoc
-
-    Dim DS As Object
-    Dim EngelImage As DsRecordingDoc
-    Dim OtherHechtImage As RecordingDocument
-    Dim index As Long
-    Dim ImageIndex As Long
-    Dim Title As String
-    Dim OriginalTitle As String
-    Dim Success As Integer
-
-    Set DS = Lsm5.ExternalDsObject
-    If Not HechtImage Is Nothing Then
-        OriginalTitle = HechtImage.Title
-        For index = 1 To DS.RecordingDocuments.Count + 1
-            Title = "XXXXXX" + CStr(index)
-            If (DS.RecordingDocuments.Item(Title) Is Nothing) Then
-                HechtImage.SetTitle Title
-                Title = HechtImage.Title
-                For ImageIndex = 0 To DS.RecordingDocuments.Count - 1
-                    Set EngelImage = Lsm5.DsRecordingDocObject(ImageIndex, Success)
-                    If EngelImage Is Nothing Then Exit For
-                    Set OtherHechtImage = EngelImage.RecordingDocument
-                    If OtherHechtImage Is Nothing Then Exit For
-                    If OtherHechtImage.Title = Title Then
-                        EngelImage.SetTitle OriginalTitle
-                        Set HechtImageToEngelImage = EngelImage
-                        HechtImage.SetTitle OriginalTitle
-                        Exit Function
-                    End If
-                Next ImageIndex
-                Set HechtImageToEngelImage = Nothing
-                Exit Function
-            End If
-        Next index
-    End If
-    Set HechtImageToEngelImage = Nothing
-
-End Function
-
-
-Function EngelImageToHechtImage(EngelImage As DsRecordingDoc) As RecordingDocument
-
-    Dim DS As Document
-    Dim HechtImage As RecordingDocument
-    Dim Found As Boolean
-    Dim index As Long
-    Dim ImageIndex As Long
-    Dim Title As String
-    Dim OriginalTitle As String
-    Dim Success As Integer
-    If Not EngelImage Is Nothing Then
-        Set EngelImageToHechtImage = EngelImage.RecordingDocument
-    End If
-'    Set Ds = Lsm5.ExternalDsObject
-'    If Not EngelImage Is Nothing Then
-'        OriginalTitle = EngelImage.title
-'
-'        For index = 1 To 1000000
-'            title = "XXXXXX" + CStr(index)
-'            Found = False
-'
-'            For ImageIndex = 0 To Ds.RecordingDocuments.Count - 1
-'                If Not (Lsm5.DsRecordingDocObject(ImageIndex, Success) Is Nothing) Then
-'                    If Lsm5.DsRecordingDocObject(ImageIndex, Success).title = title Then
-'                        Found = True
-'                        Exit For
-'                    End If
-'                End If
-'            Next ImageIndex
-'            If Not Found Then
-'                EngelImage.SetTitle title
-'                title = EngelImage.title
-'                Set HechtImage = Ds.RecordingDocuments.Item(title)
-'                If HechtImage Is Nothing Then Exit For
-'                HechtImage.SetTitle OriginalTitle
-'                Set EngelImageToHechtImage = HechtImage
-'                EngelImage.SetTitle OriginalTitle
-'                Exit Function
-'            End If
-'        Next index
-'    End If
-'    Set EngelImageToHechtImage = Nothing
-
-End Function
-
-
-Sub Heapsort(arr() As Double, hcount As Long, art() As Long)
-Dim i As Long
-Dim L As Long
-Dim Ir As Long
-Dim Rra As Double
-Dim Tra As Double
-Dim J As Long
-ReDim art(hcount + 1)
-For i = 1 To hcount
-    art(i) = i
-Next i
-
-If hcount > 1 Then
-  L = CInt(hcount / 2) + 1
-  Ir = hcount
-Cont:
-  If L > 1 Then
-    L = L - 1
-    Rra = arr(art(L))
-    Tra = art(L)
-  Else
-    Rra = arr(art(Ir))
-    Tra = art(Ir)
-    art(Ir) = art(1)
-    Ir = Ir - 1
-    If Ir = 1 Then
-      art(1) = Tra
-      GoTo Done
-    End If
-  End If
-  i = L
-  J = L + L
-back:
-  If J <= Ir Then
-    If J < Ir Then
-      If arr(art(J)) < arr(art(J + 1)) Then
-        J = J + 1
-      End If
-    End If
-    If Rra < arr(art(J)) Then
-      art(i) = art(J)
-      i = J
-      J = J + J
-    Else
-      J = Ir + 1
-    End If
-    GoTo back
-  End If
-  art(i) = Tra
-  GoTo Cont
-Done:
-End If
-End Sub
-
-
-Sub WaitSeconds(seconds As Double)
-    Dim Start As Double
-    Start = RunTime
-    While RunTime < Start + seconds
-    Wend
-End Sub
-
-Function RunTime() As Double
-    Dim secTime As Currency
-    Dim secFreq As Currency
-    Dim time As Double
-    Dim frequency As Double
-    
-    QueryPerformanceFrequency secFreq
-    QueryPerformanceCounter secTime
-    
-    time = secTime
-    frequency = secFreq
-
-    If frequency = 0 Then
-        RunTime = 0
-    Else
-        RunTime = time / frequency
-    End If
-End Function
-
-Public Function IsLaserOn(Wavelength As Long) As Boolean
-    Dim indx As Long
-    Dim Count As Long
-    
-    Dim countLines As Integer
-    Dim jndx As Integer
-    
-    Dim Wave As Long
-    Dim LaserName As String
-    
-    Dim OK As Boolean
-    Dim Power As Double
-    Dim Attenuation As Double
-    Dim OnOff As Integer
-    
-    If GlobalSystemVersion < 35 Then
-'        For indx = 0 To count - 1
-'            If Wavelength = Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).lWavelength Then
-'                IsLaserOn = (Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).pChLaser.lState = eLaserStateOn) _
-'                         Or (Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).pChLaser.lState = eLaserStateStandby)
-'                Exit Function
-'            End If
-'        Next indx
-        Count = Lsm5.Hardware.CpLaserLines.Count
-        For indx = 0 To Count - 1
-            OK = Lsm5.Hardware.CpLaserLines.LineInfo(indx, Wave, Attenuation, OnOff, LaserName)
-            If Wavelength = Wave Then
-                OK = Lsm5.Hardware.CpLasers.Select(LaserName)
-                If OK Then
-                    IsLaserOn = Lsm5.Hardware.CpLaserLines.IsLaserOn(Wave)
-'                    OK = Lsm5.Hardware.CpLasers.IsIgnited
-'                    OK = Lsm5.Hardware.CpLasers.Status
-'                    If OnOff = 1 Then
-'                        IsLaserOn = True
-'                    Else
-'                        IsLaserOn = False
-'                    End If
-                    Exit Function
-                End If
-            End If
-        Next indx
-    Else
-        Count = Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.lCount
-        For indx = 0 To Count - 1
-            If Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).Group = GlobalSystemGroup Then
-                If Wavelength = Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).lWavelength Then
-                    IsLaserOn = (Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).pChLaser.lState = eLaserStateOn) _
-                             Or (Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).pChLaser.lState = eLaserStateStandby)
-                    Exit Function
-                End If
-            End If
-        Next indx
-    End If
-    IsLaserOn = False
-End Function
-
-Public Sub FindLaserNameAndPower(LaserWave As Long, TheLaserName As String, LaserPower As Double, IsLaserOn As Boolean)
-    Dim Count As Integer
-    Dim indx As Integer
-    Dim countLines As Integer
-    Dim jndx As Integer
-    
-    Dim Wave As Long
-    Dim IndexArray() As Long
-    
-    Dim Attenuation As Double
-    Dim OnOff As Integer
-    Dim LaserName As String
-    
-    Dim OK As Boolean
-    Dim Power As Double
-    Dim Done As Boolean
-'    Count = Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.lCount
-'    For indx = 0 To Count - 1
-'        If Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).Group = GlobalSystemGroup Then
-'
-'            Wave = Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).lWavelength
-'    'to check if the laser is on :
-'    'if Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).pChLaser.lState = eLaserStateOn  then ...
-'    'possible states
-'                '   eLaserStateOff = 0,
-'                '   eLaserStateOn = 1
-'                '   eLaserStateStandby = 2
-'                '   eLaserStateBusy = 3
-'                '   eLaserStateNone = 4
-'        End If
-'    Next indx
-IsLaserOn = False
-TheLaserName = ""
-LaserPower = 0
-
-If GlobalSystemVersion < 35 Then
-    Count = Lsm5.Hardware.CpLaserLines.Count
-    For indx = 0 To Count - 1
-        OK = Lsm5.Hardware.CpLaserLines.LineInfo(indx, Wave, Attenuation, OnOff, LaserName)
-        If Wave = LaserWave Then
-            OK = Lsm5.Hardware.CpLasers.Select(LaserName)
-            If OK Then
-                LaserPower = Lsm5.Hardware.CpLasers.PowerWatt
-                If OnOff = 1 Then
-                    IsLaserOn = True
-                Else
-                    IsLaserOn = False
-                End If
-                TheLaserName = LaserName
-                Exit Sub
-            End If
-        End If
-    Next indx
-        For indx = 0 To Count - 1
-            OK = Lsm5.Hardware.CpLaserLines.LineInfo(indx, Wave, Attenuation, OnOff, LaserName)
-            If LaserWave = Wave Then
-                OK = Lsm5.Hardware.CpLasers.Select(LaserName)
-                If OK Then
-                    LaserPower = Lsm5.Hardware.CpLasers.PowerWatt
-                    IsLaserOn = Lsm5.Hardware.CpLaserLines.IsLaserOn(Wave)
-                    TheLaserName = LaserName
-
-'                    OK = Lsm5.Hardware.CpLasers.IsIgnited
-'                    OK = Lsm5.Hardware.CpLasers.Status
-'                    If OnOff = 1 Then
-'                        IsLaserOn = True
-'                    Else
-'                        IsLaserOn = False
-'                    End If
-                    Exit Sub
-                End If
-            End If
-        Next indx
-    
-Else
-    Count = Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.lCount
-    For indx = 0 To Count - 1
-        If Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).Group = GlobalSystemGroup Then
-            Wave = Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).lWavelength
-            If Wave = LaserWave Then
-                IsLaserOn = (Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).pChLaser.lState = eLaserStateOn) _
-                         Or (Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).pChLaser.lState = eLaserStateStandby)
-            
-                TheLaserName = Lsm5.ExternalCpObject.pHardwareObjects.pAttenuators.pItem(CVar(indx)).pChLaser.strName
-                OK = Lsm5.Hardware.CpLasers.Select(TheLaserName)
-                OK = Lsm5.Hardware.CpLasers.IsPowerChangeable
-                If OK Then
-                    LaserPower = Lsm5.Hardware.CpLasers.Power
-                Else
-                    LaserPower = 0
-                End If
-                Exit For
-            End If
-        End If
-    Next indx
-End If
-End Sub
-
-Public Sub InitializeSampleObservationTime()
-    Dim IsLIVE As Boolean
-    If GlobalSystemVersion >= 30 Then
-        If GlobalIsDuo Then
-            IsLIVE = IsLIVEorLSM
-        End If
-        If (GlobalSystemGroup = "LIVE") Or IsLIVE Then
-            GlobalSampleObservationTime(1) = 493000 * 10 ^ -8
-            GlobalSampleObservationTime(2) = 493000 * 10 ^ -8
-            GlobalSampleObservationTime(3) = 244000 * 10 ^ -8
-            GlobalSampleObservationTime(4) = 120000 * 10 ^ -8
-            GlobalSampleObservationTime(5) = 58962 * 10 ^ -8
-            GlobalSampleObservationTime(6) = 39310 * 10 ^ -8
-            GlobalSampleObservationTime(7) = 23585 * 10 ^ -8
-            GlobalSampleObservationTime(8) = 15725 * 10 ^ -8
-            GlobalSampleObservationTime(9) = 11782 * 10 ^ -8
-            GlobalSampleObservationTime(10) = 7860 * 10 ^ -8
-            GlobalSampleObservationTime(11) = 5896 * 10 ^ -8
-            GlobalSampleObservationTime(12) = 3928 * 10 ^ -8
-            GlobalSampleObservationTime(13) = 2968 * 10 ^ -8
-
-
-        Else
-            GlobalSampleObservationTime(1) = 20484 * 10 ^ -8
-            GlobalSampleObservationTime(2) = 10240 * 10 ^ -8
-            GlobalSampleObservationTime(3) = 5120 * 10 ^ -8
-            GlobalSampleObservationTime(4) = 2560 * 10 ^ -8
-            GlobalSampleObservationTime(5) = 1280 * 10 ^ -8
-            GlobalSampleObservationTime(6) = 640 * 10 ^ -8
-            GlobalSampleObservationTime(7) = 320 * 10 ^ -8
-            GlobalSampleObservationTime(8) = 256 * 10 ^ -8
-            GlobalSampleObservationTime(9) = 160 * 10 ^ -8
-            GlobalSampleObservationTime(10) = 128 * 10 ^ -8
-            GlobalSampleObservationTime(11) = 96 * 10 ^ -8
-            GlobalSampleObservationTime(12) = 80 * 10 ^ -8
-            GlobalSampleObservationTime(13) = 64 * 10 ^ -8
-        End If
-     Else
-        GlobalSampleObservationTime(1) = 7168 * 10 ^ -8
-        GlobalSampleObservationTime(2) = 7168 * 10 ^ -8
-        GlobalSampleObservationTime(3) = 3584 * 10 ^ -8
-        GlobalSampleObservationTime(4) = 1792 * 10 ^ -8
-        GlobalSampleObservationTime(5) = 896 * 10 ^ -8
-        GlobalSampleObservationTime(6) = 448 * 10 ^ -8
-        GlobalSampleObservationTime(7) = 224 * 10 ^ -8
-        GlobalSampleObservationTime(8) = 176 * 10 ^ -8
-        GlobalSampleObservationTime(9) = 112 * 10 ^ -8
-        GlobalSampleObservationTime(10) = 88 * 10 ^ -8
-        GlobalSampleObservationTime(11) = 64 * 10 ^ -8
-        GlobalSampleObservationTime(12) = 56 * 10 ^ -8
-        GlobalSampleObservationTime(13) = 40 * 10 ^ -8
-    End If
-End Sub
-
-
-Public Sub UpdateFocus(LabelFocus As MSForms.Label)
-    LabelFocus.Caption = " Z=" + Strings.Format(Lsm5.Hardware.CpFocus.Position, "0.00")
-       
-End Sub
-
-Public Sub UpdateCurrPos(LabelFocus As MSForms.Label, LabelCurrentPos As MSForms.Label)
-    Dim x As Double
-    Dim y As Double
-    
-    x = GetStagePositionX
-    y = GetStagePositionY
-'    x = Stage.PositionX
-'    y = Stage.PositionY
-    LabelCurrentPos.Caption = "Current Pos: X=" + Strings.Format(x, "0.00") + _
-    " Y=" + Strings.Format(y, "0.00")
-    LabelFocus.Caption = " Z=" + Strings.Format(Lsm5.Hardware.CpFocus.Position, "0.00")
-        
-End Sub
-
-Public Sub UsedDevices40(bLSM As Boolean, bLIVE As Boolean, bCamera As Boolean)
-Dim ScanController As AimScanController
-Dim TrackParameters As AimTrackParameters
-Dim Size As Long
-Dim lTrack As Long
-Dim eDeviceMode As Long
-'Dim MyRecord As DsRecording
-
-    bLSM = False
-    bLIVE = False
-    bCamera = False
-    Set ScanController = Lsm5.ExternalDsObject.ScanController
-    Set TrackParameters = ScanController.TrackParameters
-    If TrackParameters Is Nothing Then Exit Sub
-'    Set MyRecord = Lsm5.DsRecording
-'    Size = MyRecord.TrackCount
-    
-    Size = TrackParameters.GetTrackArraySize
-    For lTrack = 0 To Size - 1
-        If TrackParameters.IsTrackUsed(lTrack) Then
-            eDeviceMode = TrackParameters.TrackDeviceMode(lTrack)
-            Select Case eDeviceMode
-                Case eAimDeviceModeLSM
-                Case eAimDeviceModeLSM_ChannelMode
-                Case eAimDeviceModeLSM_NDD
-                Case eAimDeviceModeLSM_DD
-                Case eAimDeviceModeSpectralImager
-                    bLSM = True
-                    Exit Sub
-                Case eAimDeviceModeRtScanner
-                    bLIVE = True
-                    Exit Sub
-                Case eAimDeviceModeCamera1
-                    bCamera = True
-                    Exit Sub
-                
-            End Select
-        End If
-    Next lTrack
-End Sub
-
-
-Public Sub CoordinateConversion(bExchangeXY As Boolean, bMirrorX As Boolean, bMirrorY As Boolean)
-    Dim bLSM As Boolean
-    Dim bLIVE As Boolean
-    Dim bCamera As Boolean
-    Dim lSystem As Long
-    If GlobalSystemVersion = 32 Then
-        Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisState bExchangeXY, bMirrorX, bMirrorY
-    ElseIf GlobalSystemVersion > 32 Then
-        UsedDevices40 bLSM, bLIVE, bCamera
-        If bLSM Then
-            lSystem = 0
-        ElseIf bLIVE Then
-            lSystem = 1
-        ElseIf bCamera Then
-            lSystem = 3
-        End If
-        Lsm5.ExternalCpObject.pHardwareObjects.GetImageAxisStateS lSystem, bExchangeXY, bMirrorX, bMirrorY
-    End If
-
-End Sub
-
-
-Public Sub RemoveInvalidCharacters(InputString As String, OutputString As String)
-    OutputString = Replace(InputString, " ", "_")
-    OutputString = Replace(OutputString, "\", "_")
-    OutputString = Replace(OutputString, "/", "_")
-    OutputString = Replace(OutputString, "*", "_")
-    OutputString = Replace(OutputString, "|", "_")
-    OutputString = Replace(OutputString, "?", "_")
-    OutputString = Replace(OutputString, ":", "_")
-    OutputString = Replace(OutputString, "<", "_")
-    OutputString = Replace(OutputString, ">", "_")
-    OutputString = Replace(OutputString, Chr(34), "_")
-
-End Sub
-
-Public Function IsLIVEorLSM()
-    Dim Td As DsTrack
-    Dim DetS As DsDetectionChannel
-    Dim lT As Long
-    Dim lI As Long
-    Dim Count As Long
-    Dim OK As Boolean
-    Dim Success As Integer
-    OK = False
-    IsLIVEorLSM = False
-    For lT = 0 To Lsm5.DsRecording.TrackCount - 1
-        Set Td = Lsm5.DsRecording.TrackObjectByIndex(lT, Success)
-        If Td.Acquire Then
-            Count = Td.DetectionChannelCount
-            For lI = 0 To Count - 1
-                Set DetS = Td.DetectionChannelObjectByIndex(lI, Success)
-                If DetS.Acquire Then
-                    If DetS.Name = "ChL1" Or DetS.Name = "ChL2" Then
-                        IsLIVEorLSM = True
-                    Else
-                        IsLIVEorLSM = False
-                    End If
-                    OK = True
-                    Exit For
-                End If
-                If OK Then Exit For
-            Next lI
-            If OK Then Exit For
-        End If
-    Next lT
-End Function
-
-Public Function TransferPicture(Source As AimImageBitmap) As AimImageBitmap
-    Dim x As Long
-    Dim y As Long
-    Dim Picture As New AimImageBitmap
-    Set TransferPicture = New AimImageBitmap
-    If Source Is Nothing Then
-        TransferPicture.Cleanup
-    Else
-        Picture.Data = Source.Data
-        
-        x = Picture.GetLogicalWidth
-        y = Picture.GetLogicalHeight
-        
-        If (x < 1) Or (y < 1) Then
-            TransferPicture.Clenaup
-        Else
-            If x > y Then
-                y = 200 * y / x
-                x = 200
-            Else
-                x = 200 * x / y
-                y = 200
-            End If
-        End If
-        
-        TransferPicture.Create x, y, eAimImageBitmapFormatBGRA
-        TransferPicture.Copy Picture, True, False, False
-    End If
-End Function
-
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/NumOfTimes.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/NumOfTimes.frm
deleted file mode 100644
index 9346e57..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/NumOfTimes.frm
+++ /dev/null
@@ -1,78 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} NumOfTimes 
-   Caption         =   "Enter Number Of Time Images"
-   ClientHeight    =   2730
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   5535
-   OleObjectBlob   =   "NumOfTimes.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "NumOfTimes"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-Option Explicit
-
-Dim NumOfTimesLoaded As Boolean
-
-Private Sub CanceButton1_Click()
-    TimeNumberChange = False
-    SaveWindowPosition
-    Unload NumOfTimes
-End Sub
-
-Private Sub OkButton_Click()
-    TimeNumberChange = True
-    GlobalNumberOfStacks = BSlider1.Value
-    GlobalTimeIntv = BSlider2.Value
-    Unload NumOfTimes
-End Sub
-
-Private Sub UserForm_Activate()
-    If Not NumOfTimesLoaded Then
-        LoadWindowPosition
-    End If
-    NumOfTimesLoaded = True
-
-End Sub
-
-Private Sub UserForm_Initialize()
-    BSlider1.Value = GlobalNumberOfStacks
-    BSlider2.Value = GlobalTimeIntv
-End Sub
-
-Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
-    TimeNumberChange = False
-    SaveWindowPosition
-End Sub
-
-Public Function LoadWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Left = Lsm5.tools.RegLongValue(PosKey, "Left")
-    Top = Lsm5.tools.RegLongValue(PosKey, "Top")
-    If Left < 1 Then Left = 0
-    If Top < 1 Then Top = 0
-    
-    If Left = 0 And Top = 0 Then
-                'Center frm
-                Left = 300
-                Top = 300
-'    SaveWindowPosition
-                Exit Function
-    End If
-End Function
-
-
-
-Public Sub SaveWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Lsm5.tools.RegLongValue(PosKey, "Left") = CInt(Left)
-    Lsm5.tools.RegLongValue(PosKey, "Top") = CInt(Top)
-End Sub
-
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/SetWlForm.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/SetWlForm.frm
deleted file mode 100644
index fb10651..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/SetWlForm.frm
+++ /dev/null
@@ -1,87 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} SetWlForm 
-   Caption         =   "Set Wavelength"
-   ClientHeight    =   2580
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   4665
-   OleObjectBlob   =   "SetWlForm.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "SetWlForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-Option Explicit
-
-Dim SetWlLoaded As Boolean
-
-Private Sub CanceButton1_Click()
-    GlobalSetWlChange = False
-    SaveWindowPosition
-    Unload SetWlForm
-End Sub
-
-Private Sub DefaultButton_Click()
-    SetDefaultWl 4, GlobalStartWlTmp, GlobalStepWlTmp
-    BSlider1.Value = GlobalStartWlTmp
-    BSlider2.Value = GlobalStepWlTmp
-
-End Sub
-
-Private Sub OkButton_Click()
-    GlobalSetWlChange = True
-    GlobalStartWlTmp = BSlider1.Value
-    GlobalStepWlTmp = BSlider2.Value
-    Unload SetWlForm
-End Sub
-
-
-Private Sub UserForm_Activate()
-    If Not SetWlLoaded Then
-        LoadWindowPosition
-    End If
-    SetWlLoaded = True
-
-End Sub
-
-Private Sub UserForm_Initialize()
-    BSlider1.Value = GlobalStartWlTmp
-    BSlider2.Value = GlobalStepWlTmp
-End Sub
-
-Public Function LoadWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Left = Lsm5.tools.RegLongValue(PosKey, "Left")
-    Top = Lsm5.tools.RegLongValue(PosKey, "Top")
-    If Left < 1 Then Left = 0
-    If Top < 1 Then Top = 0
-    
-    If Left = 0 And Top = 0 Then
-                'Center frm
-                Left = 300
-                Top = 300
-'    SaveWindowPosition
-                Exit Function
-    End If
-End Function
-
-
-
-Public Sub SaveWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Lsm5.tools.RegLongValue(PosKey, "Left") = CInt(Left)
-    Lsm5.tools.RegLongValue(PosKey, "Top") = CInt(Top)
-End Sub
-
-Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
-    GlobalSetWlChange = False
-    SaveWindowPosition
-
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/TimeStampForm.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/TimeStampForm.frm
deleted file mode 100644
index 5f44848..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/TimeStampForm.frm
+++ /dev/null
@@ -1,79 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} TimeStampForm 
-   Caption         =   "Modify Time Stamp"
-   ClientHeight    =   3120
-   ClientLeft      =   45
-   ClientTop       =   435
-   ClientWidth     =   4710
-   OleObjectBlob   =   "TimeStampForm.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "TimeStampForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-
-Option Explicit
-
-Dim TimeStampLoaded As Boolean
-Private Sub CanceButton1_Click()
-    TimeStampChange = False
-    SaveWindowPosition
-    Unload TimeStampForm
-End Sub
-
-Private Sub OkButton_Click()
-    TimeStampChange = True
-    GlobalTimeStampDate = DTPicker1.Value
-    GlobalTimeStampTime = DTPicker2.Value
-    Unload TimeStampForm
-End Sub
-
-Private Sub UserForm_Activate()
-    If Not TimeStampLoaded Then
-        LoadWindowPosition
-    End If
-    TimeStampLoaded = True
-
-End Sub
-
-Private Sub UserForm_Initialize()
-    DTPicker1.Value = GlobalTimeStampDate
-    DTPicker2.Value = GlobalTimeStampTime
-    TimeStampChange = False
-End Sub
-
-Public Function LoadWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Left = Lsm5.tools.RegLongValue(PosKey, "Left")
-    Top = Lsm5.tools.RegLongValue(PosKey, "Top")
-    If Left < 1 Then Left = 0
-    If Top < 1 Then Top = 0
-    
-    If Left = 0 And Top = 0 Then
-                'Center frm
-                Left = 300
-                Top = 300
-'    SaveWindowPosition
-                Exit Function
-    End If
-End Function
-
-
-
-Public Sub SaveWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Lsm5.tools.RegLongValue(PosKey, "Left") = CInt(Left)
-    Lsm5.tools.RegLongValue(PosKey, "Top") = CInt(Top)
-End Sub
-
-Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
-    TimeStampChange = False
-    SaveWindowPosition
-
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ZStepForm.frm b/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ZStepForm.frm
deleted file mode 100644
index 6fcc950..0000000
--- a/AutofocusScreen_ZEN_v2_OfficialRelease/src/concat/ZStepForm.frm
+++ /dev/null
@@ -1,78 +0,0 @@
-VERSION 5.00
-Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} ZStepForm 
-   Caption         =   "Enter Z Step"
-   ClientHeight    =   2310
-   ClientLeft      =   45
-   ClientTop       =   330
-   ClientWidth     =   4665
-   OleObjectBlob   =   "ZStepForm.frx":0000
-   StartUpPosition =   1  'CenterOwner
-End
-Attribute VB_Name = "ZStepForm"
-Attribute VB_GlobalNameSpace = False
-Attribute VB_Creatable = False
-Attribute VB_PredeclaredId = True
-Attribute VB_Exposed = False
-Option Explicit
-
-Dim ZStepLoaded As Boolean
-
-Private Sub CanceButton1_Click()
-    ZStepChange = False
-    SaveWindowPosition
-    Unload ZStepForm
-End Sub
-
-Private Sub OkButton_Click()
-    ZStepChange = True
-    GlobalZStep = ZStepForm.BSlider1.Value
-    Unload ZStepForm
-End Sub
-
-
-Private Sub UserForm_Activate()
-    If Not ZStepLoaded Then
-        LoadWindowPosition
-    End If
-    ZStepLoaded = True
-
-End Sub
-
-Private Sub UserForm_Initialize()
-    ZStepForm.BSlider1.Value = GlobalZStep
-    ZStepChange = False
-End Sub
-
-Public Function LoadWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Left = Lsm5.tools.RegLongValue(PosKey, "Left")
-    Top = Lsm5.tools.RegLongValue(PosKey, "Top")
-    If Left < 1 Then Left = 0
-    If Top < 1 Then Top = 0
-    
-    If Left = 0 And Top = 0 Then
-                'Center frm
-                Left = 300
-                Top = 300
-'    SaveWindowPosition
-                Exit Function
-    End If
-End Function
-
-
-
-Public Sub SaveWindowPosition()
-    Dim PosKey As String
-    
-    PosKey = Lsm5.tools.GetWindowPositionKey() + "\" + Caption
-    Lsm5.tools.RegLongValue(PosKey, "Left") = CInt(Left)
-    Lsm5.tools.RegLongValue(PosKey, "Top") = CInt(Top)
-End Sub
-
-Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
-    ZStepChange = False
-    SaveWindowPosition
-
-End Sub
diff --git a/AutofocusScreen_ZEN_v2_Tischi/20120913_ZEN_Tischi .lvb b/AutofocusScreen_ZEN_v2_Tischi/20120913_ZEN_Tischi .lvb
deleted file mode 100644
index 9e85a73..0000000
Binary files a/AutofocusScreen_ZEN_v2_Tischi/20120913_ZEN_Tischi .lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_Tischi/20121119_ZEN_Tischi.lvb b/AutofocusScreen_ZEN_v2_Tischi/20121119_ZEN_Tischi.lvb
deleted file mode 100644
index 9303a35..0000000
Binary files a/AutofocusScreen_ZEN_v2_Tischi/20121119_ZEN_Tischi.lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_Tischi/AdditionalAcquisition.PNG b/AutofocusScreen_ZEN_v2_Tischi/AdditionalAcquisition.PNG
deleted file mode 100644
index db6e1c8..0000000
Binary files a/AutofocusScreen_ZEN_v2_Tischi/AdditionalAcquisition.PNG and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_Tischi/AutofocusPage.PNG b/AutofocusScreen_ZEN_v2_Tischi/AutofocusPage.PNG
deleted file mode 100644
index 6e18e73..0000000
Binary files a/AutofocusScreen_ZEN_v2_Tischi/AutofocusPage.PNG and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_Tischi/AutofocusScreen_ZEN_version2 .lvb b/AutofocusScreen_ZEN_v2_Tischi/AutofocusScreen_ZEN_version2 .lvb
deleted file mode 100644
index e90917c..0000000
Binary files a/AutofocusScreen_ZEN_v2_Tischi/AutofocusScreen_ZEN_version2 .lvb and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_Tischi/GridScanPage.PNG b/AutofocusScreen_ZEN_v2_Tischi/GridScanPage.PNG
deleted file mode 100644
index 2b72329..0000000
Binary files a/AutofocusScreen_ZEN_v2_Tischi/GridScanPage.PNG and /dev/null differ
diff --git a/AutofocusScreen_ZEN_v2_Tischi/MicropilotPage.PNG b/AutofocusScreen_ZEN_v2_Tischi/MicropilotPage.PNG
deleted file mode 100644
index 4c428a3..0000000
Binary files a/AutofocusScreen_ZEN_v2_Tischi/MicropilotPage.PNG and /dev/null differ
diff --git a/AutofocusScreenv2.1.2_OfficialRelease.zip b/AutofocusScreenv2.1.2_OfficialRelease.zip
deleted file mode 100644
index fffeb85..0000000
Binary files a/AutofocusScreenv2.1.2_OfficialRelease.zip and /dev/null differ
diff --git a/FcsRunner/fcsTests.lvb b/FcsRunner/fcsTests.lvb
deleted file mode 100644
index 6a32dd2..0000000
Binary files a/FcsRunner/fcsTests.lvb and /dev/null differ
